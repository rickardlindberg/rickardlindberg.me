<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Rickard's personal homepage: latest posts</title>
        <link>http://rickardlindberg.me</link>
        <description><![CDATA[Rickard's personal homepage: latest posts]]></description>
        <atom:link href="http://rickardlindberg.me/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 20 May 2023 00:00:00 UT</lastBuildDate>
        <item>
    <title>How to test a router?</title>
    <link>http://rickardlindberg.me/writing/how-to-test-a-router/</link>
    <description><![CDATA[<h1>How to test a router?</h1>

<p><em>Published on 20 May 2023.</em></p>

<p>I’ve been practicing <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks">Testing Without Mocks</a> for a while now. It describes a way of doing overlapping, sociable testing, which include infrastructure, without having side effects occur in your tests.</p>
<p>Recently I’ve been wondering how to test a “router” using this pattern. By router I mean an entry level function that looks at a url or command line arguments or whatever and dispatches to the relevant “controller”. Something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">MyWebApp</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;/home&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">home_controller</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;/about&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">about_controller</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>I <a href="https://hachyderm.io/@rickardlindberg/110379826738876668">asked</a> James if he had any examples of this, and he <a href="https://github.com/jamesshore/testing-without-mocks-complex/tree/javascript/src/www">had</a>. Let’s explore.</p>
<h2 id="james-example">James’ example</h2>
<p>Overly simplified, to only highlight the parts that I’m interested in, James’ example looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">WwwRouter</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">home_page_controller</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">home_page_controller</span> <span class="o">=</span> <span class="n">home_page_controller</span>

    <span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">url</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">home_page_controller</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;FAIL&quot;</span>

<span class="k">class</span> <span class="nc">HomePageController</span><span class="p">:</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">HomePageController</span><span class="p">(</span><span class="n">SomeInfrastructure</span><span class="o">.</span><span class="n">create</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_null</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">HomePageController</span><span class="p">(</span><span class="n">SomeInfrastructure</span><span class="o">.</span><span class="n">create_null</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">some_infrastructure</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">some_infrastructure</span> <span class="o">=</span> <span class="n">some_infrastructure</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="s2">&quot;Home Page&quot;</span>
</pre>
</div>
</div>
</div>
<p>The question I had was, how to test the <code>WwwRouter</code>? James does it like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_routes_home_page</span><span class="p">():</span>
    <span class="n">router</span> <span class="o">=</span> <span class="n">WwwRouter</span><span class="p">(</span><span class="n">HomePageController</span><span class="o">.</span><span class="n">create_null</span><span class="p">())</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">router</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">response</span> <span class="o">==</span> <span class="n">HomePageController</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">test_routes_errors</span><span class="p">():</span>
    <span class="n">router</span> <span class="o">=</span> <span class="n">WwwRouter</span><span class="p">(</span><span class="n">HomePageController</span><span class="o">.</span><span class="n">create_null</span><span class="p">())</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">router</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">&quot;/no-such-url&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">response</span> <span class="o">==</span> <span class="s2">&quot;FAIL&quot;</span>
</pre>
</div>
</div>
</div>
<p>Some characteristics of this test setup:</p>
<ul>
<li><p>The router takes all the controllers as dependencies.</p></li>
<li><p>The null version of the controllers are used.</p></li>
<li><p>The test uses <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#isolation">collaborator-based isolation</a>. (The test doesn’t care what <code>HomePageController</code> returns as long as it is the same as the router returns.)</p></li>
</ul>
<h2 id="what-if-return-value-is-missing">What if return value is missing?</h2>
<p>How about a router or dispatcher where the controllers don’t return anything. How to we test that?</p>
<p>Example:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">CliDispatcher</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_command</span><span class="p">,</span> <span class="n">remove_command</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_command</span> <span class="o">=</span> <span class="n">add_command</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_command</span> <span class="o">=</span> <span class="n">remove_command</span>

    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arguments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arguments</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;add&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_command</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">arguments</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;remove&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_command</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Unknown command.&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We start out the same:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_dispatches_to_add</span><span class="p">():</span>
    <span class="n">add_command</span> <span class="o">=</span> <span class="n">AddCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">remove_command</span> <span class="o">=</span> <span class="n">RemoveCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">cli</span> <span class="o">=</span> <span class="n">CliDispatcher</span><span class="p">(</span><span class="n">add_command</span><span class="p">,</span> <span class="n">remove_command</span><span class="p">)</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">dispatch</span><span class="p">([</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="s2">&quot;item name&quot;</span><span class="p">])</span>
</pre>
</div>
</div>
</div>
<p>But <code>dispatch</code> does not return anything, so we can’t check any return value. What to do?</p>
<p>We want to test that the function of <code>AddCommand</code> was performed, and nothing else. We could introduce queries on commands to see if they have been run. Then we can write the asserts like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="n">add_command</span><span class="o">.</span><span class="n">get_last_arguments</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;item name&quot;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">remove_command</span><span class="o">.</span><span class="n">get_last_arguments</span><span class="p">()</span> <span class="o">==</span> <span class="kc">None</span>
</pre>
</div>
</div>
</div>
<p>So we want to assert that the add command was run with the given arguments and that all the other (only one in the example) commands were not run.</p>
<p>I think this is in the spirit of testing without mocks. Here is what it says about state-based testing:</p>
<blockquote>
<p>Use state-based tests instead of interaction-based tests. A state-based test checks the output or state of the code under test, without any awareness of its implementation.</p>
</blockquote>
<p>An it goes on to say</p>
<blockquote>
<p>For mutable objects, provide a way for changes in state to be observed, either with a getter method or an event.</p>
</blockquote>
<h2 id="events-instead">Events instead</h2>
<p>I am not a fan of the <code>get_last_*</code> pattern. Our code could call <code>command.run(...)</code> twice, and the test would not catch the error. I prefer an events approach instead.</p>
<p>Assuming that commands are observable and that they emit events when run (we can test that separately), the test can be written like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_dispatches_to_add</span><span class="p">():</span>
    <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">add_command</span> <span class="o">=</span> <span class="n">AddCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">add_command</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">remove_command</span> <span class="o">=</span> <span class="n">RemoveCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">remove_command</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">cli</span> <span class="o">=</span> <span class="n">CliDispatcher</span><span class="p">(</span><span class="n">add_command</span><span class="p">,</span> <span class="n">remove_command</span><span class="p">)</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">dispatch</span><span class="p">([</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="s2">&quot;item name&quot;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">events</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;AddCommand&quot;</span><span class="p">,</span> <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;item name&quot;</span><span class="p">]},</span>
    <span class="p">]</span>
</pre>
</div>
</div>
</div>
<p>This test ensures that exactly one command was run and that it was run only once. Exactly what we wanted to test, but now expressed with a single assert.</p>
<h2 id="better-test-setup">Better test setup</h2>
<p>This test setup becomes tedious to do for every command. We can extract it to a factory method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">create_cli</span><span class="p">():</span>
    <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">add_command</span> <span class="o">=</span> <span class="n">AddCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">add_command</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">remove_command</span> <span class="o">=</span> <span class="n">RemoveCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">remove_command</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">cli</span> <span class="o">=</span> <span class="n">CliDispatcher</span><span class="p">(</span><span class="n">add_command</span><span class="p">,</span> <span class="n">remove_command</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cli</span><span class="p">,</span> <span class="n">events</span>

<span class="k">def</span> <span class="nf">test_dispatches_to_add</span><span class="p">():</span>
    <span class="n">cli</span><span class="p">,</span> <span class="n">events</span> <span class="o">=</span> <span class="n">create_cli</span><span class="p">()</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">dispatch</span><span class="p">([</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="s2">&quot;item name&quot;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">events</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;AddCommand&quot;</span><span class="p">,</span> <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;item name&quot;</span><span class="p">]},</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">test_dispatches_to_remove</span><span class="p">():</span>
    <span class="n">cli</span><span class="p">,</span> <span class="n">events</span> <span class="o">=</span> <span class="n">create_cli</span><span class="p">()</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">dispatch</span><span class="p">([</span><span class="s2">&quot;remove&quot;</span><span class="p">,</span> <span class="s2">&quot;item name&quot;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">events</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;RemoveCommand&quot;</span><span class="p">,</span> <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;item name&quot;</span><span class="p">]},</span>
    <span class="p">]</span>
</pre>
</div>
</div>
</div>
<p>Or even better:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run_in_test_mode</span><span class="p">(</span><span class="n">arguments</span><span class="p">):</span>
    <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">add_command</span> <span class="o">=</span> <span class="n">AddCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">add_command</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">remove_command</span> <span class="o">=</span> <span class="n">RemoveCommand</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
    <span class="n">remove_command</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">cli</span> <span class="o">=</span> <span class="n">CliDispatcher</span><span class="p">(</span><span class="n">add_command</span><span class="p">,</span> <span class="n">remove_command</span><span class="p">)</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">events</span>

<span class="k">def</span> <span class="nf">test_dispatches_to_add</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">run_in_test_mode</span><span class="p">([</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="s2">&quot;item name&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;AddCommand&quot;</span><span class="p">,</span> <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;item name&quot;</span><span class="p">]},</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">test_dispatches_to_remove</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">run_in_test_mode</span><span class="p">([</span><span class="s2">&quot;remove&quot;</span><span class="p">,</span> <span class="s2">&quot;item name&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;RemoveCommand&quot;</span><span class="p">,</span> <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;item name&quot;</span><span class="p">]},</span>
    <span class="p">]</span>
</pre>
</div>
</div>
</div>
<h2 id="summary">Summary</h2>
<p>In hindsight, this seems quite obvious to me. I’m not sure what I had a hard time understanding. But the example from James helped. Thanks! And writing this blog post helped me clarify my thinking on the subject.</p>
]]></description>
    <pubDate>Sat, 20 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/how-to-test-a-router/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Programming a Logitech Gamepad F310</title>
    <link>http://rickardlindberg.me/writing/agdpp-logitech-gamepad-f310/</link>
    <description><![CDATA[<h1>Programming a Logitech Gamepad F310</h1>

<p><em>Published on 19 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>I recently bought a pair of Logitech gamepads that me and my son use when playing <a href="https://supertuxkart.net/Main_Page">SuperTuxKart</a>.</p>
<p>
<center>
<img src="logitech-gamepad-f310.png" title="fig:" alt="Logitech Gamepad F310." />
</center>
</p>
<p>I want to be able to use those gamepads in the balloon shooter as well. My suspicion is that the balloon shooter will feel many times more like a “real” game if we can control it using “real” game controllers. Even though we are all about having fun here and learning, we still want this to feel like a real game, not some toy example. So let’s get started.</p>
<h2 id="learning-about-events">Learning about events</h2>
<p>How do we capture events from a Logitech gamepad?</p>
<p>One way to find out is to print all the events that pygame generates. We can for example do that in the <code>tick</code> method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This makes the test suite fail since the print statement is outputting event information that the tests do not expect to find.</p>
<p>This might be a downside of doctest, that it captures stdout and asserts on it. Normally a print statement should not affect the function of the code, so it should be fine.</p>
<p>On the other hand, if we use print statements for debugging, maybe it’s a good thing that our test suite fails so that we are remembered to keep the debug session short and remove it once we are done.</p>
<p>Anyway, if we run the game now and press keys on the keyboard we can see things like this in the output:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>&lt;Event(771-TextInput {&#39;text&#39;: &#39; &#39;, &#39;window&#39;: None})&gt;
&lt;Event(769-KeyUp {&#39;unicode&#39;: &#39; &#39;, &#39;key&#39;: 32, &#39;mod&#39;: 0, &#39;scancode&#39;: 44, &#39;window&#39;: None})&gt;
&lt;Event(768-KeyDown {&#39;unicode&#39;: &#39;&#39;, &#39;key&#39;: 1073742049, &#39;mod&#39;: 1, &#39;scancode&#39;: 225, &#39;window&#39;: None})&gt;
&lt;Event(768-KeyDown {&#39;unicode&#39;: &#39;&#39;, &#39;key&#39;: 1073742050, &#39;mod&#39;: 257, &#39;scancode&#39;: 226, &#39;window&#39;: None})&gt;
</pre>
</div>
</div>
</div>
<p>But when we press keys on the Logitech gamepad, nothing happens.</p>
<p>However, if we look at the beginning of the event log, we see this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>&lt;Event(1541-JoyDeviceAdded {&#39;device_index&#39;: 0, &#39;guid&#39;: &#39;030000006d0400001dc2000014400000&#39;})&gt;
</pre>
</div>
</div>
</div>
<p>Is this our Logitech gamepad?</p>
<h2 id="initializing-joysticks">Initializing joysticks</h2>
<p>We read about joysticks in the <a href="https://www.pygame.org/docs/ref/joystick.html">pygame documentation</a>. It seems like they must be initialized before events are generated for them.</p>
<blockquote>
<p>Joysticks are initialised on creation and are shut down when deallocated. Once the device is initialized the pygame event queue will start receiving events about its input.</p>
</blockquote>
<p>We try to mimic the example in the documentation to initialize joysticks:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">),</span> <span class="n">fps</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="n">joysticks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">pygame_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame_events</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">JOYDEVICEADDED</span><span class="p">:</span>
                        <span class="n">joy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">joystick</span><span class="o">.</span><span class="n">Joystick</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">device_index</span><span class="p">)</span>
                        <span class="n">joysticks</span><span class="p">[</span><span class="n">joy</span><span class="o">.</span><span class="n">get_instance_id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">joy</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">game</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">Event</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
                <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We don’t handle <code>JOYDEVICEREMOVED</code> yet. We probably should, but unless we unplug the gamepad while running the game, we should be fine I think.</p>
<p>This change passes all the tests. However, we are never simulating the <code>JOYDEVICEADDED</code> event, so the code is never executed.</p>
<p>I think we will get faster feedback by just testing this thing for real. We can come back and describe the joystick handling code in the form of tests later on if we feel the need. And maybe test the <code>JOYDEVICEREMOVED</code> as well.</p>
<p>Anyway, if we run the game now and press keys on the gamepad, we see events like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>&lt;Event(1536-JoyAxisMotion {&#39;joy&#39;: 0, &#39;instance_id&#39;: 0, &#39;axis&#39;: 0, &#39;value&#39;: 0.003906369212927641})&gt;
&lt;Event(1539-JoyButtonDown {&#39;joy&#39;: 0, &#39;instance_id&#39;: 0, &#39;button&#39;: 0})&gt;
&lt;Event(1540-JoyButtonUp {&#39;joy&#39;: 0, &#39;instance_id&#39;: 0, &#39;button&#39;: 0})&gt;
</pre>
</div>
</div>
</div>
<p>I feel a disproportional sense of excitement and joy over this. We can now get input from the Logitech gamepad. We are real game developers now! Thanks pygame for making this relatively straight forward. Now it’s a matter of mapping events to actions in our game.</p>
<h2 id="isolating-input-handling">Isolating input handling</h2>
<p>We want to be able to play our game with both the keyboard and the Logitech gamepad. I will most likely use the gamepad 99% of the time, but if you don’t have it, we still want you to be able to play the game.</p>
<p>Input handling is therefore something that is starting to become a little complicated. It’s not just a matter of mapping one event to one action.</p>
<p>Now, we have this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">clone_shooting</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_left</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle_left</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_right</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle_right</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>That is a one to one mapping between events and actions.</p>
<p>We still want this code to look similar but allow multiple events to generate the same action.</p>
<p>Here is what we come up with:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">action</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_shoot</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bow</span><span class="o">.</span><span class="n">clone_shooting</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bow</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_turn_angle</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>So we pass along events to an input handler, then we query it in the <code>update</code> method, asking it if a shot action was triggered (from either input device), and if so, modify <code>flying_arrows</code> as before. We do something similar for turning the arrow. But instead of asking the input handler if a left/right action was triggered, we ask it for an angle that we should turn the arrow. Since the arrow can be turned with variable speed with the Logitech gamepad, this makes more sense.</p>
<p>Before we look at the input handler, I want to discuss another thing that is new here: the bow.</p>
<h2 id="bow">Bow</h2>
<p>Instead of doing <code>arrow.angle_left/right()</code> we do <code>bow.turn(angle)</code>. We have extracted a concept called bow.</p>
<p>Right now it is a wrapper around an arrow, but the idea is that you might want to draw more graphics for the bow.</p>
<p>Here is what it looks like:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Bow</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">turn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">set_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">clone_shooting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">clone_shooting</span><span class="p">()</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>I’m not sure that bow is the right name. Do we shoot arrows with a bow in our game? Or is it some kind of cannon? I think we need to ask our product owner.</p>
<p>At the moment we are not doing any drawing except the arrow, so the bow just acts as a placeholder to attract new functionality. But the concept of a bow makes sense. You need to shoot the arrow with something. And when you shoot, the arrow leaves the bow and goes into the list of flying arrows.</p>
<h2 id="input-handler">Input handler</h2>
<p>Ok, on to the input handler.</p>
<p>It is responsible for handling events and keeping some state of what those events should result in.</p>
<p>Let’s look at how it handles shooting:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">InputHandler</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shoot_down</span> <span class="o">=</span> <span class="n">ResettableValue</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shoot</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shoot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shoot_down</span><span class="o">.</span><span class="n">get_and_reset</span><span class="p">()</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown</span><span class="p">(</span><span class="n">KEY_SPACE</span><span class="p">)</span> <span class="ow">or</span> <span class="n">event</span><span class="o">.</span><span class="n">is_joystick_down</span><span class="p">(</span><span class="n">XBOX_A</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shoot_down</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>It will be called by the game scene like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">action</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_shoot</span><span class="p">():</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The <code>shoot_down</code> variable remembers if a shoot key/button has been pressed since the last call to <code>update</code>. We only want <code>get_shoot</code> to return true one time when we press a shoot key/button. That’s why we use a resettable value, which looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">ResettableValue</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">get_and_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>
</pre>
</div>
</div>
</div>
<p>The <code>is_joystick_down</code> method on the event is new. We have added wrappers for new events <a href="/writing/agdpp-shooting-arrow/index.html">before</a>, and this is done the same way.</p>
<p>The logic for the turn angle is a little more complicated. The input handler remembers what state the keyboard and gamepad is in. For the keyboard, it is if a turn key is currently pressed or not. For the gamepad, it is the current x position of the joystick. We store that state in <code>arrow_turn_factor</code>. It is a value between -1 and 1. -1 means turn full speed to the left. 1 means turn full speed to the right. The keyboard can only turn with full speed but the gamepad can turn with variable speed by moving the joystick into different x positions. (We could imagine that the turn factor for the keyboard increase over time. So the speed increases the longer you have held a turn button down. That kind of logic would go in here and the game would still only query for the turn angle.)</p>
<p>Here is the implementation:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">InputHandler</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span> <span class="o">=</span> <span class="n">ResettableValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_turn_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">turn_angle</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">turn_angle</span> <span class="o">=</span> <span class="n">Angle</span><span class="o">.</span><span class="n">fraction_of_whole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="mi">2000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown</span><span class="p">(</span><span class="n">KEY_LEFT</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keyup</span><span class="p">(</span><span class="n">KEY_LEFT</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown</span><span class="p">(</span><span class="n">KEY_RIGHT</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keyup</span><span class="p">(</span><span class="n">KEY_RIGHT</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_joystick_motion</span><span class="p">()</span> <span class="ow">and</span> <span class="n">event</span><span class="o">.</span><span class="n">get_axis</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow_turn_factor</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>We can test the details of this in isolation. The only thing we need to test in the game scene is that it turns the arrow by the amount that it gets from the input handler.</p>
<p>Also notice the new <code>Angle</code> class. We continue down the path of eliminating primitive obsession. I’m sure it will attract some functions.</p>
<h2 id="design-discussion">Design discussion</h2>
<p>Let’s have a look at the game scene again:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">action</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_shoot</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bow</span><span class="o">.</span><span class="n">clone_shooting</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bow</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_turn_angle</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>How do we test this? What is the behavior?</p>
<p>This is what I think of:</p>
<ul>
<li>Flying arrows stays the same if no shoot key is pressed</li>
<li>Flying arrows increment if shoot key is pressed</li>
<li>Bow turns with an angle indicated by input</li>
</ul>
<p>In order to test this, we need to simulate real events. But now that we allow multiple events for shooting for example, do we need to test them all? No. We can select any of them.</p>
<p>This is overlapping, sociable testing. (I think.)</p>
<p>Then we can write specific tests for the input handler that tests that all shoot keys result in <code>get_shoot</code> being true:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Space shoots and resets:</span>

<span class="sd">&gt;&gt;&gt; i = InputHandler()</span>
<span class="sd">&gt;&gt;&gt; i.action(GameLoop.create_event_keydown(KEY_SPACE))</span>
<span class="sd">&gt;&gt;&gt; i.update(1)</span>
<span class="sd">&gt;&gt;&gt; i.get_shoot()</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; i.update(1)</span>
<span class="sd">&gt;&gt;&gt; i.get_shoot()</span>
<span class="sd">False</span>

<span class="sd">Xbox A shoots and resets:</span>

<span class="sd">&gt;&gt;&gt; i = InputHandler()</span>
<span class="sd">&gt;&gt;&gt; i.action(GameLoop.create_event_joystick_down(XBOX_A))</span>
<span class="sd">&gt;&gt;&gt; i.update(1)</span>
<span class="sd">&gt;&gt;&gt; i.get_shoot()</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; i.update(1)</span>
<span class="sd">&gt;&gt;&gt; i.get_shoot()</span>
<span class="sd">False</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The process to get to this design was a squiggly one with many refactorings. I initially had a different approach that I want to mention and talk about. It looked like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">quit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ExitGameLoop</span><span class="p">()</span>
        <span class="n">actions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;quit&quot;</span><span class="p">:</span> <span class="n">quit</span><span class="p">,</span>
            <span class="s2">&quot;shoot&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">clone_shooting</span><span class="p">()),</span>
            <span class="s2">&quot;turn_left&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle_left</span><span class="p">(),</span>
            <span class="s2">&quot;turn_right&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle_right</span><span class="p">(),</span>
        <span class="p">}</span>
        <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">action</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action</span><span class="p">:</span>
            <span class="n">actions</span><span class="p">[</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]]()</span>

<span class="k">class</span> <span class="nc">InputHandler</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;quit&#39;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">()</span> <span class="ow">or</span> <span class="n">event</span><span class="o">.</span><span class="n">is_joystick_down</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;shoot&#39;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_left</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;turn_left&#39;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_right</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;turn_right&#39;</span><span class="p">,)</span>
</pre>
</div>
</div>
</div>
<p>In this design, the input handler returns the name of the action to perform. Then the game scene looks up that action, and if it finds it, runs it.</p>
<p>This makes the input handler easy to test, which was my goal.</p>
<p>The question is what to test in the game scene. I think I would like to test all cases here as well to make sure the right action names are used. So simulate any shooting event and make sure that flying arrows are added, and so on.</p>
<p>However, what if we use the keyboard event for that test, and then write our input handler like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">InputHandler</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;shoot&#39;</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_joystick_down</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;shot&#39;</span><span class="p">,)</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>That is, we misspell the action name for the joystick case. We even misspell it in the input handler test. All tests will pass, but the arrow will not shoot when using the joystick.</p>
<p>Do we need to test all cases in the game scene to ensure that? I really don’t want to do that. The whole point of the input handler was to be able to test details of input handling in isolation.</p>
<p>That’s when I slowly moved in the direction that I presented first:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_shoot</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bow</span><span class="o">.</span><span class="n">clone_shooting</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bow</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_handler</span><span class="o">.</span><span class="n">get_turn_angle</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>In this design it is still possible for <code>get_shoot</code> to return an incorrect boolean value for the joystick. But the likelihood of that happening, I think, is much less than we misspell an action.</p>
<p>This design is also cleaner I think. No need for an “action language” where strings are mapped to actions to do.</p>
<h2 id="summary">Summary</h2>
<p>Testing is hard. You don’t want to test everything from the outside since that gives difficult to read tests. But you <em>do</em> want to test from the outside to make sure things actually work for real. So you need to make a tradeoff. I suspect there is no “right” answer. One measure you can use is this: are you worried that things are not working? Test more or test smarter.</p>
<p>With the first design of the input handler, I was worried that the input handler returned “invalid” actions. Instead of testing more from the outside, I modified the design to reduce my worry. I’m no longer worried that the input handler returns the wrong things. I feel better.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Fri, 19 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-logitech-gamepad-f310/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>A case for the infrastructure wrapper</title>
    <link>http://rickardlindberg.me/writing/agdpp-wrapper-pygame-draw-circle-bug/</link>
    <description><![CDATA[<h1>A case for the infrastructure wrapper</h1>

<p><em>Published on 14 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>I noticed something strange when playing the game.</p>
<p>When shooting arrows out the left side of the screen, a blue horizontal line is drawn. It looks something like this:</p>
<center>
<img src="negative-x-draw-bug.png" title="fig:" alt="Bug with drawing circles on negative x positions." />
</center>
<p>But it only shows for a split second and then disappears. What’s going on?</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>We troubleshoot by playing the game and shooting wildly in different directions.</p>
<p>It seems like the blue horizontal line only appears when we shoot arrows to the left–not when we shoot up or to the right.</p>
<p>So why does it only show for a split second? Most likely because arrows outside the screen are removed. But they are only removed if they are far enough outside the screen. The idea is that arrows are only removed if they are completely outside the screen. However, I don’t think it’s working quite like that at the moment. But arrows can be partially outside the screen before being removed.</p>
<p>We modify the code to draw a static arrow just outside the screen to the left, and indeed the blue horizontal line stays on the screen forever. (That’s how I managed to get the screenshot. It was not timing.)</p>
<p>The problem can now be consistently reproduced. Good!</p>
<h2 id="bug-in-pygame">Bug in Pygame?</h2>
<p>At first I thought we might use Pygame wrong in some way. But now I’m starting to think that there might actually be an issue with Pygame.</p>
<p>Let’s ask DuckDuckGo.</p>
<p>It came back with this: <a href="https://github.com/pygame/pygame/issues/3778">Circles drawn using pygame.draw.circle with negative x positions are drawn as a horizontal line across the whole screen.</a></p>
<p>Ha! A bug in Pygame. It all makes sense now. And we are not at fault.</p>
<p>However, we still have an ugly, annoying graphics artifact in our game that we want to get rid of. How?</p>
<h2 id="infrastructure-to-the-rescue">Infrastructure to the rescue</h2>
<p>Any place in the code where we draw a circle we have to modify it to handle negative x values.</p>
<p>Let’s see how.</p>
<p>We have used the <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#infrastructure-wrappers">infrastructure wrapper</a> pattern in our game. That means that every time our code interacts with the outside world, it does so via an infrastructure wrapper.</p>
<p>Anytime we draw something on the screen, we do it via the game loop infrastructure wrapper. Here is how the arrow draws itself:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">from_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">180</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="mi">20</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="mi">40</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p><code>draw_circle</code> above is part of the infrastructure wrapper. In code that we control. It in turn makes calls to Pygame like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span>
            <span class="n">color</span><span class="p">,</span>
            <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">)),</span>
            <span class="n">radius</span>
        <span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>So we are actually only calling Pygame’s <code>draw_circle</code> in one place in our code.</p>
<p>We patch it like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="n">position</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># https://github.com/pygame/pygame/issues/3778</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span>
                <span class="n">color</span><span class="p">,</span>
                <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">y</span><span class="p">)),</span>
                <span class="n">radius</span>
            <span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>This means that circles drawn partially outside the screen to the left will not be drawn at all. Not ideal. But I very much prefer that to an annoying blue horizontal line.</p>
<p>And when I play the game, I don’t notice circles of the arrow disappearing a little to early. They move so fast anyway.</p>
<p>We could do something more fancy like checking for specific versions of Pygame where we know this bug exists. But this will do for now.</p>
<h2 id="summary">Summary</h2>
<p>We were able to fix an annoying graphics artifact by adding a single if-statement to our infrastructure wrapper.</p>
<p>Wrapping third party libraries might seem like unnecessary overhead sometimes, but the benefit shown in this episode makes me think that we should do it more often.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Sun, 14 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-wrapper-pygame-draw-circle-bug/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Turning arrow</title>
    <link>http://rickardlindberg.me/writing/agdpp-turning-arrow/</link>
    <description><![CDATA[<h1>Turning arrow</h1>

<p><em>Published on 12 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>We have a basic version of a balloon shooter in place. We have a balloon moving across the screen and an arrow that can be shot and hit the balloon to score a point.</p>
<center>
<img src="points.png" title="fig:" alt="Arrow shooting straight." />
</center>
<p>When I play the game now, I want to turn the arrow. I think that will make the game a little more fun. Then you have to control both angle and timing instead of just timing to hit a balloon. (If we implement that balloons fall downwards instead, turning will also be necessary to hit balloons that are not straight above the arrow.)</p>
<h2 id="how-does-arrow-movement-work">How does arrow movement work?</h2>
<p>Arrows move first when we press the space key to shoot. Then we create a new arrow and set its shooting attribute to true:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">(</span><span class="n">shooting</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>An arrow that has the shooting attribute set to true moves like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">dy</span><span class="o">=-</span><span class="n">dt</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That is, it moves straight up in increments of <code>dt</code>. There is no concept of direction yet.</p>
<p>What we would like to have is some kind of direction attribute on the arrow that we can change. When we shoot, the arrow that we create should get that direction attribute so that it flies in the same direction that we aimed.</p>
<p>Let’s see if we can refactor towards that.</p>
<h2 id="clone-shooting">Clone shooting</h2>
<p>We start by creating a method <code>clone_shooting</code> on the arrow that should return a copy of itself (including all attributes) and have the shooting attribute set to true:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">clone_shooting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Arrow</span><span class="p">(</span><span class="n">shooting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We modify how a flying arrow is added like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="gd">- self.flying_arrows.add(Arrow(shooting=True))</span>
<span class="gi">+ self.flying_arrows.add(self.arrow.clone_shooting())</span>
</pre>
</div>
</div>
</div>
<p>One change here is that we also clone the arrow’s position attribute. The position of the arrow is always the same. Only when we shoot it, it changes. But should we choose to move the arrow to a different start position, the code now takes that into account and places shooting arrows at the right start positions.</p>
<p>I think this is still a pure refactoring. There is no change in visible behavior, but the code is more robust because we can now change the start position of the arrow, and it will shoot from the right position without we having to modify any other piece of code. The design is better.</p>
<h2 id="work-towards-arrow-velocity">Work towards arrow velocity</h2>
<p>Next we take a small step towards having an arrow velocity. We change the update method to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span><span class="p">:</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=-</span><span class="n">dt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Our relatively new <code>Point</code> class attracts more and more behavior. Here we added the <code>add</code> method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; Point(0, 5).add(Point(1, 1))</span>
<span class="sd">        Point(1, 6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<h2 id="derive-velocity-from-angle">Derive velocity from angle</h2>
<p>Now we could modify the velocity of the arrow and the update method would move it in the right direction.</p>
<p>However, I think it is better if we have a concept of an arrow angle that we can adjust left and right. That would fit our use case better.</p>
<p>We add and angle attribute to the arrow and derive the velocity vector from it:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shooting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">500</span><span class="p">)):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">90</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Point</span><span class="o">.</span><span class="n">from_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The <code>Point</code> class again attracts functionality. This time for converting angles to unit vectors (vectors of length one) and for magnifying vectors:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_angle</span><span class="p">(</span><span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; p = Point.from_angle(-90)</span>
<span class="sd">        &gt;&gt;&gt; int(p.x)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; int(p.y)</span>
<span class="sd">        -1</span>

<span class="sd">        &gt;&gt;&gt; p = Point.from_angle(0)</span>
<span class="sd">        &gt;&gt;&gt; int(p.x)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; int(p.y)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Point</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">degrees</span><span class="p">)),</span>
            <span class="n">y</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">degrees</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">magnification</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; Point(1, 5).times(2)</span>
<span class="sd">        Point(2, 10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">magnification</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">magnification</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<h2 id="base-drawing-on-angle">Base drawing on angle</h2>
<p>The arrow now moves correctly based on the angle, but it doesn’t draw its three circles correctly. It looks like this now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">dy</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">dy</span><span class="o">=</span><span class="mi">40</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That is, it draws the second two circles by moving them downwards, assuming that the arrow is pointing up.</p>
<p>Let’s instead draw them offset by the opposite direction of what the arrow points:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">from_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">180</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="mi">20</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">times</span><span class="p">(</span><span class="mi">40</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We get the reverse angle by turning it 180 degrees.</p>
<p>Perhaps angle is another case of primitive obsession. If we had an angle class, we could have a <code>reverse</code> method that did this and we would no longer be required to know about degrees (the angle could be implemented with radians instead for example). We make a note about that.</p>
<p>Anyway, we can change the angle attribute of the arrow and it will fly in the right direction and draw correctly. Now there is only one thing left: control the angle with arrow keys.</p>
<h2 id="changing-angle-with-leftright">Changing angle with left/right</h2>
<p>Here is the test we write for changing arrow angle:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space)</span>
<span class="sd">&gt;&gt;&gt; game.get_arrow_angle()</span>
<span class="sd">-90</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_left())</span>
<span class="sd">&gt;&gt;&gt; game.get_arrow_angle()</span>
<span class="sd">-95</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_right())</span>
<span class="sd">&gt;&gt;&gt; game.get_arrow_angle()</span>
<span class="sd">-90</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>For this to work we need to create new event wrappers for keydown left/right and add a getter to expose the arrow angle. We have done similar things before. Same procedure this time.</p>
<p>We make it pass by handling the events and changing the angle:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_left</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle_left</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_right</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">angle_right</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">angle_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">-=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">angle_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+=</span> <span class="mi">5</span>
</pre>
</div>
</div>
</div>
<p>This almost works, but when we turn and arrow and shoot it, it still goes straight up. We need to fix the <code>clone_shooting</code> method to also clone the angle.</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">clone_shooting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It preserves position and angle and set it to shooting:</span>

<span class="sd">        &gt;&gt;&gt; arrow = Arrow(position=Point(x=5, y=5), angle=-45)</span>
<span class="sd">        &gt;&gt;&gt; new_arrow = arrow.clone_shooting()</span>
<span class="sd">        &gt;&gt;&gt; new_arrow.get_position()</span>
<span class="sd">        (5, 5)</span>
<span class="sd">        &gt;&gt;&gt; new_arrow.angle</span>
<span class="sd">        -45</span>
<span class="sd">        &gt;&gt;&gt; new_arrow.shooting</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Arrow</span><span class="p">(</span><span class="n">shooting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<h2 id="result">Result</h2>
<p>Now we can turn the arrow with left/right keys and shoot it in different directions. It looks like this:</p>
<center>
<img src="turning-arrow.png" title="fig:" alt="Turning arrow." />
</center>
<p>If you want to try it out, the full source code from this episode on <a href="https://github.com/rickardlindberg/agdpp/tree/turning-arrow">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>Testing continues to go smooth with state based testing and getters to expose internal state.</p>
<p>What I like to do after implementing a feature is to take a break and then come back later to review to code for possible improvements. Often times it is small things like renaming a variable to make it more clear. In this episode we also noted that angle might benefit being wrapped in an abstraction. Not sure they are too interesting to write about. Let me know if you think otherwise.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Fri, 12 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-turning-arrow/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Hit balloon and score points</title>
    <link>http://rickardlindberg.me/writing/agdpp-hit-balloon-and-score-points/</link>
    <description><![CDATA[<h1>Hit balloon and score points</h1>

<p><em>Published on  9 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>We have two stories left before we think we have a first, minimal version of a balloon shooter game:</p>
<ul>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
</ul>
<p>In this episode we will work on both of them. We will start with collision detection between arrow and balloon.</p>
<h2 id="clarify-behavior-with-test">Clarify behavior with test</h2>
<p>To clarify what we mean by arrow can hit balloon, we want to write a test first that shows the lacking behavior. Then implement the thing. We use the test both as a design tool to figure out what we are actually going to implement and as a testing tool to verify that behavior.</p>
<p>Our game scene object currently inits like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Balloon</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We would like to write a test where we shoot an arrow, make it collide with the balloon, and then assert that the balloon disappears.</p>
<p>With the current design, this is really difficult to do. It can only be done something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(...)</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span>
<span class="sd">&gt;&gt;&gt; game.update(??)</span>
<span class="sd">&gt;&gt;&gt; game.get_balloon() is None</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>But this is really flaky and hard to understand. In order for this to work, we have to time the shooting and the updating so that the arrow actually hits the balloon. Even if we get it to work, it will start failing if we for example change the speed of the arrow. And this test should really not care about arrow speed.</p>
<p>Let’s see if we can do better.</p>
<p>We change the init method to this instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">balloons</span><span class="o">=</span><span class="p">[(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)],</span> <span class="n">arrows</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">([</span>
            <span class="n">Balloon</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">balloons</span>
        <span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">([</span>
            <span class="n">Arrow</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">arrows</span>
        <span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>That is, we make it possible to create a game scene object where we specify where all the balloons should be and where all the flying arrows should be. We also change the balloon from a single object to a sprite group. This is not strictly necessary, but it will make removing hit balloons easier. The default values for the balloons and arrows mimics the current default. We have one balloon that starts at (50, 50) and zero flying arrows.</p>
<p>Here is the test that checks initial state:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(100, 100)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; len(game.get_flying_arrows())</span>
<span class="sd">1</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>In order for it to work, we expose another getter for the balloon sprites:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_balloons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>The test continues to check that we still have one balloon and one flying arrow after an update:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; len(game.get_flying_arrows())</span>
<span class="sd">1</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We update with 0 to ensure that nothing moves. We need to call update to make the collision detection code run, but to ensure exact positions, we pass 0 as the delta time. All movements should take the delta time into account, so 0 should result in no movement.</p>
<p>We continue and write the test for hitting a balloon like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; game.get_balloons()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We place the arrow at the center of the balloon, invoke the collision detection code with update, and assert that there are no longer any balloons.</p>
<h2 id="implement-arrow-hit">Implement arrow hit</h2>
<p>In the game update, we already loop over the arrows to remove the ones that are outside the screen. We add a loop that checks if any arrow hits any of the balloons. If so, we remove that balloon:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="o">...</span>
            <span class="k">for</span> <span class="n">balloon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_baloon</span><span class="p">(</span><span class="n">balloon</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">balloon</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We add <code>hits_baloon</code> to arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">hits_baloon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">balloon</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">balloon</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>And implement <code>inside</code> in balloon like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This is a bit of a trick in OOP that I learned some time ago that I’m not sure what I think about. Let me explain.</p>
<p>We could have written the test like this instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="n">balloon</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">arrow</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">arrow</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">balloon</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>But then the game scene object would have to reach into the arrow object to access the x and y coordinates.</p>
<p>With <code>hits_baloon</code> we introduce one more step in the chain where the arrow itself pass its coordinates along to <code>inside</code>. No need to expose them to the outside.</p>
<p>I like this because objects can expose less details about themselves. I dislike this because I think the code sometimes becomes a little harder to read. I guess the solution is good naming. And I think <code>arrow.hits_baloon(balloon)</code> reads pretty well.</p>
<h2 id="demo-trick">Demo trick</h2>
<p>The game works and if we manage to hit a balloon, it disappears. Again, bummer. We can shoot infinitely many arrows, but if there are no more balloons to hit, the game is not that interesting.</p>
<p>We had a situation like this <a href="/writing/agdpp-shooting-arrow/index.html">before</a> where you shot the arrow and you could only get a new one by restarting the game.</p>
<p>One trick I used when I demoed this for the customer was to run the game in a loop like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>$ <span class="k">while</span> true<span class="p">;</span> <span class="k">do</span> ./zero.py rundev<span class="p">;</span> <span class="k">done</span>
</pre>
</div>
</div>
</div>
<p>So when you have no more arrows to shoot or no more balloons to hit, you close the game window and a new one will immediately pop up.</p>
<p>That way, it is a little smoother to gather feedback on the current game functionality.</p>
<p>We fixed so that you get more arrows to shoot before. Let’s also fix so that a new balloon is spawned after one is hit so we don’t need to restart the game in a loop anymore.</p>
<h2 id="primitive-obsession-refactoring">Primitive obsession refactoring</h2>
<p>Before we start adding new functionality, let’s have a look at the code and see if there is anything that we can improve to make it more clear and make the future a little smoother.</p>
<p>One thing that I notice is that we are passing around (x, y) coordinates in a lot of places, and objects keep track of the x and y coordinates. Here is the balloon class for example:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This smell is called primitive obsession. It is when you pass around primitive objects (integers, strings encoding information, etc) instead of an abstraction. That leads to duplicated logic. Say for example that we want to move an object, we might do something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">2</span>
</pre>
</div>
</div>
</div>
<p>And we probably need to move multiple objects, so this kind of code will be duplicated in many places.</p>
<p>The solution is to create and abstraction for the concept. In this case, I choose to call it point:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</pre>
</div>
</div>
</div>
<p>We refactor in small, tiny steps to make use of this point.</p>
<p>Eventually, the inside check in the balloon looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We are no longer dealing with separate x and y coordinates. We are dealing with positions.</p>
<p>A big chunk of the hit test has also moved into the new point class:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">distance_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>If we are concerned about the performance of the square root, we could write <code>inside</code> like this (equivalent to what we had before):</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">distance_squared_to</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>I think this reads a little worse, and we don’t have performance issues yet.</p>
<p>What usually happens when you extract a concept like this point is that it starts attracting new functionality. Suddenly, there is a logical place to implement something instead of spreading it across the code base.</p>
<p>Another benefit of this abstraction is that we can now more easily test the behavior of <code>distance_to</code> in isolation. No need to involve a balloon.</p>
<h2 id="spawn-new-balloons">Spawn new balloons</h2>
<p>So it’s no fun to play the game after you hit the balloon, because then there are no more balloons to hit. We want to spawn new balloons.</p>
<p>We need to modify our test. It looks like this now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; game.get_balloons()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We don’t want the balloon list to be empty. We still want it to contain a balloon. But not the balloon that we just shot down, but another one.</p>
<p>I think we can do it like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; balloons = game.get_balloons()</span>
<span class="sd">&gt;&gt;&gt; len(balloons)</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; new_balloons = game.get_balloons()</span>
<span class="sd">&gt;&gt;&gt; len(new_balloons)</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; new_balloons == balloons</span>
<span class="sd">False</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We can make the test pass by adding another balloon after the one that has been shot down has been removed:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="o">...</span>
            <span class="k">for</span> <span class="n">balloon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_baloon</span><span class="p">(</span><span class="n">balloon</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">balloon</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Balloon</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">50</span><span class="p">)))</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This now works, but it is a little hard to actually notice that we hit a balloon. It should be more clear if we include a score.</p>
<h2 id="add-score">Add score</h2>
<p>We have a place in the code where we have hit a balloon. When that happens we would also like to increase a score. What is the simplest implementation of that?</p>
<p>What if we just maintain a list of sprites where each sprites represents a point? Let’s see.</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">balloons</span><span class="o">=</span><span class="p">[(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)],</span> <span class="n">arrows</span><span class="o">=</span><span class="p">[]):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="o">...</span>
            <span class="k">for</span> <span class="n">balloon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_baloon</span><span class="p">(</span><span class="n">balloon</span><span class="p">):</span>
                    <span class="o">...</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PointMarker</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">50</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">())</span><span class="o">*</span><span class="mi">10</span><span class="p">)))</span>
</pre>
</div>
</div>
</div>
<p>We use the length of the point sprites to calculate the position of the next point marker.</p>
<p>We also add a getter for the points so that we can test this behavior:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>And here is the <code>PointMarker</code> that draws a circle at the given position:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">PointMarker</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>This is what it looks like after a few balloons have been hit:</p>
<center>
<img src="points.png" title="fig:" alt="Point markers." />
</center>
<p>When I showed this to my son, he thought it was a little fun when point markers appeared on the screen. He also wanted to make the point markers go all across the screen, and also wanted me to count how many points we had about half way through. I don’t like counting small yellow circles, so we probably need a better solution for displaying points. We make a note about that.</p>
<p>If you want to try this version or look at the complete source code from this episode, it is on <a href="https://github.com/rickardlindberg/agdpp/tree/hit-balloon-and-score-points">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>The state based testing approach continues to work well. Tests are easy to write, and I don’t think the getters that we add to expose internal state are too problematic.</p>
<p>We now have a first version of a balloon shooter game. Now we have to show it to our customers, have them play it, gather feedback, and keep improving. One story at a time.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Tue, 09 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-hit-balloon-and-score-points/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Game over?</title>
    <link>http://rickardlindberg.me/writing/agdpp-game-over/</link>
    <description><![CDATA[<h1>Game over?</h1>

<p><em>Published on  6 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>When we worked on <a href="/writing/agdpp-shooting-arrow/index.html">shooting the arrow</a> we concluded that it was tedious to restart the game after each shot. When the arrow goes outside the screen, we want the game to be over instead and the arrow to be reset. Let’s work on that in this episode.</p>
<h2 id="do-we-really-need-game-over">Do we really need game over?</h2>
<p>If we implement game over now, there will be game over after every shot. Because there is no way to hit the balloon just yet.</p>
<p>If you play a game where it is game over immediately, would you enjoy it?</p>
<p>Perhaps game over is not the right story to work on? It is a solution to the problem that you don’t have any arrows to shoot after the first one.</p>
<p>How about if you get a new arrow immediately? So you can just keep firing?</p>
<p>From before, these are the stories we though about as needed for an initial balloon shooter:</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>Let’s think about this. For minimal, I don’t think we need real graphics. The circles convey the idea just fine.</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>I’m not sure the balloon needs to move downwards either. The current movement pattern is fine.</p>
<ul>
<li><del>Balloon moves downwards</del></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>And we can do something else instead of game over.</p>
<ul>
<li><del>Balloon moves downwards</del></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li><del>Game over when miss</del></li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>That leaves us with this:</p>
<ul>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>New arrow when the current one has been shot</li>
</ul>
<p>We can always make something smaller. And what we initially thought we needed, we don’t need. At least not yet. When we play the game, we quite quickly find out what is needed next. Working software. In the hands of its users. Powerful.</p>
<p>Let’s work on spawning arrows now so that we can enjoy shooting arrows for a longer time without having to restart our game.</p>
<h2 id="acceptance-criteria">Acceptance criteria</h2>
<p>I can think of two test:</p>
<ul>
<li>You get a new arrow when you shoot the current one</li>
<li>When an arrow goes outside the screen, we stop rendering it</li>
</ul>
<p>The second test is kind of internal. If we render thousands of arrows outside the screen, no one will notice. Until there is a performance issue or an out of memory crash or something like that.</p>
<p>On the other hand, it makes sense, from a gameplay perspective, to talk about arrows going off the screen as being deactivated. Otherwise it might be that they come back after a while, but now instead move downwards.</p>
<h2 id="how-to-write-the-tests">How to write the tests?</h2>
<p>All tests for our game are currently written at the top-level. Here is the test that checks for behavior when we press the space key:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">We run the game for a few frames, press the space key, let it run for a few</span>
<span class="sd">frames, then quit:</span>

<span class="sd">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_keydown_space()],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>

<span class="sd">The arrow moves:</span>

<span class="sd">&gt;&gt;&gt; arrow_head_positions = events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We filter out <code>DRAW_CIRCLE</code> events with radius 10 with the assumption that the only circle drawn with radius 10 is the arrow head.</p>
<p>This test assumes only one arrow.</p>
<p>If we were to draw another arrow, there would be no way of identifying the two different arrows in this test.</p>
<p>So writing the new tests at this level feels difficult and error prone.</p>
<p>Testing is so hard.</p>
<p>Let’s see if we can make a new attempt at extracting a subsystem where this new behavior is easier to test.</p>
<h2 id="sprite-group-and-game-scene-refactoring">Sprite group and game scene refactoring</h2>
<p>Our game currently looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="n">Balloon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>I have an idea for how to push much of this logic down one level so that it can more easily be tested. Let’s give it a try.</p>
<p>We keep all our sprites in a list. Managing a list of sprites seems like a good job for a new class. We create a <code>SpriteGroup</code> class that works like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; class TestSprite:</span>
<span class="sd">...     def update(self, dt):</span>
<span class="sd">...         print(f&quot;TEST SPRITE update {dt}&quot;)</span>
<span class="sd">...     def draw(self, loop):</span>
<span class="sd">...         print(f&quot;TEST SPRITE draw {loop}&quot;)</span>

<span class="sd">&gt;&gt;&gt; group = SpriteGroup([TestSprite()])</span>
<span class="sd">&gt;&gt;&gt; x = TestSprite()</span>
<span class="sd">&gt;&gt;&gt; y = group.add(x)</span>
<span class="sd">&gt;&gt;&gt; x is y</span>
<span class="sd">True</span>

<span class="sd">&gt;&gt;&gt; group.update(4)</span>
<span class="sd">TEST SPRITE update 4</span>
<span class="sd">TEST SPRITE update 4</span>

<span class="sd">&gt;&gt;&gt; group.draw(None)</span>
<span class="sd">TEST SPRITE draw None</span>
<span class="sd">TEST SPRITE draw None</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>A sprite is any object that can respond to <code>update</code> and <code>draw</code> calls. When we update and draw the sprite group, it calls the corresponding methods on all its sprites.</p>
<p>We can use this new class in our game like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="n">Balloon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sprites</span> <span class="o">=</span> <span class="n">SpriteGroup</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sprites</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sprites</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>Not much of a difference. Mainly we moved the looping over the sprites from our game to the sprite group class. I think this is a bit cleaner, but it makes testing no easier.</p>
<p>But we are not done yet. Now, let’s extract a lower level object that we call <code>GameScene</code>.</p>
<p>The init of the game then changes to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span> <span class="o">=</span> <span class="n">GameScene</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>And the tick method changes to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That is, we defer event handling, updating, and drawing to the game scene.</p>
<p>The game scene looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Balloon</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ExitGameLoop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>It inherits from <code>SpriteGroup</code> so it gets the <code>update</code> and <code>draw</code> “for free”. And the event handling code is extracted from game. (Since the <code>event</code> method does not have access to the game loop, we can’t call <code>loop.quit()</code> to exit, so we instead raise the exception that <code>loop.quit()</code> would have raised. Initially I thought it would be nice if the loop hide the quit mechanism, and so I did not want to expose the exception. That made this part difficult to write, so I reverted that decision. We constantly adapt the design to the current needs. Perhaps hiding was not the right decision? Or perhaps it was. This will do for now.)</p>
<p>Now that we have a new lower-level object, has testing become any easier?</p>
<h2 id="slow-progress">Slow progress</h2>
<p>I feel like this feature we are working on is quite easy to implement. It will just be a couple of lines of code. Yet, here we are many hours into a sprite group refactoring that we are not sure will even pay off. Why? Only so that we can write a test that “allow” us to write those couple of lines that actually implement this feature.</p>
<p>When we work in an agile way, we constantly change our software, and having a good safety net in the form of a test suite allows us to make changes confidently.</p>
<p>But if it always takes x minutes to write the test and x/10 minutes to implement the thing, is it really worth it?</p>
<p>My suspicion and hope is that testing time varies. When a feature requires a design change, things will take a little longer. With a new design in place, new features can more easily be added (and tested). Until another design challenge comes a long.</p>
<h2 id="state-based-testing">State based testing</h2>
<p>Let’s see how we can test our lower-level game scene object. It is now responsible for some behavior that the balloon shooter class was previously responsible for, so we should be able to write some tests that check the same behavior.</p>
<p>Let’s try initial state: the balloon should animate and the arrow should stay still. Here are tests for that:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initial state</span>
<span class="sd">    =============</span>

<span class="sd">    The balloon animates:</span>

<span class="sd">    &gt;&gt;&gt; game = GameScene()</span>
<span class="sd">    &gt;&gt;&gt; first_position = game.get_balloon_position()</span>
<span class="sd">    &gt;&gt;&gt; game.update(10)</span>
<span class="sd">    &gt;&gt;&gt; second_position = game.get_balloon_position()</span>
<span class="sd">    &gt;&gt;&gt; first_position == second_position</span>
<span class="sd">    False</span>

<span class="sd">    The arrow stays still:</span>

<span class="sd">    &gt;&gt;&gt; game = GameScene()</span>
<span class="sd">    &gt;&gt;&gt; first_position = game.get_arrow_position()</span>
<span class="sd">    &gt;&gt;&gt; game.update(10)</span>
<span class="sd">    &gt;&gt;&gt; second_position = game.get_arrow_position()</span>
<span class="sd">    &gt;&gt;&gt; first_position == second_position</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We create a game scene, query some of its state, update it, query some it its state again and make some assertions.</p>
<p>When we wrote these test at the balloon shooter level, we had to assert that circles were drawn in specific locations. In this test, no drawing is involved.</p>
<p>In order for the tests above to work, we have to write getters to expose some internal state:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_balloon_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_arrow_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>These are only used in tests.</p>
<p>For a long time, I was reluctant do this. Mainly because I’ve been taught that objects should not expose internals to the outside world. That is bad object oriented design.</p>
<p>But <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#visible-behavior">James writes</a></p>
<blockquote>
<p>For mutable objects, provide a way for changes in state to be observed, either with a getter method or an event.</p>
</blockquote>
<p>So if we don’t want to use mocks (which we are practicing), exposing state via getters is probably fine.</p>
<p>One thing that we are not testing with these new tests is that the balloon and the arrow are actually drawn at the positions that are returned by the getters.</p>
<p>We could probably write tests where we call the draw method as well and observe <code>DRAW_CIRCLE</code> events and see that they match. But I think the trade off is not worth it in this case. We still have the top-level tests that check that things are drawn on the screen, and the likelihood that we don’t draw at the position that the getter returns is quite small I think.</p>
<p>Anyway, now that we are (mostly) fine with writing getters to expose internal state, testing should be a little smoother.</p>
<h2 id="tests-for-new-arrow-behavior">Tests for new arrow behavior</h2>
<p>Let’s start with the initial state. We introduce the concept of flying arrows (arrows that have been shot) and check that there aren’t any in the beginning:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene()</span>
<span class="sd">&gt;&gt;&gt; game.get_flying_arrows()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We make it work like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_flying_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">()</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We also add the <code>get_sprites</code> getter in the <code>SpriteGroup</code> class. Again, this getter is only used in tests. This bothers me again. Not that it is only used in tests, but that this feels like bad object oriented design. Perhaps it would be cleaner it the sprite group only provided a <code>get_count</code> method? Or something more specific instead of just exposing its internal collection.</p>
<p>But we are fine with exposing internal state for testing purposes. So we don’t think too much about it now. But let’s keep it in the back of our minds for the future.</p>
<p>Let’s move on to shooting so that we get some flying arrows. Here is the test:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene()</span>
<span class="sd">&gt;&gt;&gt; initial_position = game.get_arrow_position()</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span>
<span class="sd">&gt;&gt;&gt; game.update(10)</span>

<span class="sd">It makes the arrow fire:</span>

<span class="sd">&gt;&gt;&gt; flying = game.get_flying_arrows()</span>
<span class="sd">&gt;&gt;&gt; len(flying)</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; flying[0].get_position() == initial_position</span>
<span class="sd">False</span>

<span class="sd">The initial arrow stays the same:</span>

<span class="sd">&gt;&gt;&gt; game.get_arrow_position() == initial_position</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We simulate a shot by sending a space keydown event followed by an update. We assert that we now have a flying arrow and that its position is not the original position of the arrow (it has moved). Furthermore we assert that the current arrow position is the same as the initial meaning that we still have an arrow that we can shoot.</p>
<p>The implementation: change the event handler for keydown space from this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">(</span><span class="n">shooting</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>So the arrow that we shoot actually stays the same and we create a new arrow instance which will be the one shot.</p>
<p>At this point we can actually shoot multiple arrows in the game:</p>
<center>
<img src="multiple-arrows.png" title="fig:" alt="Multiple arrows." />
</center>
<h2 id="remove-arrows-outside-screen">Remove arrows outside screen</h2>
<p>We are almost there. But if we keep running the game for long enough, we will get an out of memory error. So we need to remove arrows that go outside the screen.</p>
<p>We write this test:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space)</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span>
<span class="sd">&gt;&gt;&gt; game.update(10000)</span>
<span class="sd">&gt;&gt;&gt; game.get_flying_arrows()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>If we decrease the number in <code>update</code> the flying arrows collection will not be empty because the arrow that we shoot has not had time to fly off screen yet.</p>
<p>We make this test pass by overriding the <code>update</code> method of the sprite group and doing the collision detection to remove flying arrows outside the screen:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">hits_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Now the <code>get_sprites</code> method that we wrote before, for testing purposes, comes in handy. Iterating over sprites in a collection seems like a reasonable behavior. I still don’t think we should expose the internal collection. That is bad. But we could expose some kind of iterator.</p>
<p>Oh, and to remove the sprite, we actually reach into the fields of the flying arrows group and call it’s <code>remove</code> method. Yikes. But the tests pass. Let’s commit and see if we can improve this.</p>
<p>We come up wit this instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">SpriteGroup</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">arrow</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p><code>x</code> is not a very meaningful name, so we call it <code>arrow</code> instead. Then we call a new <code>remove</code> method on the sprite group. No more reaching into internal fields and modifying them.</p>
<p>The sprite group looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">SpriteGroup</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_sprites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We ensure that <code>get_sprites</code> returns a new list so that the internal list is never exposed. This has two benefits:</p>
<ol type="1">
<li><p>The sprite group is in control of its own collection. No one on the outside can modify it.</p></li>
<li><p>It is safe to call <code>remove</code> at any time. Before we removed sprites from the collection we were iterating over. That is, in general, is a bad idea.</p></li>
</ol>
<p>I didn’t cover how the collision detection works or what <code>space</code> is. If you are curious, check out the details in <a href="https://github.com/rickardlindberg/agdpp/commit/4956769829b3426c9f0bb3fbe48ccde3150ca5a7">this commit</a>. The complete source code from this episode is on <a href="https://github.com/rickardlindberg/agdpp/tree/shoot-multiple-arrows">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>The big breakthrough in this episode was the realization that it’s OK to write getters to expose internal state for testing purposes. We saw that one of those getters turned out to be useful for the production code as well. I think this will make testing easier, and we will try to write as few getters as possible and only expose “sane” state. We still want to do good object oriented design.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Sat, 06 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-game-over/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>April 2023 Update</title>
    <link>http://rickardlindberg.me/writing/newsletter/april-2023/</link>
    <description><![CDATA[<h1>April 2023 Update</h1>

<p><em>Published on  3 May 2023.</em></p>

<p>This is what I’ve been up to in April 2023:</p>
<ul>
<li><p>I finished writing the blog post <a href="/writing/what-should-a-ci-server-do/index.html">What should a Continuous Integration (CI) server do?</a></p></li>
<li><p>I started working on a game and am documenting the journey in a series called <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>. This month I wrote 6 blog posts with 4 accompanying videos. It has been a lot of fun. Right now I’ve spend a little more time programming and a little less time writing, so I have some catch up to do.</p></li>
<li><p>I read a bit and thought a bit about the agile concept of a (user) story. I plan to clarify my thinking about stories by writing a blog post about it.</p></li>
<li><p>I watched <a href="https://youtu.be/UwYbSBUrotU">Ron Jeffries and Chet Hendrickson Live from Agile2017 - LeadingAgile Soundnotes</a>. The part that was most interesting to me (and my research about stories) was the idea that not everything the team does is on the backlog. Only stuff the PO cares about is on the backlog.</p></li>
<li><p>I spent some time reading articles on <a href="https://www.ronjeffries.com/">Ron’s site</a>. One favourite is <a href="https://www.ronjeffries.com/articles/-z022/0222ff/gotta-be-good/">Gotta Be Good</a>. Ron is also working on a game in Python which I tried and <a href="/writing/trying-rons-python-asteroids/index.html">wrote</a> about. His writing about his game development partly inspired me to do a similar series about my game.</p></li>
<li><p>I published another four programming videos on my <a href="https://www.youtube.com/channel/UC4XI09URnsM_YYTSizAMliA">Youtube channel</a>:</p>
<ul>
<li><a href="https://youtu.be/9DZ81lOPfmo">Introducing Agile Game Development with Python and Pygame</a></li>
<li><a href="https://youtu.be/Q0347KVq7oU">Test driving the game loop | Agile Game Development with Python and Pygame (part 2)</a></li>
<li><a href="https://youtu.be/z20IocFrKLY">Demo and game idea | Agile Game Development with Python and Pygame (part 3)</a></li>
<li><a href="https://youtu.be/CfhEcp9Qghc">Shooting the arrow | Agile Game Development with Python and Pygame (part 4)</a></li>
</ul></li>
</ul>
]]></description>
    <pubDate>Wed, 03 May 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/april-2023/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Thinking about test design</title>
    <link>http://rickardlindberg.me/writing/agdpp-thinking-about-test-setup/</link>
    <description><![CDATA[<h1>Thinking about test design</h1>

<p><em>Published on 28 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In the <a href="/writing/agdpp-shooting-arrow/index.html">previous</a> episode we were not quite happy with the design of our tests. Are we testing things at the right level? Do we see any smells? Are we missing tests? We will take some time in this episode to reflect on those questions so that things will go smooth(er), testing wise, when working on the next story.</p>
<h2 id="a-concrete-problem">A concrete problem</h2>
<p>In the previous episode I had a feeling that everything was not alright with the tests. I poked around a bit and noticed that I could change some vital production code that would break the game without my tests noticing.</p>
<p>Let’s have a look.</p>
<p>The event handling in the game now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>If we skip the check for the space key and always shoot the arrow, like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>Then the arrow goes off immediately when the game starts, which is obviously not correct, but all tests still pass.</p>
<h2 id="coverage-and-expectation">Coverage and expectation</h2>
<p>The promise of TDD and automated testing is that you can have very high test coverage. What I aspire to is to create a test suite that within seconds tells me if I broke the production code with my change. It might not be realistic, but when I find a case where I could break my production code without my tests noticing, I want to look more closely.</p>
<p>Testing can for sure be seen as a trade off. At some point it probably costs more to test than what you gain.</p>
<p>One reason to not test is that you don’t know how. That can be solved by practicing. Another reason might be that you decide that the cost is not worth it. However, the cost of testing goes down the better you get at it.</p>
<p>And in this series I’m trying to learn as well and document that process. So let’s analyze the problem with the gap in the test suite and see what we can come up with.</p>
<h2 id="what-test-is-missing">What test is missing?</h2>
<p>The balloon shooter has two tests. Here are their descriptions:</p>
<ol type="1">
<li><p>I draw the initial scene of the game which consists of a balloon and an arrow and quit when the user closes the window.</p></li>
<li><p>The arrow moves when it is shot by pressing the space key.</p></li>
</ol>
<p>The first test is checking that the initial frame is drawn correctly.</p>
<p>The second test is checking that the arrow moves when we press space.</p>
<p>But there is no test checking that the arrow stays still if we don’t press space.</p>
<p>I think we tried to remedy that in the previous episode by adding these two “lower-level tests” to the arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I stay still if I&#39;ve not been fired:</span>

<span class="sd">    &gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">    &gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; initial_y == arrow.y</span>
<span class="sd">    True</span>

<span class="sd">    I move upwards when fired:</span>

<span class="sd">    &gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">    &gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">    &gt;&gt;&gt; arrow.shoot()</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.y &lt; initial_y</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The problem is that the event checking logic is not in the <code>Arrow</code> class, but in the <code>BalloonShooter</code> class. So what we want to test can’t be tested at this level.</p>
<h2 id="where-to-test">Where to test?</h2>
<p>Writing all tests as “top-level tests” which includes all objects is not a good idea. The test setup will get complicated. The asserts will get difficult to write. The test will be slower.</p>
<p>So we want to test at as a low level as possible.</p>
<p>So if we want to test the initial state of the arrow in the <code>Arrow</code> class, we need to move event handling logic into it, so that it’s its responsibility and does not need to be tested in <code>BalloonShooter</code>.</p>
<p>On the other hand, when you start writing tests for smaller subsystems, those subsystems become harder to refactor. Suppose you are not happy with the subsystems that you have created, and you want a different design. If you do that refactoring, you also have to modify the tests to fit. That makes refactoring and design harder. So you don’t want to do it too early.</p>
<p>In our case, I think we did it too early. Our game class only has one test, and we already started extracting subsystems and writing tests there.</p>
<p>Let’s see if we can fix that.</p>
<h2 id="testing-initial-state">Testing initial state</h2>
<p>Before we had this test for the initial state:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw the initial scene of the game which consists of a balloon and an</span>
<span class="sd">arrow and quit when the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 520</span>
<span class="sd">    radius: 15</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 540</span>
<span class="sd">    radius: 20</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This only captures the initial frame. Let’s see if we can rewrite this.</p>
<p>We start with this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I am a balloon shooter game!</span>

<span class="sd">Initial state</span>
<span class="sd">=============</span>

<span class="sd">We run the game for a few frames, then quit:</span>

<span class="sd">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This is just the setup. We simulate that we start the game, run it for a couple of frames, then quit.</p>
<p>What are some behaviors that we expect to see here?</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The game loop is initialized and cleaned up:</span>

<span class="sd">&gt;&gt;&gt; events.filter(&quot;GAMELOOP_INIT&quot;, &quot;GAMELOOP_QUIT&quot;)</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The balloon is drawn animated:</span>

<span class="sd">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=40).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">[(50, 50), (51, 50), (52, 50)]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The arrow is drawn in a fixed position:</span>

<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 500)}</span>
<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=15).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 520)}</span>
<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=20).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 540)}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>These new cases cover all the cases in the old test, so we can remove the old. Furthermore it also checks that the arrow doesn’t move so that we no longer can do the mistake of always shooting the arrow. Success!</p>
<h2 id="reflecting-on-new-test-setup">Reflecting on new test setup</h2>
<p>The test for the initial state is structured by simulating a run of the game, collecting events of what happened, and then making specific assertions about those events to check different behavior.</p>
<p>Let’s structure the rests of the test that way too:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">User presses space key</span>
<span class="sd">======================</span>

<span class="sd">We run the game for a few frames, press the space key, let it run for a few</span>
<span class="sd">frames, then quit:</span>

<span class="sd">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_keydown_space()],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>

<span class="sd">The arrow moves:</span>

<span class="sd">&gt;&gt;&gt; arrow_head_positions = events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>If there are more things that should happen when we press the space key, we can add asserts for it. But for now, I don’t think there is any.</p>
<h2 id="summary">Summary</h2>
<p>All our tests for the game are now written at the top-level. They include all the objects. And they are written close to the acceptance criteria for stories. Don’t we need lower-level tests as well?</p>
<p>We for sure can’t keep testing all aspects of the game with top-level tests. Subsystems must for sure emerge that are easier to test. We will keep that in mind for the future and look extra carefully at what those subsystems might be. But for now, we are happy that we closed the gap in our test suite.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Fri, 28 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-thinking-about-test-setup/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Shooting the arrow</title>
    <link>http://rickardlindberg.me/writing/agdpp-shooting-arrow/</link>
    <description><![CDATA[<h1>Shooting the arrow</h1>

<p><em>Published on 27 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we continue towards the first version of the balloon shooter. It’s time to shoot the arrow!</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/CfhEcp9Qghc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="recap">Recap</h2>
<p>We are trying to create an absolute minimum version of a balloon shooter game that we can show to our customer and ask if that was what he had in mind. Our idea for minimal is this:</p>
<ul>
<li>1 balloon falling down the screen</li>
<li>1 arrow pointing in a fixed direction</li>
<li>1 button to shoot that single arrow</li>
<li>Then game over</li>
</ul>
<p>In the <a href="/writing/agdpp-demo-and-game-idea/index.html">previous</a> episode, we took the first step by drawing a balloon and an arrow. Here is what it looks like:</p>
<center>
<img src="shooter.png" title="fig:" alt="Balloon shooter." />
</center>
<p>And here is a list of possible stories to work on next:</p>
<ul>
<li>Balloon moves downwards</li>
<li><strong>Arrow animates when shot</strong></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>I sometimes find it hard to look too far into the future. Perhaps that is true for our customer as well. I find it much easier to look at the current state of the software and ask myself “What to work on next?”</p>
<p>When I run the game now, all I want to do is fire that arrow and see it flying across the screen. So that is our next story!</p>
<h2 id="acceptance">Acceptance</h2>
<p>When working in an agile way, things might seem reversed from what you are used to. For example, when doing TDD, we write the test before we write the code. The same applies for stories. Before starting work on a story, we should figure out the acceptance criteria. How do we know when we are done?</p>
<p>For the story with shooting arrow I think the acceptance criteria is that you should see the arrow flying across the screen when you press the space key. Our customer agrees on that.</p>
<p>The next step is to figure out how to write an automated test for that.</p>
<h2 id="the-test-we-want-to-write">The test we want to write</h2>
<p>Just to recap, the test for the balloon shooter looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; BalloonShooter(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">...</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>That is, we run the balloon shooter game, configure a set of events that should be simulated, and then assert that certain things happens (game loop inits, circles are drawn on screen, etc).</p>
<p>The test we want to write the for the shoot behavior starts like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The arrow moves when it is shot by pressing the space key:</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_keydown_space()],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; BalloonShooter(loop).run()</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We introduce a new event, keydown space, and simulate that it happens after one frame, and then we simulate a couple of more frames. The reason that we include a couple of frames is that we want to observe that the arrows moves between different frames.</p>
<p>This partial test fails because this new event does not yet exist, so let’s fix that.</p>
<h2 id="adding-a-new-event">Adding a new event</h2>
<p>We add the new event like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_event_keydown_space</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; GameLoop.create_event_keydown_space().is_keydown_space()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">K_SPACE</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">is_keydown_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">K_SPACE</span>
</pre>
</div>
</div>
</div>
<p>We figure out the Pygame event parameters to use by reading the documentation.</p>
<p>We verify that we got it correct by printing something when we get the keydown space event when running the game. We press different keys to see if it correctly only captures the space key.</p>
<p>It seems to work.</p>
<h2 id="filtering-events">Filtering events</h2>
<p>The initial test now runs, but if we print all the events that we get, there is a lot of noise:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">...</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>What we want to observe in that list of events is that the arrow has been drawn in different positions (indicating movement).</p>
<p>So first we want to filter out the <code>DRAW_CIRCLE</code> events that are for the head of the arrow.</p>
<p>We want to write like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=10)</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Filtering on event fields is not yet possible, but we own the library, and the fix goes smoothly.</p>
<p>Once that is done, we get this list of events:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This means that when we ran our game in test mode, four frames where drawn and here are all the circles with radius 10. We use 10 here because we know that the head of the arrow is the only circle that is drawn with radius 10. But it is not bullet proof. It would be better if we could pass an id to the draw method call that is included in the event as well so that we could more accurately identify objects. But this will do for now.</p>
<h2 id="extracting-positions">Extracting positions</h2>
<p>In the output above, we can look at the x and y coordinates and see if they change. But there are also other fields that we don’t care about in this test. Let’s filter out the position like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">[(500, 500), (500, 500), (500, 500), (500, 500)]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Again, the <code>collect</code> method does not exist, but we can extend our library with it.</p>
<p>Now we have a list of positions where the head of the arrow is drawn. It doesn’t seem to change, which we can see more clearly by making the collection into a set and seeing that it has only one element:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 500)}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<h2 id="real-test-failure">Real test failure</h2>
<p>We want the arrow to move, so let’s write an assert like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>That is, we should get more than one position, and the set of all those positions should also be larger than one, indicating movement.</p>
<p>The first assertion passes, but the other one fails. That is expected. Finally we have the assertion failure that we wanted. Took a bit of time, huh? That might tell us something about the design of our system. We’ll talk about it in <a href="/writing/agdpp-thinking-about-test-setup/index.html">another episode</a>.</p>
<h2 id="implementation">Implementation</h2>
<p>First, we modify the event handler to check for the space key and shoot the arrow if so:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="o">...</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The shooting mechanism, we implement like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">dt</span>
</pre>
</div>
</div>
</div>
<p>We also adjust the drawing code so that all three circles that are drawn for the arrow are drawn relative to the now variable y position.</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="mi">20</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>The arrow now moves when we press the space key. Success! Unfortunately we only have one shot. Then we need to restart the game to get a new arrow. We will fix that in another story.</p>
<h2 id="getting-tangled-up-in-tests">Getting tangled up in tests</h2>
<p>The shooting works, but I think we forgot to test the initial case. If we don’t press the space key, the arrow should stay still.</p>
<p>We can change the tick method of the arrow to this, and all tests still pass:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">dt</span>
</pre>
</div>
</div>
</div>
<p>But that makes the arrow move immediately, even if not shot, which was not intended.</p>
<p>We write a few more specific tests for the behavior of the arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I stay still if I&#39;ve not been fired:</span>

<span class="sd">&gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">&gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; initial_y == arrow.y</span>
<span class="sd">True</span>

<span class="sd">I move upwards when fired:</span>

<span class="sd">&gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">&gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">&gt;&gt;&gt; arrow.shoot()</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.y &lt; initial_y</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>That forces us to add the if statement again.</p>
<p>I’m not sure I’m entirely happy that we access the y variable like that. I prefer to see all fields of a class in Python as private (unless it’s a pure data object). But we got the test working at least.</p>
<p>I’m not happy with the current tests. On the other hand, I’m not sure how to improve them either.</p>
<p>Maybe it’s time to go for a jog or spend some time off the computer with my notebook to see if any better ideas emerge. But for now, we leave it like this.</p>
<h2 id="summary">Summary</h2>
<p>The arrow now moves. So exciting! But it’s a bummer that you have to restart the game after each shot. Therefore I think the game over screen might be most interesting to work on next. When the arrow misses (goes outside the screen) the game should be over, and the arrow should be reset.</p>
<p>After that, I think collision check with balloon would be most interesting.</p>
<p>All those require tests of course. So we should probably work on getting comfortable with the test setup as well.</p>
<p>The source code from this episode is on <a href="https://github.com/rickardlindberg/agdpp/tree/shoot-arrow">GitHub</a>.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Thu, 27 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-shooting-arrow/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Demo and game idea</title>
    <link>http://rickardlindberg.me/writing/agdpp-demo-and-game-idea/</link>
    <description><![CDATA[<h1>Demo and game idea</h1>

<p><em>Published on 24 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we demo the “game” for our customer. We get some feedback on it and start evolving the game to meet our customer’s vision.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z20IocFrKLY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="demo">Demo</h2>
<p>I mentioned to my son that I had started working on a game. He wanted to see it. I told him that there isn’t much to play yet, but that I can show him what it looks like.</p>
<p>I started the “game” and he watched the circle going back and forth.</p>
<p>For reference, this is what the “game” looks like now:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<p>Then he tried to interact with the circle. He grabbed the mouse and clicked away and was disappointed that nothing happened. I told him that you can’t do anything yet, that it’s just an animation.</p>
<p>He looked at me sad and said “Dad, this game is boring.”</p>
<p>Initially I wasn’t planning on showing him the game because in this early stage there is not much to play, and I knew he was not going to like it. Did I ruin it?</p>
<p>Then I asked him, “What would you like to do with the circle?”</p>
<p>The sadness in his face disappeared and he started talking about balloons. He said that he wanted the circle to be a balloon and that he wanted to shoot down balloons with arrows.</p>
<p>I think we have an idea for a game.</p>
<h2 id="on-early-feedback">On early feedback</h2>
<p>My initial idea for the game was some kind of tetris variant. I was thinking that you have two boards and that you could help each other out by clearing blocks on each other’s boards. Cooperation seems more fun that competition.</p>
<p>Turns out, the customer wants a balloon shooter. If we hadn’t shown the demo, we might have never found that out.</p>
<h2 id="simplest-possible-version">Simplest possible version</h2>
<p>In the spirit of <a href="https://www.artima.com/articles/the-simplest-thing-that-could-possibly-work#part3">Ward</a> we ask ourselves what the simplest possible balloon shooter could look like. What is the absolute minimum version that I can give to my son and he can somewhat enjoy playing or at least recognize as a balloon shooter? (The goal is to create a game that <em>we</em> can enjoy playing together. That means some kind of multiplayer mode. But that is another for a later story.)</p>
<p>Here is what I’m thinking:</p>
<ul>
<li>1 balloon falling down the screen</li>
<li>1 arrow pointing in a fixed direction</li>
<li>1 button to shoot that single arrow</li>
<li>Then game over</li>
</ul>
<p>So the only challenge will be to fire the arrow at the right time for it to hit the balloon. You will either hit and get a point or miss and it’ll be game over.</p>
<p>Oh, and circles for the graphics is probably fine. The balloon can be drawn with one big circle, and the arrow maybe with three smaller circles in a row. If I tell my son to imagine they are balloons and arrows, I think he’ll accept that.</p>
<h2 id="first-story">First story</h2>
<p>To make progress towards a balloon shooter, I want to work on a story that is about drawing a balloon and an arrow. Create the initial scene of the game sort of.</p>
<p>Our game already animates a circle. Let’s put all behavior related to that circle into its own class called <code>Balloon</code>. Here is how our game <code>tick</code> method looks like now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>After we extract the balloon class, it looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>And here is the balloon class:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Any behavior that the balloon should have, we can now test at this lower level. We can instantiate a balloon, call its tick method, and observe that the right thing happens. There is no need to involve the game or the game loop. (At least if we accept exposing somewhat internal state like the x variable.)</p>
<p>With the balloon object in place, it is natural to create a new object called <code>Arrow</code> for our other piece in the balloon shooter game. We create a version that just draws a circle:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We make sure it is included in the game by modifying the tick method of the game to also tick and draw the arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tick</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We notice a pattern here. It seems like the responsibility of the game is to call tick and draw on a set of objects. In games (or in Pygame) those objects are referred to as sprites. My understanding is that a sprite is any visual element that shows up in the game.</p>
<p>We refactor our game to reflect this new understanding:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="n">Balloon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>Is our game class just becoming a thing layer of loops? Can we move some of that responsibility to the game loop? I’m not certain yet, so we will leave it like this for now.</p>
<p>If we run the game now, this is what we see:</p>
<center>
<img src="scene1.png" title="fig:" alt="First scene of balloon shooter." />
</center>
<p>Not very pretty. What is that?</p>
<p>Let’s see if we can improve the drawing of the arrow. But remember, not perfection, but improvement. If I look at the game now, I don’t get an idea what the game is about. We just want to make the arrow slightly more realistic to convey the meaning of the object. We are still restricted to drawing circles. The current <code>draw_circle</code> looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That’s stupid! Why is there no ability to specify anything but the x-coordinate? Well, until now, we haven’t needed that. Now that we do need it, let’s add it. No biggie:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">radius</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">radius</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We experiment with three circles for the arrow and tweak the numbers until we think it looks good. Here is the result:</p>
<center>
<img src="scene2.png" title="fig:" alt="Improved drawing of arrow." />
</center>
<p>I don’t know about you, but when I see this, I want to press a button to fire that arrow so it hits the balloon. I’m convinced this is a balloon shooter now. I hope our customer is as well.</p>
<p>Right, balloon shooter. Before we didn’t know what game we should write, so our game class was just called <code>Game</code>. Let’s fix that:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span> from gameloop import GameLoop
 
<span class="gd">-class Game:</span>
<span class="gi">+class BalloonShooter:</span>
</pre>
</div>
</div>
</div>
<p>There! Now the code more accurately represent the ideas that we have in our minds about this game.</p>
<p>I forget to mention anything about testing. (For the complete workflow, check out the video.) But here is what the test for the balloon shooter looks like now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw the initial scene of the game which consists of a balloon and an</span>
<span class="sd">arrow and quit when the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; BalloonShooter(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 520</span>
<span class="sd">    radius: 15</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 540</span>
<span class="sd">    radius: 20</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We both changed the description, becasue we have a balloon shooter now, not a generic game, and added checks for it drawing both the balloon and the arrow.</p>
<p>It might be too specific to assert on exact coordinates here. We have to visually inspect the output and see if we think it looks good. That’s what I did here. And when I was happy, I copied the coordinates into the test.</p>
<h2 id="summary">Summary</h2>
<p>We have completed a first vertical slice of our balloon shooter. There is now a balloon and an arrow on the screen. This is new behavior that we could show to our customer and get feedback on. Perhaps he doesn’t like the position of the arrow. If so, we can adjust. Perhaps he can’t imagine that the circle is actually a balloon. If so, we can work on improving the graphics.</p>
<p>What else do we think we need before we have the first version of the balloon shooter?</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow animates when shot</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>Which one is the most important one to work on next? We’ll tackle that one in the next episode!</p>
<p>You can browse the <a href="https://github.com/rickardlindberg/agdpp/tree/initial-balloon-shooter-story">complete source code</a> from this episode.</p>
<p>See you!</p>
]]></description>
    <pubDate>Mon, 24 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-demo-and-game-idea/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Separating pygame completely from the rest of the game</title>
    <link>http://rickardlindberg.me/writing/agdpp-pygame-separation-design/</link>
    <description><![CDATA[<h1>Separating pygame completely from the rest of the game</h1>

<p><em>Published on 20 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we reflect on our current design. I see something that bothers me. We talk about it and how to fix it.</p>
<h2 id="the-problem">The problem</h2>
<p>Right now our game is split up into two main classes: the game and the game loop. The game contains the logic of our game, while the game loop is responsible for setting up pygame and calling our game on every frame.</p>
<p>Almost all references to pygame are contained in the game loop class. Our game knows almost nothing about pygame. Almost. And that bothers me.</p>
<p>Let’s have a look at the test for our game:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We can see references to pygame in two places. First when we create the quit event. We create an instance of a pygame event and pass that to the null version of the game loop. Later in the events that we assert on, there are event names mentioning pygame (<code>PYGAME_INIT</code> and <code>PYGAME_QUIT</code>).</p>
<p>Why does this bother me?</p>
<p>One purpose of introducing the game loop class was to separate pygame code from our game. One reason to do that is that our game becomes easier to test. And if it’s easier to test, it suggests that the design is also better. (People claim at least. So let’s go with that here.)</p>
<p>But some details of pygame are leaking out.</p>
<p>If <code>GameLoop</code> were instead called <code>PygameGameLoop</code>, I would be more fine with this. But I think the design would be more clear if the game didn’t know anything at all about pygame.</p>
<p>Our game loop uses the <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#infrastructure-wrappers">infrastructure wrapper</a> pattern. One purpose of that pattern is to isolate and contain infrastructure code so that the user of it can be provided an interface that is optimal for its consumption. In our case we want to design our game loop to fit exactly what our game needs. And the loop should encapsulate all the details of how to make that happen (using pygame).</p>
<p>Our game now needs to know that the pygame quit event is fired when the user closes the window. But wouldn’t it be more clear if that could be expressed in the code something like this instead?</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>Above, the game does not need to know about pygame and can directly express the idea that if the user closes the window, the game loop should be quit.</p>
<p>Enough talking, let’s see if we can fix this.</p>
<h2 id="wrapping-events">Wrapping events</h2>
<p>The tick method of our game now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The interface is that events is a list of pygame event instances.</p>
<p>Let’s change that to instead be instances of a new event class that we control. Here is a first version:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pygame_event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span> <span class="o">=</span> <span class="n">pygame_event</span>

    <span class="k">def</span> <span class="nf">is_user_closed_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Now we can change how the game loop calls the game from this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>to this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="p">[</span><span class="n">Event</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()])</span>
</pre>
</div>
</div>
</div>
<p>This breaks our tests saying that</p>
<pre><code>AttributeError: &#39;Event&#39; object has no attribute &#39;type&#39;</code></pre>
<p>We modify our game to use our new method instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>All tests are passing again.</p>
<p>We can rely on our tests for this refactoring.</p>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/ac00de877b8f4ee58716c0030c8b2ecab19a318e"><code>git commit -a -m ‘Wrap events to tick for a nicer interface.’</code></a></p>
<h2 id="test-still-mentions-pygame">Test still mentions pygame</h2>
<p>Our test for the game still creates pygame events:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Here we would like to instead express the idea that we want to simulate a user closes the window event without mentioning any more details.</p>
<p>Here is one attempt:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>And in game loop, we add this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_event_user_closed_window</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Now the game loop knows the details of how to create pygame events. I think this is better. But there is one thing that still bothers me.</p>
<p>The tick method expects a list of events with the interface that we make up, but <code>create_event_user_closed_window</code> creates a pygame event. So right now, there is no way for us to test the tick method in isolation, because there is no way to create events. If we expose the <code>Event</code> class we could do something like this in a test:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game.tick(dt=1, events=[Event(GameLoop.create_user_close_window())])</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>I’m not sure I like that. I think I would feel better if <code>create_event_user_closed_window</code> returned an event with our interface. Let’s try that.</p>
<p>We modify it:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_event_user_closed_window</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>Test fail:</p>
<pre><code>AttributeError: &#39;Event&#39; object has no attribute &#39;type&#39;</code></pre>
<p>I think we are now wrapping events in events. Let’s unpack the pygame event when creating the null version, going from this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">NullEvent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
</pre>
</div>
</div>
</div>
<p>to this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">NullEvent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">pygame_event</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[]</span>
</pre>
</div>
</div>
</div>
<p>Now another test fails:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">create_null</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;some event&quot;</span><span class="p">]])</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We just changed the interface of <code>create_null</code> to expect <code>Event</code> instances. Here we are passing a string. It should really be a pygame event. But we ignore that for now and just change to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">create_null</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[[</span><span class="n">Event</span><span class="p">(</span><span class="s2">&quot;some event&quot;</span><span class="p">)]])</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>All tests are passing. Success!</p>
<p>We add a test to illustrate the usage of the factory method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_event_user_closed_window</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; GameLoop.create_event_user_closed_window().is_user_closed_window()</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>At this point our game no longer depends on pygame. It only depends on the game loop which provides the infrastructure needed for writing a game (graphics, user input, music, etc). We can remove the import of pygame so the top of the file now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">from</span> <span class="nn">gameloop</span> <span class="kn">import</span> <span class="n">GameLoop</span>

<span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/3686e4d1f5740301f2177810cfa26fa093153c17"><code>git commit -a -m ‘Wrap events so that our game now longer knows about pygame.’</code></a></p>
<h2 id="get-rid-of-last-pygame-reference">Get rid of last pygame reference</h2>
<p>There is still one place left where our game test refers to pygame:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Some events that the game loop emits have pygame in their name.</p>
<p>Imagine that we could plug any game loop implementation into our game and from the game’s perspective, they all worked the same. Then it doesn’t make sense for it to emit events that talk about the underlying technology to realize the game loop.</p>
<p>Let’s rename <code>PYGAME_INIT</code> to <code>GAMELOOP_INIT</code> and <code>PYGAME_QUIT</code> to <code>GAMELOOP_QUIT</code>. And while we are improving events, let’s also add the resolution and fps to the init event so that we can observe them.</p>
<p>Here is how the test reads then:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/b6ef6430ee93bf9b933f5f06d69d9666ca2d1cd2"><code>git commit -a -m ‘Game loop emits events with clearer names.’</code></a></p>
<h2 id="unnecessary-work">Unnecessary work?</h2>
<p>At this point, our game knows nothing about pygame. It only relies on the interface of the game loop. That is something that we control and can design specifically for what our game needs. And should we want to switch out pygame for another graphics library, we only need to modify the game loop, not our game.</p>
<p>You might object that this seems like too much speculative design. What is the likelyhood that we want to switch graphics package? And can’t we deal with those problems when they arise?</p>
<p>On the one hand, I think that objection is valid. But I would like to see this from another angle. The purpose of this change was not to make pygame easily replaceable. The purpose of the change was to design a clean interface for our game where the different classes had different responsibilities. Only as a side effect pygame became more replaceable.</p>
<p>Had we designed a base class <code>GameLoop</code> and then derived a <code>PygameGameLoop</code> from it, then I think we would have designed speculatively. There is only one implementation of the game loop right now. We don’t even anticipate any more implementations, so why make a “placeholder” in our design where a second implementation could be plugged in?</p>
<h2 id="summary">Summary</h2>
<p>Making design changes in the beginning is generally easier. The further you go in the wrong direction, the harder it is to undo. (But with careful refactoring, it is always possible.) One problem is that it might be harder to see problems with the design early on. How are a few references to pygame problematic? I think thinking in terms of code smells instead of in terms of speculative design is useful here.</p>
<p>By the way, I’m not sure the design I choose here is the “correct” one. I’m just trying to learn and practice here and explain my thinking. But I think if I give attention to design early on, the future will be easier.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Thu, 20 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-pygame-separation-design/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Test driving the game loop</title>
    <link>http://rickardlindberg.me/writing/agdpp-game-loop/</link>
    <description><![CDATA[<h1>Test driving the game loop</h1>

<p><em>Published on 19 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we look at how to set up the game loop, draw something on the screen, and test it. We begin with a spike to learn Pygame fundamentals and then we look at how to set up tests for it.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Q0347KVq7oU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="hello-world">Hello World</h2>
<p>We start with this example straight from the <a href="https://www.pygame.org/docs/">Pygame docs</a>:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="c1"># Example file showing a basic pygame &quot;game loop&quot;</span>
<span class="kn">import</span> <span class="nn">pygame</span>

<span class="c1"># pygame setup</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>
<span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="c1"># poll for events</span>
    <span class="c1"># pygame.QUIT event means the user clicked X to close your window</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># fill the screen with a color to wipe away anything from last frame</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>

    <span class="c1"># RENDER YOUR GAME HERE</span>

    <span class="c1"># flip() the display to put your work on screen</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>

    <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># limits FPS to 60</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>When we run it, it shows an empty screen:</p>
<center>
<img src="tutorial.png" title="fig:" alt="Tutorial output." />
</center>
<h2 id="draw-something">Draw something</h2>
<p>An empty screen is not that interesting, so let’s see if we can get an animation going.</p>
<p>We add a call to draw a circle and some logic to animate it:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="o">...</span>

<span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">running</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">if</span> <span class="n">pos_x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_x</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="mf">0.3</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>

    <span class="o">...</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># limits FPS to 60</span>

<span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This seems to work. We get an animated circle:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<h2 id="refactor-to-clarify">Refactor to clarify</h2>
<p>Next we separate the logic of the game loop from the logic of our game. We refactor in small steps, testing manually that everything works, and end up with this for our game:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">screen</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="mf">0.3</span>
        <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>And this for our game loop:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
        <span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>
        <span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">screen</span><span class="p">):</span>
                <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>And it is all used like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">Game</span><span class="p">(</span><span class="n">GameLoop</span><span class="p">())</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>Remember, we are only doing a spike here. We are trying to learn Pygame and how we could split the different responsibilities into different classes and how to possibly test it.</p>
<p>With this refactoring, the game is now responsible for handling events and drawing the animated circle and the game loop is responsible for setting up Pygame and calling the game in a loop.</p>
<p>I think we have learned enough about this setup and I think I know how we could test it. Let’s see.</p>
<h2 id="how-to-test-this">How to test this?</h2>
<p>So now we start completely from scratch, test driving our game. We know roughly what we want to do from the spike.</p>
<p>Where to start?</p>
<p>I find it easiest to start from the outside when writing tests. What should the system do? What should our game do?</p>
<p>Well, our game draws a circle on the screen until the user closes the window. Let’s start there.</p>
<p>Here is how we get some basic structure in place:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I draw an animated circle until the user closes the window.</span>

<span class="sd">    &gt;&gt;&gt; game = Game(GameLoop())</span>
<span class="sd">    &gt;&gt;&gt; game.run()</span>
<span class="sd">    DRAW_CIRCLE</span>
<span class="sd">    EXIT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GameLoop</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Instead of actually drawing and exiting, we just print the action. We fake it. The point of this is to get some basic structure in place with tests. From the spike we know in which direction to go. Let’s continue.</p>
<h2 id="remove-fakes">Remove fakes</h2>
<p>Eventually we want to turn <code>GameLoop</code> into an infrastructure wrapper. This will give us the ability to conveniently use it in tests. This pattern is explained in depth in <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks">Testing Without Mocks</a>.</p>
<p>One part of that pattern is that we should be able to observe what <code>GameLoop</code> is doing.</p>
<p>Here is how we rewrite the test for our game to assert on events fired from <code>GameLoop</code> instead of print statements:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The <code>GameLoop</code> now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
</pre>
</div>
</div>
</div>
<p>Instead of printing actions, it notifies about its actions via an observable pattern.</p>
<p>We also moved the circle drawing code to the game loop and have the game call that method instead. The game loop will be responsible for drawing things on the current frame.</p>
<p>But we are still not doing anything real, we are just firing events and asserting on them. Time to fix that.</p>
<h2 id="flesh-out-pygame-calls">Flesh out pygame calls</h2>
<p>Continuing the pattern of an infrastructure wrapper, we add an argument to <code>GameLoop</code> which is the Pygame module. We provide an embedded stub for the null version that does nothing:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">pygame</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_null</span><span class="p">():</span>
        <span class="k">class</span> <span class="nc">NullPygame</span><span class="p">:</span>
            <span class="o">...</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">NullPygame</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pygame</span><span class="p">):</span>
        <span class="n">Observable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span> <span class="o">=</span> <span class="n">pygame</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We write a test for the game loop that checks that the proper events are fired:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I init and clean up pygame:</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; loop.run(NullGame())</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>And we also create a test that uses the real Pygame module:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; GameLoop.create().run(NullGame())</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This test will actually cause a window to pop up on the screen, so it is a bit distracting, but it makes sure we are calling Pygame correctly.</p>
<p>The game loop now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;PYGAME_INIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We are getting closer. If we run the game now and look carefully, we can see that a circle is drawn on the screen for a split second before it closes. That is because there is no loop yet. We just render one frame and then exit. Time to fix that.</p>
<h2 id="loop-and-events">Loop and events</h2>
<p>Let’s start with our game. The test for it should simulate an event that the user closes the window, and first then exit the application:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The <code>tick</code> method is modified to look like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>So we made the decision that the game loop should exit if the tick method returns true.</p>
<p>We add the ability for the null version of the game loop to simulate events:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_null</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[]):</span>
    <span class="k">class</span> <span class="nc">NullPygame</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">NullEvent</span><span class="p">()</span>
            <span class="o">...</span>
    <span class="k">class</span> <span class="nc">NullEvent</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">events</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">NullPygame</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>And we modify the run method to actually do a loop and pass events to the <code>tick</code> method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()):</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>If we do not configure tests for our game to simulate the quit event, the test will hang in an infinite loop.</p>
<p>If we run the game now, the circle stays on the screen until we close the window. But it doesn’t move. Let’s work on that.</p>
<h2 id="test-animation">Test animation</h2>
<p>We modify the test for our game by simulating one more event so that one more frame is rendered. That gives us two calls to draw circle:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We had to add the <code>x</code> argument to the <code>DRAW_CIRCLE</code> event so that we could observe that it changed:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We also had to make a new call to clear the screen. If we don’t clear the screen we end up with circles drawn on top of each other. Clearing the screen works like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">clear_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;CLEAR_SCREEN&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>And the implementation for the animation looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>To make the animation frame rate independent, we also had to include the delta time. This is implemented in the game loop similar to how we did it in the spike:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()):</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">...</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>At this point our test-driven implementation does the same thing that our spike does. We are now in a good place to move forward.</p>
<h2 id="refactor-exit">Refactor exit</h2>
<p>Before closing this episode, let’s take advantage of our test suite and explore an alternative way to exit the application. Instead of having a boolean return from <code>tick</code> indicating if we should exit or not, which I think is a bit unclear, let’s try an exception. Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">ExitGameLoop</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre>
</div>
</div>
</div>
<p>The tick method then turns into this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExitGameLoop</span><span class="p">()</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>And the game loop into this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="o">...</span>
    <span class="k">except</span> <span class="n">ExitGameLoop</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;PYGAME_QUIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>I like this better. And all the tests still pass, unchanged.</p>
<h2 id="summary">Summary</h2>
<p>We have now recreated the functionality that we had in the spike, added the ability to test it, and improved the design with the safety net of our tests. Great success!</p>
<p>You can browse the <a href="https://github.com/rickardlindberg/agdpp/tree/initial-game-loop">complete source code</a> from this episode.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Wed, 19 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-game-loop/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Trying Ron's Python Asteroids</title>
    <link>http://rickardlindberg.me/writing/trying-rons-python-asteroids/</link>
    <description><![CDATA[<h1>Trying Ron's Python Asteroids</h1>

<p><em>Published on 18 April 2023.</em></p>

<p><a href="https://www.ronjeffries.com/">Ron</a> is working on an Asteroids game in Python and also <a href="https://www.ronjeffries.com/categories/python/">writing</a> about it. I’m interested in his workflow, so I follow along.</p>
<p>He recently published the code on <a href="https://github.com/RonJeffries/python-asteroids-1">Github</a>.</p>
<p>I thought I would have a look.</p>
<h2 id="first-look">First look</h2>
<p>I clone the repo and see a bunch of Python files and an <code>.idea</code> folder.</p>
<p>I’ve never been a fan of IDEs. Perhaps I should learn one properly. In any case I find it useful to be able to run commands from the command line as well.</p>
<p>First, I want to see if I can get this game running:</p>
<pre><code>$ python game.py
AttributeError: &#39;pygame.math.Vector2&#39; object has no attribute &#39;copy&#39;</code></pre>
<p>I suspect I’m using a different version of pygame that lacks the copy method on vectors.</p>
<p>I try to run the test to see if I get the same failure there. How to run the tests? I think Ron mentioned that he uses <a href="https://pytest.org/">pytets</a>. I try:</p>
<pre><code>$ pytest
===================================================================== test session starts =====================================================================
platform linux -- Python 3.9.10, pytest-6.2.2, py-1.11.0, pluggy-0.13.1
rootdir: /home/rick/downloads/python-asteroids-1
collected 3 items / 3 errors
...</code></pre>
<p>I see the same error about the copy method of vector and some more in the same style.</p>
<p>I read about the copy method in the pygame manual and conclude that it was added in a later version.</p>
<h2 id="upgrade-pygame">Upgrade pygame</h2>
<p>I think I’ve installed pygame via Fedora’s package manager. That doesn’t have a more recent version of pygame.</p>
<p>I try to install it using pip instead:</p>
<pre><code>$ pip install --user pygame
Requirement already satisfied: pygame in /usr/lib64/python3.9/site-packages (2.0.3)</code></pre>
<p>I add <code>--user</code> because I don’t want to install anything globally using pip. I suppose I should create a virtual environment, but I haven’t worked much with them. This will do.</p>
<p>It indeed tells me that I already have pygame installed. How do I upgrade? Ah, the <code>--upgrade</code> flag:</p>
<pre><code>$ pip install --user --upgrade pygame
Requirement already satisfied: pygame in /usr/lib64/python3.9/site-packages (2.0.3)
Collecting pygame
  Downloading pygame-2.3.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (13.8 MB)
     |████████████████████████████████| 13.8 MB 692 kB/s 
Installing collected packages: pygame
Successfully installed pygame-2.3.0</code></pre>
<p>Sometimes I hesitate to install Python packages via pip. Especially when they are not pure Python packages (like pygame which depends on SDL and C libraries). Mostly because it hasn’t worked so well for me in the past. Maybe things are better now. And maybe it depends on the library. Let’s see how this works now.</p>
<h2 id="testing-the-game-again">Testing the game again</h2>
<p>I try running the game again:</p>
<pre><code>$ python game.py 
pygame 2.3.0 (SDL 2.24.2, Python 3.9.10)
Hello from the pygame community. https://www.pygame.org/contribute.html</code></pre>
<p>Success! Or, I don’t get any errors at least. But it exits right away. Am I running the wrong file?</p>
<p>Ah, there is a <code>main.py</code>. Let’s try that.</p>
<p>It works!</p>
<center>
<img src="game.png" title="fig:" alt="Ron’s Asteroids game." />
</center>
<h2 id="zero-friction">Zero friction</h2>
<p>I’m quite familiar with both Python and pygame, so it was not that difficult for me to get started. But I think we can improve.</p>
<p>One idea that I got from James Shore’s writing about a <a href="https://www.jamesshore.com/v2/books/aoad2/zero_friction">zero friction</a> development is that you should have scripts for doing common tasks like running your tests.</p>
<p>Let’s <a href="https://github.com/RonJeffries/python-asteroids-1/pull/1">see</a> if Ron likes that as well. I add one script to test</p>
<div class="rliterate-code">
<div class="rliterate-code-header">
<ol class="rliterate-code-path">
<li>
<span class="cp">build.sh </span>
</li>
</ol>
</div>
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="ch">#!/usr/bin/env bash</span>

<span class="nb">set</span> -e

pytest
</pre>
</div>
</div>
</div>
<p>and one to run the application</p>
<div class="rliterate-code">
<div class="rliterate-code-header">
<ol class="rliterate-code-path">
<li>
<span class="cp">rundev.sh </span>
</li>
</ol>
</div>
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="ch">#!/usr/bin/env bash</span>

<span class="nb">exec</span> python main.py
</pre>
</div>
</div>
</div>
<p>Should the way to run tests or the application change, only those files need to be changed, and the usage of the developer stays the same.</p>
]]></description>
    <pubDate>Tue, 18 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/trying-rons-python-asteroids/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>TDD trick: fake it!</title>
    <link>http://rickardlindberg.me/writing/tdd-fake-it/</link>
    <description><![CDATA[<h1>TDD trick: fake it!</h1>

<p><em>Published on 17 April 2023.</em></p>

<ul>
<li><a href="#the-example">The example</a></li>
<li><a href="#fake-it">Fake it!</a></li>
<li><a href="#refactor">Refactor</a></li>
<li><a href="#infrastructure-wrapper">Infrastructure wrapper</a></li>
<li><a href="#make-game-loop-more-real">Make game loop more real</a></li>
<li><a href="#looping-and-animation">Looping and animation</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
<p>The first step in the TDD loop is to think about what test to write. I find it easiest to do that from the outside-in. I might not yet know what different parts my system will consist of (especially in the beginning), but I do know some behavior of the entire system.</p>
<p>The problem with outside-in is that the test might be difficult to write because we don’t have enough infrastructure in place to make the appropriate assertions.</p>
<p>In this blog post I want to show you a trick to overcome that problem: fake it! (This is also similar to what James describes in <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#grow-seeds">Grow Evolutionary Seeds</a>.)</p>
<h2 id="the-example">The example</h2>
<p>I will illustrate this trick with an example from a <a href="/projects/agdpp/index.html">game</a> that I’m working on.</p>
<p>So far, the game doesn’t do much. It just animates a circle:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<p>The behavior of the game can be described as this:</p>
<blockquote>
<p>I draw an animated circle until the user closes the window.</p>
</blockquote>
<h2 id="fake-it">Fake it!</h2>
<p>With an empty project, it seems quite difficult to write a test that actually checks for that. What to do? Let’s fake it! Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I draw an animated circle until the user closes the window.</span>

<span class="sd">    &gt;&gt;&gt; game = Game()</span>
<span class="sd">    &gt;&gt;&gt; game.run()</span>
<span class="sd">    DRAW_CIRCLE</span>
<span class="sd">    EXIT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Really? How is this useful?</p>
<p>First of all we have got a description of one behavior of our system. We also have code that verifies that behavior, even though it is not yet complete. (The example shown in the docstring of the game class is actually an executable test written using Python’s <a href="https://docs.python.org/3/library/doctest.html">doctest</a> module.)</p>
<p>From here it is usually easier to see what to continue with. When we have <a href="https://www.artima.com/articles/the-simplest-thing-that-could-possibly-work">something on the screen</a>, we can more easily criticize it and improve it.</p>
<p>So, what next?</p>
<h2 id="refactor">Refactor</h2>
<p>Are you kidding? Refactor already?</p>
<p>To make this game testable, I want to separate the logic of the game from the infrastructure needed to initialize and use a graphics library. I imagine a game loop class that is responsible for that.</p>
<p>We can evolve the design in that direction even with what we have now. Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I draw an animated circle until the user closes the window.</span>

<span class="sd">    &gt;&gt;&gt; game = Game(GameLoop())</span>
<span class="sd">    &gt;&gt;&gt; game.run()</span>
<span class="sd">    DRAW_CIRCLE</span>
<span class="sd">    EXIT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">GameLoop</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>The game now gets a loop as a dependency. Can you see how this would be possible to test now? We could inject some kind of test double as the loop and verify that it is called correctly.</p>
<p>Notice that we were able to do this refactoring with the safety net of the test. We have one teeny, tiny test that asserts something fake, but it still helped us do this refactoring.</p>
<h2 id="infrastructure-wrapper">Infrastructure wrapper</h2>
<p>For the test double version of the game loop, I want to use some patterns from <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks">Testing Without Mocks</a>.</p>
<p>I want to turn the game loop into an infrastructure wrapper. One part of that pattern is that it should emit events of what it’s doing so that tests can observe it.</p>
<p>Let’s replace the print statements, that we used to fake actions, with events. Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
</pre>
</div>
</div>
</div>
<p>The test for the game then changes to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>(I won’t show the code for <code>Observable</code>. If you are curious to know the details, you can look <a href="https://github.com/rickardlindberg/agdpp/blob/initial-game-loop/events.py">here</a>.)</p>
<p>And this is starting to look more real now. There is no real faking going on in the game or its test any more. It seems logical to assert that the game loop emits those events.</p>
<p>But the game loop is still just emitting events, it’s not actually doing anything.</p>
<h2 id="make-game-loop-more-real">Make game loop more real</h2>
<p>The game loop should initialize a graphics library and provide to the game a way to draw on the screen. We will use <a href="https://www.pygame.org/news">pygame</a> for that. So our game loop will be an infrastructure wrapper around pygame providing a clean interface for our game to draw on the screen.</p>
<p>We need to make the <code>run</code> method and the <code>draw_circle</code> method do something real. Here is a first version:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;PYGAME_INIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Notice that have an instance variable called <code>pygame</code>.</p>
<p>When we test our game class, we don’t actually want to execute any pygame code that creates windows and draws circles on the screen. Therefore we use another pattern of an infrastructure wrapper which is that it can be nullable. That means that we can instantiate two version of our game loop:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">GameLoop</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">GameLoop</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>The creation methods look like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">pygame</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_null</span><span class="p">():</span>
        <span class="k">class</span> <span class="nc">NullPygame</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span> <span class="c1"># Do nothing</span>
            <span class="o">...</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">NullPygame</span><span class="p">())</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The null version works exactly the same as the real version except it nulls out all the calls that actually do anything with pygame. This is useful in tests so that we don’t open windows and actually draw graphics when we don’t need to.</p>
<p>Our game test can use the null version of the game loop and will continue to work as it did before.</p>
<p>When actually running our game, we create the real version of the game loop which will include all the real calls to pygame.</p>
<p>We can also test the real game loop in isolation, passing it a test game, to make sure that we call pygame correctly:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; GameLoop.create().run(TestGame())</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This will actually open a window and draw whatever the test game draws. We can program the test game to exit immediately so that the test suite will not hang waiting for user input. But we will still see a flashing window which is a bit distracting.</p>
<p>To verify that our implementation of <code>draw_circle</code> works, we have to inspect the output visually. A test like the one above only asserts that we call pygame functions correctly, not that the output looks the way we want.</p>
<p>This is a general problem with infrastructure that it is difficult to test, because it involves the real world.</p>
<p>Anyway, that’s a little beside the point of this article. Where were we?</p>
<h2 id="looping-and-animation">Looping and animation</h2>
<p>If we run our game now, it will actually show a window with a circle on it. But the window will close immediately.</p>
<p>That is because the game loop still doesn’t implement a loop.</p>
<p>Let’s have a look at our game test again:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>It talks about <em>animating</em> a circle, and about <em>waiting</em> for the user to close the window. But there is nothing in the setup or assertions about this. We are missing something.</p>
<p>Hopefully, at this point, it is a bit more clear where to continue.</p>
<p>Once we implement the loop and some event handling, I think the initial behavior of our game will actually be fully realized.</p>
<p>Here is what the final test for the game looks like when I continued fleshing out all the fakes and missing pieces:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<h2 id="summary">Summary</h2>
<p>We started with something fake, then did a bit of design, then removed one fake at a time until there were no fakes left.</p>
<p>I find this a useful way of working, especially when getting started. Once you have some structure in place it is easier to see where you need to add additional tests and functionality.</p>
<p>(If you want more details about this example in particular, check out my <a href="/writing/agdpp-game-loop/index.html">article</a> about how I implemented this part of the game.)</p>
]]></description>
    <pubDate>Mon, 17 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/tdd-fake-it/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Introducing Agile Game Development with Python and Pygame</title>
    <link>http://rickardlindberg.me/writing/agdpp-introduction/</link>
    <description><![CDATA[<h1>Introducing Agile Game Development with Python and Pygame</h1>

<p><em>Published on  9 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>I recently started playing computer games with my son. That sparked an interest in me to create a game myself that we can play together. Mostly because I think this will be a <strong>fun project</strong>, but also to show my son that you can actually make your own games. It’s not something that you <em>only</em> consume.</p>
<p>I thought I would also document this journey in a series of blog posts and videos.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/9DZ81lOPfmo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="the-challenge">The challenge</h2>
<p>The challenge is to create a game that me and my son will enjoy playing together.</p>
<h2 id="the-method">The method</h2>
<p>I want to develop this game using Agile methodology.</p>
<p>It means that instead of first figuring out what game I want to write, I will develop it incrementally and guide development by feedback.</p>
<p>It also means that I will rely heavily on self-testing code and TDD.</p>
<h2 id="my-background-in-games">My background in games</h2>
<p>I’m by no means an expert in creating games. I don’t even play games that much. But I have enjoyed creating some simple games in the past, like a Tetris clone and some kind of Asteroids.</p>
<p>I was actually able to restore an old copy of one of my Tetris games. It is written using Python and Pygame (which I also plan to use for my new game). I just needed to make a few small adjustments to make it work with Python 3. This is what it looks like:</p>
<center>
<img src="tetris1.png" title="fig:" alt="Intro screen of my Tetris game." />
</center>
<center>
<img src="tetris2.png" title="fig:" alt="Gameplay screen of my Tetris game." />
</center>
<h2 id="series-overview">Series overview</h2>
<p>So this series will cover how to create a game from the perspective of someone who has much experience programming, but not that much knowledge in the game domain.</p>
<p>Here is a list of topics off the top of my head that I imagine I will cover:</p>
<ul>
<li>Game loop and how to test it</li>
<li>Can you really use TDD for games?</li>
<li>Learn to capture events from Logitech controller</li>
<li>How to come up with an idea for a game?</li>
<li>Performance: background erase vs redraw?</li>
<li>Resolution: what to choose?</li>
<li>How to incrementally develop a game idea?</li>
<li>Particle effects</li>
</ul>
<p>This list is just the beginning of my journey. I hope will enjoy following along.</p>
<p>See you in the next episode!</p>
]]></description>
    <pubDate>Sun, 09 Apr 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/agdpp-introduction/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>

    </channel>
</rss>
