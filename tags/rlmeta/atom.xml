<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Rickard's personal homepage: latest posts tagged rlmeta</title>
    <link href="http://rickardlindberg.me/tags/rlmeta/atom.xml" rel="self" />
    <link href="http://rickardlindberg.me" />
    <id>http://rickardlindberg.me/tags/rlmeta/atom.xml</id>
    <author>
        <name>Rickard Lindberg</name>
        <email>rickard@rickardlindberg.me</email>
    </author>
    <updated>2022-02-12T00:00:00Z</updated>
    <entry>
    <title>RLMeta poster 2: the poster that wasn't</title>
    <link href="http://rickardlindberg.me/writing/rlmeta-poster-2/" />
    <id>http://rickardlindberg.me/writing/rlmeta-poster-2/</id>
    <published>2022-02-12T00:00:00Z</published>
    <updated>2022-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>RLMeta poster 2: the poster that wasn't</h1>

<p><em>Published on 12 February 2022.</em></p>

<ul>
<li><a href="#code-walk-through">Code walk through</a>
<ul>
<li><a href="#getting-rlmeta">Getting RLMeta</a></li>
<li><a href="#file-structure">File structure</a></li>
<li><a href="#exploring-rlmeta">Exploring RLMeta</a></li>
<li><a href="#a-tour-of-the-main-function">A tour of the main function</a></li>
<li><a href="#following-a-compilation">Following a compilation</a></li>
<li><a href="#the-purpose-of-the-make-script">The purpose of the make script</a></li>
</ul></li>
<li><a href="#changes-from-the-poster-version">Changes from the poster version</a>
<ul>
<li><a href="#generate-labels-in-semantic-actions">Generate labels in semantic actions</a></li>
<li><a href="#remove-dependency-on-bash">Remove dependency on Bash</a></li>
<li><a href="#extract-assembler">Extract assembler</a></li>
<li><a href="#rewrite-vm-for-clarity">Rewrite VM for clarity</a></li>
<li><a href="#add-ability-to-run-a-rule-in-semantic-action">Add ability to run a rule in semantic action</a></li>
<li><a href="#misc">Misc</a></li>
</ul></li>
<li><a href="#the-future">The future</a></li>
<li><a href="#code-listings-for-rlmeta">Code listings for RLMeta</a>
<ul>
<li><a href="#srcparser.rlmeta">src/parser.rlmeta</a></li>
<li><a href="#srccodegenerator.rlmeta">src/codegenerator.rlmeta</a></li>
<li><a href="#srcassembler.rlmeta">src/assembler.rlmeta</a></li>
<li><a href="#srcsupport.py">src/support.py</a></li>
<li><a href="#srcmain.py">src/main.py</a></li>
<li><a href="#make.py">make.py</a></li>
</ul></li>
</ul>
<p>A while ago I created a <a href="/writing/creating-rlmeta-poster/index.html">poster</a> to showcase RLMeta. The version of RLMeta on the poster is based on the version from the <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures</a> article, but I made it smaller and more beautiful to better fit the poster. To be able to finish the poster, I had to stop making changes and put the source code on the poster. That was difficult because I felt the need for it to be perfect. Eventually I did stop polishing, and left a few items unresolved.</p>
<p>Almost immediately after I finished the poster, I started working on a second version. Initially, my plan was to make a second version of the poster. I started to fix the unresolved items and I was making progress. But somehow imperfections kept creeping in. It felt like a never ending game of chasing perfection. That’s when I decided that a second poster was probably not going to be worth it. But I still liked the new version of RLMeta.</p>
<p>Instead, I decided to attempt to present the new version in the style of a code walk through. In other words, another way to showcase RLMeta that is also a bit more practical. Compared to the poster version, this version could also be more easily improved because rendering the blog post is automatic whereas creating the layout of a poster requires manual work every time the source code changes. I also wanted to experiment with the walk through format because I thought it could be something worth putting into the README of a project.</p>
<p>The rest of this blog post consists of the walk through of the new version of RLMeta and a section on the most important changes from the poster version and motivations for them.</p>
<h2 id="code-walk-through">Code walk through</h2>
<h3 id="getting-rlmeta">Getting RLMeta</h3>
<p>In order to follow along on this walk through, you need to download the version of RLMeta from here: <a href="rlmeta-poster-2.zip">rlmeta-poster-2.zip</a>.</p>
<h3 id="file-structure">File structure</h3>
<p>The zip file consists of the source code for the RLMeta compiler, a make script, and the compiler itself (<code>rlmeta.py</code>):</p>
<pre class="text"><code>$ tree --dirsfirst
.
├── src
│   ├── assembler.rlmeta
│   ├── codegenerator.rlmeta
│   ├── main.py
│   ├── parser.rlmeta
│   └── support.py
├── make.py
└── rlmeta.py

1 directory, 7 files</code></pre>
<p>The size of the source code is quite small:</p>
<pre class="text"><code>$ wc -l src/*
   39 src/assembler.rlmeta
   57 src/codegenerator.rlmeta
   26 src/main.py
   60 src/parser.rlmeta
  240 src/support.py
  422 total</code></pre>
<p>The compiler can be created from this source code only. We will see how later in this walk through.</p>
<h3 id="exploring-rlmeta">Exploring RLMeta</h3>
<p>Before we dive into how the RLMeta compiler is created, let’s explore RLMeta by writing a small, but real, program in it.</p>
<p>What types of programs can we write in RLMeta?</p>
<p>In RLMeta, we write grammars. Grammars have rules that specify how to match objects from an input stream and specify what should happen when objects are matched.</p>
<p>Let’s write a grammar that counts the number of objects in an input stream and produces a report:</p>
<pre class="text"><code>$ cat object_counter.rlmeta
ObjectCounter {
    count = .*:xs -&gt; { &quot;number of objects = &quot; len(xs) }
}</code></pre>
<p>The main function of the RLMeta compiler is to transform grammars into Python code. If invoked without arguments, the compiler reads a grammar from stdin and writes Python code to stdout:</p>
<pre class="text"><code>$ cat object_counter.rlmeta | python rlmeta.py
class ObjectCounter(Grammar):
    rules = {
        &#39;count&#39;: 0
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        10,
        MATCH,
        &#39;any&#39;,
        lambda x: True,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        &#39;xs&#39;,
        ACTION,
        lambda self: join([&#39;number of objects = &#39;, self.lookup(&#39;len&#39;)(self.lookup(&#39;xs&#39;))]),
        POP_SCOPE,
        RETURN
    ]</code></pre>
<p>This is equivalent to using the <code>--compile</code> command with a value of <code>-</code> which stands for stdin:</p>
<pre class="text"><code>$ cat object_counter.rlmeta | python rlmeta.py --compile - | head -n3
class ObjectCounter(Grammar):
    rules = {
        &#39;count&#39;: 0</code></pre>
<p>And, the file can also be specified directly like this:</p>
<pre class="text"><code>$ python rlmeta.py --compile object_counter.rlmeta | head -n3
class ObjectCounter(Grammar):
    rules = {
        &#39;count&#39;: 0</code></pre>
<p>Don’t worry about understanding the generated code. We will explore it more later. Just note that the generated class inherits from a class called <code>Grammar</code> and that it uses some constants like <code>PUSH_SCOPE</code> and <code>LIST_START</code>. These things are defined in a support library which can be generated by the RLMeta compiler with the <code>--support</code> command:</p>
<pre class="text"><code>$ python rlmeta.py --support | grep &#39;^\(class\|def\)&#39;
class VM:
def PUSH_SCOPE(vm):
def POP_SCOPE(vm):
def BACKTRACK(vm):
def COMMIT(vm):
def CALL(vm):
def CALL_(vm, pc):
def RETURN(vm):
def MATCH(vm):
def MATCH_(vm, fn, message):
def MATCH_CALL_RULE(vm):
def LIST_START(vm):
def LIST_APPEND(vm):
def LIST_END(vm):
def BIND(vm):
def ACTION(vm):
def PUSH_STREAM(vm):
def POP_STREAM(vm):
def FAIL(vm):
def FAIL_(vm, fail_message):
class SemanticAction(object):
class MatchError(Exception):
class Grammar(object):
class Runtime(dict):
class Counter(object):
def splice(depth, item):
def concat(lists):
def join(items, delimiter=&quot;&quot;):
def indent(text, prefix=&quot;    &quot;):
def compile_chain(grammars, source):</code></pre>
<p>To create a complete program, we also have to write a main function that instantiates the <code>ObjectCounter</code> grammar and invokes its <code>count</code> rule.</p>
<p>Here is an example that passes stdin as the input stream to the <code>count</code> rule and prints the result to stdout:</p>
<pre class="text"><code>$ cat object_counter_main.py
if __name__ == &quot;__main__&quot;:
    import sys
    sys.stdout.write(ObjectCounter().run(&quot;count&quot;, sys.stdin.read()))</code></pre>
<p>The <code>--copy</code> command of the RLMeta compiler can be used to copy this main file, as is, to the output.</p>
<p>Combining these pieces into a single compile command, we get this:</p>
<pre class="text"><code>$ python rlmeta.py --support --compile object_counter.rlmeta --copy object_counter_main.py &gt; object_counter.py</code></pre>
<p>It will perform all commands in the given order and write all generated code concatenated into a single file.</p>
<p>Note that the support library comes before the grammar so that <code>Grammar</code> is defined by the time <code>ObjectCounter</code> is evaluated.</p>
<p>The object counter source code has now been compiled into a standalone Python program that can be run like this:</p>
<pre class="text"><code>$ echo &#39;hello&#39; | python object_counter.py
number of objects = 6```

```text
$ echo &#39;this is longer&#39; | python object_counter.py
number of objects = 15```

So programs in RLMeta are written mainly in grammar files with some support
functions written in Python. The RLMeta compiler can process all these files to
produce a single Python file which is the compiled program.


### Compiling RLMeta itself

Now that we have an understanding of RLMeta, let&#39;s look at the command that
compiles the RLMeta compiler itself from the source code:

```text
$ python rlmeta.py --embed SUPPORT src/support.py --support --compile src/parser.rlmeta --compile src/codegenerator.rlmeta --compile src/assembler.rlmeta --copy src/main.py &gt; rlmeta-raw.py</code></pre>
<p>The first command, <code>--embed SUPPORT src/support.py</code>, tells the compiler to generate a Python variable named <code>SUPPORT</code> containing the contents of the file <code>src/support.py</code>. The <code>--embed</code> command is the last command of the compiler that we have not yet seen. (The RLMeta compiler needs the support library in a variable so that it can generate it later with the <code>--support</code> command.)</p>
<p>Next, the <code>--support</code> command tells the compiler to generate the support library that is embedded in it.</p>
<p>The <code>--compile ...</code> commands tell the compiler to compile the given grammar files.</p>
<p>The last command, <code>--copy src/main.py</code>, tells the compiler to copy the main file verbatim. Similar to what we did to the main file in the object counter.</p>
<p>The make script can be called with the <code>--compile</code> command to perform this exact function:</p>
<pre class="text"><code>$ ./make.py --compile &gt; rlmeta-compile.py
Compiling rlmeta using rlmeta.py
  O-----------------O
  | RLMeta compiled |
~~|     itself!     |
  O-----------------O</code></pre>
<p>And all these files are exactly the same:</p>
<pre class="text"><code>$ md5sum rlmeta.py rlmeta-compile.py rlmeta-raw.py
92396155e85e24fb45cb3e58e160e89e  rlmeta.py
92396155e85e24fb45cb3e58e160e89e  rlmeta-compile.py
92396155e85e24fb45cb3e58e160e89e  rlmeta-raw.py</code></pre>
<p>Thus, the RLMeta compiler reproduced itself exactly from the source code.</p>
<h3 id="a-tour-of-the-main-function">A tour of the main function</h3>
<p>Let’s now look at how all commands of the RLMeta compiler are implemented. Here is the main function:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="kw">def</span> read(path):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>        <span class="cf">if</span> path <span class="op">==</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>            <span class="cf">return</span> sys.stdin.read()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        <span class="cf">with</span> <span class="bu">open</span>(path) <span class="im">as</span> f:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>            <span class="cf">return</span> f.read()</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    args <span class="op">=</span> sys.argv[<span class="dv">1</span>:] <span class="kw">or</span> [<span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;-&quot;</span>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    <span class="cf">while</span> args:</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>        command <span class="op">=</span> args.pop(<span class="dv">0</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>        <span class="cf">if</span> command <span class="op">==</span> <span class="st">&quot;--support&quot;</span>:</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>            sys.stdout.write(SUPPORT)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--copy&quot;</span>:</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>            sys.stdout.write(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--embed&quot;</span>:</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>            sys.stdout.write(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> = </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>                args.pop(<span class="dv">0</span>),</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>                <span class="bu">repr</span>(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>            ))</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--compile&quot;</span>:</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>            sys.stdout.write(compile_chain(</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>                [(Parser, <span class="st">&quot;file&quot;</span>), (CodeGenerator, <span class="st">&quot;asts&quot;</span>), (Assembler, <span class="st">&quot;asts&quot;</span>)],</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>                read(args.pop(<span class="dv">0</span>))</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>            ))</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: Unknown command &#39;</span><span class="sc">{}</span><span class="st">&#39;&quot;</span>.<span class="bu">format</span>(command))</span></code></pre></div>
<p>It contains command line parsing and handles processing of all commands.</p>
<p>The <code>--compile</code> command is the most complex of them all. It calls the <code>compile_chain</code> function which runs the given grammars/rules in order (in this case the input will first be parsed, then passed to the code generator, and finally passed to the assembler) and prints a pretty error message to stderr upon failure:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">def</span> compile_chain(grammars, source):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    <span class="im">import</span> os</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    <span class="im">import</span> pprint</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="cf">for</span> grammar, rule <span class="kw">in</span> grammars:</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>            source <span class="op">=</span> grammar().run(rule, source)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        <span class="cf">except</span> MatchError <span class="im">as</span> e:</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>            marker <span class="op">=</span> <span class="st">&quot;&lt;ERROR POSITION&gt;&quot;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>            <span class="cf">if</span> os.isatty(sys.stderr.fileno()):</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>                marker <span class="op">=</span> <span class="ss">f&quot;</span><span class="ch">\033</span><span class="ss">[0;31m</span><span class="sc">{</span>marker<span class="sc">}</span><span class="ch">\033</span><span class="ss">[0m&quot;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(e.stream, <span class="bu">str</span>):</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>                stream_string <span class="op">=</span> e.stream[:e.pos] <span class="op">+</span> marker <span class="op">+</span> e.stream[e.pos:]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>                stream_string <span class="op">=</span> pprint.pformat(e.stream)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">POSITION: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">STREAM:</span><span class="ch">\n</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>                e.message,</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>                e.pos,</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a>                indent(stream_string)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a>            ))</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>    <span class="cf">return</span> source</span></code></pre></div>
<p>This function might be useful for other RLMeta programs as well. That is why it’s included in the support library and not only in the main file.</p>
<h3 id="following-a-compilation">Following a compilation</h3>
<p>Let’s now follow a compilation of an example grammar to learn more about how a grammar file is turned into Python code. Here it is:</p>
<pre class="text"><code>$ cat example.rlmeta
Example {
    main = .
}</code></pre>
<p>And this is what it compiles to:</p>
<pre class="text"><code>$ python rlmeta.py --compile example.rlmeta
class Example(Grammar):
    rules = {
        &#39;main&#39;: 0
    }
    code = [
        PUSH_SCOPE,
        MATCH,
        &#39;any&#39;,
        lambda x: True,
        POP_SCOPE,
        RETURN
    ]</code></pre>
<p>The transformations that the grammar goes through are defined in the main function:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>[(Parser, <span class="st">&quot;file&quot;</span>), (CodeGenerator, <span class="st">&quot;asts&quot;</span>), (Assembler, <span class="st">&quot;asts&quot;</span>)],</span></code></pre></div>
<p>So first the grammar file is passed to the <code>file</code> rule of the parser:</p>
<pre class="text"><code>file =
  | (space grammar)*:xs space !.            -&gt; xs</code></pre>
<p>It in turn calls the <code>grammar</code> rule to parse all grammars in the file:</p>
<pre class="text"><code>grammar =
  | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;     -&gt; [&quot;Grammar&quot; x ~ys]</code></pre>
<p>This rule matches the name, the open curly brace, a set of rules, and the closing curly brace. It will then return an AST that looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>[</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    <span class="st">&quot;Grammar&quot;</span>,</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="st">&quot;Example&quot;</span>,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    ...</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>All grammar AST nodes are handed off to the <code>asts</code> rule in the code generator:</p>
<pre class="text"><code>asts          = ast*:xs !.  -&gt; xs</code></pre>
<p>It it turn calls the <code>ast</code> rule to process each AST node:</p>
<pre class="text"><code>ast           = [%:x]       -&gt; x</code></pre>
<p>The <code>ast</code> rule treats the first argument in the AST as a rule name, and calls that rule. In this case <code>Grammar</code>:</p>
<pre class="text"><code>Grammar       = .:x ast*:ys -&gt; [&quot;Grammar&quot; x ~~ys]</code></pre>
<p>The code generator creates a new AST node representing a grammar. But this AST node is slightly different and meant to be processed by the assembler. The result is this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>[</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>    <span class="st">&quot;Grammar&quot;</span>,</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    <span class="st">&quot;Example&quot;</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    ... ast nodes <span class="cf">for</span> consumption by assembler ...</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>This AST node and all the others that the code generator produces are passed to the <code>asts</code> rule in the assembler:</p>
<pre class="text"><code>asts     = ast*:xs !.      -&gt; { xs }</code></pre>
<p>It in turn calls the <code>ast</code> rule:</p>
<pre class="text"><code>ast      = [%:x]           -&gt; x</code></pre>
<p>Which does the same trick again, now invoking the <code>Grammar</code> rule (in the assembler) which looks like this:</p>
<pre class="text"><code>Grammar  = .:x ast*:ys     -&gt; list():rules
                           -&gt; list():code
                           -&gt; dict():labels
                           -&gt; list():patches
                           -&gt; ys
                           -&gt; run(&quot;asts&quot; patches)
                           -&gt; { &quot;class &quot; x &quot;(Grammar):\n&quot; &gt;
                                  &quot;rules = {\n&quot; &gt; join(rules &quot;,\n&quot;) &lt; &quot;\n}\n&quot;
                                  &quot;code = [\n&quot; &gt; join(code  &quot;,\n&quot;) &lt; &quot;\n]\n&quot;
                                &lt; }</code></pre>
<p>This rule can be read as follows:</p>
<ul>
<li>Match the grammar name and all AST nodes</li>
<li>Perform the following action
<ul>
<li>Define a variable called <code>rules</code> which is a list</li>
<li>Define a variable called <code>code</code> which is a list</li>
<li>Define a variable called <code>labels</code> which is a dictionary</li>
<li>Define a variable called <code>patches</code> which is a list</li>
<li>Evaluate the AST nodes (with possible side effects recorded in the above variables)</li>
<li>Treat the value of the <code>patches</code> variable as a list of AST nodes and process them with the <code>asts</code> rule of this grammar</li>
<li>Return a string which is generated Python code</li>
</ul></li>
</ul>
<p>The generated code from our example looks like this:</p>
<pre><code>class Example(Grammar):
    rules = {
        ...
    }
    code = [
        ...
    ]</code></pre>
<p>To understand how the <code>rule</code> and <code>code</code> sections are generated, we just have to follow a few more transformations.</p>
<p>Let’s look at one more and see how the rule in our example grammar is transformed.</p>
<p>First, the rule is parsed by the <code>rule</code> rule in the parser:</p>
<pre class="text"><code>rule =
  | name:x space &#39;=&#39; choice:y               -&gt; [&quot;Rule&quot; x y]</code></pre>
<p>First the name is matched, then the equals sign, and then an expression representing the body of the rule.</p>
<p>It our case, this rule produces this AST node:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>[</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>    <span class="st">&quot;Rule&quot;</span>,</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>    <span class="st">&quot;main&quot;</span>,</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>    ...</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>That node is going to be processed by the <code>Rule</code> rule in the code generator:</p>
<pre class="text"><code>Rule          = .:x ast:y   -&gt; [[&quot;Rule&quot; x]
                                ~y
                                [&quot;OpCode&quot; &quot;RETURN&quot;]]</code></pre>
<p>Generating an AST node that looks like this:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>[</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>    [<span class="st">&quot;Rule&quot;</span>, <span class="st">&quot;main&quot;</span>],</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    ...,</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    [<span class="st">&quot;OpCode&quot;</span>, <span class="st">&quot;RETURN&quot;</span>]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>Here we can see that the AST from the code generator looks a bit more like assembly code than a representation of the syntax in the grammar.</p>
<p>The first child in this AST node is going to be handled the <code>Rule</code> rule in the assembler:</p>
<pre class="text"><code>Rule     = .:x             -&gt; add(rules { repr(x) &quot;: &quot; len(code) })
                           -&gt; set(labels x len(code))</code></pre>
<p>It does two things:</p>
<ol type="1">
<li>Adds a string value to the <code>rules</code> list</li>
<li>Adds an entry to the <code>labels</code> dictionary to map a label to an index in the <code>code</code> list</li>
</ol>
<p>At this point, the variables have the following values.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>rules <span class="op">=</span> [</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="st">&quot;&#39;main&#39;: 0&quot;</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>]</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>labels <span class="op">=</span> {</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>    <span class="st">&#39;main&#39;</span>: <span class="dv">0</span>,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>The second child in the AST node is going to be handled by the <code>OpCode</code> rule in the assembler:</p>
<pre class="text"><code>OpCode   = .:x             -&gt; add(code x)</code></pre>
<p>It adds the given op code to the <code>code</code> list, giving it this value:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>code <span class="op">=</span> [</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>    ...,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    <span class="st">&quot;RETURN&quot;</span>,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>]</span></code></pre></div>
<p>When the <code>rules</code> and <code>code</code> variables are expanded, the resulting class looks like this:</p>
<pre><code>class Example(Grammar):
    rules = {
        &#39;main&#39;: 0
    }
    code = [
        ...,
        RETURN
    ]</code></pre>
<p>Hopefully you should now be comfortable to follow transformations yourself to understand how a compilation is done.</p>
<h3 id="the-purpose-of-the-make-script">The purpose of the make script</h3>
<p>When the make script is called without arguments, it performs a meta compilation and runs a few tests:</p>
<pre class="text"><code>$ ./make.py
Compiling rlmeta using rlmeta.py
Writing rlmeta1.py
Test: Has its own support library
Test: Disallow semantic action in the middle
ERROR: expected }
POSITION: 22
STREAM:
    Grammar { x = . -&gt; [] &lt;ERROR POSITION&gt;. }
Test: Call unknown rule foo
Moving rlmeta1.py -&gt; rlmeta.py
  O-----------------O
  | RLMeta compiled |
~~|     itself!     |
  O-----------------O</code></pre>
<p>The meaning of a meta compilation is to create a new version of RLMeta that can still reproduce itself from the source code.</p>
<p>In the output above, we can see that it compiled RLMeta and wrote the result to <code>rlmeta1.py</code>. In this case, since it is exactly the same as <code>rlmeta.py</code>, the compilation stopped there and a few more tests were run using this compiler. But if we make changes to the source code, <code>rlmeta1.py</code> will most likely not be exactly the same as <code>rlmeta.py</code>, and a few more compilations might be needed. I’ve written about the details of meta compilation in a <a href="/writing/modifying-rlmeta/index.html#5f6a1c91143146dbb3b865ac42562135">previous blog post</a>.</p>
<p>So the purpose of the make script is to ease meta compilations and also run a test suit on the newly generated metacompiler before accepting it.</p>
<p>The make script can also be used to perform a single compilation of RLMeta with the <code>--compile</code> argument as we saw earlier.</p>
<h2 id="changes-from-the-poster-version">Changes from the poster version</h2>
<p>This section explains the most important changes in this version of RLMeta compared to the poster version.</p>
<p>First of all, I wanted to work on the unresolved items which were the following:</p>
<ul>
<li>The label counter is incremented at match time, not at semantic action evaluation time.</li>
<li>Compilation depends on Bash.</li>
<li>Assembly code in code generator is hard to read.</li>
</ul>
<p>In the poster article, I also had a few notes about <a href="/writing/creating-rlmeta-poster/index.html#b070abcd2f134cf894e33e63188a9fee">future versions</a>:</p>
<blockquote>
<p>The smaller it is, the easier it is to understand and therefore extend. The more flexible it is to extend the better. If I make another poster version it would therefore focus on being smaller and more flexible. Since all successive version of RLMeta have been faster than the ones before, performance is also important. But small size, clarity, and flexibility come first.</p>
</blockquote>
<p>I used these guidelines to decide if certain changes should go into the new version or not.</p>
<p>One interesting thing to note is that the guidelines are sometimes contradicting. Writing clear code might mean more lines of code which makes the code base larger. Perhaps that’s also why I got stuck chasing perfection. I thought I made something easier to read, but it ended up costing 10 extra lines of code. Should I include it?</p>
<h3 id="generate-labels-in-semantic-actions">Generate labels in semantic actions</h3>
<p>One thing that I left in the poster version that still annoyed me was that labels were generated at match time, not at semantic action evaluation time. It would not produce incorrect results. At worst, some labels end up not being used because the counter value captured was in a rule that later failed. But dealing with labels at match time does not make sense. It should really happen at semantic action evaluation time.</p>
<p>Here is what the <code>Not</code> rule looks like in the poster version:</p>
<pre class="text"><code>Not = ast:x #:a #:b -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                         x
                         &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                         &quot;LABEL(&quot; a &quot;)\n&quot;
                         &quot;I(&#39;FAIL&#39;, &#39;no match expected&#39;)\n&quot;
                         &quot;LABEL(&quot; b &quot;)\n&quot;                   }</code></pre>
<p>Here is what the <code>Not</code> rule looks like after the change:</p>
<pre class="text"><code>Not = ast:x -&gt; label():a -&gt; label():b
            -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                 x
                 &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                 &quot;LABEL(&quot; a &quot;)\n&quot;
                 &quot;I(&#39;FAIL&#39;, &#39;no match expected&#39;)\n&quot;
                 &quot;LABEL(&quot; b &quot;)\n&quot;                   }</code></pre>
<p>This change puts label generation where it belongs, in semantic actions, and thus makes the implementation <strong>more clear</strong>. The VM is no longer concerned with labels. It is only concerned with matching. This change required a bit of rework how semantic actions work. Previously only one expression was allowed:</p>
<pre><code>&lt;match expression&gt; -&gt; &lt;semantic action expression&gt;</code></pre>
<p>Now multiple expressions are allowed:</p>
<pre><code>&lt;match expression&gt; -&gt; &lt;semantic action expression&gt;:x
                   -&gt; &lt;semantic action expression&gt;
                   -&gt; &lt;semantic action expression&gt;</code></pre>
<p>The result of expressions can also be bound to names which subsequent expressions can refer to. <code>label</code> is such a variable that is set internally to a function that generates increasing integers starting at 0.</p>
<p>The implementation of this change also <strong>increases the flexibility</strong> of RLMeta. For example, it is now possible to write a semantic action that generates code in different sections like this:</p>
<pre class="text"><code>ExampleBuffers {
    program  = ast:x  -&gt; []:header
                      -&gt; { &quot;# HEADER\n&quot;
                           header
                           &quot;# BODY\n&quot;
                           x            }
    ast      = [%:x]  -&gt; x
    Program  = ast*
    Function = .:name -&gt; add(header { &quot;def &quot; name &quot;\n&quot; })
                      -&gt; { name &quot;()\n&quot; }
}</code></pre>
<p>The expression <code>[]:header</code> creates a list and assigns it to the variable <code>header</code>. When <code>x</code> is evaluated in the next step, the semantic action for the <code>Function</code> rule will be evaluated which can then access the <code>header</code> variable defined earlier. These variables are not lexically scoped, but dynamically scoped. If at runtime, a variable is defined, it will be accessible. It also means that the <code>Function</code> rule can not be run without <code>program</code> being run first, or the <code>header</code> variable will not be defined.</p>
<p>Here is an example AST representing a program:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>AST <span class="op">=</span> [</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>    [<span class="st">&#39;Program&#39;</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>        [<span class="st">&#39;Function&#39;</span>, <span class="st">&#39;foo&#39;</span>],</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>        [<span class="st">&#39;Function&#39;</span>, <span class="st">&#39;bar&#39;</span>]</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>    ]</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>]</span></code></pre></div>
<p>When the <code>program</code> rule is run on the example input, the following is output:</p>
<pre class="text"><code>$ python example_buffers.py
# HEADER
def foo
def bar
# BODY
foo()
bar()</code></pre>
<p>In summary, this change is as follows:</p>
<ul>
<li>Label syntax (<code>#</code>) in parser is removed</li>
<li>Actions can have multiple expressions</li>
<li>Expressions can be bound to names</li>
<li>A default <code>label</code> function to generate labels</li>
<li>Names in semantic actions refer to matches or results bound earlier</li>
</ul>
<p>(The complete initial diff for this change can be found on <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/5154583e9d98c123630fb41664aa6906d4801d05">GitHub</a>.)</p>
<p>The increased clarity and flexibility come with a price. The size increases and the performance drops.</p>
<p>The parser and the code generator are mostly the same. The greatest addition is in the support library. Which is expected when semantic action evaluation becomes more complex. The drop in performance is likely due to more function calls when evaluating semantic actions. Even though size and performance got worse, I believe the clarity and flexibility gain is worth it.</p>
<h3 id="remove-dependency-on-bash">Remove dependency on Bash</h3>
<p>To compile the poster version of RLMeta, you ran the following command:</p>
<pre><code>./compile.sh rlmeta.py</code></pre>
<p>In one way, the compiler could not compile itself, but relied on a Bash script for gluing things together. It would call the <code>rlmeta.py</code> compiler for certain tasks and use Bash and Python for other tasks.</p>
<p>As we have already seen, the new version of RLMeta compiles itself like this:</p>
<pre><code>python rlmeta.py \
    --embed SUPPORT src/support.py \
    --support \
    --compile src/parser.rlmeta \
    --compile src/codegenerator.rlmeta \
    --compile src/assembler.rlmeta \
    --copy src/main.py \
    &gt; rlmeta.py</code></pre>
<p>The <code>rlmeta.py</code> compiler now has support (via <code>--embed</code> and <code>--copy</code>) for doing what the Bash script previously did.</p>
<p>This makes the compiler slightly larger, but it feels so much cleaner.</p>
<p>In addition, the extra features are useful when writing programs in RLMeta. Those programs can now also be compiled with a single command, and there is no need to concatenate different pieces together.</p>
<p>(The complete diff for this change can be found on <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/935bb77e1d5b88e09de64112aa2fb2f46dbcb7d9">GitHub</a>.)</p>
<h3 id="extract-assembler">Extract assembler</h3>
<p>The third thing that annoyed me with in the poster version was the readability of the code generator. For example, the <code>Not</code> rule looked like this:</p>
<pre class="text"><code>Not = ast:x -&gt; label():a -&gt; label():b
            -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                 x
                 &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                 &quot;LABEL(&quot; a &quot;)\n&quot;
                 &quot;I(&#39;FAIL&#39;, &#39;no match expected&#39;)\n&quot;
                 &quot;LABEL(&quot; b &quot;)\n&quot;                   }</code></pre>
<p>It generates a string which contains Python code that calls functions to create “assembly” code. So part of the compilation is actually happening at runtime here. It is mixed and messy.</p>
<p>The new <code>Not</code> rule looks like this:</p>
<pre class="text"><code>Not = ast:x -&gt; label():a -&gt; label():b
            -&gt; [[&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                [&quot;Target&quot; b]
                ~x
                [&quot;OpCode&quot; &quot;COMMIT&quot;]
                [&quot;Target&quot; a]
                [&quot;Label&quot; a]
                [&quot;OpCode&quot; &quot;FAIL&quot;]
                [&quot;Value&quot; &quot;no match&quot;]
                [&quot;Label&quot; b]]</code></pre>
<p>Instead of outputting Python code directly, it now generates abstract assembly code. Then a new third pass, the assembler, turns those instructions into Python code as well as resolves label positions. So no more compilation at runtime.</p>
<p>This reads better because the purpose of the code generator is now a bit narrower. It can focus on one thing and leave the rest to the assembler.</p>
<p>Adding another pass also opens up the possibility to do peep-hole optimizations on the abstract assembly code before the assembler turns the instructions into Python code.</p>
<h3 id="rewrite-vm-for-clarity">Rewrite VM for clarity</h3>
<p>In the poster version, the virtual machine was written as a single function with one loop like this:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="kw">def</span> vm(instructions, labels, start_rule, stream):</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>    ...</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>        name, arg1, arg2 <span class="op">=</span> instructions[pc]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>        <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;PUSH_SCOPE&quot;</span>:</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>            scope_stack.append(scope)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>            scope <span class="op">=</span> {}</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BACKTRACK&quot;</span>:</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>            ...</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>It was written like that to be as fast as possible. It avoided function calls. It avoided class variables lookup by avoiding classes. All variables used were defined locally in the <code>vm</code> function. Because function calls could not be used, some code was also duplicated.</p>
<p>I decided that I would not consider performance at all, and instead try to write the VM as clear as I could. I ended up with a <code>VM</code> class to hold some state and instruction functions that operate on an instance of a VM:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="kw">class</span> VM:</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, code, rules):</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>        ...</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>    ...</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a><span class="kw">def</span> PUSH_SCOPE(vm):</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>    vm.scope_rest <span class="op">=</span> (vm.scope, vm.scope_rest)</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true"></a>    vm.scope <span class="op">=</span> {}</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true"></a></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true"></a><span class="kw">def</span> BACKTRACK(vm):</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true"></a>    ...</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true"></a>...</span></code></pre></div>
<p>As I noted earlier, I’m not sure I am happy with this result. I’m not convinced that it reads better. The biggest upside is that since function calls are now allowed, part of the VM can be expressed more clearly without repetition.</p>
<p>Before I ended up with this VM, I experimented with a language for writing virtual machines that compiled to Python code. You could define instructions and the arguments they took and define macros for code re-use. It was basically a small macro language on top of Python. It looked something like this:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="kw">def</span> vm(code, rules, start_rule, stream):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>    action <span class="op">=</span> SemanticAction(<span class="va">None</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>    pc <span class="op">=</span> rules[start_rule]</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>    call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>    stream, stream_rest <span class="op">=</span> (stream, <span class="va">None</span>)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a>    pos, pos_rest <span class="op">=</span> (<span class="dv">0</span>, <span class="bu">tuple</span>())</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>    scope, scope_rest <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>    fail_message <span class="op">=</span> <span class="va">None</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>    latest_fail_message, latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>    memo <span class="op">=</span> {}</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true"></a>definstruction PUSH_SCOPE():</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true"></a>    scope_rest <span class="op">=</span> (scope, scope_rest)</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true"></a>    scope <span class="op">=</span> {}</span></code></pre></div>
<p>And here is how macros were used:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>definstruction FAIL(arg_message):</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (arg_message,)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>    <span class="co">#FAIL</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>defmacro FAIL:</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>When this was compiled, something similar to the <code>vm</code> function above was generated. A single function that was intended to run as fast as possible. But you could write the VM quite clearly anyway.</p>
<p>I liked the result of that, but it introduced yet another language and made compilation and metacompilation more complicated. For that reason, I decided against it.</p>
<p>Perhaps another approach would be to consider the VM a separate piece, not to be included in compilations and metacompilations. But they are also strongly connected. Say for example that an optimizer decides to output a new VM instruction, then the VM has to change.</p>
<p>I am not entirely clear about the interface here between the VM and the rest of the compiler.</p>
<h3 id="add-ability-to-run-a-rule-in-semantic-action">Add ability to run a rule in semantic action</h3>
<p>Another feature that was added in this version was the ability to run a grammar rule recursively from a semantic action.</p>
<p>This was initially needed to to implement recursive macros in the VM language mentioned in the previous section, but it made its way into RLMeta to support the patching of assembly instructions.</p>
<p>When a <code>Target</code> instruction is encountered, the <code>patches</code> list is populated with a command:</p>
<pre class="text"><code>Target   = .:x             -&gt; add(patches [&quot;Patch&quot; len(code) x])
                           -&gt; add(code &quot;placeholder&quot;)</code></pre>
<p>These commands are then evaluated by running the <code>asts</code> rule on the <code>patches</code> list. This starts another parse on the given stream.</p>
<pre class="text"><code>-&gt; run(&quot;asts&quot; patches)</code></pre>
<p>The new parse has access to all the runtime variables that the semantic action that invokes it has. So that is why a <code>Patch</code> instruction can modify the <code>code</code> array and insert the correct index there instead of the placeholder:</p>
<pre class="text"><code>Patch    = .:x .:y         -&gt; set(code x get(labels y))</code></pre>
<h3 id="misc">Misc</h3>
<p>Many more small changes were made. Here are a few notes about them.</p>
<ul>
<li><p>Various renames to make intention more clear and reformats to improve readability.</p></li>
<li><p>Various clean ups in the parser:</p>
<ul>
<li><p>Only allow semantic actions at the very end of a rule.</p></li>
<li><p>Make sure the whole file is parsed so that junk after a grammar results in an error.</p></li>
</ul></li>
<li><p>Adapt to Python 3.</p></li>
</ul>
<h2 id="the-future">The future</h2>
<p>On the one hand, I’m quite happy with the improvements to RLMeta that I was able to make. The code feels more clear and flexible. Definitely a better version of RLMeta.</p>
<p>On the other hand, this article turned out to have the same problem as the poster. It just kept growing and growing, and at some point I had to stop working on in, leave some issues unresolved, and call the article finished. For example, I am not happy with how the new VM looks. A mix between classes and functions and helpers.</p>
<p>I decided to set up a <a href="https://github.com/rickardlindberg/rlmeta">repo on GitHub</a> for RLMeta where it can continue to be improved.</p>
<p>I plan for it to contain the base version of RLMeta which is the minimal version that is able to compile itself and maintain properties such as flexible, easy to extend, and easy to understand. Then I want to include examples as well to show how RLMeta can be used and how you can extend it in various ways.</p>
<h2 id="code-listings-for-rlmeta">Code listings for RLMeta</h2>
<p>Here is all the source code and also the make script for this version of RLMeta.</p>
<h3 id="srcparser.rlmeta">src/parser.rlmeta</h3>
<pre class="text"><code>Parser {
  file =
    | (space grammar)*:xs space !.            -&gt; xs
  grammar =
    | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;     -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space &#39;=&#39; choice:y               -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space &#39;|&#39;)?
      sequence:x (space &#39;|&#39; sequence)*:xs     -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr*:xs maybeAction:ys                 -&gt; [&quot;Scope&quot; [&quot;And&quot; ~xs ~ys]]
  expr =
    | expr1:x space &#39;:&#39; name:y                -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space &#39;*&#39;                       -&gt; [&quot;Star&quot; x]
    | expr2:x space &#39;?&#39;                       -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space &#39;!&#39; expr2:x                       -&gt; [&quot;Not&quot; x]
    | space &#39;%&#39;                               -&gt; [&quot;MatchCallRule&quot;]
    | expr2
  expr2 =
    | name:x !(space &#39;=&#39;)                     -&gt; [&quot;MatchRule&quot; x]
    | space char:x &#39;-&#39; char:y                 -&gt; [&quot;MatchObject&quot; [&quot;Range&quot; x y]]
    | space &#39;\&#39;&#39; (!&#39;\&#39;&#39; matchChar)*:xs &#39;\&#39;&#39;   -&gt; [&quot;And&quot; ~xs]
    | space &#39;.&#39;                               -&gt; [&quot;MatchObject&quot; [&quot;Any&quot;]]
    | space &#39;(&#39; choice:x space &#39;)&#39;            -&gt; x
    | space &#39;[&#39; expr*:xs space &#39;]&#39;            -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  matchChar =
    | innerChar:x                             -&gt; [&quot;MatchObject&quot; [&quot;Eq&quot; x]]
  maybeAction =
    | actionExpr:x                            -&gt; [[&quot;Action&quot; x]]
    |                                         -&gt; []
  actionExpr =
    | space &#39;-&gt;&#39; hostExpr:x
      (space &#39;:&#39; name | -&gt; &quot;&quot;):y actionExpr:z -&gt; [&quot;Set&quot; y x z]
    | space &#39;-&gt;&#39; hostExpr:x                   -&gt; x
  hostExpr =
    | space string:x                          -&gt; [&quot;String&quot; x]
    | space &#39;[&#39; hostListItem*:xs space &#39;]&#39;    -&gt; [&quot;List&quot; ~xs]
    | space &#39;{&#39; formatExpr*:xs space &#39;}&#39;      -&gt; [&quot;Format&quot; ~xs]
    | var:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;Call&quot; x ~ys]
    | var:x
  hostListItem =
    | space &#39;~&#39;*:ys hostExpr:x                -&gt; [&quot;ListItem&quot; len(ys) x]
  formatExpr =
    | space &#39;&gt;&#39; formatExpr*:xs space &#39;&lt;&#39;      -&gt; [&quot;Indent&quot; [&quot;Format&quot; ~xs]]
    | hostExpr
  var =
    | name:x !(space &#39;=&#39;)                     -&gt; [&quot;Lookup&quot; x]
  string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;  -&gt; { xs }
  char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39; -&gt; x
  innerChar = &#39;\\&#39; escape | .
  escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
            | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs  -&gt; { x xs }
  nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
  nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;
  space     = (&#39; &#39; | &#39;\n&#39;)*
}</code></pre>
<h3 id="srccodegenerator.rlmeta">src/codegenerator.rlmeta</h3>
<pre class="text"><code>CodeGenerator {
  Grammar       = .:x ast*:ys -&gt; [&quot;Grammar&quot; x ~~ys]
  Rule          = .:x ast:y   -&gt; [[&quot;Rule&quot; x]
                                  ~y
                                  [&quot;OpCode&quot; &quot;RETURN&quot;]]
  Or            =
    | ast:x Or:y              -&gt; label():a -&gt; label():b
                              -&gt; [[&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                                  [&quot;Target&quot; a]
                                  ~x
                                  [&quot;OpCode&quot; &quot;COMMIT&quot;]
                                  [&quot;Target&quot; b]
                                  [&quot;Label&quot; a]
                                  ~y
                                  [&quot;Label&quot; b]]
    | ast
  Scope         = ast:x       -&gt; [[&quot;OpCode&quot; &quot;PUSH_SCOPE&quot;]
                                  ~x
                                  [&quot;OpCode&quot; &quot;POP_SCOPE&quot;]]
  And           = ast*:xs     -&gt; [~~xs]
  Bind          = .:x ast:y   -&gt; [~y
                                  [&quot;OpCode&quot; &quot;BIND&quot;]
                                  [&quot;Value&quot; x]]
  Star          = ast:x       -&gt; label():a -&gt; label():b
                              -&gt; [[&quot;OpCode&quot; &quot;LIST_START&quot;]
                                  [&quot;Label&quot; a]
                                  [&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                                  [&quot;Target&quot; b]
                                  ~x
                                  [&quot;OpCode&quot; &quot;LIST_APPEND&quot;]
                                  [&quot;OpCode&quot; &quot;COMMIT&quot;]
                                  [&quot;Target&quot; a]
                                  [&quot;Label&quot; b]
                                  [&quot;OpCode&quot; &quot;LIST_END&quot;]]
  Not           = ast:x       -&gt; label():a -&gt; label():b
                              -&gt; [[&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                                  [&quot;Target&quot; b]
                                  ~x
                                  [&quot;OpCode&quot; &quot;COMMIT&quot;]
                                  [&quot;Target&quot; a]
                                  [&quot;Label&quot; a]
                                  [&quot;OpCode&quot; &quot;FAIL&quot;]
                                  [&quot;Value&quot; &quot;no match&quot;]
                                  [&quot;Label&quot; b]]
  MatchCallRule =             -&gt; [[&quot;OpCode&quot; &quot;MATCH_CALL_RULE&quot;]]
  MatchRule     = .:x         -&gt; [[&quot;OpCode&quot; &quot;CALL&quot;]
                                  [&quot;Target&quot; x]]
  MatchObject   = .:x         -&gt; [[&quot;OpCode&quot; &quot;MATCH&quot;]
                                  x]
  MatchList     = ast:x       -&gt; [[&quot;OpCode&quot; &quot;PUSH_STREAM&quot;]
                                  ~x
                                  [&quot;OpCode&quot; &quot;POP_STREAM&quot;]]
  Action        = .:x         -&gt; [[&quot;OpCode&quot; &quot;ACTION&quot;]
                                  [&quot;Action&quot; x]]
  asts          = ast*:xs !.  -&gt; xs
  ast           = [%:x]       -&gt; x
}</code></pre>
<h3 id="srcassembler.rlmeta">src/assembler.rlmeta</h3>
<pre class="text"><code>Assembler {
  Grammar  = .:x ast*:ys     -&gt; list():rules
                             -&gt; list():code
                             -&gt; dict():labels
                             -&gt; list():patches
                             -&gt; ys
                             -&gt; run(&quot;asts&quot; patches)
                             -&gt; { &quot;class &quot; x &quot;(Grammar):\n&quot; &gt;
                                    &quot;rules = {\n&quot; &gt; join(rules &quot;,\n&quot;) &lt; &quot;\n}\n&quot;
                                    &quot;code = [\n&quot; &gt; join(code  &quot;,\n&quot;) &lt; &quot;\n]\n&quot;
                                  &lt; }
  Rule     = .:x             -&gt; add(rules { repr(x) &quot;: &quot; len(code) })
                             -&gt; set(labels x len(code))
  Label    = .:x             -&gt; set(labels x len(code))
  Target   = .:x             -&gt; add(patches [&quot;Patch&quot; len(code) x])
                             -&gt; add(code &quot;placeholder&quot;)
  Patch    = .:x .:y         -&gt; set(code x get(labels y))
  OpCode   = .:x             -&gt; add(code x)
  Value    = .:x             -&gt; add(code repr(x))
  Eq       = .:x             -&gt; add(code repr(x))
                             -&gt; add(code { &quot;lambda x: x == &quot; repr(x) })
  Range    = .:x .:y         -&gt; add(code repr({&quot;range &quot; repr(x) &quot;-&quot; repr(y)}))
                             -&gt; add(code { &quot;lambda x: &quot; repr(x) &quot; &lt;= x &lt;= &quot; repr(y) })
  Any      =                 -&gt; add(code repr(&quot;any&quot;))
                             -&gt; add(code &quot;lambda x: True&quot;)
  Action   = ast:x           -&gt; add(code {&quot;lambda self: &quot; x})
  Set      = .:x ast:y ast:z -&gt; { &quot;self.bind(&quot; repr(x) &quot;, &quot; y &quot;, lambda: &quot; z &quot;)&quot; }
  String   = .:x             -&gt; repr(x)
  List     = astList:x       -&gt; { &quot;concat([&quot; x &quot;])&quot; }
  ListItem = .:x ast:y       -&gt; { &quot;splice(&quot; repr(x) &quot;, &quot; y &quot;)&quot; }
  Format   = astList:x       -&gt; { &quot;join([&quot; x &quot;])&quot; }
  Indent   = ast:x           -&gt; { &quot;indent(&quot; x &quot;, &quot;
                                  &quot;self.lookup(&#39;indentprefix&#39;))&quot; }
  Call     = ast:x astList:y -&gt; { x &quot;(&quot; y &quot;)&quot; }
  Lookup   = .:x             -&gt; { &quot;self.lookup(&quot; repr(x) &quot;)&quot; }
  asts     = ast*:xs !.      -&gt; { xs }
  astList  = ast*:xs         -&gt; join(xs &quot;, &quot;)
  ast      = [%:x]           -&gt; x
}</code></pre>
<h3 id="srcsupport.py">src/support.py</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="kw">class</span> VM:</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, code, rules):</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>        <span class="va">self</span>.code <span class="op">=</span> code</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>        <span class="va">self</span>.rules <span class="op">=</span> rules</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, start_rule, stream):</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>        <span class="va">self</span>.action <span class="op">=</span> SemanticAction(<span class="va">None</span>)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a>        <span class="va">self</span>.pc <span class="op">=</span> <span class="va">self</span>.rules[start_rule]</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>        <span class="va">self</span>.call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a>        <span class="va">self</span>.stream, <span class="va">self</span>.stream_rest <span class="op">=</span> (stream, <span class="va">None</span>)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a>        <span class="va">self</span>.pos, <span class="va">self</span>.pos_rest <span class="op">=</span> (<span class="dv">0</span>, <span class="bu">tuple</span>())</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a>        <span class="va">self</span>.scope, <span class="va">self</span>.scope_rest <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>)</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true"></a>        <span class="va">self</span>.latest_fail_message, <span class="va">self</span>.latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true"></a>        <span class="va">self</span>.memo <span class="op">=</span> {}</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true"></a>            result <span class="op">=</span> <span class="va">self</span>.pop_arg()(<span class="va">self</span>)</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true"></a>            <span class="cf">if</span> result:</span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true"></a>                <span class="cf">return</span> result</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true"></a></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true"></a>    <span class="kw">def</span> pop_arg(<span class="va">self</span>):</span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true"></a>        code <span class="op">=</span> <span class="va">self</span>.code[<span class="va">self</span>.pc]</span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true"></a>        <span class="va">self</span>.pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true"></a>        <span class="cf">return</span> code</span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true"></a></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true"></a><span class="kw">def</span> PUSH_SCOPE(vm):</span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true"></a>    vm.scope_rest <span class="op">=</span> (vm.scope, vm.scope_rest)</span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true"></a>    vm.scope <span class="op">=</span> {}</span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true"></a></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true"></a><span class="kw">def</span> POP_SCOPE(vm):</span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true"></a>    vm.scope, vm.scope_rest <span class="op">=</span> vm.scope_rest</span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true"></a></span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true"></a><span class="kw">def</span> BACKTRACK(vm):</span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true"></a>    vm.call_backtrack_stack.append((</span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true"></a>        vm.pop_arg(), vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest</span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true"></a>    ))</span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true"></a></span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true"></a><span class="kw">def</span> COMMIT(vm):</span>
<span id="cb60-39"><a href="#cb60-39" aria-hidden="true"></a>    vm.call_backtrack_stack.pop()</span>
<span id="cb60-40"><a href="#cb60-40" aria-hidden="true"></a>    vm.pc <span class="op">=</span> vm.pop_arg()</span>
<span id="cb60-41"><a href="#cb60-41" aria-hidden="true"></a></span>
<span id="cb60-42"><a href="#cb60-42" aria-hidden="true"></a><span class="kw">def</span> CALL(vm):</span>
<span id="cb60-43"><a href="#cb60-43" aria-hidden="true"></a>    CALL_(vm, vm.pop_arg())</span>
<span id="cb60-44"><a href="#cb60-44" aria-hidden="true"></a></span>
<span id="cb60-45"><a href="#cb60-45" aria-hidden="true"></a><span class="kw">def</span> CALL_(vm, pc):</span>
<span id="cb60-46"><a href="#cb60-46" aria-hidden="true"></a>    key <span class="op">=</span> (pc, vm.pos_rest<span class="op">+</span>(vm.pos,))</span>
<span id="cb60-47"><a href="#cb60-47" aria-hidden="true"></a>    <span class="cf">if</span> key <span class="kw">in</span> vm.memo:</span>
<span id="cb60-48"><a href="#cb60-48" aria-hidden="true"></a>        <span class="cf">if</span> vm.memo[key][<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb60-49"><a href="#cb60-49" aria-hidden="true"></a>            FAIL_(vm, vm.memo[key][<span class="dv">1</span>])</span>
<span id="cb60-50"><a href="#cb60-50" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb60-51"><a href="#cb60-51" aria-hidden="true"></a>            vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest <span class="op">=</span> vm.memo[key]</span>
<span id="cb60-52"><a href="#cb60-52" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-53"><a href="#cb60-53" aria-hidden="true"></a>        vm.call_backtrack_stack.append((vm.pc, key))</span>
<span id="cb60-54"><a href="#cb60-54" aria-hidden="true"></a>        vm.pc <span class="op">=</span> pc</span>
<span id="cb60-55"><a href="#cb60-55" aria-hidden="true"></a></span>
<span id="cb60-56"><a href="#cb60-56" aria-hidden="true"></a><span class="kw">def</span> RETURN(vm):</span>
<span id="cb60-57"><a href="#cb60-57" aria-hidden="true"></a>    <span class="cf">if</span> <span class="kw">not</span> vm.call_backtrack_stack:</span>
<span id="cb60-58"><a href="#cb60-58" aria-hidden="true"></a>        <span class="cf">return</span> vm.action</span>
<span id="cb60-59"><a href="#cb60-59" aria-hidden="true"></a>    vm.pc, key <span class="op">=</span> vm.call_backtrack_stack.pop()</span>
<span id="cb60-60"><a href="#cb60-60" aria-hidden="true"></a>    vm.memo[key] <span class="op">=</span> (vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest)</span>
<span id="cb60-61"><a href="#cb60-61" aria-hidden="true"></a></span>
<span id="cb60-62"><a href="#cb60-62" aria-hidden="true"></a><span class="kw">def</span> MATCH(vm):</span>
<span id="cb60-63"><a href="#cb60-63" aria-hidden="true"></a>    object_description <span class="op">=</span> vm.pop_arg()</span>
<span id="cb60-64"><a href="#cb60-64" aria-hidden="true"></a>    fn <span class="op">=</span> vm.pop_arg()</span>
<span id="cb60-65"><a href="#cb60-65" aria-hidden="true"></a>    MATCH_(vm, fn, (<span class="st">&quot;expected </span><span class="sc">{}</span><span class="st">&quot;</span>, object_description))</span>
<span id="cb60-66"><a href="#cb60-66" aria-hidden="true"></a></span>
<span id="cb60-67"><a href="#cb60-67" aria-hidden="true"></a><span class="kw">def</span> MATCH_(vm, fn, message):</span>
<span id="cb60-68"><a href="#cb60-68" aria-hidden="true"></a>    <span class="cf">if</span> vm.pos <span class="op">&gt;=</span> <span class="bu">len</span>(vm.stream) <span class="kw">or</span> <span class="kw">not</span> fn(vm.stream[vm.pos]):</span>
<span id="cb60-69"><a href="#cb60-69" aria-hidden="true"></a>        FAIL_(vm, message)</span>
<span id="cb60-70"><a href="#cb60-70" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-71"><a href="#cb60-71" aria-hidden="true"></a>        vm.action <span class="op">=</span> SemanticAction(vm.stream[vm.pos])</span>
<span id="cb60-72"><a href="#cb60-72" aria-hidden="true"></a>        vm.pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-73"><a href="#cb60-73" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb60-74"><a href="#cb60-74" aria-hidden="true"></a></span>
<span id="cb60-75"><a href="#cb60-75" aria-hidden="true"></a><span class="kw">def</span> MATCH_CALL_RULE(vm):</span>
<span id="cb60-76"><a href="#cb60-76" aria-hidden="true"></a>    <span class="cf">if</span> MATCH_(vm, <span class="kw">lambda</span> x: x <span class="kw">in</span> vm.rules, (<span class="st">&quot;expected rule name&quot;</span>,)):</span>
<span id="cb60-77"><a href="#cb60-77" aria-hidden="true"></a>        CALL_(vm, vm.rules[vm.action.value])</span>
<span id="cb60-78"><a href="#cb60-78" aria-hidden="true"></a></span>
<span id="cb60-79"><a href="#cb60-79" aria-hidden="true"></a><span class="kw">def</span> LIST_START(vm):</span>
<span id="cb60-80"><a href="#cb60-80" aria-hidden="true"></a>    vm.scope_rest <span class="op">=</span> (vm.scope, vm.scope_rest)</span>
<span id="cb60-81"><a href="#cb60-81" aria-hidden="true"></a>    vm.scope <span class="op">=</span> []</span>
<span id="cb60-82"><a href="#cb60-82" aria-hidden="true"></a></span>
<span id="cb60-83"><a href="#cb60-83" aria-hidden="true"></a><span class="kw">def</span> LIST_APPEND(vm):</span>
<span id="cb60-84"><a href="#cb60-84" aria-hidden="true"></a>    vm.scope.append(vm.action)</span>
<span id="cb60-85"><a href="#cb60-85" aria-hidden="true"></a></span>
<span id="cb60-86"><a href="#cb60-86" aria-hidden="true"></a><span class="kw">def</span> LIST_END(vm):</span>
<span id="cb60-87"><a href="#cb60-87" aria-hidden="true"></a>    vm.action <span class="op">=</span> SemanticAction(vm.scope, <span class="kw">lambda</span> <span class="va">self</span>: [x.<span class="bu">eval</span>(<span class="va">self</span>.runtime) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.value])</span>
<span id="cb60-88"><a href="#cb60-88" aria-hidden="true"></a>    vm.scope, vm.scope_rest <span class="op">=</span> vm.scope_rest</span>
<span id="cb60-89"><a href="#cb60-89" aria-hidden="true"></a></span>
<span id="cb60-90"><a href="#cb60-90" aria-hidden="true"></a><span class="kw">def</span> BIND(vm):</span>
<span id="cb60-91"><a href="#cb60-91" aria-hidden="true"></a>    vm.scope[vm.pop_arg()] <span class="op">=</span> vm.action</span>
<span id="cb60-92"><a href="#cb60-92" aria-hidden="true"></a></span>
<span id="cb60-93"><a href="#cb60-93" aria-hidden="true"></a><span class="kw">def</span> ACTION(vm):</span>
<span id="cb60-94"><a href="#cb60-94" aria-hidden="true"></a>    vm.action <span class="op">=</span> SemanticAction(vm.scope, vm.pop_arg())</span>
<span id="cb60-95"><a href="#cb60-95" aria-hidden="true"></a></span>
<span id="cb60-96"><a href="#cb60-96" aria-hidden="true"></a><span class="kw">def</span> PUSH_STREAM(vm):</span>
<span id="cb60-97"><a href="#cb60-97" aria-hidden="true"></a>    <span class="cf">if</span> vm.pos <span class="op">&gt;=</span> <span class="bu">len</span>(vm.stream) <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(vm.stream[vm.pos], <span class="bu">list</span>):</span>
<span id="cb60-98"><a href="#cb60-98" aria-hidden="true"></a>        FAIL_(vm, (<span class="st">&quot;expected list&quot;</span>,))</span>
<span id="cb60-99"><a href="#cb60-99" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-100"><a href="#cb60-100" aria-hidden="true"></a>        vm.stream_rest <span class="op">=</span> (vm.stream, vm.stream_rest)</span>
<span id="cb60-101"><a href="#cb60-101" aria-hidden="true"></a>        vm.pos_rest <span class="op">=</span> vm.pos_rest <span class="op">+</span> (vm.pos,)</span>
<span id="cb60-102"><a href="#cb60-102" aria-hidden="true"></a>        vm.stream <span class="op">=</span> vm.stream[vm.pos]</span>
<span id="cb60-103"><a href="#cb60-103" aria-hidden="true"></a>        vm.pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb60-104"><a href="#cb60-104" aria-hidden="true"></a></span>
<span id="cb60-105"><a href="#cb60-105" aria-hidden="true"></a><span class="kw">def</span> POP_STREAM(vm):</span>
<span id="cb60-106"><a href="#cb60-106" aria-hidden="true"></a>    <span class="cf">if</span> vm.pos <span class="op">&lt;</span> <span class="bu">len</span>(vm.stream):</span>
<span id="cb60-107"><a href="#cb60-107" aria-hidden="true"></a>        FAIL_(vm, (<span class="st">&quot;expected end of list&quot;</span>,))</span>
<span id="cb60-108"><a href="#cb60-108" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-109"><a href="#cb60-109" aria-hidden="true"></a>        vm.stream, vm.stream_rest <span class="op">=</span> vm.stream_rest</span>
<span id="cb60-110"><a href="#cb60-110" aria-hidden="true"></a>        vm.pos, vm.pos_rest <span class="op">=</span> vm.pos_rest[<span class="op">-</span><span class="dv">1</span>], vm.pos_rest[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb60-111"><a href="#cb60-111" aria-hidden="true"></a>        vm.pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-112"><a href="#cb60-112" aria-hidden="true"></a></span>
<span id="cb60-113"><a href="#cb60-113" aria-hidden="true"></a><span class="kw">def</span> FAIL(vm):</span>
<span id="cb60-114"><a href="#cb60-114" aria-hidden="true"></a>    FAIL_(vm, (vm.pop_arg(),))</span>
<span id="cb60-115"><a href="#cb60-115" aria-hidden="true"></a></span>
<span id="cb60-116"><a href="#cb60-116" aria-hidden="true"></a><span class="kw">def</span> FAIL_(vm, fail_message):</span>
<span id="cb60-117"><a href="#cb60-117" aria-hidden="true"></a>    fail_pos <span class="op">=</span> vm.pos_rest<span class="op">+</span>(vm.pos,)</span>
<span id="cb60-118"><a href="#cb60-118" aria-hidden="true"></a>    <span class="cf">if</span> fail_pos <span class="op">&gt;=</span> vm.latest_fail_pos:</span>
<span id="cb60-119"><a href="#cb60-119" aria-hidden="true"></a>        vm.latest_fail_message <span class="op">=</span> fail_message</span>
<span id="cb60-120"><a href="#cb60-120" aria-hidden="true"></a>        vm.latest_fail_pos <span class="op">=</span> fail_pos</span>
<span id="cb60-121"><a href="#cb60-121" aria-hidden="true"></a>    call_backtrack_entry <span class="op">=</span> <span class="bu">tuple</span>()</span>
<span id="cb60-122"><a href="#cb60-122" aria-hidden="true"></a>    <span class="cf">while</span> vm.call_backtrack_stack:</span>
<span id="cb60-123"><a href="#cb60-123" aria-hidden="true"></a>        call_backtrack_entry <span class="op">=</span> vm.call_backtrack_stack.pop()</span>
<span id="cb60-124"><a href="#cb60-124" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">==</span> <span class="dv">7</span>:</span>
<span id="cb60-125"><a href="#cb60-125" aria-hidden="true"></a>            <span class="cf">break</span></span>
<span id="cb60-126"><a href="#cb60-126" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb60-127"><a href="#cb60-127" aria-hidden="true"></a>            vm.memo[call_backtrack_entry[<span class="dv">1</span>]] <span class="op">=</span> (<span class="va">None</span>, fail_message)</span>
<span id="cb60-128"><a href="#cb60-128" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">!=</span> <span class="dv">7</span>:</span>
<span id="cb60-129"><a href="#cb60-129" aria-hidden="true"></a>        <span class="cf">raise</span> MatchError(</span>
<span id="cb60-130"><a href="#cb60-130" aria-hidden="true"></a>            vm.latest_fail_message[<span class="dv">0</span>].<span class="bu">format</span>(<span class="op">*</span>vm.latest_fail_message[<span class="dv">1</span>:]),</span>
<span id="cb60-131"><a href="#cb60-131" aria-hidden="true"></a>            vm.latest_fail_pos[<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb60-132"><a href="#cb60-132" aria-hidden="true"></a>            vm.stream</span>
<span id="cb60-133"><a href="#cb60-133" aria-hidden="true"></a>        )</span>
<span id="cb60-134"><a href="#cb60-134" aria-hidden="true"></a>    (vm.pc, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest) <span class="op">=</span> call_backtrack_entry</span>
<span id="cb60-135"><a href="#cb60-135" aria-hidden="true"></a></span>
<span id="cb60-136"><a href="#cb60-136" aria-hidden="true"></a><span class="kw">class</span> SemanticAction(<span class="bu">object</span>):</span>
<span id="cb60-137"><a href="#cb60-137" aria-hidden="true"></a></span>
<span id="cb60-138"><a href="#cb60-138" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, fn<span class="op">=</span><span class="kw">lambda</span> <span class="va">self</span>: <span class="va">self</span>.value):</span>
<span id="cb60-139"><a href="#cb60-139" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb60-140"><a href="#cb60-140" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb60-141"><a href="#cb60-141" aria-hidden="true"></a></span>
<span id="cb60-142"><a href="#cb60-142" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>, runtime):</span>
<span id="cb60-143"><a href="#cb60-143" aria-hidden="true"></a>        <span class="va">self</span>.runtime <span class="op">=</span> runtime</span>
<span id="cb60-144"><a href="#cb60-144" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn(<span class="va">self</span>)</span>
<span id="cb60-145"><a href="#cb60-145" aria-hidden="true"></a></span>
<span id="cb60-146"><a href="#cb60-146" aria-hidden="true"></a>    <span class="kw">def</span> bind(<span class="va">self</span>, name, value, continuation):</span>
<span id="cb60-147"><a href="#cb60-147" aria-hidden="true"></a>        <span class="va">self</span>.runtime <span class="op">=</span> <span class="va">self</span>.runtime.<span class="bu">set</span>(name, value)</span>
<span id="cb60-148"><a href="#cb60-148" aria-hidden="true"></a>        <span class="cf">return</span> continuation()</span>
<span id="cb60-149"><a href="#cb60-149" aria-hidden="true"></a></span>
<span id="cb60-150"><a href="#cb60-150" aria-hidden="true"></a>    <span class="kw">def</span> lookup(<span class="va">self</span>, name):</span>
<span id="cb60-151"><a href="#cb60-151" aria-hidden="true"></a>        <span class="cf">if</span> name <span class="kw">in</span> <span class="va">self</span>.value:</span>
<span id="cb60-152"><a href="#cb60-152" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">self</span>.value[name].<span class="bu">eval</span>(<span class="va">self</span>.runtime)</span>
<span id="cb60-153"><a href="#cb60-153" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb60-154"><a href="#cb60-154" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">self</span>.runtime[name]</span>
<span id="cb60-155"><a href="#cb60-155" aria-hidden="true"></a></span>
<span id="cb60-156"><a href="#cb60-156" aria-hidden="true"></a><span class="kw">class</span> MatchError(<span class="pp">Exception</span>):</span>
<span id="cb60-157"><a href="#cb60-157" aria-hidden="true"></a></span>
<span id="cb60-158"><a href="#cb60-158" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, message, pos, stream):</span>
<span id="cb60-159"><a href="#cb60-159" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb60-160"><a href="#cb60-160" aria-hidden="true"></a>        <span class="va">self</span>.message <span class="op">=</span> message</span>
<span id="cb60-161"><a href="#cb60-161" aria-hidden="true"></a>        <span class="va">self</span>.pos <span class="op">=</span> pos</span>
<span id="cb60-162"><a href="#cb60-162" aria-hidden="true"></a>        <span class="va">self</span>.stream <span class="op">=</span> stream</span>
<span id="cb60-163"><a href="#cb60-163" aria-hidden="true"></a></span>
<span id="cb60-164"><a href="#cb60-164" aria-hidden="true"></a><span class="kw">class</span> Grammar(<span class="bu">object</span>):</span>
<span id="cb60-165"><a href="#cb60-165" aria-hidden="true"></a></span>
<span id="cb60-166"><a href="#cb60-166" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule, stream, runtime<span class="op">=</span>{}):</span>
<span id="cb60-167"><a href="#cb60-167" aria-hidden="true"></a>        <span class="cf">return</span> Runtime(<span class="va">self</span>, <span class="bu">dict</span>(runtime, <span class="op">**</span>{</span>
<span id="cb60-168"><a href="#cb60-168" aria-hidden="true"></a>            <span class="st">&quot;label&quot;</span>: Counter(),</span>
<span id="cb60-169"><a href="#cb60-169" aria-hidden="true"></a>            <span class="st">&quot;indentprefix&quot;</span>: <span class="st">&quot;    &quot;</span>,</span>
<span id="cb60-170"><a href="#cb60-170" aria-hidden="true"></a>            <span class="st">&quot;list&quot;</span>: <span class="bu">list</span>,</span>
<span id="cb60-171"><a href="#cb60-171" aria-hidden="true"></a>            <span class="st">&quot;dict&quot;</span>: <span class="bu">dict</span>,</span>
<span id="cb60-172"><a href="#cb60-172" aria-hidden="true"></a>            <span class="st">&quot;add&quot;</span>: <span class="kw">lambda</span> x, y: x.append(y),</span>
<span id="cb60-173"><a href="#cb60-173" aria-hidden="true"></a>            <span class="st">&quot;get&quot;</span>: <span class="kw">lambda</span> x, y: x[y],</span>
<span id="cb60-174"><a href="#cb60-174" aria-hidden="true"></a>            <span class="st">&quot;set&quot;</span>: <span class="kw">lambda</span> x, y, z: x.<span class="fu">__setitem__</span>(y, z),</span>
<span id="cb60-175"><a href="#cb60-175" aria-hidden="true"></a>            <span class="st">&quot;len&quot;</span>: <span class="bu">len</span>,</span>
<span id="cb60-176"><a href="#cb60-176" aria-hidden="true"></a>            <span class="st">&quot;repr&quot;</span>: <span class="bu">repr</span>,</span>
<span id="cb60-177"><a href="#cb60-177" aria-hidden="true"></a>            <span class="st">&quot;join&quot;</span>: join,</span>
<span id="cb60-178"><a href="#cb60-178" aria-hidden="true"></a>        })).run(rule, stream)</span>
<span id="cb60-179"><a href="#cb60-179" aria-hidden="true"></a></span>
<span id="cb60-180"><a href="#cb60-180" aria-hidden="true"></a><span class="kw">class</span> Runtime(<span class="bu">dict</span>):</span>
<span id="cb60-181"><a href="#cb60-181" aria-hidden="true"></a></span>
<span id="cb60-182"><a href="#cb60-182" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, grammar, values):</span>
<span id="cb60-183"><a href="#cb60-183" aria-hidden="true"></a>        <span class="bu">dict</span>.<span class="fu">__init__</span>(<span class="va">self</span>, <span class="bu">dict</span>(values, run<span class="op">=</span><span class="va">self</span>.run))</span>
<span id="cb60-184"><a href="#cb60-184" aria-hidden="true"></a>        <span class="va">self</span>.grammar <span class="op">=</span> grammar</span>
<span id="cb60-185"><a href="#cb60-185" aria-hidden="true"></a></span>
<span id="cb60-186"><a href="#cb60-186" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">set</span>(<span class="va">self</span>, key, value):</span>
<span id="cb60-187"><a href="#cb60-187" aria-hidden="true"></a>        <span class="cf">return</span> Runtime(<span class="va">self</span>.grammar, <span class="bu">dict</span>(<span class="va">self</span>, <span class="op">**</span>{key: value}))</span>
<span id="cb60-188"><a href="#cb60-188" aria-hidden="true"></a></span>
<span id="cb60-189"><a href="#cb60-189" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule, stream):</span>
<span id="cb60-190"><a href="#cb60-190" aria-hidden="true"></a>        <span class="cf">return</span> VM(<span class="va">self</span>.grammar.code, <span class="va">self</span>.grammar.rules).run(rule, stream).<span class="bu">eval</span>(<span class="va">self</span>)</span>
<span id="cb60-191"><a href="#cb60-191" aria-hidden="true"></a></span>
<span id="cb60-192"><a href="#cb60-192" aria-hidden="true"></a><span class="kw">class</span> Counter(<span class="bu">object</span>):</span>
<span id="cb60-193"><a href="#cb60-193" aria-hidden="true"></a></span>
<span id="cb60-194"><a href="#cb60-194" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb60-195"><a href="#cb60-195" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb60-196"><a href="#cb60-196" aria-hidden="true"></a></span>
<span id="cb60-197"><a href="#cb60-197" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>):</span>
<span id="cb60-198"><a href="#cb60-198" aria-hidden="true"></a>        result <span class="op">=</span> <span class="va">self</span>.value</span>
<span id="cb60-199"><a href="#cb60-199" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-200"><a href="#cb60-200" aria-hidden="true"></a>        <span class="cf">return</span> result</span>
<span id="cb60-201"><a href="#cb60-201" aria-hidden="true"></a></span>
<span id="cb60-202"><a href="#cb60-202" aria-hidden="true"></a><span class="kw">def</span> splice(depth, item):</span>
<span id="cb60-203"><a href="#cb60-203" aria-hidden="true"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb60-204"><a href="#cb60-204" aria-hidden="true"></a>        <span class="cf">return</span> [item]</span>
<span id="cb60-205"><a href="#cb60-205" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-206"><a href="#cb60-206" aria-hidden="true"></a>        <span class="cf">return</span> concat([splice(depth<span class="op">-</span><span class="dv">1</span>, subitem) <span class="cf">for</span> subitem <span class="kw">in</span> item])</span>
<span id="cb60-207"><a href="#cb60-207" aria-hidden="true"></a></span>
<span id="cb60-208"><a href="#cb60-208" aria-hidden="true"></a><span class="kw">def</span> concat(lists):</span>
<span id="cb60-209"><a href="#cb60-209" aria-hidden="true"></a>    <span class="cf">return</span> [x <span class="cf">for</span> xs <span class="kw">in</span> lists <span class="cf">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb60-210"><a href="#cb60-210" aria-hidden="true"></a></span>
<span id="cb60-211"><a href="#cb60-211" aria-hidden="true"></a><span class="kw">def</span> join(items, delimiter<span class="op">=</span><span class="st">&quot;&quot;</span>):</span>
<span id="cb60-212"><a href="#cb60-212" aria-hidden="true"></a>    <span class="cf">return</span> delimiter.join(</span>
<span id="cb60-213"><a href="#cb60-213" aria-hidden="true"></a>        join(item, delimiter) <span class="cf">if</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>) <span class="cf">else</span> <span class="bu">str</span>(item)</span>
<span id="cb60-214"><a href="#cb60-214" aria-hidden="true"></a>        <span class="cf">for</span> item <span class="kw">in</span> items</span>
<span id="cb60-215"><a href="#cb60-215" aria-hidden="true"></a>    )</span>
<span id="cb60-216"><a href="#cb60-216" aria-hidden="true"></a></span>
<span id="cb60-217"><a href="#cb60-217" aria-hidden="true"></a><span class="kw">def</span> indent(text, prefix<span class="op">=</span><span class="st">&quot;    &quot;</span>):</span>
<span id="cb60-218"><a href="#cb60-218" aria-hidden="true"></a>    <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join(prefix<span class="op">+</span>line <span class="cf">for</span> line <span class="kw">in</span> text.splitlines(<span class="va">True</span>))</span>
<span id="cb60-219"><a href="#cb60-219" aria-hidden="true"></a></span>
<span id="cb60-220"><a href="#cb60-220" aria-hidden="true"></a><span class="kw">def</span> compile_chain(grammars, source):</span>
<span id="cb60-221"><a href="#cb60-221" aria-hidden="true"></a>    <span class="im">import</span> os</span>
<span id="cb60-222"><a href="#cb60-222" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb60-223"><a href="#cb60-223" aria-hidden="true"></a>    <span class="im">import</span> pprint</span>
<span id="cb60-224"><a href="#cb60-224" aria-hidden="true"></a>    <span class="cf">for</span> grammar, rule <span class="kw">in</span> grammars:</span>
<span id="cb60-225"><a href="#cb60-225" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb60-226"><a href="#cb60-226" aria-hidden="true"></a>            source <span class="op">=</span> grammar().run(rule, source)</span>
<span id="cb60-227"><a href="#cb60-227" aria-hidden="true"></a>        <span class="cf">except</span> MatchError <span class="im">as</span> e:</span>
<span id="cb60-228"><a href="#cb60-228" aria-hidden="true"></a>            marker <span class="op">=</span> <span class="st">&quot;&lt;ERROR POSITION&gt;&quot;</span></span>
<span id="cb60-229"><a href="#cb60-229" aria-hidden="true"></a>            <span class="cf">if</span> os.isatty(sys.stderr.fileno()):</span>
<span id="cb60-230"><a href="#cb60-230" aria-hidden="true"></a>                marker <span class="op">=</span> <span class="ss">f&quot;</span><span class="ch">\033</span><span class="ss">[0;31m</span><span class="sc">{</span>marker<span class="sc">}</span><span class="ch">\033</span><span class="ss">[0m&quot;</span></span>
<span id="cb60-231"><a href="#cb60-231" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(e.stream, <span class="bu">str</span>):</span>
<span id="cb60-232"><a href="#cb60-232" aria-hidden="true"></a>                stream_string <span class="op">=</span> e.stream[:e.pos] <span class="op">+</span> marker <span class="op">+</span> e.stream[e.pos:]</span>
<span id="cb60-233"><a href="#cb60-233" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb60-234"><a href="#cb60-234" aria-hidden="true"></a>                stream_string <span class="op">=</span> pprint.pformat(e.stream)</span>
<span id="cb60-235"><a href="#cb60-235" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">POSITION: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">STREAM:</span><span class="ch">\n</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb60-236"><a href="#cb60-236" aria-hidden="true"></a>                e.message,</span>
<span id="cb60-237"><a href="#cb60-237" aria-hidden="true"></a>                e.pos,</span>
<span id="cb60-238"><a href="#cb60-238" aria-hidden="true"></a>                indent(stream_string)</span>
<span id="cb60-239"><a href="#cb60-239" aria-hidden="true"></a>            ))</span>
<span id="cb60-240"><a href="#cb60-240" aria-hidden="true"></a>    <span class="cf">return</span> source</span></code></pre></div>
<h3 id="srcmain.py">src/main.py</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a>    <span class="kw">def</span> read(path):</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>        <span class="cf">if</span> path <span class="op">==</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>            <span class="cf">return</span> sys.stdin.read()</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true"></a>        <span class="cf">with</span> <span class="bu">open</span>(path) <span class="im">as</span> f:</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true"></a>            <span class="cf">return</span> f.read()</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true"></a>    args <span class="op">=</span> sys.argv[<span class="dv">1</span>:] <span class="kw">or</span> [<span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;-&quot;</span>]</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true"></a>    <span class="cf">while</span> args:</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true"></a>        command <span class="op">=</span> args.pop(<span class="dv">0</span>)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true"></a>        <span class="cf">if</span> command <span class="op">==</span> <span class="st">&quot;--support&quot;</span>:</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true"></a>            sys.stdout.write(SUPPORT)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--copy&quot;</span>:</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true"></a>            sys.stdout.write(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--embed&quot;</span>:</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true"></a>            sys.stdout.write(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> = </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true"></a>                args.pop(<span class="dv">0</span>),</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true"></a>                <span class="bu">repr</span>(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true"></a>            ))</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--compile&quot;</span>:</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true"></a>            sys.stdout.write(compile_chain(</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true"></a>                [(Parser, <span class="st">&quot;file&quot;</span>), (CodeGenerator, <span class="st">&quot;asts&quot;</span>), (Assembler, <span class="st">&quot;asts&quot;</span>)],</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true"></a>                read(args.pop(<span class="dv">0</span>))</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true"></a>            ))</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: Unknown command &#39;</span><span class="sc">{}</span><span class="st">&#39;&quot;</span>.<span class="bu">format</span>(command))</span></code></pre></div>
<h3 id="make.py">make.py</h3>
<div class="sourceCode" id="cb62"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a><span class="co">#!/usr/bin/env python</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a><span class="im">import</span> os</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a><span class="im">import</span> subprocess</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a><span class="im">import</span> sys</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true"></a><span class="kw">def</span> make_next_version():</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true"></a>    final_compiler <span class="op">=</span> meta_compile_rlmeta()</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true"></a>    test(final_compiler)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true"></a>    mv(final_compiler, <span class="st">&quot;rlmeta.py&quot;</span>)</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true"></a><span class="kw">def</span> meta_compile_rlmeta():</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true"></a>    compiler <span class="op">=</span> <span class="st">&quot;rlmeta.py&quot;</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true"></a>    content <span class="op">=</span> read(compiler)</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true"></a>        next_compiler <span class="op">=</span> <span class="st">&quot;rlmeta</span><span class="sc">{}</span><span class="st">.py&quot;</span>.<span class="bu">format</span>(i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true"></a>        next_content <span class="op">=</span> compile_rlmeta(compiler)</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true"></a>        log(<span class="st">&quot;Writing </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(next_compiler))</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true"></a>        write(next_compiler, next_content)</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true"></a>        <span class="cf">if</span> next_content <span class="op">==</span> content:</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true"></a>            <span class="cf">return</span> next_compiler</span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true"></a>        compiler <span class="op">=</span> next_compiler</span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true"></a>        content <span class="op">=</span> next_content</span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true"></a>    fail(<span class="st">&quot;Unable to produce metacompiler.&quot;</span>)</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true"></a></span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true"></a><span class="kw">def</span> compile_rlmeta(rlmeta):</span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true"></a>    log(<span class="st">&quot;Compiling rlmeta using </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(rlmeta))</span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true"></a>    <span class="cf">return</span> run_rlmeta(rlmeta, [</span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true"></a>        <span class="st">&quot;--embed&quot;</span>, <span class="st">&quot;SUPPORT&quot;</span>, <span class="st">&quot;src/support.py&quot;</span>,</span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true"></a>        <span class="st">&quot;--support&quot;</span>,</span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true"></a>        <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;src/parser.rlmeta&quot;</span>,</span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true"></a>        <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;src/codegenerator.rlmeta&quot;</span>,</span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true"></a>        <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;src/assembler.rlmeta&quot;</span>,</span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true"></a>        <span class="st">&quot;--copy&quot;</span>, <span class="st">&quot;src/main.py&quot;</span>,</span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true"></a>    ])</span>
<span id="cb62-36"><a href="#cb62-36" aria-hidden="true"></a></span>
<span id="cb62-37"><a href="#cb62-37" aria-hidden="true"></a><span class="kw">def</span> test(rlmeta):</span>
<span id="cb62-38"><a href="#cb62-38" aria-hidden="true"></a>    log(<span class="st">&quot;Test: Has its own support library&quot;</span>)</span>
<span id="cb62-39"><a href="#cb62-39" aria-hidden="true"></a>    <span class="cf">assert</span> run_rlmeta(rlmeta, [<span class="st">&quot;--support&quot;</span>]) <span class="op">==</span> read(<span class="st">&quot;src/support.py&quot;</span>)</span>
<span id="cb62-40"><a href="#cb62-40" aria-hidden="true"></a>    log(<span class="st">&quot;Test: Disallow semantic action in the middle&quot;</span>)</span>
<span id="cb62-41"><a href="#cb62-41" aria-hidden="true"></a>    run_rlmeta(rlmeta, [], b<span class="st">&quot;Grammar { x = . -&gt; [] . }&quot;</span>, expect_failure<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb62-42"><a href="#cb62-42" aria-hidden="true"></a>    log(<span class="st">&quot;Test: Call unknown rule foo&quot;</span>)</span>
<span id="cb62-43"><a href="#cb62-43" aria-hidden="true"></a>    <span class="cf">assert</span> test_grammar(</span>
<span id="cb62-44"><a href="#cb62-44" aria-hidden="true"></a>        rlmeta,</span>
<span id="cb62-45"><a href="#cb62-45" aria-hidden="true"></a>        b<span class="st">&quot;Grammar { x = % | . }&quot;</span>,</span>
<span id="cb62-46"><a href="#cb62-46" aria-hidden="true"></a>        b<span class="st">&quot;print(compile_chain([(Grammar, &#39;x&#39;)], [&#39;foo&#39;]))&quot;</span></span>
<span id="cb62-47"><a href="#cb62-47" aria-hidden="true"></a>    ) <span class="op">==</span> b<span class="st">&quot;foo</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb62-48"><a href="#cb62-48" aria-hidden="true"></a></span>
<span id="cb62-49"><a href="#cb62-49" aria-hidden="true"></a><span class="kw">def</span> test_grammar(rlmeta, grammar, main_code):</span>
<span id="cb62-50"><a href="#cb62-50" aria-hidden="true"></a>    compiled <span class="op">=</span> run_rlmeta(rlmeta, [<span class="st">&quot;--support&quot;</span>, <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;-&quot;</span>], grammar)</span>
<span id="cb62-51"><a href="#cb62-51" aria-hidden="true"></a>    total <span class="op">=</span> compiled <span class="op">+</span> main_code</span>
<span id="cb62-52"><a href="#cb62-52" aria-hidden="true"></a>    process <span class="op">=</span> subprocess.Popen(</span>
<span id="cb62-53"><a href="#cb62-53" aria-hidden="true"></a>        [<span class="st">&quot;python&quot;</span>],</span>
<span id="cb62-54"><a href="#cb62-54" aria-hidden="true"></a>        stdin<span class="op">=</span>subprocess.PIPE,</span>
<span id="cb62-55"><a href="#cb62-55" aria-hidden="true"></a>        stdout<span class="op">=</span>subprocess.PIPE</span>
<span id="cb62-56"><a href="#cb62-56" aria-hidden="true"></a>    )</span>
<span id="cb62-57"><a href="#cb62-57" aria-hidden="true"></a>    stdout, _ <span class="op">=</span> process.communicate(total)</span>
<span id="cb62-58"><a href="#cb62-58" aria-hidden="true"></a>    <span class="cf">return</span> stdout</span>
<span id="cb62-59"><a href="#cb62-59" aria-hidden="true"></a></span>
<span id="cb62-60"><a href="#cb62-60" aria-hidden="true"></a><span class="kw">def</span> run_rlmeta(rlmeta, args, stdin<span class="op">=</span>b<span class="st">&quot;&quot;</span>, expect_failure<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb62-61"><a href="#cb62-61" aria-hidden="true"></a>    process <span class="op">=</span> subprocess.Popen(</span>
<span id="cb62-62"><a href="#cb62-62" aria-hidden="true"></a>        [<span class="st">&quot;python&quot;</span>, rlmeta]<span class="op">+</span>args,</span>
<span id="cb62-63"><a href="#cb62-63" aria-hidden="true"></a>        stdin<span class="op">=</span>subprocess.PIPE,</span>
<span id="cb62-64"><a href="#cb62-64" aria-hidden="true"></a>        stdout<span class="op">=</span>subprocess.PIPE</span>
<span id="cb62-65"><a href="#cb62-65" aria-hidden="true"></a>    )</span>
<span id="cb62-66"><a href="#cb62-66" aria-hidden="true"></a>    stdout, _ <span class="op">=</span> process.communicate(stdin)</span>
<span id="cb62-67"><a href="#cb62-67" aria-hidden="true"></a>    <span class="cf">if</span> expect_failure:</span>
<span id="cb62-68"><a href="#cb62-68" aria-hidden="true"></a>        <span class="cf">if</span> process.returncode <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb62-69"><a href="#cb62-69" aria-hidden="true"></a>            fail(<span class="st">&quot;Expected failure&quot;</span>)</span>
<span id="cb62-70"><a href="#cb62-70" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb62-71"><a href="#cb62-71" aria-hidden="true"></a>        <span class="cf">if</span> process.returncode <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb62-72"><a href="#cb62-72" aria-hidden="true"></a>            fail(<span class="st">&quot;Expected success&quot;</span>)</span>
<span id="cb62-73"><a href="#cb62-73" aria-hidden="true"></a>    <span class="cf">return</span> stdout</span>
<span id="cb62-74"><a href="#cb62-74" aria-hidden="true"></a></span>
<span id="cb62-75"><a href="#cb62-75" aria-hidden="true"></a><span class="kw">def</span> mv(src, dest):</span>
<span id="cb62-76"><a href="#cb62-76" aria-hidden="true"></a>    log(<span class="st">&quot;Moving </span><span class="sc">{}</span><span class="st"> -&gt; </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(src, dest))</span>
<span id="cb62-77"><a href="#cb62-77" aria-hidden="true"></a>    os.remove(dest)</span>
<span id="cb62-78"><a href="#cb62-78" aria-hidden="true"></a>    os.rename(src, dest)</span>
<span id="cb62-79"><a href="#cb62-79" aria-hidden="true"></a></span>
<span id="cb62-80"><a href="#cb62-80" aria-hidden="true"></a><span class="kw">def</span> cleanup():</span>
<span id="cb62-81"><a href="#cb62-81" aria-hidden="true"></a>    <span class="cf">for</span> path <span class="kw">in</span> [</span>
<span id="cb62-82"><a href="#cb62-82" aria-hidden="true"></a>        <span class="st">&quot;rlmeta1.py&quot;</span>,</span>
<span id="cb62-83"><a href="#cb62-83" aria-hidden="true"></a>        <span class="st">&quot;rlmeta2.py&quot;</span>,</span>
<span id="cb62-84"><a href="#cb62-84" aria-hidden="true"></a>        <span class="st">&quot;rlmeta3.py&quot;</span>,</span>
<span id="cb62-85"><a href="#cb62-85" aria-hidden="true"></a>        <span class="st">&quot;rlmeta4.py&quot;</span>,</span>
<span id="cb62-86"><a href="#cb62-86" aria-hidden="true"></a>    ]:</span>
<span id="cb62-87"><a href="#cb62-87" aria-hidden="true"></a>        <span class="cf">if</span> os.path.exists(path):</span>
<span id="cb62-88"><a href="#cb62-88" aria-hidden="true"></a>            log(<span class="st">&quot;Deleting </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(path))</span>
<span id="cb62-89"><a href="#cb62-89" aria-hidden="true"></a>            os.remove(path)</span>
<span id="cb62-90"><a href="#cb62-90" aria-hidden="true"></a></span>
<span id="cb62-91"><a href="#cb62-91" aria-hidden="true"></a><span class="kw">def</span> read(path):</span>
<span id="cb62-92"><a href="#cb62-92" aria-hidden="true"></a>    <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">&quot;rb&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb62-93"><a href="#cb62-93" aria-hidden="true"></a>        <span class="cf">return</span> f.read()</span>
<span id="cb62-94"><a href="#cb62-94" aria-hidden="true"></a></span>
<span id="cb62-95"><a href="#cb62-95" aria-hidden="true"></a><span class="kw">def</span> write(path, content):</span>
<span id="cb62-96"><a href="#cb62-96" aria-hidden="true"></a>    <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">&quot;wb&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb62-97"><a href="#cb62-97" aria-hidden="true"></a>        <span class="cf">return</span> f.write(content)</span>
<span id="cb62-98"><a href="#cb62-98" aria-hidden="true"></a></span>
<span id="cb62-99"><a href="#cb62-99" aria-hidden="true"></a><span class="kw">def</span> log(message):</span>
<span id="cb62-100"><a href="#cb62-100" aria-hidden="true"></a>    sys.stderr.write(color(<span class="ss">f&quot;</span><span class="sc">{</span>message<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>, <span class="st">&quot;33&quot;</span>))</span>
<span id="cb62-101"><a href="#cb62-101" aria-hidden="true"></a></span>
<span id="cb62-102"><a href="#cb62-102" aria-hidden="true"></a><span class="kw">def</span> success(message):</span>
<span id="cb62-103"><a href="#cb62-103" aria-hidden="true"></a>    sys.stderr.write(color(<span class="ss">f&quot;</span><span class="sc">{</span>message<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>, <span class="st">&quot;32&quot;</span>))</span>
<span id="cb62-104"><a href="#cb62-104" aria-hidden="true"></a></span>
<span id="cb62-105"><a href="#cb62-105" aria-hidden="true"></a><span class="kw">def</span> fail(message):</span>
<span id="cb62-106"><a href="#cb62-106" aria-hidden="true"></a>    sys.exit(color(<span class="ss">f&quot;ERROR: </span><span class="sc">{</span>message<span class="sc">}</span><span class="ss">&quot;</span>, <span class="st">&quot;31&quot;</span>))</span>
<span id="cb62-107"><a href="#cb62-107" aria-hidden="true"></a></span>
<span id="cb62-108"><a href="#cb62-108" aria-hidden="true"></a><span class="kw">def</span> color(message, color):</span>
<span id="cb62-109"><a href="#cb62-109" aria-hidden="true"></a>    <span class="cf">if</span> os.isatty(sys.stderr.fileno()):</span>
<span id="cb62-110"><a href="#cb62-110" aria-hidden="true"></a>        <span class="cf">return</span> <span class="ss">f&quot;</span><span class="ch">\033</span><span class="ss">[0;</span><span class="sc">{</span>color<span class="sc">}</span><span class="ss">m</span><span class="sc">{</span>message<span class="sc">}</span><span class="ch">\033</span><span class="ss">[0m&quot;</span></span>
<span id="cb62-111"><a href="#cb62-111" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb62-112"><a href="#cb62-112" aria-hidden="true"></a>        <span class="cf">return</span> message</span>
<span id="cb62-113"><a href="#cb62-113" aria-hidden="true"></a></span>
<span id="cb62-114"><a href="#cb62-114" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb62-115"><a href="#cb62-115" aria-hidden="true"></a>    cleanup()</span>
<span id="cb62-116"><a href="#cb62-116" aria-hidden="true"></a>    <span class="cf">if</span> sys.argv[<span class="dv">1</span>:] <span class="op">==</span> [<span class="st">&quot;--compile&quot;</span>]:</span>
<span id="cb62-117"><a href="#cb62-117" aria-hidden="true"></a>        sys.stdout.<span class="bu">buffer</span>.write(compile_rlmeta(<span class="st">&quot;rlmeta.py&quot;</span>))</span>
<span id="cb62-118"><a href="#cb62-118" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb62-119"><a href="#cb62-119" aria-hidden="true"></a>        make_next_version()</span>
<span id="cb62-120"><a href="#cb62-120" aria-hidden="true"></a>    cleanup()</span>
<span id="cb62-121"><a href="#cb62-121" aria-hidden="true"></a>    success(<span class="st">&quot;  O-----------------O&quot;</span>)</span>
<span id="cb62-122"><a href="#cb62-122" aria-hidden="true"></a>    success(<span class="st">&quot;  | RLMeta compiled |&quot;</span>)</span>
<span id="cb62-123"><a href="#cb62-123" aria-hidden="true"></a>    success(<span class="st">&quot;~~|     itself!     |&quot;</span>)</span>
<span id="cb62-124"><a href="#cb62-124" aria-hidden="true"></a>    success(<span class="st">&quot;  O-----------------O&quot;</span>)</span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>Creating the RLMeta poster</title>
    <link href="http://rickardlindberg.me/writing/creating-rlmeta-poster/" />
    <id>http://rickardlindberg.me/writing/creating-rlmeta-poster/</id>
    <published>2020-05-24T00:00:00Z</published>
    <updated>2020-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Creating the RLMeta poster</h1>

<p><em>Published on 24 May 2020.</em></p>

<p>RLMeta is the most interesting program I've written. I find the grammar syntax beautiful to read and the meta-approach intriguing. To me, it approaches art. I wanted to showcase it by putting the whole implementation on a poster. Here is a preview:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
Preview of poster.
</center>
<p>Read on to learn how I created the poster and the RLMeta version displayed on it.</p>
<hr>
<p>This article is about how I created the RLMeta poster. Do you want to get the poster yourself?</p>
<p><a href="/pages/rlmeta-poster/index.html" class="btn btn-primary btn-lg">Check this page out!</a></p>
<hr>
<ul>
<li><a href="#822b34b481dd40c797d64d7d4dc1c83a">Poster design</a></li>
<li><a href="#227a05deecde41ad94738cb5cde516a0">RLMeta version</a>
<ul>
<li><a href="#2e83db1fb82b47c087bf7a6eb93d9440">Remove string builder</a></li>
<li><a href="#b391fa9375a5457cb91d265a597c6f0a">Move error reporting out of support</a></li>
<li><a href="#aeb916fedcdd47d5bb42e8d21b198c5b">Move assemble function to support</a></li>
<li><a href="#eb05ba1c676e4061a91f61e7c6234957">Compact and modify formatting</a></li>
<li><a href="#d2ab43bf941642b68c5af6af5937b17d">Have only one semantic action class</a></li>
<li><a href="#49f769c882b84649bcac36fe7401ce73">Allow unlimited splice</a></li>
<li><a href="#789c6116aa5449d691284a7fe3d36f9e">Redefine matching of character sequences</a></li>
</ul></li>
<li><a href="#b070abcd2f134cf894e33e63188a9fee">Future posters</a></li>
<li><a href="#730eea3f33b24e07b3714ef4c1981fd1">Code listings for RLMeta</a>
<ul>
<li><a href="#9ce22f137e4a4bf3b4080f4803f3205d">parser.rlmeta</a></li>
<li><a href="#af73e151e4a847e98832b2460fd43cc1">codegenerator.rlmeta</a></li>
<li><a href="#79d15a72ff31485ea0204c8f79d3a641">support.py</a></li>
<li><a href="#7142a9c9c93e4aa2aaf35c7962eb3c88">compile.sh</a></li>
<li><a href="#8c47ff964a3f43a29a4413bbf5b0132d">meta_compile.sh</a></li>
</ul></li>
</ul>
<h2 id="b34b481dd40c797d64d7d4dc1c83aposter-design">[]{#822b34b481dd40c797d64d7d4dc1c83a}Poster design</h2>
<p>I created the poster using <a href="https://inkscape.org/">Inkscape</a>. I have used Inkscape on and off in the past, but I am by no means an expert. I used the <a href="https://github.com/etlapale/inksyntax">inksyntax</a> plugin to create syntax highlighted text.</p>
<p>To come up with the design for the poster, I started by creating text objects for each file in the implementation. Then I tried to fit them on a page. Portrait mode worked best since I did not want to break the VM implementation, which was the longest piece of text and determined the main layout of the poster. I also concluded that I needed three columns to fit all code and that I wanted them to be of equal width for symmetry. I modified the source code to better fit the poster layout. In particular I worked on reducing the number of lines of code. After a while, making the VM code shorter would not help to fit more on the page because I still needed three columns. I made lots of test printouts and edits. You can see some of them in the pictures below.</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
I experimented with landscape mode. I figured that it would be bad usage of available space. I also had an idea about drawing arrows to show how the source code flow in the compiler. I decided that it would just clutter the poster.
</center>
<p><img src="image3.png" /></p>
<!-- image text -->
<center>
I printed half the poster on an A4 page to simulate text size on an A3 page. I concluded that the smallest text would probably be big enough if printed with a good printer.
</center>
<p><img src="image4.png" /></p>
<!-- image text -->
<center>
Here I have gravitated toward the final base design. I still haven't given up on the arrows.
</center>
<p><img src="image5.png" /></p>
<!-- image text -->
<center>
Here I have added introduction text and an example. My notes indicate improvements to RLMeta to make it a better fit for the poster. So even if this was printed on an A4 page on my cheap printer, it was possible to read, but not comfortable.
</center>
<p><img src="image6.png" /></p>
<!-- image text -->
<center>
I did some test printouts on two A4 papers and taped them together to simulate final size. <a href="https://pdfposter.readthedocs.io/en/stable/">pdfposter</a> was a useful tool here. Here is the command I used to split one A3 page in portrait mode into two A4 pages in landscape mode: <code>pdfposter /tmp/rlmeta-a3.pdf /tmp/rlmeta-a4.pdf -m a4 -p 2x1a4</code>.
</center>
<p><img src="image7.png" /></p>
<!-- image text -->
<center>
Here is the final beta poster printed on an A4 page. This is the one that I ordered for myself but in 12x16 inch format (close to A3).
</center>
<p><img src="image8.png" /></p>
<!-- image text -->
<center>
Finally, the poster arrived in my mail.
</center>
<hr>
<p>Do you want to have this poster in your hands as well?</p>
<p><a href="/pages/rlmeta-poster/index.html" class="btn btn-primary btn-lg">Check this page out!</a></p>
<hr>
<h2 id="a05deecde41ad94738cb5cde516a0rlmeta-version">[]{#227a05deecde41ad94738cb5cde516a0}RLMeta version</h2>
<p>The version of RLMeta on the poster is based on the VM based version from the <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures</a> article. In order to fit it nicely on a poster I had to make it smaller by reducing the number of lines of code. I also took the opportunity to clean up some things that annoyed me to make the poster extra beautiful. I believe this is the most beautiful version of RLMeta to date.</p>
<p>I though the memoizing version was already quite small. So I was not confident that I could make the poster version smaller. But when thinking about it a few things came to mind and I was able to reduce it by 103 lines. As a result, the poster version is also the smallest version of RLMeta to date. The changes also made it faster. So it is also the fastest version of RLMeta to date. I'm sure it can become even shorter and faster, and it's probably something I will think about again. But at some point I had to say it was good enough for a first version of a poster.</p>
<p><img src="image9.png" /></p>
<!-- image text -->
<center>
Performance measurements.
</center>
<p>Next I will describe the changes I did compared to the memoizing version.</p>
<h3 id="e83db1fb82b47c087bf7a6eb93d9440remove-string-builder">[]{#2e83db1fb82b47c087bf7a6eb93d9440}Remove string builder</h3>
<p>In the memoizing version, curly brace expressions in semantic actions are compiled to builder objects. Take the following example:</p>
<pre class="text"><code>Example {
  rule = .:x -&gt; { &quot;build a string with &quot; x &quot;!&quot; }
}</code></pre>
<p>The semantic action is compiled to the following Python code:</p>
<pre class="text"><code>lambda scope: _Builder.create([
    &#39;build a string with &#39;,
    scope[&#39;x&#39;].eval(),
    &#39;!&#39;
])</code></pre>
<p>And in the <code>run</code> method that kicks off matching, there is code to check if the result is a builder, and if so, the result of building the string is returned:</p>
<pre class="text"><code>if isinstance(result, _Builder):
    return result.build_string()
else:
    return result</code></pre>
<p>I figured that all builder logic was not really needed. Instead curly brace expressions could be compiled to Python expressions that directly build and return strings.</p>
<p>With this change, the example semantic action is compiled to this:</p>
<pre class="text"><code>lambda scope: join([
    &#39;build a string with &#39;,
    scope[&#39;x&#39;].eval(),
    &#39;!&#39;
])</code></pre>
<p>Where <code>join</code> is defined like this:</p>
<pre class="text"><code>def join(items):
    return &quot;&quot;.join(
        join(item) if isinstance(item, list) else str(item)
        for item in items
    )</code></pre>
<p>Indentation is handled similarly by directly indenting the string with the <code>indent</code> function:</p>
<pre class="text"><code>def indent(text):
    return join(join([&quot;    &quot;, line]) for line in text.splitlines(True))</code></pre>
<p>This change made lots of code obsolete:</p>
<ul>
<li>All builder-related classes could be removed (-61 lines)</li>
<li>The top level builder check could be removed (-3 lines)</li>
<li>The parser and the codegenerator actually got a little cleaner (-2 lines)</li>
<li>Import of <code>StringIO</code> could be removed (-5 lines)</li>
<li>Two string formatting functions (<code>join</code> and <code>indent</code>) had to be added (+9 lines)</li>
</ul>
<p>In total, it made RLMeta <strong>62 lines shorter</strong>.</p>
<p>I suspect that this change is also what made the poster version a little faster. So simpler, cleaner, and faster.</p>
<h3 id="move-error-reporting-out-of-support"><span id="b391fa9375a5457cb91d265a597c6f0a"></span>Move error reporting out of support</h3>
<p>In the memoizing version, the main function looks like this:</p>
<pre class="text"><code>try:
    sys.stdout.write(compile_grammar(sys.stdin.read()))
except _MatchError as e:
    sys.stderr.write(e.describe())
    sys.exit(1)</code></pre>
<p>If an error occurs, the <code>describe</code> method of the exception is used to format an error message suitable for printing to the console.</p>
<p>I decided that this was not really a responsibility of the support library. The support library should only provide information about the error, and it should be up to the handler of the error how to present it.</p>
<p>I therefore removed the <code>describe</code> method and replaced it with a much simpler error reporting scheme directly in the main method that looks like this:</p>
<pre class="text"><code>try:
    ...
except MatchError as e:
    stream = e.stream
    for pos in e.pos[:-1]:
        stream = stream[pos]
    pos = e.pos[-1]
    MARKER = &quot;\\033[0;31m&lt;ERROR POSITION&gt;\\033[0m&quot;
    if isinstance(stream, basestring):
        stream_string = stream[:pos] + MARKER + stream[pos:]
    else:
        stream_string = pprint.pformat(stream)
    sys.exit(&quot;ERROR: {}\\nPOSITION: {}\\nSTREAM:\\n{}&quot;.format(
      e.message,
      pos,
      indent(stream_string)
    ))</code></pre>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/b24d5cce5b684a62b9b85a48cd62443e48ccfb04">here</a>.</p>
<p>This change made RLMeta <strong>21 lines shorter</strong>.</p>
<p>This error reporting scheme is not that bad, and also doesn't suffer from edge case bugs like the one in the memoizing version does. But more importantly it is more clean. It is now the responsibility of the handler of the error to do formatting.</p>
<h3 id="move-assemble-function-to-support"><span id="aeb916fedcdd47d5bb42e8d21b198c5b"></span>Move assemble function to support</h3>
<p>In the memoizing version, the <code>Grammar</code> rule in the code generator looks like this:</p>
<pre class="text"><code>Grammar = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(_Grammar):\n\n&quot; &gt;
                             &quot;def __init__(self):\n&quot; &gt;
                               &quot;self._instructions = i = []\n&quot;
                               &quot;self._labels = l = {}\n&quot;
                               &quot;def I(name, x=None, y=None):\n&quot; &gt;
                                 &quot;i.append((name, x, y))\n&quot;
                               &lt;
                               &quot;def LABEL(name):\n&quot; &gt;
                                 &quot;l[name] = len(i)\n&quot;
                               &lt;
                               ys
                             &lt;
                           &lt;                                    }</code></pre>
<p>Having lot's of Python code in the code generator makes it harder to read. I therefore decided to put this code in the support library instead.</p>
<p>The new <code>Grammar</code> rule looks like this:</p>
<pre class="text"><code>Grammar = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(Grammar):\n\n&quot; &gt;
                             &quot;def assemble(self, I, LABEL):\n&quot; &gt;
                               ys
                             &lt;
                           &lt;                                    }</code></pre>
<p>And the support function looks like this:</p>
<pre class="text"><code>def run(self, rule_name, stream):
    instructions = []
    labels = {}
    def I(name, arg1=None, arg2=None):
        instructions.append((name, arg1, arg2))
    def LABEL(name):
        labels[name] = len(instructions)
    self.assemble(I, LABEL)
    return vm(instructions, labels, rule_name, stream)</code></pre>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/7709ec4b72c1c8c2dfbbef1f75b1e2946d5ee0fd">here</a>.</p>
<p>This change made RLMeta <strong>1 line shorter</strong>. But more importantly, it made the code generator easier to read.</p>
<h3 id="compact-and-modify-formatting"><span id="eb05ba1c676e4061a91f61e7c6234957"></span>Compact and modify formatting</h3>
<p>I made many small changes to improve the readability of RLMeta as well as some formatting to make it fit better on the poster. They did not affect performance or lines of code significantly. Here are some of them:</p>
<ul>
<li>I dropped <code>_</code> in names because it is easier to read.</li>
<li>I split long lines to make the code easier to read.</li>
<li>I reordered pieces of code for a more logical presentation order.</li>
</ul>
<h3 id="have-only-one-semantic-action-class"><span id="d2ab43bf941642b68c5af6af5937b17d"></span>Have only one semantic action class</h3>
<p>In the memoizing version, there are two semantic action classes:</p>
<pre class="text"><code>class _ConstantSemanticAction(object):

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

class _UserSemanticAction(object):

    def __init__(self, fn, scope):
        self.fn = fn
        self.scope = scope

    def eval(self):
        return self.fn(self.scope)</code></pre>
<p>I realized that this could be written more cleanly with only one class and the identity function being the default for the function:</p>
<pre class="text"><code>class SemanticAction(object):

    def __init__(self, value, fn=lambda value: value):
        self.value = value
        self.fn = fn

    def eval(self):
        return self.fn(self.value)</code></pre>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/31d01ad0db1bd1e76e51929f2b508601ed6caa4e">here</a>.</p>
<p>This change made RLMeta <strong>8 lines shorter</strong>.</p>
<h3 id="f769c882b84649bcac36fe7401ce73allow-unlimited-splice">[]{#49f769c882b84649bcac36fe7401ce73}Allow unlimited splice</h3>
<p>In the memoizing version, the splice operator inside lists (<code>~</code>) can only be used once.</p>
<p>I have written grammars where multiple splices were needed, so I have added support for it in a different version of RLMeta. I knew it would make the grammars a bit easier to read at the expense of a few more lines of code.</p>
<p>The full diff can seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/0d29337b8e21eb76a68708d2156c07bc42118fc1">here</a>.</p>
<p>This change made RLMeta <strong>6 lines longer</strong> but made the parser and codegenerator cleaner to read plus increasing flexibility.</p>
<p>This change also allowed the string matching to be removed since it was no longer used.</p>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/2bdd81fdf9eabcc30b29673c5eca760c0257a0fe">here</a> (ignoring the next change which is included in the diff).</p>
<p>This change made RLMeta <strong>10 lines shorter</strong>.</p>
<h3 id="c6116aa5449d691284a7fe3d36f9eredefine-matching-of-character-sequences">[]{#789c6116aa5449d691284a7fe3d36f9e}Redefine matching of character sequences</h3>
<p>In the memoizing version, the meaning of matching a character sequence is to match all characters and return that character sequence as a string. The following two rules are therefore identical:</p>
<pre class="text"><code>rule1 = &#39;hello&#39;
rule2 = &#39;h&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; -&gt; &quot;hello&quot;</code></pre>
<p>This requires a special VM instruction. I decided that I could instead just have it mean match all the characters in the sequence and return the last matched character. That is <code>rule2</code> without the semantic action added. When matching a sequence of characters, you always know what the result is, so most of the time you don't need the full sequence as a result anyway, and when you do, you know what it is.</p>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/2bdd81fdf9eabcc30b29673c5eca760c0257a0fe">here</a> (ignoring the previous change which is included in the diff).</p>
<p>This change made RLMeta <strong>1 line shorter</strong>. But more importantly, it made the VM a little cleaner.</p>
<h2 id="future-posters"><span id="b070abcd2f134cf894e33e63188a9fee"></span>Future posters</h2>
<p>The main feature of RLMeta is that you can easily extend it to be whatever you need it to be. The poster version or the base version should have the smallest subset of features just enough to support compiling itself. The smaller it is, the easier it is to understand and therefore extend. The more flexible it is to extend the better. If I make another poster version it would therefore focus on being smaller and more flexible. Since all successive version of RLMeta have been faster than the ones before, performance is also important. But small size, clarity, and flexibility come first.</p>
<p>Things that still annoy me with the poster version that I left:</p>
<ul>
<li>Assembly code in code generator is hard to read. I suspect it is because of all the different quotes. I'm not sure how to easily improve it at this moment.</li>
<li>The label counter is incremented at match time, not at semantic action evaluation time. This is really an incorrect behavior, but it will not lead to anything bad. It is just annoying. Labels should really be generated by semantic actions. I did not come up with an easy fix for this. But I have some ideas that I might try to implement in the future.</li>
<li>The compilation depends on Bash as well. I decided that it was okay because compilation can be done manually if it had to. It is not essential. It is more of a tool to put everything together for convenience. But it also contains crucial code which is the main function. So it's sort of glue that both compiles and has some code. It annoys me because it does not feel clean. But I don't have ideas right now how to improve it.</li>
</ul>
<h2 id="eea3f33b24e07b3714ef4c1981fd1code-listings-for-rlmeta">[]{#730eea3f33b24e07b3714ef4c1981fd1}Code listings for RLMeta</h2>
<p>The code here is exactly the same as on the poster. The <code>meta_compile.sh</code> script is not shown on the poster because it is not strictly part of the implementation. It is more of a developer tool.</p>
<h3 id="ce22f137e4a4bf3b4080f4803f3205dparser.rlmeta">[]{#9ce22f137e4a4bf3b4080f4803f3205d}parser.rlmeta</h3>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  grammar =
    | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space &#39;=&#39; choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space &#39;|&#39;)?
      sequence:x (space &#39;|&#39; sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space &#39;:&#39; name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space &#39;*&#39;                        -&gt; [&quot;Star&quot; x]
    | expr2:x space &#39;?&#39;                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space &#39;!&#39; expr2:x                        -&gt; [&quot;Not&quot; x]
    | space &#39;%&#39;                                -&gt; [&quot;MatchCallRule&quot;]
    | space &#39;#&#39;                                -&gt; [&quot;Label&quot;]
    | expr2
  expr2 =
    | space &#39;-&gt;&#39; hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space &#39;=&#39;)                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x &#39;-&#39; char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space charseq
    | space &#39;.&#39;                                -&gt; [&quot;MatchAny&quot;]
    | space &#39;(&#39; choice:x space &#39;)&#39;             -&gt; x
    | space &#39;[&#39; expr*:xs space &#39;]&#39;             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space &#39;[&#39; hostExprListItem*:xs space &#39;]&#39; -&gt; [&quot;List&quot; ~xs]
    | space &#39;{&#39; formatExpr*:xs space &#39;}&#39;       -&gt; [&quot;Format&quot; ~xs]
    | name:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space &#39;~&#39;*:ys hostExpr:x                 -&gt; [&quot;ListItem&quot; len(ys) x]
  formatExpr =
    | space &#39;&gt;&#39; formatExpr*:xs space &#39;&lt;&#39;       -&gt; [&quot;Indent&quot; [&quot;Format&quot; ~xs]]
    | hostExpr
  charseq   = &#39;\&#39;&#39; (!&#39;\&#39;&#39; matchChar)*:xs &#39;\&#39;&#39;  -&gt; [&quot;And&quot; ~xs]
  matchChar = innerChar:x                      -&gt; [&quot;MatchObject&quot; x]
  string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;   -&gt; { xs }
  char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39;  -&gt; x
  innerChar = &#39;\\&#39; escape | .
  escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
            | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; { x xs }
  nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
  nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;
  space     = (&#39; &#39; | &#39;\n&#39;)*
}</code></pre>
<h3 id="codegenerator.rlmeta"><span id="af73e151e4a847e98832b2460fd43cc1"></span>codegenerator.rlmeta</h3>
<pre><code>1.  codegenerator.rlmeta</code></pre>
<pre class="rlmeta"><code>CodeGenerator {
  ast            = [%:x]          -&gt; x
  Grammar        = .:x ast*:ys    -&gt; { &quot;class &quot; x &quot;(Grammar):\n\n&quot; &gt;
                                         &quot;def assemble(self, I, LABEL):\n&quot; &gt;
                                           ys
                                         &lt;
                                       &lt;                                    }
  Rule           = py:x ast:y     -&gt; { &quot;LABEL(&quot; x &quot;)\n&quot;
                                       y
                                       &quot;I(&#39;RETURN&#39;)\n&quot;                      }
  Or             =
    | ast:x Or:y #:a #:b          -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; a &quot;)\n&quot;
                                       x
                                       &quot;I(&#39;COMMIT&#39;, &quot; b &quot;)\n&quot;
                                       &quot;LABEL(&quot; a &quot;)\n&quot;
                                       y
                                       &quot;LABEL(&quot; b &quot;)\n&quot;                     }
    | ast
  Scope          = ast:x          -&gt; { &quot;I(&#39;PUSH_SCOPE&#39;)\n&quot;
                                       x
                                       &quot;I(&#39;POP_SCOPE&#39;)\n&quot;                   }
  And            = ast*
  Bind           = py:x ast:y     -&gt; { y
                                       &quot;I(&#39;BIND&#39;, &quot; x &quot;)\n&quot;                 }
  Star           = ast:x #:a #:b  -&gt; { &quot;I(&#39;LIST_START&#39;)\n&quot;
                                       &quot;LABEL(&quot; a &quot;)\n&quot;
                                       &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                                       x
                                       &quot;I(&#39;LIST_APPEND&#39;)\n&quot;
                                       &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                                       &quot;LABEL(&quot; b &quot;)\n&quot;
                                       &quot;I(&#39;LIST_END&#39;)\n&quot;                    }
  Not            = ast:x #:a #:b  -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                                       x
                                       &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                                       &quot;LABEL(&quot; a &quot;)\n&quot;
                                       &quot;I(&#39;FAIL&#39;, &#39;no match expected&#39;)\n&quot;
                                       &quot;LABEL(&quot; b &quot;)\n&quot;                     }
  MatchCallRule  =                -&gt; { &quot;I(&#39;MATCH_CALL_RULE&#39;)\n&quot;             }
  Label          =                -&gt; { &quot;I(&#39;LABEL&#39;)\n&quot;                       }
  SemanticAction = ast:x          -&gt; { &quot;I(&#39;ACTION&#39;, lambda scope: &quot; x &quot;)\n&quot; }
  MatchRule      = py:x           -&gt; { &quot;I(&#39;CALL&#39;, &quot; x &quot;)\n&quot;                 }
  MatchRange     = py:x py:y      -&gt; { &quot;I(&#39;MATCH_RANGE&#39;, &quot; x &quot;, &quot; y &quot;)\n&quot;   }
  MatchObject    = py:x           -&gt; { &quot;I(&#39;MATCH_OBJECT&#39;, &quot; x &quot;)\n&quot;         }
  MatchAny       =                -&gt; { &quot;I(&#39;MATCH_ANY&#39;)\n&quot;                   }
  MatchList      = ast:x          -&gt; { &quot;I(&#39;PUSH_STREAM&#39;)\n&quot;
                                       x
                                       &quot;I(&#39;POP_STREAM&#39;)\n&quot;                  }
  String         = py
  List           = astItems:x     -&gt; { &quot;concat([&quot; x &quot;])&quot;                    }
  ListItem       = py:x ast:y     -&gt; { &quot;splice(&quot; x &quot;, &quot; y &quot;)&quot;               }
  Format         = astItems:x     -&gt; { &quot;join([&quot; x &quot;])&quot;                      }
  Indent         = ast:x          -&gt; { &quot;indent(&quot; x &quot;)&quot;                      }
  FnCall         = .:x astItems:y -&gt; { x &quot;(&quot; y &quot;)&quot;                          }
  VarLookup      = py:x           -&gt; { &quot;scope[&quot; x &quot;].eval()&quot;                }
  astItems       =
    | ast:x astItem*:xs           -&gt; { x xs                                 }
    |                             -&gt; {                                      }
  astItem        = ast:x          -&gt; { &quot;, &quot; x                               }
  py             = .:x            -&gt; repr(x)
}</code></pre>
<h3 id="d15a72ff31485ea0204c8f79d3a641support.py">[]{#79d15a72ff31485ea0204c8f79d3a641}support.py</h3>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb20"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">def</span> vm(instructions, labels, start_rule, stream):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    label_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    action <span class="op">=</span> SemanticAction(<span class="va">None</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    pc <span class="op">=</span> labels[start_rule]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    stream, pos, stream_pos_stack <span class="op">=</span> (stream, <span class="dv">0</span>, [])</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    scope, scope_stack <span class="op">=</span> (<span class="va">None</span>, [])</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    fail_message <span class="op">=</span> <span class="va">None</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>    latest_fail_message, latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>    memo <span class="op">=</span> {}</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>        name, arg1, arg2 <span class="op">=</span> instructions[pc]</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>        <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;PUSH_SCOPE&quot;</span>:</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>            scope_stack.append(scope)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>            scope <span class="op">=</span> {}</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BACKTRACK&quot;</span>:</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>            call_backtrack_stack.append((</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>                labels[arg1], pos, <span class="bu">len</span>(stream_pos_stack), <span class="bu">len</span>(scope_stack)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>            ))</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;CALL&quot;</span>:</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>            key <span class="op">=</span> (arg1, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>            <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>                <span class="cf">if</span> memo[key][<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a>                    fail_message <span class="op">=</span> memo[key][<span class="dv">1</span>]</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a>                <span class="cf">else</span>:</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>                    action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a>                    stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a>                    stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a>                    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>                    <span class="cf">continue</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>                call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a>                pc <span class="op">=</span> labels[arg1]</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_SCOPE&quot;</span>:</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true"></a>            scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_OBJECT&quot;</span>:</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> stream[pos] <span class="op">!=</span> arg1:</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1)</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true"></a>                action <span class="op">=</span> SemanticAction(arg1)</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;COMMIT&quot;</span>:</span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true"></a>            call_backtrack_stack.pop()</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true"></a>            pc <span class="op">=</span> labels[arg1]</span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;RETURN&quot;</span>:</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_stack) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true"></a>                <span class="cf">return</span> action.<span class="bu">eval</span>()</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true"></a>            pc, key <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true"></a>            memo[key] <span class="op">=</span> (action, stream_pos_stack<span class="op">+</span>[(stream, pos)])</span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_APPEND&quot;</span>:</span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true"></a>            scope.append(action)</span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BIND&quot;</span>:</span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true"></a>            scope[arg1] <span class="op">=</span> action</span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;ACTION&quot;</span>:</span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true"></a>            action <span class="op">=</span> SemanticAction(scope, arg1)</span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_RANGE&quot;</span>:</span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> (arg1 <span class="op">&lt;=</span> stream[pos] <span class="op">&lt;=</span> arg2):</span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected range </span><span class="sc">{!r}</span><span class="st">-</span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1, arg2)</span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true"></a>                action <span class="op">=</span> SemanticAction(stream[pos])</span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_START&quot;</span>:</span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true"></a>            scope_stack.append(scope)</span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true"></a>            scope <span class="op">=</span> []</span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_END&quot;</span>:</span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true"></a>            action <span class="op">=</span> SemanticAction(scope, <span class="kw">lambda</span> xs: [x.<span class="bu">eval</span>() <span class="cf">for</span> x <span class="kw">in</span> xs])</span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true"></a>            scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_ANY&quot;</span>:</span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true"></a>                action <span class="op">=</span> SemanticAction(stream[pos])</span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;PUSH_STREAM&quot;</span>:</span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(stream[pos], <span class="bu">list</span>):</span>
<span id="cb20-101"><a href="#cb20-101" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected list&quot;</span>,)</span>
<span id="cb20-102"><a href="#cb20-102" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-103"><a href="#cb20-103" aria-hidden="true"></a>                stream_pos_stack.append((stream, pos))</span>
<span id="cb20-104"><a href="#cb20-104" aria-hidden="true"></a>                stream <span class="op">=</span> stream[pos]</span>
<span id="cb20-105"><a href="#cb20-105" aria-hidden="true"></a>                pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-106"><a href="#cb20-106" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-107"><a href="#cb20-107" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-108"><a href="#cb20-108" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_STREAM&quot;</span>:</span>
<span id="cb20-109"><a href="#cb20-109" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&lt;</span> <span class="bu">len</span>(stream):</span>
<span id="cb20-110"><a href="#cb20-110" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected end of list&quot;</span>,)</span>
<span id="cb20-111"><a href="#cb20-111" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-112"><a href="#cb20-112" aria-hidden="true"></a>                stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb20-113"><a href="#cb20-113" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-114"><a href="#cb20-114" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-115"><a href="#cb20-115" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-116"><a href="#cb20-116" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_CALL_RULE&quot;</span>:</span>
<span id="cb20-117"><a href="#cb20-117" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb20-118"><a href="#cb20-118" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb20-119"><a href="#cb20-119" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-120"><a href="#cb20-120" aria-hidden="true"></a>                fn_name <span class="op">=</span> <span class="bu">str</span>(stream[pos])</span>
<span id="cb20-121"><a href="#cb20-121" aria-hidden="true"></a>                key <span class="op">=</span> (fn_name, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb20-122"><a href="#cb20-122" aria-hidden="true"></a>                <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb20-123"><a href="#cb20-123" aria-hidden="true"></a>                    <span class="cf">if</span> memo[key][<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-124"><a href="#cb20-124" aria-hidden="true"></a>                        fail_message <span class="op">=</span> memo[key][<span class="dv">1</span>]</span>
<span id="cb20-125"><a href="#cb20-125" aria-hidden="true"></a>                    <span class="cf">else</span>:</span>
<span id="cb20-126"><a href="#cb20-126" aria-hidden="true"></a>                        action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb20-127"><a href="#cb20-127" aria-hidden="true"></a>                        stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb20-128"><a href="#cb20-128" aria-hidden="true"></a>                        stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb20-129"><a href="#cb20-129" aria-hidden="true"></a>                        pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-130"><a href="#cb20-130" aria-hidden="true"></a>                        <span class="cf">continue</span></span>
<span id="cb20-131"><a href="#cb20-131" aria-hidden="true"></a>                <span class="cf">else</span>:</span>
<span id="cb20-132"><a href="#cb20-132" aria-hidden="true"></a>                    call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb20-133"><a href="#cb20-133" aria-hidden="true"></a>                    pc <span class="op">=</span> labels[fn_name]</span>
<span id="cb20-134"><a href="#cb20-134" aria-hidden="true"></a>                    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-135"><a href="#cb20-135" aria-hidden="true"></a>                    <span class="cf">continue</span></span>
<span id="cb20-136"><a href="#cb20-136" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;FAIL&quot;</span>:</span>
<span id="cb20-137"><a href="#cb20-137" aria-hidden="true"></a>            fail_message <span class="op">=</span> (arg1,)</span>
<span id="cb20-138"><a href="#cb20-138" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LABEL&quot;</span>:</span>
<span id="cb20-139"><a href="#cb20-139" aria-hidden="true"></a>            action <span class="op">=</span> SemanticAction(label_counter)</span>
<span id="cb20-140"><a href="#cb20-140" aria-hidden="true"></a>            label_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-141"><a href="#cb20-141" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-142"><a href="#cb20-142" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-143"><a href="#cb20-143" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb20-144"><a href="#cb20-144" aria-hidden="true"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&quot;unknown instruction </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(name))</span>
<span id="cb20-145"><a href="#cb20-145" aria-hidden="true"></a>        fail_pos <span class="op">=</span> <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos])</span>
<span id="cb20-146"><a href="#cb20-146" aria-hidden="true"></a>        <span class="cf">if</span> fail_pos <span class="op">&gt;=</span> latest_fail_pos:</span>
<span id="cb20-147"><a href="#cb20-147" aria-hidden="true"></a>            latest_fail_message <span class="op">=</span> fail_message</span>
<span id="cb20-148"><a href="#cb20-148" aria-hidden="true"></a>            latest_fail_pos <span class="op">=</span> fail_pos</span>
<span id="cb20-149"><a href="#cb20-149" aria-hidden="true"></a>        call_backtrack_entry <span class="op">=</span> <span class="bu">tuple</span>()</span>
<span id="cb20-150"><a href="#cb20-150" aria-hidden="true"></a>        <span class="cf">while</span> call_backtrack_stack:</span>
<span id="cb20-151"><a href="#cb20-151" aria-hidden="true"></a>            call_backtrack_entry <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb20-152"><a href="#cb20-152" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb20-153"><a href="#cb20-153" aria-hidden="true"></a>                <span class="cf">break</span></span>
<span id="cb20-154"><a href="#cb20-154" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-155"><a href="#cb20-155" aria-hidden="true"></a>                _, key <span class="op">=</span> call_backtrack_entry</span>
<span id="cb20-156"><a href="#cb20-156" aria-hidden="true"></a>                memo[key] <span class="op">=</span> (<span class="va">None</span>, fail_message)</span>
<span id="cb20-157"><a href="#cb20-157" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb20-158"><a href="#cb20-158" aria-hidden="true"></a>            <span class="cf">raise</span> MatchError(</span>
<span id="cb20-159"><a href="#cb20-159" aria-hidden="true"></a>                latest_fail_message[<span class="dv">0</span>].<span class="bu">format</span>(<span class="op">*</span>latest_fail_message[<span class="dv">1</span>:]),</span>
<span id="cb20-160"><a href="#cb20-160" aria-hidden="true"></a>                latest_fail_pos,</span>
<span id="cb20-161"><a href="#cb20-161" aria-hidden="true"></a>                stream_pos_stack[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> stream_pos_stack <span class="cf">else</span> stream</span>
<span id="cb20-162"><a href="#cb20-162" aria-hidden="true"></a>            )</span>
<span id="cb20-163"><a href="#cb20-163" aria-hidden="true"></a>        (pc, pos, stream_stack_len, scope_stack_len) <span class="op">=</span> call_backtrack_entry</span>
<span id="cb20-164"><a href="#cb20-164" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(stream_pos_stack) <span class="op">&gt;</span> stream_stack_len:</span>
<span id="cb20-165"><a href="#cb20-165" aria-hidden="true"></a>            stream <span class="op">=</span> stream_pos_stack[stream_stack_len][<span class="dv">0</span>]</span>
<span id="cb20-166"><a href="#cb20-166" aria-hidden="true"></a>        stream_pos_stack <span class="op">=</span> stream_pos_stack[:stream_stack_len]</span>
<span id="cb20-167"><a href="#cb20-167" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(scope_stack) <span class="op">&gt;</span> scope_stack_len:</span>
<span id="cb20-168"><a href="#cb20-168" aria-hidden="true"></a>            scope <span class="op">=</span> scope_stack[scope_stack_len]</span>
<span id="cb20-169"><a href="#cb20-169" aria-hidden="true"></a>        scope_stack <span class="op">=</span> scope_stack[:scope_stack_len]</span>
<span id="cb20-170"><a href="#cb20-170" aria-hidden="true"></a></span>
<span id="cb20-171"><a href="#cb20-171" aria-hidden="true"></a><span class="kw">class</span> SemanticAction(<span class="bu">object</span>):</span>
<span id="cb20-172"><a href="#cb20-172" aria-hidden="true"></a></span>
<span id="cb20-173"><a href="#cb20-173" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, fn<span class="op">=</span><span class="kw">lambda</span> value: value):</span>
<span id="cb20-174"><a href="#cb20-174" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb20-175"><a href="#cb20-175" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb20-176"><a href="#cb20-176" aria-hidden="true"></a></span>
<span id="cb20-177"><a href="#cb20-177" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb20-178"><a href="#cb20-178" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn(<span class="va">self</span>.value)</span>
<span id="cb20-179"><a href="#cb20-179" aria-hidden="true"></a></span>
<span id="cb20-180"><a href="#cb20-180" aria-hidden="true"></a><span class="kw">class</span> MatchError(<span class="pp">Exception</span>):</span>
<span id="cb20-181"><a href="#cb20-181" aria-hidden="true"></a></span>
<span id="cb20-182"><a href="#cb20-182" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, message, pos, stream):</span>
<span id="cb20-183"><a href="#cb20-183" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb20-184"><a href="#cb20-184" aria-hidden="true"></a>        <span class="va">self</span>.message <span class="op">=</span> message</span>
<span id="cb20-185"><a href="#cb20-185" aria-hidden="true"></a>        <span class="va">self</span>.pos <span class="op">=</span> pos</span>
<span id="cb20-186"><a href="#cb20-186" aria-hidden="true"></a>        <span class="va">self</span>.stream <span class="op">=</span> stream</span>
<span id="cb20-187"><a href="#cb20-187" aria-hidden="true"></a></span>
<span id="cb20-188"><a href="#cb20-188" aria-hidden="true"></a><span class="kw">class</span> Grammar(<span class="bu">object</span>):</span>
<span id="cb20-189"><a href="#cb20-189" aria-hidden="true"></a></span>
<span id="cb20-190"><a href="#cb20-190" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule_name, stream):</span>
<span id="cb20-191"><a href="#cb20-191" aria-hidden="true"></a>        instructions <span class="op">=</span> []</span>
<span id="cb20-192"><a href="#cb20-192" aria-hidden="true"></a>        labels <span class="op">=</span> {}</span>
<span id="cb20-193"><a href="#cb20-193" aria-hidden="true"></a>        <span class="kw">def</span> I(name, arg1<span class="op">=</span><span class="va">None</span>, arg2<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb20-194"><a href="#cb20-194" aria-hidden="true"></a>            instructions.append((name, arg1, arg2))</span>
<span id="cb20-195"><a href="#cb20-195" aria-hidden="true"></a>        <span class="kw">def</span> LABEL(name):</span>
<span id="cb20-196"><a href="#cb20-196" aria-hidden="true"></a>            labels[name] <span class="op">=</span> <span class="bu">len</span>(instructions)</span>
<span id="cb20-197"><a href="#cb20-197" aria-hidden="true"></a>        <span class="va">self</span>.assemble(I, LABEL)</span>
<span id="cb20-198"><a href="#cb20-198" aria-hidden="true"></a>        <span class="cf">return</span> vm(instructions, labels, rule_name, stream)</span>
<span id="cb20-199"><a href="#cb20-199" aria-hidden="true"></a></span>
<span id="cb20-200"><a href="#cb20-200" aria-hidden="true"></a><span class="kw">def</span> splice(depth, item):</span>
<span id="cb20-201"><a href="#cb20-201" aria-hidden="true"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-202"><a href="#cb20-202" aria-hidden="true"></a>        <span class="cf">return</span> [item]</span>
<span id="cb20-203"><a href="#cb20-203" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb20-204"><a href="#cb20-204" aria-hidden="true"></a>        <span class="cf">return</span> concat([splice(depth<span class="op">-</span><span class="dv">1</span>, subitem) <span class="cf">for</span> subitem <span class="kw">in</span> item])</span>
<span id="cb20-205"><a href="#cb20-205" aria-hidden="true"></a></span>
<span id="cb20-206"><a href="#cb20-206" aria-hidden="true"></a><span class="kw">def</span> concat(lists):</span>
<span id="cb20-207"><a href="#cb20-207" aria-hidden="true"></a>    <span class="cf">return</span> [x <span class="cf">for</span> xs <span class="kw">in</span> lists <span class="cf">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb20-208"><a href="#cb20-208" aria-hidden="true"></a></span>
<span id="cb20-209"><a href="#cb20-209" aria-hidden="true"></a><span class="kw">def</span> join(items):</span>
<span id="cb20-210"><a href="#cb20-210" aria-hidden="true"></a>    <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join(</span>
<span id="cb20-211"><a href="#cb20-211" aria-hidden="true"></a>        join(item) <span class="cf">if</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>) <span class="cf">else</span> <span class="bu">str</span>(item)</span>
<span id="cb20-212"><a href="#cb20-212" aria-hidden="true"></a>        <span class="cf">for</span> item <span class="kw">in</span> items</span>
<span id="cb20-213"><a href="#cb20-213" aria-hidden="true"></a>    )</span>
<span id="cb20-214"><a href="#cb20-214" aria-hidden="true"></a></span>
<span id="cb20-215"><a href="#cb20-215" aria-hidden="true"></a><span class="kw">def</span> indent(text):</span>
<span id="cb20-216"><a href="#cb20-216" aria-hidden="true"></a>    <span class="cf">return</span> join(join([<span class="st">&quot;    &quot;</span>, line]) <span class="cf">for</span> line <span class="kw">in</span> text.splitlines(<span class="va">True</span>))</span></code></pre></div>
<h3 id="a9c9c93e4aa2aaf35c7962eb3c88compile.sh">[]{#7142a9c9c93e4aa2aaf35c7962eb3c88}compile.sh</h3>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">&#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>import sys</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a>import pprint</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>SUPPORT = <span class="va">$support_py_string</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true"></a></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true"></a>if __name__ == &quot;__main__&quot;:</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true"></a>    if &quot;--support&quot; in sys.argv:</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true"></a>        sys.stdout.write(SUPPORT)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true"></a>    else:</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true"></a>        try:</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true"></a>            sys.stdout.write(</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true"></a>                CodeGenerator().run(</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true"></a>                    &quot;ast&quot;,</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true"></a>                    [Parser().run(&quot;grammar&quot;, sys.stdin.read())]</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true"></a>                )</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true"></a>            )</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true"></a>        except MatchError as e:</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true"></a>            stream = e.stream</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true"></a>            for pos in e.pos[:-1]:</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true"></a>                stream = stream[pos]</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true"></a>            pos = e.pos[-1]</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true"></a>            MARKER = &quot;<span class="dt">\\</span>033[0;31m&lt;ERROR POSITION&gt;<span class="dt">\\</span>033[0m&quot;</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true"></a>            if isinstance(stream, basestring):</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true"></a>                stream_string = stream[:pos] + MARKER + stream[pos:]</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true"></a>            else:</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true"></a>                stream_string = pprint.pformat(stream)</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true"></a>            sys.exit(&quot;ERROR: {}<span class="dt">\\</span>nPOSITION: {}<span class="dt">\\</span>nSTREAM:<span class="dt">\\</span>n{}&quot;.format(</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true"></a>              e.message,</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true"></a>              pos,</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true"></a>              indent(stream_string)</span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true"></a>            ))</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<h3 id="c47ff964a3f43a29a4413bbf5b0132dmeta_compile.sh">[]{#8c47ff964a3f43a29a4413bbf5b0132d}meta_compile.sh</h3>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Test: Reproduces itself&quot;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Test: Has its own support library embedded&quot;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Test: Error reporting string input&quot;</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Grammar { foo = . &quot;</span> <span class="kw">|</span> <span class="ex">python</span> rlmeta3.py <span class="kw">&amp;&amp;</span> <span class="fu">false</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;OK&quot;</span></span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>Memoizing failures in RLMeta</title>
    <link href="http://rickardlindberg.me/writing/rlmeta-memoize-failures/" />
    <id>http://rickardlindberg.me/writing/rlmeta-memoize-failures/</id>
    <published>2020-01-11T00:00:00Z</published>
    <updated>2020-01-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Memoizing failures in RLMeta</h1>

<p><em>Published on 11 January 2020.</em></p>

<p>After reading <a href="https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9">Generating a PEG Parser</a> I realized that RLMeta has a flaw in its its memoization logic: It only memoizes results when a rule matches. If a rule fails, it is not recorded in the memoization table. Therefore, if that rule is tried again at the same position, matching has to be tried again, even though it will fail. In the article, Guido writes</p>
<blockquote>
<p>It is important to cache negative results too - in fact most calls to parsing methods will be negative results.</p>
</blockquote>
<p>Besides fixing the flaw in the memoization logic, I am also interested in seeing how it affects performance.</p>
<p>In this article I show how to fix the memoization logic in both the <a href="/writing/optimizing-rlmeta/index.html">optimized version</a> and the <a href="/writing/rlmeta-vm/index.html">vm based version</a> and show how performance is affected.</p>
<ul>
<li><a href="#a9a4166e943a4d2c974c443cef1da5a9">Optimized version</a></li>
<li><a href="#fe17638693e344ad9e521e55bf0676f3">VM based version</a></li>
<li><a href="#42ae6babf74d427880f831bd14109002">Performance measurements</a></li>
<li><a href="#042d4832e92c48349da9e4fe0a73f955">Appendix</a>
<ul>
<li><a href="#ea9e60e51c034b99b32520af593fa2c0">Support library (optimized)</a></li>
<li><a href="#46ac5a5f243c4bd69cec58758e92eadd">Support library (VM)</a></li>
</ul></li>
</ul>
<h2 id="optimized-version"><span id="a9a4166e943a4d2c974c443cef1da5a9"></span>Optimized version</h2>
<p>In the optimized version, the memoization table stores tuples with result, start position, and end position. If a rule fails, a new kind of value that indicates a failure must be stored. We reuse the same tuple, but have the result be <code>None</code> in case of a failure and have the start position be the lazy fail message.</p>
<p>The memoization table is both queried and populated in the support library method <code>_match_rule</code>. The fixed version looks like this:</p>
<pre><code>1.  optimized
2.  support.py
3.  [match rule]{.cp}</code></pre>
<pre><code>def _match_rule(self, rule_name):
    key = (rule_name, self._stream.position())
    if key in self._memo:
        if self._memo[key][0] is None:
            self._stream.fail(self._memo[key][1])
        else:
            result, _, self._stream = self._memo[key]
    else:
        try:
            start = self._stream
            result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
            end = self._stream
            self._memo[key] = (result, start, end)
        except _MatchError as e:
            self._memo[key] = (None, e.lazy_message, None)
            raise
    return result</code></pre>
<p>If a memoization entry exists and the result part is <code>None</code>, the match fails immediately with the fail message stored in the entry. If the result part is not <code>None</code> the result is used as before.</p>
<p>If a memoization entry does not exist and the match fails, the failure is recorded in the memoization table before propagating the exception. If the match succeeds the result is recorded as before.</p>
<p>The <code>_MatchError</code> class is also modified to save the lazy message so that it can be accessed for storage in the memoization table:</p>
<pre><code>1.  optimized
2.  support.py
3.  [memo fail]{.cp}</code></pre>
<pre><code>def fail(self, stream, lazy_message):
    if stream.position() &gt;= self._latest_stream.position():
        self._latest_stream = stream
        self._latest_lazy_message = lazy_message
    raise _MatchError(self, lazy_message)</code></pre>
<pre><code>1.  optimized
2.  support.py
3.  [match error]{.cp}</code></pre>
<pre><code>class _MatchError(Exception):

    def __init__(self, memo, lazy_message):
        Exception.__init__(self)
        self._memo = memo
        self.lazy_message = lazy_message

    def describe(self):
        return self._memo.describe()</code></pre>
<h2 id="vm-based-version"><span id="fe17638693e344ad9e521e55bf0676f3"></span>VM based version</h2>
<p>In the VM based version, the memoization table stores tuples with last action, and stream position stack. If a rule fails, a new kind of value that indicates a failure must be stored. We reuse the same tuple, but have the last action be <code>None</code> in case of a failure and have the stream position stack be the failure message.</p>
<p>The memoization table is queried and populated in different places. The first place it's populated is in the <code>RETURN</code> instruction:</p>
<pre><code>1.  vm
2.  support.py
3.  [RETURN]{.cp}</code></pre>
<pre><code>if len(call_backtrack_stack) == 0:
    return last_action.eval()
pc, key = call_backtrack_stack.pop()
memo[key] = (last_action, stream_pos_stack+[(stream, pos)])
continue</code></pre>
<p>This code is unchanged and I include it here only for context. It populates the memoization table when a rule has matched. To populate the memoization table with a failure, the code that pops a backtrack entry must be modified like this:</p>
<pre><code>1.  vm
2.  support.py
3.  [pop backtrack entry]{.cp}</code></pre>
<pre><code>call_backtrack_entry = tuple()
while call_backtrack_stack:
    call_backtrack_entry = call_backtrack_stack.pop()
    if len(call_backtrack_entry) == 4:
        break
    else:
        _, key = call_backtrack_entry
        memo[key] = (None, fail_message)</code></pre>
<p>If the popped item is not a backtrack entry (length of tuple is 4), it must be a call entry. It means that the given rule has been called, and it has failed. In that case, <code>None</code> is stored in the memoization table to indicate a failure, along with the fail message as second element.</p>
<p>Next code that queries the memoization table need to be updated. It happens in the two call instructions <code>CALL</code> and <code>MATCH_CALL_RULE</code>:</p>
<pre><code>1.  vm
2.  support.py
3.  [CALL]{.cp}</code></pre>
<pre><code>key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))
if key in memo:
    if memo[key][0] is None:
        fail_message = memo[key][1]
    else:
        last_action, stream_pos_stack = memo[key]
        stream_pos_stack = stream_pos_stack[:]
        stream, pos = stream_pos_stack.pop()
        pc += 1
        continue
else:
    call_backtrack_stack.append((pc+1, key))
    pc = labels[arg1]
    continue</code></pre>
<pre><code>1.  vm
2.  support.py
3.  [MATCH\_CALL\_RULE]{.cp}</code></pre>
<pre><code>if pos &gt;= len(stream):
    fail_message = (&quot;expected any&quot;,)
else:
    fn_name = str(stream[pos])
    key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))
    if key in memo:
        if memo[key][0] is None:
            fail_message = memo[key][1]
        else:
            last_action, stream_pos_stack = memo[key]
            stream_pos_stack = stream_pos_stack[:]
            stream, pos = stream_pos_stack.pop()
            pc += 1
            continue
    else:
        call_backtrack_stack.append((pc+1, key))
        pc = labels[fn_name]
        pos += 1
        continue</code></pre>
<p>They are changed to look at the first argument in the memoized entry. If it is <code>None</code>, it indicates a failure. The <code>fail_message</code> is then set and the <code>continue</code> statement is skipped:</p>
<h2 id="ae6babf74d427880f831bd14109002performance-measurements">[]{#42ae6babf74d427880f831bd14109002}Performance measurements</h2>
<p>Are the versions that also memoize failures faster? Here are the performance measurements:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
Performance measurements.
</center>
<p>To measure the performance without memoization I commented out the code that populates the memoization table.</p>
<p>Memoizing failures seems to be much less important than memoizing matches. But it still improves performance.</p>
<h2 id="d4832e92c48349da9e4fe0a73f955appendix">[]{#042d4832e92c48349da9e4fe0a73f955}Appendix</h2>
<h3 id="support-library-optimized"><span id="ea9e60e51c034b99b32520af593fa2c0"></span>Support library (optimized)</h3>
<p>The rest of the support library for the optimized version:</p>
<pre><code>1.  optimized
2.  support.py</code></pre>
<pre><code>try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

class _Grammar(object):

    def _or(self, matchers):
        original_stream = self._stream
        for matcher in matchers[:-1]:
            try:
                return matcher()
            except _MatchError:
                self._stream = original_stream
        return matchers[-1]()

    def _and(self, matchers):
        result = None
        for matcher in matchers:
            result = matcher()
        return result

    def _star(self, matcher):
        result = []
        while True:
            original_stream = self._stream
            try:
                result.append(matcher())
            except _MatchError:
                self._stream = original_stream
                return _SemanticAction(lambda: [x.eval() for x in result])

    def _not(self, matcher):
        original_stream = self._stream
        try:
            matcher()
        except _MatchError:
            return _SemanticAction(lambda: None)
        else:
            original_stream.fail(lambda: &quot;match found&quot;)
        finally:
            self._stream = original_stream

    &lt;&lt;match rule&gt;&gt;

    def _match_range(self, start, end):
        next_objext = self._stream.peek()
        if next_objext &gt;= start and next_objext &lt;= end:
            self._stream = self._stream.advance()
            return _SemanticAction(lambda: next_objext)
        else:
            self._stream.fail(
                lambda: &quot;expected range {!r}-{!r} but found {!r}&quot;.format(start, end, next_objext)
            )

    def _match_string(self, string):
        next_object = self._stream.peek()
        if next_object == string:
            self._stream = self._stream.advance()
            return _SemanticAction(lambda: string)
        else:
            self._stream.fail(
                lambda: &quot;expected {!r} but found {!r}&quot;.format(string, next_object)
            )

    def _match_charseq(self, charseq):
        for char in charseq:
            next_object = self._stream.peek()
            if next_object != char:
                self._stream.fail(
                    lambda: &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
                )
            self._stream = self._stream.advance()
        return _SemanticAction(lambda: charseq)

    def _match_any(self):
        next_object = self._stream.peek()
        self._stream = self._stream.advance()
        return _SemanticAction(lambda: next_object)

    def _match_call_rule(self):
        next_object = self._stream.peek()
        self._stream = self._stream.advance()
        return self._match_rule(str(next_object))

    def _match_list(self, matcher):
        original_stream = self._stream
        next_object = self._stream.peek()
        if isinstance(next_object, list):
            self._stream = self._stream.nested(next_object)
            matcher()
            if self._stream.is_at_end():
                self._stream = original_stream.advance()
                return _SemanticAction(lambda: next_object)
        original_stream.fail(lambda: &quot;list match failed&quot;)

    def run(self, rule_name, input_object):
        self._memo = _Memo()
        self._stream = _Stream.from_object(self._memo, input_object)
        result = self._match_rule(rule_name).eval()
        if isinstance(result, _Builder):
            return result.build_string()
        else:
            return result

class _Vars(dict):

    def bind(self, name, value):
        self[name] = value
        return value

    def lookup(self, name):
        return self[name]

class _SemanticAction(object):

    def __init__(self, fn):
        self.fn = fn

    def eval(self):
        return self.fn()

class _Builder(object):

    def build_string(self):
        output = _Output()
        self.write(output)
        return output.value

    @classmethod
    def create(self, item):
        if isinstance(item, _Builder):
            return item
        elif isinstance(item, list):
            return _ListBuilder([_Builder.create(x) for x in item])
        else:
            return _AtomBuilder(item)

class _Output(object):

    def __init__(self):
        self.buffer = StringIO()
        self.indentation = 0
        self.on_newline = True

    @property
    def value(self):
        return self.buffer.getvalue()

    def write(self, value):
        for ch in value:
            is_linebreak = ch == &quot;\n&quot;
            if self.indentation and self.on_newline and not is_linebreak:
                self.buffer.write(&quot;    &quot;*self.indentation)
            self.buffer.write(ch)
            self.on_newline = is_linebreak

class _ListBuilder(_Builder):

    def __init__(self, builders):
        self.builders = builders

    def write(self, output):
        for builder in self.builders:
            builder.write(output)

class _AtomBuilder(_Builder):

    def __init__(self, atom):
        self.atom = atom

    def write(self, output):
        output.write(str(self.atom))

class _IndentBuilder(_Builder):

    def write(self, output):
        output.indentation += 1

class _DedentBuilder(_Builder):

    def write(self, output):
        output.indentation -= 1

class _Memo(dict):

    def __init__(self):
        dict.__init__(self)
        self._latest_stream = _ObjectStream(self, [], -1)
        self._latest_lazy_message = lambda: &quot;&quot;

    def describe(self):
        items = []
        for (rule_name, _), (_, start, end) in self.items():
            if end &gt; start:
                items.append((rule_name, start, end))
        items.sort(key=lambda item: (item[2].position(), item[1].position()))
        message = []
        for item in items:
            message.append(&quot;matched {: &lt;20} {} -&gt; {}\n&quot;.format(*item))
        message.append(&quot;\n&quot;)
        message.append(&quot;ERROR: {}: {}\n&quot;.format(
            self._latest_stream,
            self._latest_lazy_message()
        ))
        return &quot;&quot;.join(message)

    &lt;&lt;memo fail&gt;&gt;

&lt;&lt;match error&gt;&gt;

class _Stream(object):

    @classmethod
    def from_object(cls, memo, input_object):
        if isinstance(input_object, basestring):
            return _CharStream(memo, input_object, 0)
        else:
            return _ObjectStream(memo, [input_object], 0)

    def __init__(self, memo, objects, index):
        self._memo = memo
        self._objects = objects
        self._index = index

    def fail(self, lazy_message):
        self._memo.fail(self, lazy_message)

    def peek(self):
        if self.is_at_end():
            self.fail(lambda: &quot;not eof&quot;)
        return self._objects[self._index]

    def is_at_end(self):
        return self._index &gt;= len(self._objects)

class _CharStream(_Stream):

    def __init__(self, memo, objects, index, line=1, column=1):
        _Stream.__init__(self, memo, objects, index)
        self._line = line
        self._column = column

    def position(self):
        return self._index

    def advance(self):
        if self._objects[self._index] == &quot;\n&quot;:
            line = self._line + 1
            column = 1
        else:
            line = self._line
            column = self._column + 1
        return _CharStream(self._memo, self._objects, self._index+1, line, column)

    def __str__(self):
        return &quot;L{:03d}:C{:03d}&quot;.format(self._line, self._column)

class _ObjectStream(_Stream):

    def __init__(self, memo, objects, index, parent=()):
        _Stream.__init__(self, memo, objects, index)
        self._parent_position = parent
        self._position = self._parent_position + (self._index,)

    def position(self):
        return self._position

    def nested(self, input_object):
        return _ObjectStream(self._memo, input_object, 0, self._position)

    def advance(self):
        return _ObjectStream(self._memo, self._objects, self._index+1, self._parent_position)

    def __str__(self):
        return &quot;[{}]&quot;.format(&quot;, &quot;.join(str(x) for x in self.position()))</code></pre>
<h3 id="ac5a5f243c4bd69cec58758e92eaddsupport-library-vm">[]{#46ac5a5f243c4bd69cec58758e92eadd}Support library (VM)</h3>
<p>The rest of the support library for the VM based version:</p>
<pre><code>1.  vm
2.  support.py</code></pre>
<pre><code>try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

def rlmeta_vm(instructions, labels, start_rule, stream):
    label_counter = 0
    last_action = _ConstantSemanticAction(None)
    pc = labels[start_rule]
    call_backtrack_stack = []
    stream, pos, stream_pos_stack = (stream, 0, [])
    scope, scope_stack = (None, [])
    fail_message = None
    latest_fail_message, latest_fail_pos = (None, tuple())
    memo = {}
    while True:
        name, arg1, arg2 = instructions[pc]
        if name == &quot;PUSH_SCOPE&quot;:
            scope_stack.append(scope)
            scope = {}
            pc += 1
            continue
        elif name == &quot;BACKTRACK&quot;:
            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))
            pc += 1
            continue
        elif name == &quot;CALL&quot;:
            &lt;&lt;CALL&gt;&gt;
        elif name == &quot;MATCH_CHARSEQ&quot;:
            for char in arg1:
                if pos &gt;= len(stream) or stream[pos] != char:
                    fail_message = (&quot;expected {!r}&quot;, char)
                    break
                pos += 1
            else:
                last_action = _ConstantSemanticAction(arg1)
                pc += 1
                continue
        elif name == &quot;COMMIT&quot;:
            call_backtrack_stack.pop()
            pc = labels[arg1]
            continue
        elif name == &quot;POP_SCOPE&quot;:
            scope = scope_stack.pop()
            pc += 1
            continue
        elif name == &quot;RETURN&quot;:
            &lt;&lt;RETURN&gt;&gt;
        elif name == &quot;LIST_APPEND&quot;:
            scope.append(last_action)
            pc += 1
            continue
        elif name == &quot;BIND&quot;:
            scope[arg1] = last_action
            pc += 1
            continue
        elif name == &quot;ACTION&quot;:
            last_action = _UserSemanticAction(arg1, scope)
            pc += 1
            continue
        elif name == &quot;MATCH_RANGE&quot;:
            if pos &gt;= len(stream) or not (arg1 &lt;= stream[pos] &lt;= arg2):
                fail_message = (&quot;expected range {!r}-{!r}&quot;, arg1, arg2)
            else:
                last_action = _ConstantSemanticAction(stream[pos])
                pos += 1
                pc += 1
                continue
        elif name == &quot;LIST_START&quot;:
            scope_stack.append(scope)
            scope = []
            pc += 1
            continue
        elif name == &quot;LIST_END&quot;:
            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)
            scope = scope_stack.pop()
            pc += 1
            continue
        elif name == &quot;MATCH_ANY&quot;:
            if pos &gt;= len(stream):
                fail_message = (&quot;expected any&quot;,)
            else:
                last_action = _ConstantSemanticAction(stream[pos])
                pos += 1
                pc += 1
                continue
        elif name == &quot;PUSH_STREAM&quot;:
            if pos &gt;= len(stream) or not isinstance(stream[pos], list):
                fail_message = (&quot;expected list&quot;,)
            else:
                stream_pos_stack.append((stream, pos))
                stream = stream[pos]
                pos = 0
                pc += 1
                continue
        elif name == &quot;POP_STREAM&quot;:
            if pos &lt; len(stream):
                fail_message = (&quot;expected end of list&quot;,)
            else:
                stream, pos = stream_pos_stack.pop()
                pos += 1
                pc += 1
                continue
        elif name == &quot;MATCH_CALL_RULE&quot;:
            &lt;&lt;MATCH_CALL_RULE&gt;&gt;
        elif name == &quot;FAIL&quot;:
            fail_message = (arg1,)
        elif name == &quot;LABEL&quot;:
            last_action = _ConstantSemanticAction(label_counter)
            label_counter += 1
            pc += 1
            continue
        elif name == &quot;MATCH_STRING&quot;:
            if pos &gt;= len(stream) or stream[pos] != arg1:
                fail_message = (&quot;expected {!r}&quot;, arg1)
            else:
                last_action = _ConstantSemanticAction(arg1)
                pos += 1
                pc += 1
                continue
        else:
            raise Exception(&quot;unknown instruction {}&quot;.format(name))
        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])
        if fail_pos &gt;= latest_fail_pos:
            latest_fail_message = fail_message
            latest_fail_pos = fail_pos
        &lt;&lt;pop backtrack entry&gt;&gt;
        if len(call_backtrack_entry) != 4:
            fail_pos = list(latest_fail_pos)
            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream
            while len(fail_pos) &gt; 1:
                fail_stream = fail_stream[fail_pos.pop(0)]
            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)
        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry
        if len(stream_pos_stack) &gt; stream_stack_len:
            stream = stream_pos_stack[stream_stack_len][0]
        stream_pos_stack = stream_pos_stack[:stream_stack_len]
        if len(scope_stack) &gt; scope_stack_len:
            scope = scope_stack[scope_stack_len]
        scope_stack = scope_stack[:scope_stack_len]

class _Grammar(object):

    def run(self, rule_name, input_object):
        if isinstance(input_object, basestring):
            stream = input_object
        else:
            stream = [input_object]
        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)
        if isinstance(result, _Builder):
            return result.build_string()
        else:
            return result

class _Builder(object):

    def build_string(self):
        output = _Output()
        self.write(output)
        return output.value

    @classmethod
    def create(self, item):
        if isinstance(item, _Builder):
            return item
        elif isinstance(item, list):
            return _ListBuilder([_Builder.create(x) for x in item])
        else:
            return _AtomBuilder(item)

class _Output(object):

    def __init__(self):
        self.buffer = StringIO()
        self.indentation = 0
        self.on_newline = True

    @property
    def value(self):
        return self.buffer.getvalue()

    def write(self, value):
        for ch in value:
            is_linebreak = ch == &quot;\n&quot;
            if self.indentation and self.on_newline and not is_linebreak:
                self.buffer.write(&quot;    &quot;*self.indentation)
            self.buffer.write(ch)
            self.on_newline = is_linebreak

class _ListBuilder(_Builder):

    def __init__(self, builders):
        self.builders = builders

    def write(self, output):
        for builder in self.builders:
            builder.write(output)

class _AtomBuilder(_Builder):

    def __init__(self, atom):
        self.atom = atom

    def write(self, output):
        output.write(str(self.atom))

class _IndentBuilder(_Builder):

    def write(self, output):
        output.indentation += 1

class _DedentBuilder(_Builder):

    def write(self, output):
        output.indentation -= 1

class _ConstantSemanticAction(object):

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

class _UserSemanticAction(object):

    def __init__(self, fn, scope):
        self.fn = fn
        self.scope = scope

    def eval(self):
        return self.fn(self.scope)

class _MatchError(Exception):

    def __init__(self, message, pos, stream):
        Exception.__init__(self)
        self.message = message
        self.pos = pos
        self.stream = stream

    def describe(self):
        message = &quot;&quot;
        if isinstance(self.stream, basestring):
            before = self.stream[:self.pos].splitlines()
            after = self.stream[self.pos:].splitlines()
            for context_before in before[-4:-1]:
                message += self._context(context_before)
            message += self._context(before[-1], after[0])
            message += self._arrow(len(before[-1]))
            for context_after in after[1:4]:
                message += self._context(context_after)
        else:
            message += self._context(&quot;[&quot;)
            for context_before in self.stream[:self.pos]:
                message += self._context(&quot;  &quot;, repr(context_before), &quot;,&quot;)
            message += self._context(&quot;  &quot;, repr(self.stream[self.pos]), &quot;,&quot;)
            message += self._arrow(2)
            for context_after in self.stream[self.pos+1:]:
                message += self._context(&quot;  &quot;, repr(context_after), &quot;,&quot;)
            message += self._context(&quot;]&quot;)
        message += &quot;Error: &quot;
        message += self.message[0].format(*self.message[1:])
        message += &quot;\n&quot;
        return message

    def _context(self, *args):
        return &quot;&gt; {}\n&quot;.format(&quot;&quot;.join(args))

    def _arrow(self, lenght):
        return &quot;--{}^\n&quot;.format(&quot;-&quot;*lenght)</code></pre>
]]></summary>
</entry>
<entry>
    <title>Parsing left associative operators using RLMeta</title>
    <link href="http://rickardlindberg.me/writing/rlmeta-left-associativity/" />
    <id>http://rickardlindberg.me/writing/rlmeta-left-associativity/</id>
    <published>2019-09-07T00:00:00Z</published>
    <updated>2019-09-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Parsing left associative operators using RLMeta</h1>

<p><em>Published on  7 September 2019.</em></p>

<p>The <a href="/writing/rlmeta/index.html">first article</a> about RLMeta has this example grammar implementing a simple calculator:</p>
<pre class="text"><code>Calculator {
  expression =
    | additive
  additive =
    | multitive:x &#39;+&#39; additive:y -&gt; add(x y)
    | multitive
  multitive =
    | digit:x &#39;*&#39; multitive:y    -&gt; mul(x y)
    | digit
  digit =
    | &#39;0&#39;-&#39;9&#39;:x                  -&gt; int(x)
}</code></pre>
<p>It works, but if we were to add a second case to support subtraction, it would break because subtraction is a left associate operator but the calculator creates a right associative parse. In this article I show how it would brake and how it can be solved.</p>
<ul>
<li><a href="#37144d09790c48a3bbdc3485473b5416">What is operator associativity?</a></li>
<li><a href="#cb24f5d3a7df423e9081889d4a2d3785">Right associative calculator</a></li>
<li><a href="#8366ac579e1e4be9930317242abd5dd6">Left associative calculator</a></li>
<li><a href="#855b50c552e54c0895128e7e86da55e9">Correct left associative calculator</a></li>
<li><a href="#736626ed0c3c4fea922cc4f14c5cda38">Right associative calculator without recursion</a></li>
<li><a href="#ae39c406658e4cd287411ab2c76710f8">Calculator combining operators</a></li>
<li><a href="#063f23a343574259bf31debb9b8425bf">Cleaner handling of precedence</a></li>
<li><a href="#24d9bf94e3b64dfba2841df8b3cf00b1">Comparison of operator parsers</a></li>
<li><a href="#5cca99df2e2c4c78ab4bfe4cb946d89a">Resources</a></li>
<li><a href="#c1716e6e63034983a86a1c9f621b2a52">Appendix: Test script</a></li>
</ul>
<h2 id="d09790c48a3bbdc3485473b5416what-is-operator-associativity">[]{#37144d09790c48a3bbdc3485473b5416}What is operator associativity?</h2>
<p>Operator associativity has to do with the order that operators are evaluated. The following expression can be evaluated in two ways:</p>
<pre class="text"><code>1-2-3</code></pre>
<p>Either as this (if the operator is left associative):</p>
<pre class="text"><code>(1-2)-3</code></pre>
<p>Or as this (if the operator is right associative):</p>
<pre class="text"><code>1-(2-3)</code></pre>
<p>Let's see how the calculator evaluates expressions.</p>
<h2 id="right-associative-calculator"><span id="cb24f5d3a7df423e9081889d4a2d3785"></span>Right associative calculator</h2>
<p>The following grammar works like the calculator but only supports subtraction:</p>
<pre><code>1.  right.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x &#39;-&#39; expr:y -&gt; sub(x y)
        | digit
  digit = &#39;0&#39;-&#39;9&#39;:x          -&gt; int(x)
}</code></pre>
<p>The <code>sub</code> function is implemented in two ways. The first creates an AST node representing a subtraction:</p>
<pre><code>1.  ast.py</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">def</span> sub(left, right):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;-&quot;</span>, left, right]</span></code></pre></div>
<p>The second evaluates the subtraction expression:</p>
<pre><code>1.  eval.py</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">def</span> sub(left, right):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">-</span> right</span></code></pre></div>
<p>Let's see how the calculator handles the following two expressions:</p>
<pre class="text"><code>1-2
1-2-3</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>[&#39;-&#39;, 1, 2]
=&gt;
-1

[&#39;-&#39;,
 1,
 [&#39;-&#39;, 2, 3]]
=&gt;
2</code></pre>
<p>For an expression with only two numbers, the calculator works as expected. But with more numbers, the parse is incorrect. The calculator parses <code>1-2-3</code> as <code>1-(2-3)</code> which is incorrect because subtraction is left associative and should thus be parsed as <code>(1-2)-3</code>.</p>
<p>The original calculator does not have this problem because it only supports operators that evaluate the same no matter if parsed as left associative or right associative.</p>
<p>If we strip the semantic actions from the <code>expr</code> rule it is easier to see what creates this right associative parse:</p>
<pre class="text"><code>expr = digit &#39;-&#39; expr | digit</code></pre>
<p>The topmost expression will be parsed as a digit followed by an arbitrary complex expression: <code>(digit - (...))</code>.</p>
<p>Let's see if we can get a left associative parse instead.</p>
<h2 id="ac579e1e4be9930317242abd5dd6left-associative-calculator">[]{#8366ac579e1e4be9930317242abd5dd6}Left associative calculator</h2>
<p>In order to get a left associate parse (that we need for subtraction) we would like to write the <code>expr</code> rule like this instead:</p>
<pre class="text"><code>expr = expr &#39;-&#39; digit | digit</code></pre>
<p>The whole grammar would then look like this:</p>
<pre><code>1.  left.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = expr:x &#39;-&#39; digit:y -&gt; sub(x y)
        | digit
  digit = &#39;0&#39;-&#39;9&#39;:x          -&gt; int(x)
}</code></pre>
<p>Unfortunately, this will not work with the parsing algorithm that RLMeta uses. In order to parse an <code>expr</code> it first has to parse an <code>expr</code> and so on, and it will get stuck in an infinite loop. The parsing algorithm is based on recursive descent parsing and the first choice in the <code>expr</code> rule will thus be translated into something like this:</p>
<pre class="text"><code>def expr():
    x = expr()
    atom(&quot;-&quot;)
    y = digit()
    return sub(x, y)</code></pre>
<p>We need to handle left associative operators differently.</p>
<h2 id="b50c552e54c0895128e7e86da55e9correct-left-associative-calculator">[]{#855b50c552e54c0895128e7e86da55e9}Correct left associative calculator</h2>
<p>The right associative parse that we saw earlier can be rewritten using a repetition:</p>
<pre class="text"><code>expr = digit &#39;-&#39; expr | digit</code></pre>
<p>It then becomes this:</p>
<pre class="text"><code>expr = digit (&#39;-&#39; digit)*</code></pre>
<p>It parses the same expressions, but it does not create a right associative parse. What does it create? Something that consist of a digit and a list of something. We can turn this into a parse tree using a function that we call <code>leftAssoc</code>. Here is the complete grammar:</p>
<pre><code>1.  left\_correct.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; leftAssoc(x xs)
  digit = &#39;0&#39;-&#39;9&#39;:x                           -&gt; int(x)
  op    = &#39;-&#39;                                 -&gt; makeSub()
}</code></pre>
<p>In the semantic action for <code>expr</code>, <code>x</code> is bound to a digit, and <code>xs</code> is bound to a list of pairs consisting of an operator and a digit: <code>[[op, digit], [op, digit], ...]</code>. The operator is a function that takes two arguments: the left hand side and the right hand side. (<code>makeSub</code> returns the <code>sub</code> function. It is used because currently global variables can not be referenced from semantic actions. Only global functions.) The function <code>leftAssoc</code> turns this into a left associative tree:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">def</span> leftAssoc(expr, items):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="cf">while</span> items:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>        expr <span class="op">=</span> op(expr, rhs)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>Here is how the expression <code>1-2-3</code> is parsed:</p>
<ul>
<li><code>leftAssoc</code> is called with <code>expr=1</code> and <code>items=[[sub, 2], [sub, 3]]</code>.</li>
<li>Since there are still items, the loop is entered
<ul>
<li><code>op=sub</code> and <code>rhs=2</code></li>
<li><code>expr=sub(1, 2)</code></li>
</ul></li>
<li>Since there are still items, the loop is entered
<ul>
<li><code>op=sub</code> and <code>rhs=3</code></li>
<li><code>expr=sub(sub(1, 2), 3)</code></li>
</ul></li>
<li>Since there are no more items, <code>sub(sub(1, 2), 3)</code> is returned</li>
</ul>
<p>Let's verify that the calculator handles the following expressions as intended:</p>
<pre class="text"><code>1-2
1-2-3</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>[&#39;-&#39;, 1, 2]
=&gt;
-1

[&#39;-&#39;,
 [&#39;-&#39;, 1, 2],
 3]
=&gt;
-4</code></pre>
<p>And indeed it does. We have now successfully parsed a left associate operator using RLMeta.</p>
<h2 id="ed0c3c4fea922cc4f14c5cda38right-associative-calculator-without-recursion">[]{#736626ed0c3c4fea922cc4f14c5cda38}Right associative calculator without recursion</h2>
<p>We can handle a right associative parse in RLMeta with a recursive rule as we have seen before:</p>
<pre class="text"><code>expr = digit &#39;-&#39; expr | digit</code></pre>
<p>However, we can also obtain a right associative parse by parsing operators as a list and then converting them into an AST with a <code>rightAssoc</code> function. Here is a grammar that supports only exponentiation which is right associative:</p>
<pre><code>1.  right\_no\_recursion.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; rightAssoc(x xs)
  digit = &#39;0&#39;-&#39;9&#39;:x                           -&gt; int(x)
  op    = &#39;^&#39;                                 -&gt; makePow()
}</code></pre>
<p>It has the exact same structure as the previous calculator, only now a different function is called to create the parse tree. The <code>rightAssoc</code> function is also similar in structure to the <code>leftAssoc</code> function, but the loop is replaced with an if statement followed by a recursive call:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">def</span> rightAssoc(expr, items):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>    <span class="cf">if</span> items:</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>        expr <span class="op">=</span> op(expr, rightAssoc(rhs, items))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>Here is how the expression <code>3^2^2</code> is parsed:</p>
<ul>
<li><code>rightAssoc</code> is called with <code>expr=3</code> and <code>items=[[pow, 2], [pow, 2]]</code></li>
<li>Since there are still items, the if statement is entered
<ul>
<li><code>op=pow</code> and <code>rhs=2</code></li>
<li><code>expr=pow(3, rightAssoc(2, [[pow, 2]])</code></li>
</ul></li>
<li><code>rightAssoc</code> is called with <code>expr=2</code> and <code>items=[[pow, 2]]</code></li>
<li>Since there are still items, the if statement is entered
<ul>
<li><code>op=pow</code> and <code>rhs=2</code></li>
<li><code>expr=pow(2, rightAssoc(2, [])</code></li>
</ul></li>
<li><code>rightAssoc</code> is called with <code>expr=2</code> and <code>items=[]</code></li>
<li>Since there are no more items, <code>2</code> is returned</li>
<li>The parent call returns <code>pow(2, 2)</code></li>
<li>The parent call returns <code>pow(3, pow(2, 2))</code></li>
</ul>
<p>The two <code>pow</code> functions are defined like this:</p>
<pre><code>1.  ast.py</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">def</span> <span class="bu">pow</span>(left, right):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;^&quot;</span>, left, right]</span></code></pre></div>
<pre><code>1.  eval.py</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">def</span> <span class="bu">pow</span>(left, right):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">**</span> right</span></code></pre></div>
<p>Let's verify that the calculator handles the following expressions as intended:</p>
<pre class="text"><code>3^2
3^2^2</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>[&#39;^&#39;, 3, 2]
=&gt;
9

[&#39;^&#39;,
 3,
 [&#39;^&#39;, 2, 2]]
=&gt;
81</code></pre>
<p>And indeed it does.</p>
<h2 id="calculator-combining-operators"><span id="ae39c406658e4cd287411ab2c76710f8"></span>Calculator combining operators</h2>
<p>Now that we know how to handle both left and right associative operators, we can extend the calculator to handle more operators:</p>
<pre><code>1.  calculator.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = expr1
  expr1 = expr2:x (op1:y expr2:z -&gt; [y z])*:xs -&gt; leftAssoc(x xs)
  expr2 = expr3:x (op2:y expr3:z -&gt; [y z])*:xs -&gt; leftAssoc(x xs)
  expr3 = digit:x (op3:y digit:z -&gt; [y z])*:xs -&gt; rightAssoc(x xs)
  digit = &#39;0&#39;-&#39;9&#39;:x                            -&gt; int(x)
  op1 =
    | &#39;+&#39; -&gt; makeAdd()
    | &#39;-&#39; -&gt; makeSub()
  op2 =
    | &#39;*&#39; -&gt; makeMul()
    | &#39;/&#39; -&gt; makeDiv()
  op3 =
    | &#39;^&#39; -&gt; makePow()
}</code></pre>
<p>Different levels of expressions are used to handle operators having different precedence (multiplication is done before subtraction for example).</p>
<p>The additional arithmetic functions are defined like this:</p>
<pre><code>1.  ast.py</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="kw">def</span> add(left, right):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;+&quot;</span>, left, right]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a><span class="kw">def</span> mul(left, right):</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;*&quot;</span>, left, right]</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a><span class="kw">def</span> div(left, right):</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;/&quot;</span>, left, right]</span></code></pre></div>
<pre><code>1.  eval.py</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="kw">def</span> add(left, right):</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">+</span> right</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a><span class="kw">def</span> mul(left, right):</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">*</span> right</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a><span class="kw">def</span> div(left, right):</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">/</span> right</span></code></pre></div>
<p>Let's see how the calculator handles the following expression:</p>
<pre class="text"><code>1+2-3^2^2-5</code></pre>
<p>Below is the AST and the evaluated result:</p>
<pre class="text"><code>[&#39;-&#39;,
 [&#39;-&#39;,
  [&#39;+&#39;, 1, 2],
  [&#39;^&#39;,
   3,
   [&#39;^&#39;, 2, 2]]],
 5]
=&gt;
-83</code></pre>
<p>If we enter the same expression in the Python prompt, but replace <code>^</code> with <code>**</code> as Python uses, we get the same result:</p>
<pre class="text"><code>&gt;&gt;&gt; 1+2-3**2**2-5
-83</code></pre>
<p>We can now parse complicated expressions correctly. However, if there are many precedence levels in a grammar, it might become difficult to read. Can we do better?</p>
<h2 id="f23a343574259bf31debb9b8425bfcleaner-handling-of-precedence">[]{#063f23a343574259bf31debb9b8425bf}Cleaner handling of precedence</h2>
<p>Here is the calculator grammar from the previous section rewritten in a cleaner way:</p>
<pre><code>1.  calculator\_ops.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; parseOps(x xs)
  digit = &#39;0&#39;-&#39;9&#39;:x                           -&gt; int(x)
  op    =
    | &#39;+&#39; -&gt; Op(makeAdd() &quot;1&quot; &quot;left&quot;)
    | &#39;-&#39; -&gt; Op(makeSub() &quot;1&quot; &quot;left&quot;)
    | &#39;*&#39; -&gt; Op(makeMul() &quot;2&quot; &quot;left&quot;)
    | &#39;/&#39; -&gt; Op(makeDiv() &quot;2&quot; &quot;left&quot;)
    | &#39;^&#39; -&gt; Op(makePow() &quot;3&quot; &quot;right&quot;)
}</code></pre>
<p>In this version all operators are parsed as a list and then handed over to the <code>parseOps</code> function. The operators also return an <code>Op</code> object instead of just a function to evaluate the operator. The <code>Op</code> object has information about the operator's precedence (given as a string only because RLMeta can not express integers in semantic actions) and associativity:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="kw">class</span> Op(<span class="bu">object</span>):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn, prec, assoc):</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>        <span class="va">self</span>.prec <span class="op">=</span> <span class="bu">int</span>(prec)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a>        <span class="va">self</span>.assoc <span class="op">=</span> assoc</span></code></pre></div>
<p>The <code>parseOps</code> function uses that information to create a parse tree:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="kw">def</span> parseOps(expr, items, min_level<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>    <span class="cf">while</span> items <span class="kw">and</span> items[<span class="dv">0</span>][<span class="dv">0</span>].prec <span class="op">&gt;=</span> min_level:</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>        <span class="cf">if</span> op.assoc <span class="op">==</span> <span class="st">&quot;left&quot;</span>:</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>            next_level <span class="op">=</span> op.prec <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>            next_level <span class="op">=</span> op.prec</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>        expr <span class="op">=</span> op.fn(expr, parseOps(rhs, items, next_level))</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>It combines the functionality of <code>leftAssoc</code> and <code>rightAssoc</code> and additionally also handles precedence. The increment of level if the operator is left associative ensures that only operators of higher precedence are parsed in the recursive call. If the next operator is of the same precedence, the recursive call will return immediately, and <code>parseOps</code> will behave like <code>leftAssoc</code>.</p>
<p>Here is how the expression 1+2+3*4 is parsed:</p>
<ul>
<li><code>parseOps</code> is called with <code>expr=1</code>, <code>items=[[OpAdd, 2], [OpAdd, 3], [OpMul, 4]]</code> and <code>min_level=0</code></li>
<li>Since there are still items and the add operator has <code>prec &gt;= 0</code>, the loop is entered
<ul>
<li><code>op=OpAdd</code> and <code>rhs=2</code></li>
<li>Since the add operator is left associative, <code>next_level=2</code></li>
<li><code>expr=add(1, parseOps(2, [[OpAdd, 3], [OpMul, 4]], 2))</code></li>
</ul></li>
<li><code>parseOps</code> is called with <code>expr=2</code>, <code>items=[[OpAdd, 3], [OpMul, 4]]</code> and <code>min_level=2</code></li>
<li>Since the add operator has <code>prec &lt; 2</code>, the loop is not entered, and <code>2</code> is returned</li>
<li>The outer loop continues with <code>expr=add(1, 2)</code>
<ul>
<li><code>op=OpAdd</code> and <code>rhs=3</code></li>
<li>Since the add operator is left associative, <code>next_level=2</code></li>
<li><code>expr=add(add(1, 2), parseOps(3, [[OpMul, 4]], 2))</code></li>
</ul></li>
<li><code>parseOps</code> is called with <code>expr=3</code>, <code>items=[[OpMul, 4]]</code> and <code>min_level=2</code></li>
<li>Since there are still items and the mul operator has <code>prec &gt;= 2</code>, the loop is entered
<ul>
<li><code>op=OpMul</code> and <code>rhs=4</code></li>
<li>Since the mul operator is left associative, <code>next_level=3</code></li>
<li><code>expr=mul(3, parseOps(4, [], 3))</code></li>
</ul></li>
<li><code>parseOps</code> is called with <code>expr=4</code>, <code>items=[]</code> and <code>min_level=3</code></li>
<li>Since there are no more items, <code>4</code> is returned</li>
<li>The parent returns <code>mul(3, 4)</code></li>
<li>The parent returns <code>add(add(1, 2), mul(3, 4))</code></li>
</ul>
<p>Let's see how the calculator handles the following expressions:</p>
<pre class="text"><code>1+2-3
1+2-3^2^2-5</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>[&#39;-&#39;,
 [&#39;+&#39;, 1, 2],
 3]
=&gt;
0

[&#39;-&#39;,
 [&#39;-&#39;,
  [&#39;+&#39;, 1, 2],
  [&#39;^&#39;,
   3,
   [&#39;^&#39;, 2, 2]]],
 5]
=&gt;
-83</code></pre>
<p>This looks correct. We now have a calculator whose grammar is more cleanly written and only uses one support function instead of two.</p>
<h2 id="d9bf94e3b64dfba2841df8b3cf00b1comparison-of-operator-parsers">[]{#24d9bf94e3b64dfba2841df8b3cf00b1}Comparison of operator parsers</h2>
<p>All three operator parser functions have a similar structure to them. Here they are for comparison:</p>
<pre class="text"><code>def leftAssoc(expr, items):
    while items:
        op, rhs = items.pop(0)
        expr = op(expr, rhs)
    return expr</code></pre>
<pre class="text"><code>def rightAssoc(expr, items):
    if items:
        op, rhs = items.pop(0)
        expr = op(expr, rightAssoc(rhs, items))
    return expr</code></pre>
<pre class="text"><code>def parseOps(expr, items, min_level=0):
    while items and items[0][0].prec &gt;= min_level:
        op, rhs = items.pop(0)
        if op.assoc == &quot;left&quot;:
            next_level = op.prec + 1
        else:
            next_level = op.prec
        expr = op.fn(expr, parseOps(rhs, items, next_level))
    return expr</code></pre>
<h2 id="cca99df2e2c4c78ab4bfe4cb946d89aresources">[]{#5cca99df2e2c4c78ab4bfe4cb946d89a}Resources</h2>
<p>The following articles helped me understand how to handle left associative operators in recursive descent parsers:</p>
<ul>
<li><a href="http://beastie.cs.ua.edu/proglan/readings/precedence.pdf">Implementing Associativity and Precedence in Recursive Descent Expression Grammars</a></li>
<li><a href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers">Recursive descent, LL and predictive parsers</a></li>
<li><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">Some problems of recursive descent parsers</a></li>
<li><a href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator">A recursive descent parser with an infix expression evaluator</a></li>
<li><a href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing">Top-Down operator precedence parsing</a></li>
<li><a href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing">Parsing expressions by precedence climbing</a></li>
<li><a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">Pratt Parsers: Expression Parsing Made Easy</a></li>
</ul>
<h2 id="appendix-test-script"><span id="c1716e6e63034983a86a1c9f621b2a52"></span>Appendix: Test script</h2>
<p>I used the following Bash script to run the examples:</p>
<pre><code>1.  expr.sh</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="fu">compile()</span> <span class="kw">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;import sys&quot;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;import pprint&quot;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a>    <span class="ex">rlmeta</span> --support</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true"></a>    <span class="ex">rlmeta</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true"></a>    <span class="fu">cat</span> <span class="st">&quot;support.py&quot;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true"></a>    <span class="fu">cat</span> <span class="st">&quot;</span><span class="va">$2</span><span class="st">&quot;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeAdd = lambda: add&quot;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeSub = lambda: sub&quot;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeMul = lambda: mul&quot;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeDiv = lambda: div&quot;</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makePow = lambda: pow&quot;</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;try:&quot;</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;    for expr in sys.stdin.read().splitlines():&quot;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;        pprint.pprint(Calculator().run(&#39;expr&#39;, expr), width=20)&quot;</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;except _MatchError as e:&quot;</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;    sys.stderr.write(e.describe())&quot;</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true"></a></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true"></a><span class="kw">(</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true"></a>    <span class="kw">while</span> <span class="bu">read</span> -e <span class="va">expr</span>; <span class="kw">do</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$expr</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">python</span> <span class="op">&lt;(</span><span class="ex">compile</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="st">&quot;ast.py&quot;</span><span class="op">)</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;=&gt;&quot;</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$expr</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">python</span> <span class="op">&lt;(</span><span class="ex">compile</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="st">&quot;eval.py&quot;</span><span class="op">)</span></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;&quot;</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true"></a>    <span class="kw">done</span></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true"></a><span class="kw">)</span> <span class="kw">|</span> <span class="fu">head</span> -n-1</span></code></pre></div>
<p>It reads expressions from stdin one per line. Then it evaluates them both using the AST function and the eval function and prints the result. The <code>make*</code> functions are also defined here to just return the respective function.</p>
]]></summary>
</entry>
<entry>
    <title>RLMeta: a VM based approach</title>
    <link href="http://rickardlindberg.me/writing/rlmeta-vm/" />
    <id>http://rickardlindberg.me/writing/rlmeta-vm/</id>
    <published>2019-08-06T00:00:00Z</published>
    <updated>2019-08-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>RLMeta: a VM based approach</h1>

<p><em>Published on  6 August 2019.</em></p>

<p>In this article I present an alternative implementation of <a href="/writing/rlmeta/index.html">RLMeta</a> in which grammars are compiled into instructions for a virtual machine (VM).</p>
<p>The VM based version builds upon the <a href="/writing/optimizing-rlmeta/index.html">optimized version</a> and the implementation is inspired by <a href="https://swtch.com/~rsc/regexp/regexp2.html">Regular Expression Matching: the Virtual Machine Approach</a> and <a href="http://www.inf.puc-rio.br/%7Eroberto/docs/peg.pdf">A Text Pattern-Matching Tool based on Parsing Expression Grammars</a>.</p>
<ul>
<li><a href="#3df386e2afb1452b87a29185c2de0673">Big picture difference</a></li>
<li><a href="#d1a2d050fcc444cfa4991b968a02a315">Parser</a></li>
<li><a href="#24aa83d59704475dba2a010f1b5d3eb0">Code generator</a>
<ul>
<li><a href="#8fc432da8cb94c91baeba2ee6b69f40b">Grammar</a></li>
<li><a href="#72b77f7c8a594757a67ef61f9502f8e9">Rule</a></li>
<li><a href="#613d04f41a3e4521ad022a3d4e0237ea">Or</a></li>
<li><a href="#e0d721aa4fae40af8de5a54253243cb0">Scope</a></li>
<li><a href="#34ee0862096d4fd4aa3342c4b3b6c294">And</a></li>
<li><a href="#8275c4d4e16c483f84be55f550e3d39c">Bind</a></li>
<li><a href="#963d53648b304544be75045e59c6e183">Star</a></li>
<li><a href="#0efe424b680f477a9bb8c1b9f679ff84">Not</a></li>
<li><a href="#24675b6707284a99ba3d3cb17b60e3f2">MatchCallRule</a></li>
<li><a href="#629b7ffad2d54725ad0af4e73bf434d8">Label</a></li>
<li><a href="#4ddebcb41511403c8b3fa5c96f14c8f4">SemanticAction</a></li>
<li><a href="#fc62b5be27fd4e40978d415ba4070a05">MatchRule</a></li>
<li><a href="#ce3171f9336a4f1a961f4d6fd6665361">MatchRange</a></li>
<li><a href="#40fcdbbabfe44b009d3f405060a2055f">MatchString</a></li>
<li><a href="#c6e2326b6b774601b761538455918bbe">MatchCharseq</a></li>
<li><a href="#de0847d410c6495d9a8ee4e75a0423cc">MatchAny</a></li>
<li><a href="#1dc829aba4484ed399eb025d01ed843e">MatchList</a></li>
<li><a href="#6cc83570ba674d71bccd12660fddefcc">Example revisited</a></li>
</ul></li>
<li><a href="#e66f8cec6206420abe4736ae32849c53">VM</a>
<ul>
<li><a href="#8f0fffeab7084a1d9b01d928be4878a8">MATCH_ANY</a></li>
<li><a href="#a8160d30b886418882ada3a2a884e580">MATCH_STRING</a></li>
<li><a href="#d8dcb57d5da141908f28f8c52983d1a6">MATCH_RANGE</a></li>
<li><a href="#df5dc1b5e5054e548d5c3606daba0d55">MATCH_CHARSEQ</a></li>
<li><a href="#49ca0a2fa665466cb90c8c128d5cc835">PUSH_SCOPE</a></li>
<li><a href="#b2510846e20d4cd08f9b0cd2dfb5c01d">POP_SCOPE</a></li>
<li><a href="#1315305641224e4aa99dd00ec5b524b1">BIND</a></li>
<li><a href="#738356fde86e4c7290b0f99850917ba8">ACTION</a></li>
<li><a href="#d7d285d9586b437ca7d7f51b5deb6193">LABEL</a></li>
<li><a href="#b3562467300348028f04ae5034db0f34">LIST_START</a></li>
<li><a href="#b4aacd38dec8406c9db784e0823c3554">LIST_APPEND</a></li>
<li><a href="#9940cd44d7fe4777b1c12e335bac33ae">LIST_END</a></li>
<li><a href="#fee2dcf573f04ac3a9e7cfd92adbe0c8">PUSH_STREAM</a></li>
<li><a href="#87a1eee2cfb94e1a9463a6561c226012">POP_STREAM</a></li>
<li><a href="#34915cae29994179abbe19f2f7e4c267">FAIL</a></li>
<li><a href="#8e19cbb2e71c412f95c7e241a69f0901">CALL</a></li>
<li><a href="#d42df29209bf475280ac510d9ae31182">MATCH_CALL_RULE</a></li>
<li><a href="#d104aa6d6b8e43818f662498f6566e38">RETURN</a></li>
<li><a href="#542906286e124874b2975d0ae23f034f">BACKTRACK</a></li>
<li><a href="#5b99ed36fbde45989829fde6e17d4821">COMMIT</a></li>
<li><a href="#77edfc243204447ba84468c78f05d8e5">Handling failure</a></li>
<li><a href="#95ffb1abf59546e1972c78ee7159b758">Optimizations</a></li>
</ul></li>
<li><a href="#2e3ad1de345642658be2e5910ab5be4e">Note on size</a></li>
<li><a href="#c490369b053247c0b7761f324658aa15">Note on performance</a></li>
<li><a href="#7e7b4c5318ff4c849c6e98e9ddeaacf0">Code listings for RLMeta</a>
<ul>
<li><a href="#53f0708b231b468d844291df3fe17cf2">parser.rlmeta</a></li>
<li><a href="#74bf51f7e8d94bcba1747edb477137ef">codegenerator.rlmeta</a></li>
<li><a href="#60ff77cb85fa455589e3e45cdeac8160">support.py</a></li>
<li><a href="#338ad257e61e4025b8859d610a475c6a">compile.sh</a></li>
<li><a href="#272d17f2d55749b59d7e5ec7b9b8e0ec">meta_compile.sh</a></li>
</ul></li>
</ul>
<h2 id="df386e2afb1452b87a29185c2de0673big-picture-difference">[]{#3df386e2afb1452b87a29185c2de0673}Big picture difference</h2>
<p>The optimized version compiles grammars into Python classes which can be used like this:</p>
<pre class="text"><code>g = Grammar()
result = g.run(&quot;foo&quot;, &quot;input string&quot;)</code></pre>
<p>The VM based version also compiles grammars into Python classes with the same interface. The difference is how the <code>run</code> method is implemented. In the optimized version, it calls methods that represent rules in the grammar. The above call would result in <code>_rule_foo</code> being called. That in turn would make calls to other methods representing other rules in the grammar. The VM based version instead has a sequence of instructions and a program counter that keeps track of which instruction to execute. The VM is invoked from the <code>run</code> method.</p>
<p>To make the difference more clear, let's look at the <code>Scream</code> grammar that turns its input into a screaming equivalent (<code>hello</code> to <code>HELLO!!</code> for example):</p>
<pre class="text"><code>Scream {
  scream = char*:xs -&gt; { xs &quot;!!&quot; }
  char   = .:x      -&gt; upper(x)
}</code></pre>
<p>The optimized version compiles it into the following class with one method per rule in the grammar:</p>
<pre class="text"><code>class Scream(_Grammar):

    def _rule_scream(self):
        return (lambda: (lambda _vars:
            (lambda: self._and([
                (lambda: _vars.bind(&#39;xs&#39;, (lambda: self._star((lambda: self._match_rule(&#39;char&#39;))))())),
                (lambda: _SemanticAction(lambda: _Builder.create([
                    _vars.lookup(&#39;xs&#39;).eval(),
                    &#39;!!&#39;,
                ]))),
            ]))()
        )(_Vars()))()

    def _rule_char(self):
        return (lambda: (lambda _vars:
            (lambda: self._and([
                (lambda: _vars.bind(&#39;x&#39;, self._match_any())),
                (lambda: _SemanticAction(lambda: upper(
                    _vars.lookup(&#39;x&#39;).eval(),
                ))),
            ]))()
        )(_Vars()))()</code></pre>
<p>The VM based version compiles it into the following class with a sequence of instructions (don't worry about understanding them now, it will be clear later what the instructions mean):</p>
<pre class="text"><code>class Scream(_Grammar):

    def __init__(self):
        self._instructions = i = []
        self._labels = l = {}
        def I(name, x=None, y=None):
            i.append((name, x, y))
        def LABEL(name):
            l[name] = len(i)
        LABEL(&#39;scream&#39;)
        I(&#39;PUSH_SCOPE&#39;)
        I(&#39;LIST_START&#39;)
        LABEL(0)
        I(&#39;BACKTRACK&#39;, 1)
        I(&#39;CALL&#39;, &#39;char&#39;)
        I(&#39;LIST_APPEND&#39;)
        I(&#39;COMMIT&#39;, 0)
        LABEL(1)
        I(&#39;LIST_END&#39;)
        I(&#39;BIND&#39;, &#39;xs&#39;)
        I(&#39;ACTION&#39;, lambda scope: _Builder.create([scope[&#39;xs&#39;].eval(), &#39;!!&#39;]))
        I(&#39;POP_SCOPE&#39;)
        I(&#39;RETURN&#39;)
        LABEL(&#39;char&#39;)
        I(&#39;PUSH_SCOPE&#39;)
        I(&#39;MATCH_ANY&#39;)
        I(&#39;BIND&#39;, &#39;x&#39;)
        I(&#39;ACTION&#39;, lambda scope: upper(scope[&#39;x&#39;].eval()))
        I(&#39;POP_SCOPE&#39;)
        I(&#39;RETURN&#39;)</code></pre>
<p>The external interface of the classes is exactly the same, but internally they look rather different. The <code>run</code> method in the optimized version looks like this:</p>
<pre class="text"><code>def run(self, rule_name, input_object):
    self._memo = _Memo()
    self._stream = _Stream.from_object(self._memo, input_object)
    result = self._match_rule(rule_name).eval()
    if isinstance(result, _Builder):
        return result.build_string()
    else:
        return result</code></pre>
<p>It does some setup and then calls <code>_match_rule</code> to start matching.</p>
<p>The <code>run</code> method in the VM based version looks like this:</p>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> _Grammar(<span class="bu">object</span>):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule_name, input_object):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(input_object, <span class="bu">basestring</span>):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>            stream <span class="op">=</span> input_object</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>            stream <span class="op">=</span> [input_object]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>        result <span class="op">=</span> rlmeta_vm(<span class="va">self</span>._instructions, <span class="va">self</span>._labels, rule_name, stream)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(result, _Builder):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>            <span class="cf">return</span> result.build_string()</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>            <span class="cf">return</span> result</span></code></pre></div>
<p>It also does some setup, but then it hands over the instructions (that are created in the <code>__init__</code> method) to the VM that then executes them.</p>
<p>In the rest of this article I explain how grammars are compiled into VM instructions and how the VM is implemented.</p>
<h2 id="parser"><span id="d1a2d050fcc444cfa4991b968a02a315"></span>Parser</h2>
<p>The parser in the VM based version has one additional rule for labels:</p>
<pre><code>1.  parser.rlmeta
2.  [expr1]{.cp}</code></pre>
<pre class="rlmeta"><code>| space &#39;#&#39; -&gt; [&quot;Label&quot;]</code></pre>
<p>A label returns a semantic action that evaluates to a unique number. You will see later (in <a href="#613d04f41a3e4521ad022a3d4e0237ea"><em>Or</em></a>, <a href="#963d53648b304544be75045e59c6e183"><em>Star</em></a>, and <a href="#0efe424b680f477a9bb8c1b9f679ff84"><em>Not</em></a>) how it is used in the code generator.</p>
<p>The label feature first had to be added to the optimized version before it could be used to compile the VM based version. That implementation is not shown in this article, but the implementation of labels in the VM based version is similar.</p>
<p>The rest of the parser is exactly the same as in the optimized version:</p>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  grammar =
    | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space &#39;=&#39; choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space &#39;|&#39;)?
      sequence:x (space &#39;|&#39; sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space &#39;:&#39; name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space &#39;*&#39;                        -&gt; [&quot;Star&quot; x]
    | expr2:x space &#39;?&#39;                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space &#39;!&#39; expr2:x                        -&gt; [&quot;Not&quot; x]
    | space &#39;%&#39;                                -&gt; [&quot;MatchCallRule&quot;]
    &lt;&lt;expr1&gt;&gt;
    | expr2
  expr2 =
    | space &#39;-&gt;&#39; hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space &#39;=&#39;)                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x &#39;-&#39; char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space &#39;.&#39;                                -&gt; [&quot;MatchAny&quot;]
    | space &#39;(&#39; choice:x space &#39;)&#39;             -&gt; x
    | space &#39;[&#39; expr*:xs space &#39;]&#39;             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space &#39;[&#39; hostExprListItem*:xs space &#39;]&#39; -&gt; [&quot;List&quot; ~xs]
    | space &#39;{&#39; buildExpr*:xs space &#39;}&#39;        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space &#39;~&#39; hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space &#39;&gt;&#39;                                -&gt; [&quot;IndentBuilder&quot;]
    | space &#39;&lt;&#39;                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;   -&gt; join(xs)
  charseq   = &#39;\&#39;&#39; (!&#39;\&#39;&#39; innerChar)*:xs &#39;\&#39;&#39;  -&gt; join(xs)
  char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39;  -&gt; x
  innerChar = &#39;\\&#39; escape | .
  escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
            | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
  nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;
  space     = (&#39; &#39; | &#39;\n&#39;)*
}</code></pre>
<h2 id="aa83d59704475dba2a010f1b5d3eb0code-generator">[]{#24aa83d59704475dba2a010f1b5d3eb0}Code generator</h2>
<p>The code generator in the VM based version is similarly structured to the code generator in the optimized version with a grammar and a support library:</p>
<pre><code>1.  codegenerator.rlmeta</code></pre>
<pre class="rlmeta"><code>CodeGenerator {
  &lt;&lt;rules&gt;&gt;
}</code></pre>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="op">&lt;&lt;</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="op">&lt;&lt;</span>vm<span class="op">&gt;&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="op">&lt;&lt;</span>classes<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>The <code>ast</code> rule is exactly the same as in the optimized version:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>ast = [%:x] -&gt; x</code></pre>
<p>Then there is an additional rule for when a Python representation of a value is needed:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>py = .:x -&gt; repr(x)</code></pre>
<p>Let's move on and look at how VM instructions are generated.</p>
<h3 id="fc432da8cb94c91baeba2ee6b69f40bgrammar">[]{#8fc432da8cb94c91baeba2ee6b69f40b}Grammar</h3>
<p>When a <code>Grammar</code> AST node is matched, a Python class inheriting <code>_Grammar</code> is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Grammar = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(_Grammar):\n\n&quot; &gt;
                             &quot;def __init__(self):\n&quot; &gt;
                               &quot;self._instructions = i = []\n&quot;
                               &quot;self._labels = l = {}\n&quot;
                               &quot;def I(name, x=None, y=None):\n&quot; &gt;
                                 &quot;i.append((name, x, y))\n&quot;
                               &lt;
                               &quot;def LABEL(name):\n&quot; &gt;
                                 &quot;l[name] = len(i)\n&quot;
                               &lt;
                               ys
                             &lt;
                           &lt; }</code></pre>
<p>The name of the class is the same as the name of the grammar.</p>
<p>The <code>__init__</code> method has functionality for creating instructions. An instruction is represented as a tuple with three elements: the name, the first argument, and the second argument. Arguments can be <code>None</code>. Instructions are stored in a list. Labels map names to positions in the instruction list and are stored in a dictionary.</p>
<p>Shorthand names <code>i</code> and <code>l</code> are used instead of <code>self._instructions</code> and <code>self._labels</code> because they are faster. Not using <code>self</code> reduces one dictionary lookup.</p>
<p>The child AST nodes of <code>Grammar</code> are assumed to use the <code>I</code> and <code>LABEL</code> functions to create instructions.</p>
<h3 id="b77f7c8a594757a67ef61f9502f8e9rule">[]{#72b77f7c8a594757a67ef61f9502f8e9}Rule</h3>
<p>When a <code>Rule</code> AST node is matched, instructions representing a function are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Rule = py:x ast:y -&gt; { &quot;LABEL(&quot; x &quot;)\n&quot;
                       y
                       &quot;I(&#39;RETURN&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation (where labels are in the first column and instructions are in the second column) it looks like this:</p>
<pre class="text"><code>&lt;x&gt;:
    &lt;y instructions&gt;
    RETURN</code></pre>
<p>The label name is the name of the rule. <a href="#d104aa6d6b8e43818f662498f6566e38"><em>RETURN</em></a> instructs the VM to continue execution at wherever it was before calling this rule.</p>
<h3 id="d04f41a3e4521ad022a3d4e0237eaor">[]{#613d04f41a3e4521ad022a3d4e0237ea}Or</h3>
<p>When an <code>Or</code> AST node is matched, instructions representing a choice are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Or =
  | ast:x Or:y #:a #:b -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; a &quot;)\n&quot;
                            x
                            &quot;I(&#39;COMMIT&#39;, &quot; b &quot;)\n&quot;
                            &quot;LABEL(&quot; a &quot;)\n&quot;
                            y
                            &quot;LABEL(&quot; b &quot;)\n&quot; }
  | ast</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>    BACKTRACK a
    &lt;x instructions&gt;
    COMMIT b
a:
    &lt;y instructions&gt;
b:</code></pre>
<p><a href="#542906286e124874b2975d0ae23f034f"><em>BACKTRACK</em></a> instructs the VM to push a backtrack entry onto the stack so that it can try matching again at label <code>a</code> if the <code>x</code> instructions fail. <a href="#5b99ed36fbde45989829fde6e17d4821"><em>COMMIT</em></a> instructs the VM to pop this backtrack entry off the stack and continue execution at label <code>b</code>. If <code>x</code> instructions fail, the second choice at label <code>a</code> is tried, otherwise, execution continues at label <code>b</code>. The <code>y</code> instructions might represent another choice or the last choice. If there is only once choice, only instructions for that choice are generated. In that case, no <code>BACKTRACK</code> and <code>COMMIT</code> are needed.</p>
<h3 id="scope"><span id="e0d721aa4fae40af8de5a54253243cb0"></span>Scope</h3>
<p>When a <code>Scope</code> AST node is matched, instructions creating a new scope are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Scope = ast:x -&gt; { &quot;I(&#39;PUSH_SCOPE&#39;)\n&quot;
                   x
                   &quot;I(&#39;POP_SCOPE&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>PUSH_SCOPE
&lt;x instructions&gt;
POP_SCOPE</code></pre>
<p><a href="#49ca0a2fa665466cb90c8c128d5cc835"><em>PUSH_SCOPE</em></a> instructs the VM to push a new scope onto the stack so that all bindings that are done by <code>x</code> instructions happen in this new scope. <a href="#b2510846e20d4cd08f9b0cd2dfb5c01d"><em>POP_SCOPE</em></a> instructs the VM to pop this scope off the stack.</p>
<h3 id="ee0862096d4fd4aa3342c4b3b6c294and">[]{#34ee0862096d4fd4aa3342c4b3b6c294}And</h3>
<p>When an <code>And</code> AST node is matched, instructions for all items in the sequence are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>And = ast*</code></pre>
<h3 id="c4d4e16c483f84be55f550e3d39cbind">[]{#8275c4d4e16c483f84be55f550e3d39c}Bind</h3>
<p>When a <code>Bind</code> AST node is matched, instructions binding the last result to a name are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Bind = py:x ast:y -&gt; { y
                       &quot;I(&#39;BIND&#39;, &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>&lt;y instructions&gt;
BIND &lt;x&gt;</code></pre>
<p><a href="#1315305641224e4aa99dd00ec5b524b1"><em>BIND</em></a> instructs the VM to bind the last result from <code>y</code> instructions to the name <code>x</code> in the current scope.</p>
<h3 id="d53648b304544be75045e59c6e183star">[]{#963d53648b304544be75045e59c6e183}Star</h3>
<p>When a <code>Star</code> AST node is matched, instructions representing a repetition are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Star = ast:x #:a #:b -&gt; { &quot;I(&#39;LIST_START&#39;)\n&quot;
                          &quot;LABEL(&quot; a &quot;)\n&quot;
                          &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                          x
                          &quot;I(&#39;LIST_APPEND&#39;)\n&quot;
                          &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                          &quot;LABEL(&quot; b &quot;)\n&quot;
                          &quot;I(&#39;LIST_END&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>    LIST_START
a:
    BACKTRACK b
    &lt;x instructions&gt;
    LIST_APPEND
    COMMIT a
b:
    LIST_END</code></pre>
<p><a href="#b3562467300348028f04ae5034db0f34"><em>LIST_START</em></a> instructs the VM to create a new list for accumulating results. <a href="#b4aacd38dec8406c9db784e0823c3554"><em>LIST_APPEND</em></a> instructs the VM to append the last result to this list. <a href="#9940cd44d7fe4777b1c12e335bac33ae"><em>LIST_END</em></a> instructs the VM to make this list itself the last result. The <code>BACKTRACK</code> and <code>COMMIT</code> instructions are used to create control flow for a loop. As long as <code>x</code> instructions succeed, the program loops between label <code>a</code> and the <code>COMMIT</code> instruction. As soon as <code>x</code> instructions fail, the program continues execution at label <code>b</code>.</p>
<h3 id="efe424b680f477a9bb8c1b9f679ff84not">[]{#0efe424b680f477a9bb8c1b9f679ff84}Not</h3>
<p>When a <code>Not</code> AST node is matched, instructions representing negative lookahead are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Not = ast:x #:a #:b -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                         x
                         &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                         &quot;LABEL(&quot; a &quot;)\n&quot;
                         &quot;I(&#39;FAIL&#39;, &#39;no match expected&#39;)\n&quot;
                         &quot;LABEL(&quot; b &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>    BACKTRACK b
    &lt;x instructions&gt;
    COMMIT a
a:
    FAIL &#39;no match expected&#39;
b:</code></pre>
<p><a href="#34915cae29994179abbe19f2f7e4c267"><em>FAIL</em></a> instructs the VM to fail with the given message. The <code>BACKTRACK</code> and <code>COMMIT</code> instructions are used to create control flow for negative lookahead. If <code>x</code> instructions succeed, the <code>COMMIT</code> instruction makes the program continue at label <code>a</code>. That immediately fails because the negative lookahead does not expect a match. If <code>x</code> instructions fail, the program continues execution at label <code>b</code>, and the <code>FAIL</code> instruction is skipped.</p>
<h3 id="b6707284a99ba3d3cb17b60e3f2matchcallrule">[]{#24675b6707284a99ba3d3cb17b60e3f2}MatchCallRule</h3>
<p>When a <code>MatchCallRule</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchCallRule = -&gt; { &quot;I(&#39;MATCH_CALL_RULE&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_CALL_RULE</code></pre>
<p><a href="#d42df29209bf475280ac510d9ae31182"><em>MATCH_CALL_RULE</em></a> instructs the VM to call the rule denoted by the current input object.</p>
<h3 id="b7ffad2d54725ad0af4e73bf434d8label">[]{#629b7ffad2d54725ad0af4e73bf434d8}Label</h3>
<p>When a <code>Label</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Label = -&gt; { &quot;I(&#39;LABEL&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>LABEL</code></pre>
<p><a href="#d7d285d9586b437ca7d7f51b5deb6193"><em>LABEL</em></a> instructs the VM to create a semantic action that evaluates to a unique number.</p>
<h3 id="ddebcb41511403c8b3fa5c96f14c8f4semanticaction">[]{#4ddebcb41511403c8b3fa5c96f14c8f4}SemanticAction</h3>
<p>When a <code>SemanticAction</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>SemanticAction = ast:x -&gt; { &quot;I(&#39;ACTION&#39;, lambda scope: &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>ACTION &lt;python lambda&gt;</code></pre>
<p><a href="#738356fde86e4c7290b0f99850917ba8"><em>ACTION</em></a> instructs the VM to create a user defined a semantic action. If there is a match, it will be called with the scope that was active when the action was defined.</p>
<p>Semantic actions are not evaluated by the VM, but rather by Python. The VM is only responsible for matching and creating semantic actions as results.</p>
<p>The lambda expression that is the first argument is generated by the following rules similarly to how it was done in the optimized version:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>String        = py
List          = astList
Builder       = astItems:x      -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot; }
IndentBuilder =                 -&gt; { &quot;_IndentBuilder()&quot;         }
DedentBuilder =                 -&gt; { &quot;_DedentBuilder()&quot;         }
FnCall        = .:x astItems:y  -&gt; { x &quot;(&quot; y &quot;)&quot;                }
VarLookup     = py:x            -&gt; { &quot;scope[&quot; x &quot;].eval()&quot;      }
astItems      =
  | ast:x astItem*:xs           -&gt; { x xs                       }
  |                             -&gt; {                            }
astItem       = ast:x           -&gt; { &quot;, &quot; x                     }
astList       = astListItem*:xs -&gt; { &quot;(&quot; xs &quot;[])&quot;               }
astListItem   =
  | [&quot;ListItemSplice&quot; ast:x]    -&gt; {     x  &quot;+&quot;                 }
  | ast:x                       -&gt; { &quot;[&quot; x &quot;]+&quot;                 }</code></pre>
<p>The related pieces in the support library are exactly the same as in the optimized version:</p>
<pre><code>1.  support.py
2.  [imports]{.cp}</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="cf">try</span>:</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>    <span class="im">from</span> cStringIO <span class="im">import</span> StringIO</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a><span class="cf">except</span>:</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>    <span class="im">from</span> StringIO <span class="im">import</span> StringIO</span></code></pre></div>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a><span class="kw">class</span> _Builder(<span class="bu">object</span>):</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a>    <span class="kw">def</span> build_string(<span class="va">self</span>):</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a>        output <span class="op">=</span> _Output()</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a>        <span class="va">self</span>.write(output)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true"></a>        <span class="cf">return</span> output.value</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true"></a>    <span class="at">@classmethod</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true"></a>    <span class="kw">def</span> create(<span class="va">self</span>, item):</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(item, _Builder):</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true"></a>            <span class="cf">return</span> item</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>):</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true"></a>            <span class="cf">return</span> _ListBuilder([_Builder.create(x) <span class="cf">for</span> x <span class="kw">in</span> item])</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true"></a>            <span class="cf">return</span> _AtomBuilder(item)</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true"></a></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true"></a><span class="kw">class</span> _Output(<span class="bu">object</span>):</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true"></a></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true"></a>        <span class="va">self</span>.<span class="bu">buffer</span> <span class="op">=</span> StringIO()</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true"></a>        <span class="va">self</span>.indentation <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true"></a>        <span class="va">self</span>.on_newline <span class="op">=</span> <span class="va">True</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true"></a></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true"></a>    <span class="at">@property</span></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true"></a>    <span class="kw">def</span> value(<span class="va">self</span>):</span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">buffer</span>.getvalue()</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true"></a></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, value):</span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true"></a>        <span class="cf">for</span> ch <span class="kw">in</span> value:</span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true"></a>            is_linebreak <span class="op">=</span> ch <span class="op">==</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>.indentation <span class="kw">and</span> <span class="va">self</span>.on_newline <span class="kw">and</span> <span class="kw">not</span> is_linebreak:</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true"></a>                <span class="va">self</span>.<span class="bu">buffer</span>.write(<span class="st">&quot;    &quot;</span><span class="op">*</span><span class="va">self</span>.indentation)</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true"></a>            <span class="va">self</span>.<span class="bu">buffer</span>.write(ch)</span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true"></a>            <span class="va">self</span>.on_newline <span class="op">=</span> is_linebreak</span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true"></a></span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true"></a><span class="kw">class</span> _ListBuilder(_Builder):</span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true"></a></span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, builders):</span>
<span id="cb56-39"><a href="#cb56-39" aria-hidden="true"></a>        <span class="va">self</span>.builders <span class="op">=</span> builders</span>
<span id="cb56-40"><a href="#cb56-40" aria-hidden="true"></a></span>
<span id="cb56-41"><a href="#cb56-41" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-42"><a href="#cb56-42" aria-hidden="true"></a>        <span class="cf">for</span> builder <span class="kw">in</span> <span class="va">self</span>.builders:</span>
<span id="cb56-43"><a href="#cb56-43" aria-hidden="true"></a>            builder.write(output)</span>
<span id="cb56-44"><a href="#cb56-44" aria-hidden="true"></a></span>
<span id="cb56-45"><a href="#cb56-45" aria-hidden="true"></a><span class="kw">class</span> _AtomBuilder(_Builder):</span>
<span id="cb56-46"><a href="#cb56-46" aria-hidden="true"></a></span>
<span id="cb56-47"><a href="#cb56-47" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, atom):</span>
<span id="cb56-48"><a href="#cb56-48" aria-hidden="true"></a>        <span class="va">self</span>.atom <span class="op">=</span> atom</span>
<span id="cb56-49"><a href="#cb56-49" aria-hidden="true"></a></span>
<span id="cb56-50"><a href="#cb56-50" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-51"><a href="#cb56-51" aria-hidden="true"></a>        output.write(<span class="bu">str</span>(<span class="va">self</span>.atom))</span>
<span id="cb56-52"><a href="#cb56-52" aria-hidden="true"></a></span>
<span id="cb56-53"><a href="#cb56-53" aria-hidden="true"></a><span class="kw">class</span> _IndentBuilder(_Builder):</span>
<span id="cb56-54"><a href="#cb56-54" aria-hidden="true"></a></span>
<span id="cb56-55"><a href="#cb56-55" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-56"><a href="#cb56-56" aria-hidden="true"></a>        output.indentation <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb56-57"><a href="#cb56-57" aria-hidden="true"></a></span>
<span id="cb56-58"><a href="#cb56-58" aria-hidden="true"></a><span class="kw">class</span> _DedentBuilder(_Builder):</span>
<span id="cb56-59"><a href="#cb56-59" aria-hidden="true"></a></span>
<span id="cb56-60"><a href="#cb56-60" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-61"><a href="#cb56-61" aria-hidden="true"></a>        output.indentation <span class="op">-=</span> <span class="dv">1</span></span></code></pre></div>
<h3 id="matchrule"><span id="fc62b5be27fd4e40978d415ba4070a05"></span>MatchRule</h3>
<p>When a <code>MatchRule</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchRule = py:x -&gt; { &quot;I(&#39;CALL&#39;, &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>CALL &lt;x&gt;</code></pre>
<p><a href="#8e19cbb2e71c412f95c7e241a69f0901"><em>CALL</em></a> instructs the VM to call the given rule.</p>
<h3 id="matchrange"><span id="ce3171f9336a4f1a961f4d6fd6665361"></span>MatchRange</h3>
<p>When a <code>MatchRange</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchRange = py:x py:y -&gt; { &quot;I(&#39;MATCH_RANGE&#39;, &quot; x &quot;, &quot; y &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_RANGE &lt;x&gt; &lt;y&gt;</code></pre>
<p><a href="#d8dcb57d5da141908f28f8c52983d1a6"><em>MATCH_RANGE</em></a> instructs the VM to match an object in the given range.</p>
<h3 id="fcdbbabfe44b009d3f405060a2055fmatchstring">[]{#40fcdbbabfe44b009d3f405060a2055f}MatchString</h3>
<p>When a <code>MatchString</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchString = py:x -&gt; { &quot;I(&#39;MATCH_STRING&#39;, &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_STRING &lt;x&gt;</code></pre>
<p><a href="#a8160d30b886418882ada3a2a884e580"><em>MATCH_STRING</em></a> instructs the VM to match the given string.</p>
<h3 id="matchcharseq"><span id="c6e2326b6b774601b761538455918bbe"></span>MatchCharseq</h3>
<p>When a <code>MatchCharseq</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchCharseq = py:x -&gt; { &quot;I(&#39;MATCH_CHARSEQ&#39;, &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_CHARSEQ &lt;x&gt;</code></pre>
<p><a href="#df5dc1b5e5054e548d5c3606daba0d55"><em>MATCH_CHARSEQ</em></a> instructs the VM to match the given sequence of characters.</p>
<h3 id="matchany"><span id="de0847d410c6495d9a8ee4e75a0423cc"></span>MatchAny</h3>
<p>When a <code>MatchAny</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchAny = -&gt; { &quot;I(&#39;MATCH_ANY&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_ANY</code></pre>
<p><a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> instructs the VM to match any object.</p>
<h3 id="dc829aba4484ed399eb025d01ed843ematchlist">[]{#1dc829aba4484ed399eb025d01ed843e}MatchList</h3>
<p>When a <code>MatchList</code> AST node is matched, instructions changing the input stream are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchList = ast:x -&gt; { &quot;I(&#39;PUSH_STREAM&#39;)\n&quot;
                       x
                       &quot;I(&#39;POP_STREAM&#39;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>PUSH_STREAM
&lt;x instructions&gt;
POP_STREAM</code></pre>
<p><a href="#fee2dcf573f04ac3a9e7cfd92adbe0c8"><em>PUSH_STREAM</em></a> instructs the VM to push the current input object onto the stack so that <code>x</code> instructions see it as the current input stream. <a href="#87a1eee2cfb94e1a9463a6561c226012"><em>POP_STREAM</em></a> instructs the VM to pop this input stream off the stack.</p>
<h3 id="cc83570ba674d71bccd12660fddefccexample-revisited">[]{#6cc83570ba674d71bccd12660fddefcc}Example revisited</h3>
<p>The generated instructions for the <code>Scream</code> grammar from the beginning of the article should now make more sense:</p>
<pre class="text"><code>Scream {
  scream = char*:xs -&gt; { xs &quot;!!&quot; }
  char   = .:x      -&gt; upper(x)
}</code></pre>
<pre class="text"><code>class Scream(_Grammar):

    def __init__(self):
        self._instructions = i = []
        self._labels = l = {}
        def I(name, x=None, y=None):
            i.append((name, x, y))
        def LABEL(name):
            l[name] = len(i)
        LABEL(&#39;scream&#39;)
        I(&#39;PUSH_SCOPE&#39;)
        I(&#39;LIST_START&#39;)
        LABEL(0)
        I(&#39;BACKTRACK&#39;, 1)
        I(&#39;CALL&#39;, &#39;char&#39;)
        I(&#39;LIST_APPEND&#39;)
        I(&#39;COMMIT&#39;, 0)
        LABEL(1)
        I(&#39;LIST_END&#39;)
        I(&#39;BIND&#39;, &#39;xs&#39;)
        I(&#39;ACTION&#39;, lambda scope: _Builder.create([scope[&#39;xs&#39;].eval(), &#39;!!&#39;]))
        I(&#39;POP_SCOPE&#39;)
        I(&#39;RETURN&#39;)
        LABEL(&#39;char&#39;)
        I(&#39;PUSH_SCOPE&#39;)
        I(&#39;MATCH_ANY&#39;)
        I(&#39;BIND&#39;, &#39;x&#39;)
        I(&#39;ACTION&#39;, lambda scope: upper(scope[&#39;x&#39;].eval()))
        I(&#39;POP_SCOPE&#39;)
        I(&#39;RETURN&#39;)</code></pre>
<p>There are two labels for the two rules in the grammar. Both blocks of instructions end with a <code>RETURN</code> instruction so that those functions can be called and returned from. The blocks are are also wrapped in <code>PUSH_SCOPE</code>/<code>POP_SCOPE</code> instructions so that variable bindings for the different calls happen in different scopes. Otherwise they would overwrite each other. The <code>scream</code> rule has a repetition and therefore also the <code>LIST_*</code> instructions. It also has generated label names (<code>0</code> and <code>1</code>) to create the loop. The <code>BIND</code> instructions bind the last result to a name in the current scope. The <code>ACTION</code> instructions have Python lambdas as first argument that are evaluated when there is a match. They get one argument which is the scope that was active when the action was defined.</p>
<p>Now let's move on to the implementation of the VM to understand how the execution of these instructions work.</p>
<h2 id="vm"><span id="e66f8cec6206420abe4736ae32849c53"></span>VM</h2>
<p>The VM is implemented as a single Python function with the following definition:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}</code></pre>
<div class="sourceCode" id="cb78"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a><span class="kw">def</span> rlmeta_vm(instructions, labels, start_rule, stream):</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a>    <span class="op">&lt;&lt;</span>init<span class="op">&gt;&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a>    <span class="op">&lt;&lt;</span>loop<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>It takes a list of instructions to execute, a dictionary of labels, the name of the start rule, and the input stream. The init section sets up the VM state:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [init]{.cp}</code></pre>
<div class="sourceCode" id="cb80"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>label_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a>last_action <span class="op">=</span> _ConstantSemanticAction(<span class="va">None</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a>pc <span class="op">=</span> labels[start_rule]</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a>call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a>stream, pos, stream_pos_stack <span class="op">=</span> (stream, <span class="dv">0</span>, [])</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a>scope, scope_stack <span class="op">=</span> (<span class="va">None</span>, [])</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a>fail_message <span class="op">=</span> <span class="va">None</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a>latest_fail_message, latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true"></a>memo <span class="op">=</span> {}</span></code></pre></div>
<ul>
<li><code>label_counter</code> is used to generate unique <a href="#d7d285d9586b437ca7d7f51b5deb6193"><em>labels</em></a>.</li>
<li><code>last_action</code> stores the result of the last expression (which is always a semantic action).</li>
<li><code>pc</code> is the program counter that determines what instruction to execute. It is initialized to the position of the start rule.</li>
<li><code>call_backtrack_stack</code> keeps track of what <a href="#8e19cbb2e71c412f95c7e241a69f0901"><em>call</em></a> and <a href="#542906286e124874b2975d0ae23f034f"><em>backtrack</em></a> entries have been made.</li>
<li><code>stream</code> and <code>pos</code> is the topmost item in <code>stream_pos_stack</code> which keeps track of the current input stream and the position in it. (Input streams can be nested.) The topmost item is not stored in the list because it would make it slightly less convenient to modify.</li>
<li><code>scope</code> is the topmost item in <code>scope_stack</code> which keeps track of the current scope. The topmost item is not stored in the list because it would make it slightly less convenient to modify.</li>
<li><code>fail_message</code> stores the current fail message as a tuple representing arguments to string formatting. The fail message is not formatted immediately to avoid the extra speed cost of formatting if the message is not used. (Most fail messages are never used.)</li>
<li><code>latest_fail_message</code> and <code>latest_fail_pos</code> store the latest failure message and its position that will be presented to the user if all choices fail.</li>
<li><code>memo</code> is the memoization table that stores results of rule matches.</li>
</ul>
<p>In a picture it looks something like this:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
Overview of VM.
</center>
<p>After the init section comes the VM loop:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}</code></pre>
<div class="sourceCode" id="cb82"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a>    name, arg1, arg2 <span class="op">=</span> instructions[pc]</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true"></a>    <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;PUSH_SCOPE&quot;</span>:</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>PUSH_SCOPE<span class="op">&gt;&gt;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BACKTRACK&quot;</span>:</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>BACKTRACK<span class="op">&gt;&gt;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;CALL&quot;</span>:</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>CALL<span class="op">&gt;&gt;</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_CHARSEQ&quot;</span>:</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_CHARSEQ<span class="op">&gt;&gt;</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;COMMIT&quot;</span>:</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>COMMIT<span class="op">&gt;&gt;</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_SCOPE&quot;</span>:</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>POP_SCOPE<span class="op">&gt;&gt;</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;RETURN&quot;</span>:</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>RETURN<span class="op">&gt;&gt;</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_APPEND&quot;</span>:</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LIST_APPEND<span class="op">&gt;&gt;</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BIND&quot;</span>:</span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>BIND<span class="op">&gt;&gt;</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;ACTION&quot;</span>:</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>ACTION<span class="op">&gt;&gt;</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_RANGE&quot;</span>:</span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_RANGE<span class="op">&gt;&gt;</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_START&quot;</span>:</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LIST_START<span class="op">&gt;&gt;</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_END&quot;</span>:</span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LIST_END<span class="op">&gt;&gt;</span></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_ANY&quot;</span>:</span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_ANY<span class="op">&gt;&gt;</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;PUSH_STREAM&quot;</span>:</span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>PUSH_STREAM<span class="op">&gt;&gt;</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_STREAM&quot;</span>:</span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>POP_STREAM<span class="op">&gt;&gt;</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_CALL_RULE&quot;</span>:</span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_CALL_RULE<span class="op">&gt;&gt;</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;FAIL&quot;</span>:</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>FAIL<span class="op">&gt;&gt;</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LABEL&quot;</span>:</span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LABEL<span class="op">&gt;&gt;</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_STRING&quot;</span>:</span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_STRING<span class="op">&gt;&gt;</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&quot;unknown instruction </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(name))</span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true"></a>    <span class="op">&lt;&lt;</span>handle failure<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>First it fetches the instruction pointed to by the program counter. Then it has an if-chain with cases that handle the different instructions. If an instruction is not recognized, an exception is raised. Finally, it has code to handle a failure. Many instructions can fail and therefore this common code is at the end of the loop. If an instruction succeeds, it ends with a <code>continue</code> statement to ensure that the loop is started over immediately without executing the code to handle a failure.</p>
<p>The order in which the cases appear in the if-chain is important from a performance perspective. To get to the last case, all previous cases need to be tested, which takes time. So it is important that more common cases appear earlier in the if-chain. I did an instruction frequency analysis when RLMeta compiled itself to determine the most common instructions.</p>
<p>The VM makes use of two semantic actions that represent results from expressions: one for constant values and one for user defined functions:</p>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="kw">class</span> _ConstantSemanticAction(<span class="bu">object</span>):</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value):</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.value</span></code></pre></div>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="kw">class</span> _UserSemanticAction(<span class="bu">object</span>):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn, scope):</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true"></a>        <span class="va">self</span>.scope <span class="op">=</span> scope</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn(<span class="va">self</span>.scope)</span></code></pre></div>
<p>Let's move on to the implementation of each instruction.</p>
<h3 id="f0fffeab7084a1d9b01d928be4878a8match_any">[]{#8f0fffeab7084a1d9b01d928be4878a8}MATCH_ANY</h3>
<p>This instruction matches any object from the input stream:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_ANY]{.cp}</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(stream[pos])</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<p>The only time it fails is when the end of stream has been reached. In that case <code>fail_message</code> is set and no <code>continue</code> statement is executed to ensure that the code to <a href="#77edfc243204447ba84468c78f05d8e5"><em>handle this failure</em></a> is executed.</p>
<p>Otherwise, the last result is set to a semantic action that evaluates to the current input object. <code>pos</code> is incremented because one object has been consumed from the input stream. <code>pc</code> is incremented so that the next instruction is executed in the next loop iteration.</p>
<h3 id="match_string"><span id="a8160d30b886418882ada3a2a884e580"></span>MATCH_STRING</h3>
<p>This instruction works like <a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> but also fails if the current input object is not the string that is given as the first argument:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_STRING]{.cp}</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> stream[pos] <span class="op">!=</span> arg1:</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(arg1)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="match_range"><span id="d8dcb57d5da141908f28f8c52983d1a6"></span>MATCH_RANGE</h3>
<p>This instruction works like <a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> but also fails if the current input object is not in the range given as arguments:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_RANGE]{.cp}</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> (arg1 <span class="op">&lt;=</span> stream[pos] <span class="op">&lt;=</span> arg2):</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected range </span><span class="sc">{!r}</span><span class="st">-</span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1, arg2)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(stream[pos])</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="match_charseq"><span id="df5dc1b5e5054e548d5c3606daba0d55"></span>MATCH_CHARSEQ</h3>
<p>This instruction works as <a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> but also fails if the next input objects are not the characters in the string given as the first argument:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_CHARSEQ]{.cp}</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="cf">for</span> char <span class="kw">in</span> arg1:</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>    <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> stream[pos] <span class="op">!=</span> char:</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a>        fail_message <span class="op">=</span> (<span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st">&quot;</span>, char)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>        <span class="cf">break</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(arg1)</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="ca0a2fa665466cb90c8c128d5cc835push_scope">[]{#49ca0a2fa665466cb90c8c128d5cc835}PUSH_SCOPE</h3>
<p>This instruction pushes a new scope onto the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [PUSH\_SCOPE]{.cp}</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a>scope_stack.append(scope)</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a>scope <span class="op">=</span> {}</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>Pushing a new scope onto the stack means moving the current scope to the list and assigning a new scope to the current scope. A scope is a dictionary mapping names to values.</p>
<h3 id="pop_scope"><span id="b2510846e20d4cd08f9b0cd2dfb5c01d"></span>POP_SCOPE</h3>
<p>This instruction pops a scope off the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [POP\_SCOPE]{.cp}</code></pre>
<div class="sourceCode" id="cb98"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a>scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<h3 id="e4aa99dd00ec5b524b1bind">[]{#1315305641224e4aa99dd00ec5b524b1}BIND</h3>
<p>This instruction binds the last result to the given name in the current scope:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [BIND]{.cp}</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a>scope[arg1] <span class="op">=</span> last_action</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<h3 id="fde86e4c7290b0f99850917ba8action">[]{#738356fde86e4c7290b0f99850917ba8}ACTION</h3>
<p>This instruction creates a user defined semantic action:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [ACTION]{.cp}</code></pre>
<div class="sourceCode" id="cb102"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a>last_action <span class="op">=</span> _UserSemanticAction(arg1, scope)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The first argument is a Python lambda that expects a scope as argument.</p>
<h3 id="label"><span id="d7d285d9586b437ca7d7f51b5deb6193"></span>LABEL</h3>
<p>This instruction creates a semantic action that evaluates to a unique number:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LABEL]{.cp}</code></pre>
<div class="sourceCode" id="cb104"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a>last_action <span class="op">=</span> _ConstantSemanticAction(label_counter)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a>label_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The label counter is incremented to make all labels unique.</p>
<h3 id="list_start"><span id="b3562467300348028f04ae5034db0f34"></span>LIST_START</h3>
<p>This instruction creates a list for accumulating results:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LIST\_START]{.cp}</code></pre>
<div class="sourceCode" id="cb106"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a>scope_stack.append(scope)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true"></a>scope <span class="op">=</span> []</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The list is actually stored on the scope stack, but it could as well have been stored in the current scope under a special name.</p>
<h3 id="list_append"><span id="b4aacd38dec8406c9db784e0823c3554"></span>LIST_APPEND</h3>
<p>This instruction appends the last result to the accumulation list:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LIST\_APPEND]{.cp}</code></pre>
<div class="sourceCode" id="cb108"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true"></a>scope.append(last_action)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The current scope is assumed to be an accumulation list.</p>
<h3 id="cd44d7fe4777b1c12e335bac33aelist_end">[]{#9940cd44d7fe4777b1c12e335bac33ae}LIST_END</h3>
<p>This instruction makes the accumulation list the last result:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LIST\_END]{.cp}</code></pre>
<div class="sourceCode" id="cb110"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true"></a>last_action <span class="op">=</span> _UserSemanticAction(<span class="kw">lambda</span> xs: [x.<span class="bu">eval</span>() <span class="cf">for</span> x <span class="kw">in</span> xs], scope)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true"></a>scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The current scope is assumed to be an accumulation list.</p>
<p>The accumulation list is turned into a semantic action that evaluates to a list where each semantic action in the accumulation list is also evaluated.</p>
<h3 id="push_stream"><span id="fee2dcf573f04ac3a9e7cfd92adbe0c8"></span>PUSH_STREAM</h3>
<p>This instruction pushes the current input object onto the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [PUSH\_STREAM]{.cp}</code></pre>
<div class="sourceCode" id="cb112"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(stream[pos], <span class="bu">list</span>):</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected list&quot;</span>,)</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true"></a>    stream_pos_stack.append((stream, pos))</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true"></a>    stream <span class="op">=</span> stream[pos]</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true"></a>    pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<p>It fails if the current input object is not a list. Only lists can become input streams.</p>
<p>Otherwise the current input object becomes the current input stream and the position is set to 0.</p>
<h3 id="a1eee2cfb94e1a9463a6561c226012pop_stream">[]{#87a1eee2cfb94e1a9463a6561c226012}POP_STREAM</h3>
<p>This instruction pops an input stream off the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [POP\_STREAM]{.cp}</code></pre>
<div class="sourceCode" id="cb114"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&lt;</span> <span class="bu">len</span>(stream):</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected end of list&quot;</span>,)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true"></a>    stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<p>It fails if not all items in the input stream have been consumed.</p>
<p>The position that is stored on the stack refers to the position where the input stream was found. This input stream has now been consumed so the position is therefore incremented.</p>
<h3 id="cae29994179abbe19f2f7e4c267fail">[]{#34915cae29994179abbe19f2f7e4c267}FAIL</h3>
<p>This instruction causes an explicit failure with the given message:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [FAIL]{.cp}</code></pre>
<div class="sourceCode" id="cb116"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true"></a>fail_message <span class="op">=</span> (arg1,)</span></code></pre></div>
<h3 id="e19cbb2e71c412f95c7e241a69f0901call">[]{#8e19cbb2e71c412f95c7e241a69f0901}CALL</h3>
<p>This instruction calls the given rule:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [CALL]{.cp}</code></pre>
<div class="sourceCode" id="cb118"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true"></a>key <span class="op">=</span> (arg1, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true"></a><span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true"></a>    last_action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true"></a>    stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true"></a>    stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true"></a>    call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true"></a>    pc <span class="op">=</span> labels[arg1]</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>It fist generates a key which consists of the name of the rule and the current position in the input stream. Example key: <code>('Label', (0, 1, 3))</code>. If this rule has matched at this position before, the memoized result is used. Otherwise a call is made.</p>
<p>The memoized result consists of the result from calling the rule and the state of the input stream. The memoized state is assigned to the VM state. The state of the input stream stored in the memoization table can not be modified, hence the <code>stream_pos_stack[:]</code>.</p>
<p>To make a call, the next program counter and the key is appended to the stack. The next program counter stores the position where to continue execution, and the key is used to store the result in the memoization table. See <a href="#d104aa6d6b8e43818f662498f6566e38"><em>RETURN</em></a> for how its done.</p>
<h3 id="match_call_rule"><span id="d42df29209bf475280ac510d9ae31182"></span>MATCH_CALL_RULE</h3>
<p>This instruction works like <a href="#8e19cbb2e71c412f95c7e241a69f0901"><em>CALL</em></a> but instead of getting the rule name from the instruction argument, it gets it from the input stream.</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_CALL\_RULE]{.cp}</code></pre>
<div class="sourceCode" id="cb120"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true"></a>    fn_name <span class="op">=</span> <span class="bu">str</span>(stream[pos])</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true"></a>    key <span class="op">=</span> (fn_name, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true"></a>    <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true"></a>        last_action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true"></a>        stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true"></a>        stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true"></a>        pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true"></a>        call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true"></a>        pc <span class="op">=</span> labels[fn_name]</span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true"></a>        pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="return"><span id="d104aa6d6b8e43818f662498f6566e38"></span>RETURN</h3>
<p>This instruction makes execution continue at wherever it was before the current rule was called:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [RETURN]{.cp}</code></pre>
<div class="sourceCode" id="cb122"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(call_backtrack_stack) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true"></a>    <span class="cf">return</span> last_action.<span class="bu">eval</span>()</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true"></a>pc, key <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true"></a>memo[key] <span class="op">=</span> (last_action, stream_pos_stack<span class="op">+</span>[(stream, pos)])</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>If the stack is empty, it means that the end of the <code>start_rule</code> has been reached. In that case, the result is returned from the VM. Otherwise the <code>pc</code> is set to the position that was pushed onto the stack. The memoization table is also filled in.</p>
<h3 id="e124874b2975d0ae23f034fbacktrack">[]{#542906286e124874b2975d0ae23f034f}BACKTRACK</h3>
<p>This instruction pushes a backtrack entry onto the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [BACKTRACK]{.cp}</code></pre>
<div class="sourceCode" id="cb124"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true"></a>call_backtrack_stack.append((labels[arg1], pos, <span class="bu">len</span>(stream_pos_stack), <span class="bu">len</span>(scope_stack)))</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>A backtrack entry consists of the following:</p>
<ul>
<li>The position where to continue execution. The label is given as the fist argument to, so its position is looked up in the labels dictionary.</li>
<li>The position in the input stream where to try matching again.</li>
<li>The length of the stream stack.</li>
<li>The length of the scope stack.</li>
</ul>
<p>This information is enough to reset the state and try matching the next choice at the current position. Actual backtracking is done in <a href="#77edfc243204447ba84468c78f05d8e5"><em>Handling failure</em></a>.</p>
<h3 id="b99ed36fbde45989829fde6e17d4821commit">[]{#5b99ed36fbde45989829fde6e17d4821}COMMIT</h3>
<p>This instruction pops a backtrack entry off the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [COMMIT]{.cp}</code></pre>
<div class="sourceCode" id="cb126"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true"></a>call_backtrack_stack.pop()</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true"></a>pc <span class="op">=</span> labels[arg1]</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The popped item is assumed to be a backtrack entry, and not a call entry.</p>
<p>The entry is ignored since the choice succeeded and no backtracking is needed.</p>
<h3 id="edfc243204447ba84468c78f05d8e5handling-failure">[]{#77edfc243204447ba84468c78f05d8e5}Handling failure</h3>
<p>The first step in handling a failure is to figure out if this failure should be presented to the user. It is done based on the position where the failure occurred. Failures occurring at later positions are assumed to be more relevant. The latest fail message is saved like this:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb128"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true"></a>fail_pos <span class="op">=</span> <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos])</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true"></a><span class="cf">if</span> fail_pos <span class="op">&gt;=</span> latest_fail_pos:</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true"></a>    latest_fail_message <span class="op">=</span> fail_message</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true"></a>    latest_fail_pos <span class="op">=</span> fail_pos</span></code></pre></div>
<p>Next actual backtracking is done. Items are popped off the stack until a backtrack entry is found. Backtrack entries are tuples with 4 arguments.</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb130"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true"></a>call_backtrack_entry <span class="op">=</span> <span class="bu">tuple</span>()</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true"></a><span class="cf">while</span> call_backtrack_stack:</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true"></a>    call_backtrack_entry <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true"></a>        <span class="cf">break</span></span></code></pre></div>
<p>If no backtrack entry is found, matching failed completely and the user is notified with an exception. The latest fail message is passed to the exception along with the position and input stream where the failure occurred.</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb132"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true"></a>    fail_pos <span class="op">=</span> <span class="bu">list</span>(latest_fail_pos)</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true"></a>    fail_stream <span class="op">=</span> stream_pos_stack[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> stream_pos_stack <span class="cf">else</span> stream</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true"></a>    <span class="cf">while</span> <span class="bu">len</span>(fail_pos) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true"></a>        fail_stream <span class="op">=</span> fail_stream[fail_pos.pop(<span class="dv">0</span>)]</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true"></a>    <span class="cf">raise</span> _MatchError(latest_fail_message, fail_pos[<span class="dv">0</span>], fail_stream)</span></code></pre></div>
<p>The exception has a <code>describe</code> method that formats the error nicely for the user:</p>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb134"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true"></a><span class="kw">class</span> _MatchError(<span class="pp">Exception</span>):</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true"></a></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, message, pos, stream):</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true"></a>        <span class="va">self</span>.message <span class="op">=</span> message</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true"></a>        <span class="va">self</span>.pos <span class="op">=</span> pos</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true"></a>        <span class="va">self</span>.stream <span class="op">=</span> stream</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true"></a></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true"></a>    <span class="kw">def</span> describe(<span class="va">self</span>):</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true"></a>        message <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.stream, <span class="bu">basestring</span>):</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true"></a>            before <span class="op">=</span> <span class="va">self</span>.stream[:<span class="va">self</span>.pos].splitlines()</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true"></a>            after <span class="op">=</span> <span class="va">self</span>.stream[<span class="va">self</span>.pos:].splitlines()</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true"></a>            <span class="cf">for</span> context_before <span class="kw">in</span> before[<span class="op">-</span><span class="dv">4</span>:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(context_before)</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(before[<span class="op">-</span><span class="dv">1</span>], after[<span class="dv">0</span>])</span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._arrow(<span class="bu">len</span>(before[<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true"></a>            <span class="cf">for</span> context_after <span class="kw">in</span> after[<span class="dv">1</span>:<span class="dv">4</span>]:</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(context_after)</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;[&quot;</span>)</span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true"></a>            <span class="cf">for</span> context_before <span class="kw">in</span> <span class="va">self</span>.stream[:<span class="va">self</span>.pos]:</span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;  &quot;</span>, <span class="bu">repr</span>(context_before), <span class="st">&quot;,&quot;</span>)</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;  &quot;</span>, <span class="bu">repr</span>(<span class="va">self</span>.stream[<span class="va">self</span>.pos]), <span class="st">&quot;,&quot;</span>)</span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._arrow(<span class="dv">2</span>)</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true"></a>            <span class="cf">for</span> context_after <span class="kw">in</span> <span class="va">self</span>.stream[<span class="va">self</span>.pos<span class="op">+</span><span class="dv">1</span>:]:</span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;  &quot;</span>, <span class="bu">repr</span>(context_after), <span class="st">&quot;,&quot;</span>)</span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;]&quot;</span>)</span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true"></a>        message <span class="op">+=</span> <span class="st">&quot;Error: &quot;</span></span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true"></a>        message <span class="op">+=</span> <span class="va">self</span>.message[<span class="dv">0</span>].<span class="bu">format</span>(<span class="op">*</span><span class="va">self</span>.message[<span class="dv">1</span>:])</span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true"></a>        message <span class="op">+=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true"></a>        <span class="cf">return</span> message</span>
<span id="cb134-33"><a href="#cb134-33" aria-hidden="true"></a></span>
<span id="cb134-34"><a href="#cb134-34" aria-hidden="true"></a>    <span class="kw">def</span> _context(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb134-35"><a href="#cb134-35" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;&gt; </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;&quot;</span>.join(args))</span>
<span id="cb134-36"><a href="#cb134-36" aria-hidden="true"></a></span>
<span id="cb134-37"><a href="#cb134-37" aria-hidden="true"></a>    <span class="kw">def</span> _arrow(<span class="va">self</span>, lenght):</span>
<span id="cb134-38"><a href="#cb134-38" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;--</span><span class="sc">{}</span><span class="st">^</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;-&quot;</span><span class="op">*</span>lenght)</span></code></pre></div>
<p>If the input stream is a string, the character where the failure occurred is highlighted with a few context lines around it like this:</p>
<pre class="text"><code>&gt;     | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
&gt;   expr =
&gt;     | expr1:x space &#39;:&#39; name:y                 -&gt; [&quot;Bind&quot; y x
&gt;     | expr1
------^
&gt;   expr1 =
&gt;     | expr2:x space &#39;*&#39;                        -&gt; [&quot;Star&quot; x]
&gt;     | expr2:x space &#39;?&#39;                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
Error: expected &#39;]&#39;</code></pre>
<p>If the input stream is a list, the whole list is printed as context, and the item where the failure occurred is highlighted like this:</p>
<pre class="text"><code>&gt; [
&gt;   &#39;Bind&#39;,
&gt;   &#39;x&#39;,
&gt;   [&#39;MatchRule&#39;, &#39;name&#39;],
&gt;   &#39;foo&#39;,
----^
&gt; ]
Error: expected end of list</code></pre>
<p>Finally the state of the VM is restored:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb138"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true"></a>(pc, pos, stream_stack_len, scope_stack_len) <span class="op">=</span> call_backtrack_entry</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(stream_pos_stack) <span class="op">&gt;</span> stream_stack_len:</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true"></a>    stream <span class="op">=</span> stream_pos_stack[stream_stack_len][<span class="dv">0</span>]</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true"></a>stream_pos_stack <span class="op">=</span> stream_pos_stack[:stream_stack_len]</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(scope_stack) <span class="op">&gt;</span> scope_stack_len:</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true"></a>    scope <span class="op">=</span> scope_stack[scope_stack_len]</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true"></a>scope_stack <span class="op">=</span> scope_stack[:scope_stack_len]</span></code></pre></div>
<p>The program counter and the position is restored from the backtrack entry. The stack lengths are used to restore the stacks. A failure might have occurred deeper in the input stream than when the backtrack entry was created. Similarly for the scope. Those stacks are therefore restored so they have the same length as in the backtrack entry.</p>
<h3 id="ffb1abf59546e1972c78ee7159b758optimizations">[]{#95ffb1abf59546e1972c78ee7159b758}Optimizations</h3>
<p>The <code>rlmeta_vm</code> function is heavily optimized for speed. Here are a few choices made:</p>
<ul>
<li>It is implemented as a single function to avoid function calls.</li>
<li>It handles instructions in a specific order based on how often they are used.</li>
<li>It duplicates code to avoid some Python instructions.
<ul>
<li>Most instructions increments the program counter. That could be done always, and then only instructions that need to do something other than incrementing could do that. But in those cases, some extra Python instructions would be executed.</li>
<li>The code for the two call instructions have some similar code.</li>
<li>All instructions use <code>continue</code> statements instead of the failure handling checking if a fail message was actually set.</li>
</ul></li>
</ul>
<p>These optimizations makes the VM faster and also a little harder to maintain. But it's a trade off.</p>
<h2 id="e3ad1de345642658be2e5910ab5be4enote-on-size">[]{#2e3ad1de345642658be2e5910ab5be4e}Note on size</h2>
<p>Compared to the optimized version, the VM based version is a little bigger:</p>
<pre class="text"><code> 53 parser.rlmeta
 74 codegenerator.rlmeta
302 support.py
 45 compile.sh
474 total</code></pre>
<p>That is 474 lines of code compared to 429 in the optimized version. The <code>rlmeta_vm</code> function is quite optimized and therefore is slightly longer than it could have been. But 474 lines is still small.</p>
<h2 id="note-on-performance"><span id="c490369b053247c0b7761f324658aa15"></span>Note on performance</h2>
<p>The VM based version also turns out to be faster than the <a href="/writing/optimizing-rlmeta/index.html#3616eda03f5c40458ac9439def097739">optimized version</a>:</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
</center>
<p>Being faster was not a goal with the VM based version, but it's and interesting side effect. Perhaps more programming problems would benefit from a VM based approach? There are probably also more optimizations that can be made to the instructions to make the VM even faster.</p>
<h2 id="e7b4c5318ff4c849c6e98e9ddeaacf0code-listings-for-rlmeta">[]{#7e7b4c5318ff4c849c6e98e9ddeaacf0}Code listings for RLMeta</h2>
<h3 id="f0708b231b468d844291df3fe17cf2parser.rlmeta">[]{#53f0708b231b468d844291df3fe17cf2}parser.rlmeta</h3>
<pre class="text"><code>Parser {
  grammar =
    | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space &#39;=&#39; choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space &#39;|&#39;)?
      sequence:x (space &#39;|&#39; sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space &#39;:&#39; name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space &#39;*&#39;                        -&gt; [&quot;Star&quot; x]
    | expr2:x space &#39;?&#39;                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space &#39;!&#39; expr2:x                        -&gt; [&quot;Not&quot; x]
    | space &#39;%&#39;                                -&gt; [&quot;MatchCallRule&quot;]
    | space &#39;#&#39;                                -&gt; [&quot;Label&quot;]
    | expr2
  expr2 =
    | space &#39;-&gt;&#39; hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space &#39;=&#39;)                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x &#39;-&#39; char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space &#39;.&#39;                                -&gt; [&quot;MatchAny&quot;]
    | space &#39;(&#39; choice:x space &#39;)&#39;             -&gt; x
    | space &#39;[&#39; expr*:xs space &#39;]&#39;             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space &#39;[&#39; hostExprListItem*:xs space &#39;]&#39; -&gt; [&quot;List&quot; ~xs]
    | space &#39;{&#39; buildExpr*:xs space &#39;}&#39;        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space &#39;~&#39; hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space &#39;&gt;&#39;                                -&gt; [&quot;IndentBuilder&quot;]
    | space &#39;&lt;&#39;                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;   -&gt; join(xs)
  charseq   = &#39;\&#39;&#39; (!&#39;\&#39;&#39; innerChar)*:xs &#39;\&#39;&#39;  -&gt; join(xs)
  char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39;  -&gt; x
  innerChar = &#39;\\&#39; escape | .
  escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
            | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
  nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;
  space     = (&#39; &#39; | &#39;\n&#39;)*
}</code></pre>
<h3 id="bf51f7e8d94bcba1747edb477137efcodegenerator.rlmeta">[]{#74bf51f7e8d94bcba1747edb477137ef}codegenerator.rlmeta</h3>
<pre class="text"><code>CodeGenerator {
  ast            = [%:x]           -&gt; x
  py             = .:x             -&gt; repr(x)
  Grammar        = .:x ast*:ys     -&gt; { &quot;class &quot; x &quot;(_Grammar):\n\n&quot; &gt;
                                          &quot;def __init__(self):\n&quot; &gt;
                                            &quot;self._instructions = i = []\n&quot;
                                            &quot;self._labels = l = {}\n&quot;
                                            &quot;def I(name, x=None, y=None):\n&quot; &gt;
                                              &quot;i.append((name, x, y))\n&quot;
                                            &lt;
                                            &quot;def LABEL(name):\n&quot; &gt;
                                              &quot;l[name] = len(i)\n&quot;
                                            &lt;
                                            ys
                                          &lt;
                                        &lt;                                    }
  Rule           = py:x ast:y      -&gt; { &quot;LABEL(&quot; x &quot;)\n&quot;
                                        y
                                        &quot;I(&#39;RETURN&#39;)\n&quot;                      }
  Or             =
    | ast:x Or:y #:a #:b           -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; a &quot;)\n&quot;
                                        x
                                        &quot;I(&#39;COMMIT&#39;, &quot; b &quot;)\n&quot;
                                        &quot;LABEL(&quot; a &quot;)\n&quot;
                                        y
                                        &quot;LABEL(&quot; b &quot;)\n&quot;                     }
    | ast
  Scope          = ast:x           -&gt; { &quot;I(&#39;PUSH_SCOPE&#39;)\n&quot;
                                        x
                                        &quot;I(&#39;POP_SCOPE&#39;)\n&quot;                   }
  And            = ast*
  Bind           = py:x ast:y      -&gt; { y
                                        &quot;I(&#39;BIND&#39;, &quot; x &quot;)\n&quot;                 }
  Star           = ast:x #:a #:b   -&gt; { &quot;I(&#39;LIST_START&#39;)\n&quot;
                                        &quot;LABEL(&quot; a &quot;)\n&quot;
                                        &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                                        x
                                        &quot;I(&#39;LIST_APPEND&#39;)\n&quot;
                                        &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                                        &quot;LABEL(&quot; b &quot;)\n&quot;
                                        &quot;I(&#39;LIST_END&#39;)\n&quot;                    }
  Not            = ast:x #:a #:b   -&gt; { &quot;I(&#39;BACKTRACK&#39;, &quot; b &quot;)\n&quot;
                                        x
                                        &quot;I(&#39;COMMIT&#39;, &quot; a &quot;)\n&quot;
                                        &quot;LABEL(&quot; a &quot;)\n&quot;
                                        &quot;I(&#39;FAIL&#39;, &#39;no match expected&#39;)\n&quot;
                                        &quot;LABEL(&quot; b &quot;)\n&quot;                     }
  MatchCallRule  =                 -&gt; { &quot;I(&#39;MATCH_CALL_RULE&#39;)\n&quot;             }
  Label          =                 -&gt; { &quot;I(&#39;LABEL&#39;)\n&quot;                       }
  SemanticAction = ast:x           -&gt; { &quot;I(&#39;ACTION&#39;, lambda scope: &quot; x &quot;)\n&quot; }
  String         = py
  List           = astList
  Builder        = astItems:x      -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot;           }
  IndentBuilder  =                 -&gt; { &quot;_IndentBuilder()&quot;                   }
  DedentBuilder  =                 -&gt; { &quot;_DedentBuilder()&quot;                   }
  FnCall         = .:x astItems:y  -&gt; { x &quot;(&quot; y &quot;)&quot;                          }
  VarLookup      = py:x            -&gt; { &quot;scope[&quot; x &quot;].eval()&quot;                }
  astItems       =
    | ast:x astItem*:xs            -&gt; { x xs                                 }
    |                              -&gt; {                                      }
  astItem        = ast:x           -&gt; { &quot;, &quot; x                               }
  astList        = astListItem*:xs -&gt; { &quot;(&quot; xs &quot;[])&quot;                         }
  astListItem    =
    | [&quot;ListItemSplice&quot; ast:x]     -&gt; {     x  &quot;+&quot;                           }
    | ast:x                        -&gt; { &quot;[&quot; x &quot;]+&quot;                           }
  MatchRule      = py:x            -&gt; { &quot;I(&#39;CALL&#39;, &quot; x &quot;)\n&quot;                 }
  MatchRange     = py:x py:y       -&gt; { &quot;I(&#39;MATCH_RANGE&#39;, &quot; x &quot;, &quot; y &quot;)\n&quot;   }
  MatchString    = py:x            -&gt; { &quot;I(&#39;MATCH_STRING&#39;, &quot; x &quot;)\n&quot;         }
  MatchCharseq   = py:x            -&gt; { &quot;I(&#39;MATCH_CHARSEQ&#39;, &quot; x &quot;)\n&quot;        }
  MatchAny       =                 -&gt; { &quot;I(&#39;MATCH_ANY&#39;)\n&quot;                   }
  MatchList      = ast:x           -&gt; { &quot;I(&#39;PUSH_STREAM&#39;)\n&quot;
                                        x
                                        &quot;I(&#39;POP_STREAM&#39;)\n&quot;                  }
}</code></pre>
<h3 id="ff77cb85fa455589e3e45cdeac8160support.py">[]{#60ff77cb85fa455589e3e45cdeac8160}support.py</h3>
<pre class="text"><code>try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

def rlmeta_vm(instructions, labels, start_rule, stream):
    label_counter = 0
    last_action = _ConstantSemanticAction(None)
    pc = labels[start_rule]
    call_backtrack_stack = []
    stream, pos, stream_pos_stack = (stream, 0, [])
    scope, scope_stack = (None, [])
    fail_message = None
    latest_fail_message, latest_fail_pos = (None, tuple())
    memo = {}
    while True:
        name, arg1, arg2 = instructions[pc]
        if name == &quot;PUSH_SCOPE&quot;:
            scope_stack.append(scope)
            scope = {}
            pc += 1
            continue
        elif name == &quot;BACKTRACK&quot;:
            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))
            pc += 1
            continue
        elif name == &quot;CALL&quot;:
            key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))
            if key in memo:
                last_action, stream_pos_stack = memo[key]
                stream_pos_stack = stream_pos_stack[:]
                stream, pos = stream_pos_stack.pop()
                pc += 1
            else:
                call_backtrack_stack.append((pc+1, key))
                pc = labels[arg1]
            continue
        elif name == &quot;MATCH_CHARSEQ&quot;:
            for char in arg1:
                if pos &gt;= len(stream) or stream[pos] != char:
                    fail_message = (&quot;expected {!r}&quot;, char)
                    break
                pos += 1
            else:
                last_action = _ConstantSemanticAction(arg1)
                pc += 1
                continue
        elif name == &quot;COMMIT&quot;:
            call_backtrack_stack.pop()
            pc = labels[arg1]
            continue
        elif name == &quot;POP_SCOPE&quot;:
            scope = scope_stack.pop()
            pc += 1
            continue
        elif name == &quot;RETURN&quot;:
            if len(call_backtrack_stack) == 0:
                return last_action.eval()
            pc, key = call_backtrack_stack.pop()
            memo[key] = (last_action, stream_pos_stack+[(stream, pos)])
            continue
        elif name == &quot;LIST_APPEND&quot;:
            scope.append(last_action)
            pc += 1
            continue
        elif name == &quot;BIND&quot;:
            scope[arg1] = last_action
            pc += 1
            continue
        elif name == &quot;ACTION&quot;:
            last_action = _UserSemanticAction(arg1, scope)
            pc += 1
            continue
        elif name == &quot;MATCH_RANGE&quot;:
            if pos &gt;= len(stream) or not (arg1 &lt;= stream[pos] &lt;= arg2):
                fail_message = (&quot;expected range {!r}-{!r}&quot;, arg1, arg2)
            else:
                last_action = _ConstantSemanticAction(stream[pos])
                pos += 1
                pc += 1
                continue
        elif name == &quot;LIST_START&quot;:
            scope_stack.append(scope)
            scope = []
            pc += 1
            continue
        elif name == &quot;LIST_END&quot;:
            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)
            scope = scope_stack.pop()
            pc += 1
            continue
        elif name == &quot;MATCH_ANY&quot;:
            if pos &gt;= len(stream):
                fail_message = (&quot;expected any&quot;,)
            else:
                last_action = _ConstantSemanticAction(stream[pos])
                pos += 1
                pc += 1
                continue
        elif name == &quot;PUSH_STREAM&quot;:
            if pos &gt;= len(stream) or not isinstance(stream[pos], list):
                fail_message = (&quot;expected list&quot;,)
            else:
                stream_pos_stack.append((stream, pos))
                stream = stream[pos]
                pos = 0
                pc += 1
                continue
        elif name == &quot;POP_STREAM&quot;:
            if pos &lt; len(stream):
                fail_message = (&quot;expected end of list&quot;,)
            else:
                stream, pos = stream_pos_stack.pop()
                pos += 1
                pc += 1
                continue
        elif name == &quot;MATCH_CALL_RULE&quot;:
            if pos &gt;= len(stream):
                fail_message = (&quot;expected any&quot;,)
            else:
                fn_name = str(stream[pos])
                key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))
                if key in memo:
                    last_action, stream_pos_stack = memo[key]
                    stream_pos_stack = stream_pos_stack[:]
                    stream, pos = stream_pos_stack.pop()
                    pc += 1
                else:
                    call_backtrack_stack.append((pc+1, key))
                    pc = labels[fn_name]
                    pos += 1
                continue
        elif name == &quot;FAIL&quot;:
            fail_message = (arg1,)
        elif name == &quot;LABEL&quot;:
            last_action = _ConstantSemanticAction(label_counter)
            label_counter += 1
            pc += 1
            continue
        elif name == &quot;MATCH_STRING&quot;:
            if pos &gt;= len(stream) or stream[pos] != arg1:
                fail_message = (&quot;expected {!r}&quot;, arg1)
            else:
                last_action = _ConstantSemanticAction(arg1)
                pos += 1
                pc += 1
                continue
        else:
            raise Exception(&quot;unknown instruction {}&quot;.format(name))
        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])
        if fail_pos &gt;= latest_fail_pos:
            latest_fail_message = fail_message
            latest_fail_pos = fail_pos
        call_backtrack_entry = tuple()
        while call_backtrack_stack:
            call_backtrack_entry = call_backtrack_stack.pop()
            if len(call_backtrack_entry) == 4:
                break
        if len(call_backtrack_entry) != 4:
            fail_pos = list(latest_fail_pos)
            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream
            while len(fail_pos) &gt; 1:
                fail_stream = fail_stream[fail_pos.pop(0)]
            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)
        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry
        if len(stream_pos_stack) &gt; stream_stack_len:
            stream = stream_pos_stack[stream_stack_len][0]
        stream_pos_stack = stream_pos_stack[:stream_stack_len]
        if len(scope_stack) &gt; scope_stack_len:
            scope = scope_stack[scope_stack_len]
        scope_stack = scope_stack[:scope_stack_len]

class _Grammar(object):

    def run(self, rule_name, input_object):
        if isinstance(input_object, basestring):
            stream = input_object
        else:
            stream = [input_object]
        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)
        if isinstance(result, _Builder):
            return result.build_string()
        else:
            return result

class _Builder(object):

    def build_string(self):
        output = _Output()
        self.write(output)
        return output.value

    @classmethod
    def create(self, item):
        if isinstance(item, _Builder):
            return item
        elif isinstance(item, list):
            return _ListBuilder([_Builder.create(x) for x in item])
        else:
            return _AtomBuilder(item)

class _Output(object):

    def __init__(self):
        self.buffer = StringIO()
        self.indentation = 0
        self.on_newline = True

    @property
    def value(self):
        return self.buffer.getvalue()

    def write(self, value):
        for ch in value:
            is_linebreak = ch == &quot;\n&quot;
            if self.indentation and self.on_newline and not is_linebreak:
                self.buffer.write(&quot;    &quot;*self.indentation)
            self.buffer.write(ch)
            self.on_newline = is_linebreak

class _ListBuilder(_Builder):

    def __init__(self, builders):
        self.builders = builders

    def write(self, output):
        for builder in self.builders:
            builder.write(output)

class _AtomBuilder(_Builder):

    def __init__(self, atom):
        self.atom = atom

    def write(self, output):
        output.write(str(self.atom))

class _IndentBuilder(_Builder):

    def write(self, output):
        output.indentation += 1

class _DedentBuilder(_Builder):

    def write(self, output):
        output.indentation -= 1

class _ConstantSemanticAction(object):

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

class _UserSemanticAction(object):

    def __init__(self, fn, scope):
        self.fn = fn
        self.scope = scope

    def eval(self):
        return self.fn(self.scope)

class _MatchError(Exception):

    def __init__(self, message, pos, stream):
        Exception.__init__(self)
        self.message = message
        self.pos = pos
        self.stream = stream

    def describe(self):
        message = &quot;&quot;
        if isinstance(self.stream, basestring):
            before = self.stream[:self.pos].splitlines()
            after = self.stream[self.pos:].splitlines()
            for context_before in before[-4:-1]:
                message += self._context(context_before)
            message += self._context(before[-1], after[0])
            message += self._arrow(len(before[-1]))
            for context_after in after[1:4]:
                message += self._context(context_after)
        else:
            message += self._context(&quot;[&quot;)
            for context_before in self.stream[:self.pos]:
                message += self._context(&quot;  &quot;, repr(context_before), &quot;,&quot;)
            message += self._context(&quot;  &quot;, repr(self.stream[self.pos]), &quot;,&quot;)
            message += self._arrow(2)
            for context_after in self.stream[self.pos+1:]:
                message += self._context(&quot;  &quot;, repr(context_after), &quot;,&quot;)
            message += self._context(&quot;]&quot;)
        message += &quot;Error: &quot;
        message += self.message[0].format(*self.message[1:])
        message += &quot;\n&quot;
        return message

    def _context(self, *args):
        return &quot;&gt; {}\n&quot;.format(&quot;&quot;.join(args))

    def _arrow(self, lenght):
        return &quot;--{}^\n&quot;.format(&quot;-&quot;*lenght)</code></pre>
<h3 id="ad257e61e4025b8859d610a475c6acompile.sh">[]{#338ad257e61e4025b8859d610a475c6a}compile.sh</h3>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb144"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true"></a></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true"></a></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true"></a></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true"></a></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">&#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;</span></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true"></a></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true"></a></span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true"></a>import sys</span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true"></a></span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true"></a>SUPPORT = <span class="va">$support_py_string</span></span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true"></a></span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true"></a></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true"></a></span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true"></a></span>
<span id="cb144-29"><a href="#cb144-29" aria-hidden="true"></a>join = &quot;&quot;.join</span>
<span id="cb144-30"><a href="#cb144-30" aria-hidden="true"></a></span>
<span id="cb144-31"><a href="#cb144-31" aria-hidden="true"></a>def compile_grammar(grammar):</span>
<span id="cb144-32"><a href="#cb144-32" aria-hidden="true"></a>    parser = Parser()</span>
<span id="cb144-33"><a href="#cb144-33" aria-hidden="true"></a>    code_generator = CodeGenerator()</span>
<span id="cb144-34"><a href="#cb144-34" aria-hidden="true"></a>    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))</span>
<span id="cb144-35"><a href="#cb144-35" aria-hidden="true"></a></span>
<span id="cb144-36"><a href="#cb144-36" aria-hidden="true"></a>if __name__ == &quot;__main__&quot;:</span>
<span id="cb144-37"><a href="#cb144-37" aria-hidden="true"></a>    if &quot;--support&quot; in sys.argv:</span>
<span id="cb144-38"><a href="#cb144-38" aria-hidden="true"></a>        sys.stdout.write(SUPPORT)</span>
<span id="cb144-39"><a href="#cb144-39" aria-hidden="true"></a>    else:</span>
<span id="cb144-40"><a href="#cb144-40" aria-hidden="true"></a>        try:</span>
<span id="cb144-41"><a href="#cb144-41" aria-hidden="true"></a>            sys.stdout.write(compile_grammar(sys.stdin.read()))</span>
<span id="cb144-42"><a href="#cb144-42" aria-hidden="true"></a>        except _MatchError as e:</span>
<span id="cb144-43"><a href="#cb144-43" aria-hidden="true"></a>            sys.stderr.write(e.describe())</span>
<span id="cb144-44"><a href="#cb144-44" aria-hidden="true"></a>            sys.exit(1)</span>
<span id="cb144-45"><a href="#cb144-45" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<h3 id="d17f2d55749b59d7e5ec7b9b8e0ecmeta_compile.sh">[]{#272d17f2d55749b59d7e5ec7b9b8e0ec}meta_compile.sh</h3>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb146"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true"></a></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true"></a></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true"></a></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true"></a></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true"></a></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true"></a></span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true"></a></span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true"></a></span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb146-20"><a href="#cb146-20" aria-hidden="true"></a></span>
<span id="cb146-21"><a href="#cb146-21" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb146-22"><a href="#cb146-22" aria-hidden="true"></a></span>
<span id="cb146-23"><a href="#cb146-23" aria-hidden="true"></a><span class="bu">echo</span> OK</span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>Optimizing RLMeta</title>
    <link href="http://rickardlindberg.me/writing/optimizing-rlmeta/" />
    <id>http://rickardlindberg.me/writing/optimizing-rlmeta/</id>
    <published>2019-06-28T00:00:00Z</published>
    <updated>2019-06-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Optimizing RLMeta</h1>

<p><em>Published on 28 June 2019.</em></p>

<p>In this article we optimize <a href="/writing/rlmeta/index.html">RLMeta</a> to run faster. The first version did not take performance into account, so it is not surprising that we will get it to run roughly twice as fast.</p>
<ul>
<li><a href="#31e3c712b4ce4f16bb8e5d352e76fb0e">What to measure?</a></li>
<li><a href="#2ac127d411b749919b45ae11c1e47975">And/Or optimization</a></li>
<li><a href="#f4741ec692124b31af139231151e3a29">Avoid slicing input</a></li>
<li><a href="#8deb8e7f493a474d8555eb7db34a89dc">Faster string concatenation</a></li>
<li><a href="#006ce805fef64eb88c4b8214d7e85495">And/Or again</a></li>
<li><a href="#a06ba4a722cc461f9f3eabe2c0f60e53">Remove newlines and indentation</a></li>
<li><a href="#e7f710aa99bc4a7c895e905f60b4beb8">Match call rule</a></li>
<li><a href="#5160cbceeb9f45bb992c65cc688c3c18">Don't memoize code generator</a></li>
<li><a href="#f0338cf15ddb49099abf6a135a0961d7">Optimize position</a></li>
<li><a href="#a5f5f3907de04b28bdf52a8ba57b4a71">Make fail messages lazy</a></li>
<li><a href="#898ec92a13304692857a6d4de445e4d2">Peek</a></li>
<li><a href="#84d9e890742c41d48fc1afc2009815c7">No exception for last or</a></li>
<li><a href="#3616eda03f5c40458ac9439def097739">Conclusions</a></li>
<li><a href="#3aafb64996414339b01b0d407e6e1810">Code listings for RLMeta</a>
<ul>
<li><a href="#496100180e1c4c119f90be842c1b9577">parser.rlmeta</a></li>
<li><a href="#7bd8846187ad478aa17439370f0da1e6">codegenerator.rlmeta</a></li>
<li><a href="#ecfe26a58495420b8871e522c6859a4a">support.py</a></li>
<li><a href="#1ee923adb0ed4f3b8a5cc72700aad2dd">compile.sh</a></li>
<li><a href="#d09466ef920844788d5e63457decfd86">meta_compile.sh</a></li>
</ul></li>
</ul>
<h2 id="e3c712b4ce4f16bb8e5d352e76fb0ewhat-to-measure">[]{#31e3c712b4ce4f16bb8e5d352e76fb0e}What to measure?</h2>
<p>Before optimizing something for speed it is important to measure how long it takes. We are interested in optimizing the time it takes for RLMeta to compile itself. If it compiles itself faster, it will most likely also compile other RLMeta programs faster.</p>
<p>RLMeta compiles itself in the following steps:</p>
<ul>
<li>Generate support libraries</li>
<li>Compile parser</li>
<li>Compile code generator</li>
<li>Assemble the pieces into a Python file</li>
</ul>
<p>The <code>compile.sh</code> script performs those steps like follows:</p>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">&#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>&lt;&lt;python template&gt;&gt;</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<p>The Python file template rendered at the end of the script looks like this:</p>
<pre><code>1.  compile.sh
2.  [python template]{.cp}</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ex">import</span> sys</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ex">SUPPORT</span> = <span class="va">$support_py_string</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="fu">join</span> = <span class="st">&quot;&quot;</span>.join</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="ex">def</span> compile_grammar(grammar)<span class="bu">:</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    <span class="ex">parser</span> = Parser()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    <span class="ex">code_generator</span> = CodeGenerator()</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    <span class="bu">return</span> code_generator.run(<span class="st">&quot;ast&quot;</span>, parser.run(<span class="st">&quot;grammar&quot;</span>, grammar))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="kw">if</span> <span class="ex">__name__</span> == <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    <span class="kw">if</span> <span class="st">&quot;--support&quot;</span> <span class="kw">in</span> <span class="ex">sys.argv</span>:</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>        <span class="ex">sys.stdout.write</span>(SUPPORT)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>    <span class="ex">else</span>:</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>        <span class="ex">try</span>:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>            <span class="ex">sys.stdout.write</span>(compile_grammar(sys.stdin.read()))</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>        <span class="ex">except</span> _MatchError as e:</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>            <span class="ex">sys.stderr.write</span>(e.describe())</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>            <span class="ex">sys.exit</span>(1)</span></code></pre></div>
<p>To measure how long it takes for RLMeta to compile itself, we use the <code>time</code> command:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.756s
user  0m0.701s
sys 0m0.054s</code></pre>
<p>It takes <strong>0.756s</strong>. The goal of our optimizations is to decrease this time.</p>
<p>To get a better understanding of what takes time, we measure how long it takes to compile the parser and the code generator individually:</p>
<pre class="text"><code>$ time python rlmeta.py &lt; parser.rlmeta &gt; /dev/null

real  0m0.380s
user  0m0.363s
sys 0m0.015s</code></pre>
<pre class="text"><code>$ time python rlmeta.py &lt; codegenerator.rlmeta &gt; /dev/null

real  0m0.351s
user  0m0.331s
sys 0m0.019s</code></pre>
<p>Both grammars take roughly the same time to compile (<strong>0.380s</strong> and <strong>0.351s</strong>). Moreover, the compilation of the grammars take up most of the time. The rest (generating the support libraries and rendering the Python file template) takes only <strong>0.025s</strong> (0.756-0.380-0.351). We will therefore focus on making compilation of grammars faster.</p>
<p>To get a better understanding of what takes time when compiling grammars, we compile the parser and the code generator with the Python profiler turned on:</p>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
             513780 function calls (430760 primitive calls) in 0.476 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8182/2    0.053    0.000    0.427    0.213 rlmeta.py:7(_or)
    22758    0.040    0.000    0.106    0.000 rlmeta.py:234(next)
    17411    0.027    0.000    0.046    0.000 rlmeta.py:203(fail)
  26658/2    0.023    0.000    0.427    0.213 rlmeta.py:16(_and)
  10730/2    0.020    0.000    0.427    0.213 rlmeta.py:43(_match_rule)
     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)
        1    0.013    0.013    0.013    0.013 {method &#39;write&#39; of &#39;file&#39; objects}
...</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; codegenerator.rlmeta
...
         450885 function calls (377441 primitive calls) in 0.433 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8152/2    0.052    0.000    0.396    0.198 rlmeta.py:7(_or)
    19754    0.046    0.000    0.097    0.000 rlmeta.py:234(next)
    15838    0.026    0.000    0.049    0.000 rlmeta.py:203(fail)
  23478/2    0.020    0.000    0.396    0.198 rlmeta.py:16(_and)
   9883/2    0.018    0.000    0.396    0.198 rlmeta.py:43(_match_rule)
    15838    0.016    0.000    0.016    0.000 rlmeta.py:211(__init__)
        1    0.012    0.012    0.012    0.012 {method &#39;write&#39; of &#39;file&#39; objects}
...</code></pre>
<p>This again shows that both grammars take roughly the same time to compile (<strong>0.476s</strong> and <strong>0.433s</strong>). (These numbers are higher than the <code>time</code> measurements. Probably because profiling is turned on.) It also shows what functions take most time. Both grammars have roughly the same functions at the top of the list: <code>_or</code>, <code>next</code>, <code>fail</code>, <code>_and</code>, <code>_match_rule</code>, and <code>write</code>.</p>
<p>Because the profiling output looks similar for the two grammars, we will only profile compilation of the parser.</p>
<p>Let's start by examining the <code>_or</code> function, because most time is spent there, and see if we can make it any faster.</p>
<h2 id="ac127d411b749919b45ae11c1e47975andor-optimization">[]{#2ac127d411b749919b45ae11c1e47975}And/Or optimization</h2>
<p>The <code>_or</code> function is called any time there is a choice in a grammar and it looks like this:</p>
<pre class="text"><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    original_stream.fail(&quot;no choice matched&quot;)</code></pre>
<p>There is no obvious way to optimize it so instead we try to reduce the number of calls to it. The code generator always generates calls to <code>_or</code> even if there is only one choice: <code>self._or([matcher])</code>. In this case the call to <code>_or</code> is unnecessary because the single matcher can be called directly: <code>matcher()</code>. The same reasoning goes for <code>_and</code>.</p>
<p>To make the code generator skip unnecessary calls to <code>_or</code> and <code>_and</code>, we add the following cases to it:</p>
<pre class="text"><code>| [&quot;Or&quot; ast:x]  -&gt; x
| [&quot;And&quot; ast:x] -&gt; x</code></pre>
<p>If it sees an <code>Or</code> or an <code>And</code> ast node with only one child, it will skip the calls to <code>_or</code> and <code>_and</code> and just generate the child matcher.</p>
<p>We create a new version of RLMeta as described in <a href="/writing/modifying-rlmeta/index.html">Modifying the RLMeta metacompiler</a> and then we measure.</p>
<p>Unfortunately, this does not seem to have any effect on the speed. Why is that? Perhaps because the two added cases to the code generator also makes it slower.</p>
<p>We discard this change for now and move on to the <code>next</code> function which is second on the list.</p>
<h2 id="avoid-slicing-input"><span id="f4741ec692124b31af139231151e3a29"></span>Avoid slicing input</h2>
<p>The <code>next</code> function is used to get the next object from an input stream and it looks like this:</p>
<pre class="text"><code>def next(self):
    if self.is_at_end():
        self.fail(&quot;not eof&quot;)
    next_object = self._objects[0]
    return (
        next_object,
        self._advance(next_object, self._objects[1:]),
    )</code></pre>
<p>Every time it is called, which is once per object in the input stream, the input stream is sliced: <code>self._objects[1:]</code>. This creates a new list with all objects except the first. For example, if the input stream is the string "print(1)", it will create the substrings "rint(1)", "int(1)", "nt(1)", and so on. This is wasteful.</p>
<p>To avoid slicing the input stream we rewrite it to instead maintain an index where it's at. The next object is retrieved by indexing, and the rest of the objects no longer has to be computed. The index is just incremented instead. With this change, the <code>next</code> function looks like this:</p>
<pre class="text"><code>def next(self):
    if self.is_at_end():
        self.fail(&quot;not eof&quot;)
    return (self._objects[self._index], self._advance())</code></pre>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/a358b1921a5f9afae769512ca27db795af947648#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.608s
user  0m0.585s
sys 0m0.022s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         513780 function calls (430760 primitive calls) in 0.415 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8182/2    0.042    0.000    0.366    0.183 rlmeta.py:7(_or)
    17411    0.026    0.000    0.044    0.000 rlmeta.py:203(fail)
  26658/2    0.021    0.000    0.366    0.183 rlmeta.py:16(_and)
  10730/2    0.019    0.000    0.366    0.183 rlmeta.py:43(_match_rule)
     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)
    22758    0.017    0.000    0.077    0.000 rlmeta.py:235(next)
        1    0.014    0.014    0.014    0.014 {method &#39;write&#39; of &#39;file&#39; objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.756s</strong> to <strong>0.608s</strong>. The compilation time for a single grammar went from <strong>0.476s</strong> to <strong>0.415s</strong>. The <code>next</code> function moved down the list from <strong>0.040s</strong> to <strong>0.017s</strong>.</p>
<p>Finally some progress.</p>
<p>We still don't have an obvious way to optimize <code>_or</code> and <code>_and</code>. Next on the list is the <code>fail</code> function which looks like this:</p>
<pre class="text"><code>def fail(self, stream, message):
    if stream.position() &gt;= self._latest_stream.position():
        self._latest_stream = stream
        self._latest_message = message
    raise _MatchError(self)</code></pre>
<p>There is no obvious way to make this faster either. The same goes for the <code>_match_rule</code> function which looks like this:</p>
<pre class="text"><code>def _match_rule(self, rule_name):
    key = (rule_name, self._stream.position())
    if key in self._memo:
        result, _, self._stream = self._memo[key]
    else:
        start = self._stream
        result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
        end = self._stream
        self._memo[key] = (result, start, end)
    return result</code></pre>
<p>We move down the list and examine the <code>write</code> function.</p>
<h2 id="deb8e7f493a474d8555eb7db34a89dcfaster-string-concatenation">[]{#8deb8e7f493a474d8555eb7db34a89dc}Faster string concatenation</h2>
<p>The <code>write</code> function in the <code>_Output</code> class looks like this:</p>
<pre class="text"><code>class _Output(object):

    def __init__(self):
        self.value = &quot;&quot;
        self.indentation = 0

    def write(self, value):
        for ch in value:
            if self.value and ch != &quot;\n&quot; and self.value[-1] == &quot;\n&quot;:
                self.value += &quot;    &quot;*self.indentation
            self.value += ch</code></pre>
<p>It is used by the code generator to generate string output. It builds up the value by concatenating strings to the current value: <code>self.value += ..</code>. This concatenation is done once per generated character. Concatenating strings in Python this way is not the fastest way to do it.</p>
<p>A better way is to use the <code>StringIO</code> class. Its <code>write</code> function is used to build up the value, and its <code>getvalue</code> function is used to return it:</p>
<pre class="text"><code>class _Output(object):

    def __init__(self):
        self.buffer = StringIO()
        self.indentation = 0
        self.on_newline = True

    @property
    def value(self):
        return self.buffer.getvalue()

    def write(self, value):
        for ch in value:
            is_linebreak = ch == &quot;\n&quot;
            if self.indentation and self.on_newline and not is_linebreak:
                self.buffer.write(&quot;    &quot;*self.indentation)
            self.buffer.write(ch)
            self.on_newline = is_linebreak</code></pre>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/d5327b86d3de97a621f9ca0a8d11e445484d0fcb#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.603s
user  0m0.564s
sys 0m0.038s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         527910 function calls (444890 primitive calls) in 0.397 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8182/2    0.042    0.000    0.370    0.185 rlmeta.py:12(_or)
    17411    0.026    0.000    0.045    0.000 rlmeta.py:215(fail)
  26658/2    0.021    0.000    0.370    0.185 rlmeta.py:21(_and)
  10730/2    0.019    0.000    0.370    0.185 rlmeta.py:48(_match_rule)
    22758    0.017    0.000    0.078    0.000 rlmeta.py:247(next)
    17408    0.012    0.000    0.018    0.000 rlmeta.py:279(__init__)
...
     2177    0.006    0.000    0.009    0.000 rlmeta.py:157(write)
...</code></pre>
<p>The overall compilation time went from <strong>0.608s</strong> to <strong>0.603s</strong>. The compilation time for a single grammar went from <strong>0.415s</strong> to <strong>0.397s</strong>. This is not significant. But much less time is spent in the <code>write</code> function (<strong>0.006s</strong> compared to <strong>0.019s</strong>) so we keep this change. It might be that some more time is spent doing the <code>getvalue</code> call. But it does not show up at the top of the list.</p>
<p>The <code>_or</code> and <code>_and</code> functions are still high up on the list. Now that we have made other parts of RLMeta faster, will the and/or optimization be more useful?</p>
<h2 id="ce805fef64eb88c4b8214d7e85495andor-again">[]{#006ce805fef64eb88c4b8214d7e85495}And/Or again</h2>
<p>We apply the and/or optimization again, create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.592s
user  0m0.560s
sys 0m0.031s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         508708 function calls (437696 primitive calls) in 0.380 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4898/230    0.039    0.000    0.351    0.002 rlmeta.py:12(_or)
    15852    0.025    0.000    0.041    0.000 rlmeta.py:215(fail)
  10620/2    0.019    0.000    0.354    0.177 rlmeta.py:48(_match_rule)
  21301/2    0.018    0.000    0.354    0.177 rlmeta.py:21(_and)
    23516    0.018    0.000    0.078    0.000 rlmeta.py:247(next)
    19154    0.013    0.000    0.020    0.000 rlmeta.py:279(__init__)
   8323/1    0.012    0.000    0.184    0.184 rlmeta.py:93(_match_list)
    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)
     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)
...</code></pre>
<p>The overall compilation time went from <strong>0.603s</strong> to <strong>0.592s</strong>. The compilation time for a single grammar went from <strong>0.397s</strong> to <strong>0.380s</strong>. This is not significant, but less time is spend in <code>_or</code> and <code>_and</code>, so we keep this change now.</p>
<p>We previously observed that writing output took some time. We made the <code>write</code> function faster. Now we will try another change that will cause less characters to be written to the output. This will change the grammar, and not just the support library.</p>
<h2 id="remove-newlines-and-indentation"><span id="a06ba4a722cc461f9f3eabe2c0f60e53"></span>Remove newlines and indentation</h2>
<p>The main part of the code generator has two rules that generate code for ast nodes:</p>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt; }
    ...
    | astFnBody:x             -&gt; { &quot;(lambda:\n&quot; &gt; x &lt; &quot;\n)&quot; }
  astFnBody =
    | [&quot;Or&quot; astItems:x]       -&gt; { &quot;self._or([&quot; x &quot;])&quot;               }
    ...
  ...
}</code></pre>
<p>If an ast node's body should be wrapped in a lambda, it is put in the <code>astFnBody</code> rule and the lambda is generated by the last choice in the <code>ast</code> rule. The lambda is generated with newlines and indentation like this:</p>
<pre class="text"><code>(lambda:
    body
)</code></pre>
<p>The newlines and indentation are not necessary. It might make the generated code easier to the read at the expense of outputting at least 6 more characters (two newlines and at least 4 spaces of indent). Instead we could generate this:</p>
<pre class="text"><code>(lambda: body)</code></pre>
<p>We rewrite the code generator like this:</p>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt; }
    ...
    | [&quot;Or&quot; astItems:x]       -&gt; { &quot;(lambda: self._or([&quot; x &quot;]))&quot;     }
    ...
  ...
}</code></pre>
<p>This also removes the <code>astFnBody</code> rule in favor of duplicating the lambda output code. This removes one function call, but more importantly lays the groundwork for the next optimization.</p>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/496c98d367a5dce2def17680d92f095cd2c274a5#diff-14e1afbb5e4a4c88a29fd7256cd350fb">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.565s
user  0m0.530s
sys 0m0.034s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         457174 function calls (396876 primitive calls) in 0.343 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4518/230    0.039    0.000    0.343    0.001 rlmeta.py:12(_or)
    15769    0.024    0.000    0.040    0.000 rlmeta.py:215(fail)
  10240/2    0.019    0.000    0.347    0.174 rlmeta.py:48(_match_rule)
    23516    0.017    0.000    0.078    0.000 rlmeta.py:247(next)
  20921/2    0.017    0.000    0.347    0.174 rlmeta.py:21(_and)
    19154    0.014    0.000    0.020    0.000 rlmeta.py:279(__init__)
   8323/1    0.012    0.000    0.176    0.176 rlmeta.py:93(_match_list)
     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)
    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)
    27805    0.010    0.000    0.010    0.000 rlmeta.py:239(__init__)
    17623    0.010    0.000    0.010    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.592s</strong> to <strong>0.565s</strong>. The compilation time for a single grammar went from <strong>0.380s</strong> to <strong>0.343s</strong>.</p>
<p>Now that we've made an optimization by modifying the source code, we think about how we can further modify the source code to make RLMeta faster.</p>
<h2 id="match-call-rule"><span id="e7f710aa99bc4a7c895e905f60b4beb8"></span>Match call rule</h2>
<p>The largest part of the code generator is the <code>ast</code> rule. It has many choices that are tried in order to generate code for different type of ast nodes:</p>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;   }
    ... (22 choices omitted) ...
    | [&quot;MatchList&quot; ast:x]     -&gt; { &quot;(lambda: self._match_list(&quot; x &quot;))&quot; }
  ...
}</code></pre>
<p>To generate code for the <code>MatchList</code> ast node, the <code>_or</code> function first needs to fail 23 times before it reaches the last choice that matches.</p>
<p>We introduce a new operator in RLMeta, <code>%</code>, which means read one object from the input stream and treat it as the name of a rule in the grammar. Then call that rule. It is implemented like this:</p>
<pre class="text"><code>def _match_call_rule(self):
    next_object, self._stream = self._stream.next()
    return self._match_rule(str(next_object))</code></pre>
<p>We then rewrite the code generator using this operator. The <code>ast</code> rule simply becomes matching a list, then calling the rule for that ast node. All choices are converted to rules where the ast node name becomes the rule name:</p>
<pre class="text"><code>CodeGenerator {
  Grammar   = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;   }
  ...
  MatchList = ast:x       -&gt; { &quot;(lambda: self._match_list(&quot; x &quot;))&quot; }
  ast       = [%:x]       -&gt; x
  ...
}</code></pre>
<p>With this change, the main part of the code generator is completely free of choice operators which should eliminate many calls to <code>_or</code>.</p>
<p>The complete diff can be viewed online <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/61ff2132a057cf986ae0eae8575d24b066ab3e43">here</a> and <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/f054fdca6c939506e2820d86d466fe1763244c43#diff-14e1afbb5e4a4c88a29fd7256cd350fb">here</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.406s
user  0m0.373s
sys 0m0.032s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         274963 function calls (238101 primitive calls) in 0.220 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  11129/2    0.021    0.000    0.215    0.107 rlmeta.py:48(_match_rule)
 4177/252    0.020    0.000    0.209    0.001 rlmeta.py:12(_or)
     8460    0.013    0.000    0.022    0.000 rlmeta.py:219(fail)
     7021    0.011    0.000    0.056    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.010    0.000    0.215    0.107 rlmeta.py:21(_and)
     9099    0.009    0.000    0.020    0.000 rlmeta.py:269(_advance)
    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)
     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)
    12801    0.006    0.000    0.006    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
     1443    0.006    0.000    0.008    0.000 rlmeta.py:161(write)
    26070    0.005    0.000    0.005    0.000 rlmeta.py:266(position)
     8460    0.005    0.000    0.005    0.000 rlmeta.py:227(__init__)
    10908    0.005    0.000    0.005    0.000 rlmeta.py:243(__init__)
...</code></pre>
<p>The overall compilation time went from <strong>0.565s</strong> to <strong>0.406s</strong>. The compilation time for a single grammar went from <strong>0.343s</strong> to <strong>0.220s</strong>. This is some real performance gain. Also the <code>_or</code> function is kicked down to the second position.</p>
<p>Now that the code generator is mostly free from choices, is it still worthwhile to memoize results?</p>
<h2 id="cbceeb9f45bb992c65cc688c3c18dont-memoize-code-generator">[]{#5160cbceeb9f45bb992c65cc688c3c18}Don't memoize code generator</h2>
<p>Memoizing results is done in <code>_match_rule</code> which looks like this:</p>
<pre class="text"><code>def _match_rule(self, rule_name):
    key = (rule_name, self._stream.position())
    if key in self._memo:
        result, _, self._stream = self._memo[key]
    else:
        start = self._stream
        result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
        end = self._stream
        self._memo[key] = (result, start, end)
    return result</code></pre>
<p>If the rule has matched before at the current position, the memoized result is returned. In the new code generator there will not be many such cases because most choices have been eliminated. For the code generator, we can instead just do this:</p>
<pre class="text"><code>def _match_rule(self, rule_name):
    return getattr(self, &quot;_rule_{}&quot;.format(rule_name))()</code></pre>
<p>We create a new version of RLMeta and then we measure.</p>
<p>It turns out this is not really significant. The code generator is not getting faster without memoization.</p>
<p>Now the <code>_match_rule</code> function takes most time. We previously saw no way to optimize it, but we observe now that it makes a call to the <code>position</code> function. Can we make it faster?</p>
<h2 id="optimize-position"><span id="f0338cf15ddb49099abf6a135a0961d7"></span>Optimize position</h2>
<p>The <code>position</code> function exists on streams and looks like this:</p>
<pre class="text"><code>class _CharStream(_Stream):

    def position(self):
        return (self._line, self._column)

    ...</code></pre>
<pre class="text"><code>class _ObjectStream(_Stream):

    def position(self):
        return self._parent + (self._position,)

    ...</code></pre>
<p>Every time it is called, a new tuple is created. What if we refactor it to create the position only once and return it when the <code>position</code> function is called?</p>
<p>With this change, the position is created in the constructor and just returned. The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/3cbf3437cf0478bd899ec6c6c839b3f07c32f86b#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.392s
user  0m0.364s
sys 0m0.026s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         274963 function calls (238101 primitive calls) in 0.220 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4177/252    0.020    0.000    0.206    0.001 rlmeta.py:12(_or)
  11129/2    0.020    0.000    0.212    0.106 rlmeta.py:48(_match_rule)
     8460    0.014    0.000    0.022    0.000 rlmeta.py:219(fail)
     7021    0.012    0.000    0.057    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.010    0.000    0.212    0.106 rlmeta.py:21(_and)
     9099    0.009    0.000    0.021    0.000 rlmeta.py:269(_advance)
    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)
     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)
    12801    0.006    0.000    0.006    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
     1443    0.006    0.000    0.009    0.000 rlmeta.py:161(write)
...</code></pre>
<p>The overall compilation time went from <strong>0.406s</strong> to <strong>0.392s</strong>. The compilation time for a single grammar did not change. Did anything improve? Perhaps not. But because the overall compilation time improved and the resulting code is not worse, we keep this change.</p>
<p>A new function has floated up the list, and that is <code>_match_charseq</code>. It looks like this:</p>
<pre class="text"><code>def _match_charseq(self, charseq):
    for char in charseq:
        original_stream = self._stream
        next_object, self._stream = self._stream.next()
        if next_object != char:
            original_stream.fail(
                &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
    return _SemanticAction(lambda: charseq)</code></pre>
<p>There is no obvious way to optimize it. But we notice the formatting of the fail message. The <code>format</code> function shows up on the list a bit further down. We observe that fail messages are seldom used. Only the last fail message is presented to the user. So formatting all fail messages is unnecessary. But we still want nice looking fail messages. We try to defer the formatting until it is actually needed.</p>
<h2 id="make-fail-messages-lazy"><span id="a5f5f3907de04b28bdf52a8ba57b4a71"></span>Make fail messages lazy</h2>
<p>To defer fail messages we change them from strings to lambdas. To format a fail message, the lambda has to be called. With this change, the <code>_match_charseq</code> function looks like this:</p>
<pre class="text"><code>def _match_charseq(self, charseq):
    for char in charseq:
        original_stream = self._stream
        next_object, self._stream = self._stream.next()
        if next_object != char:
            original_stream.fail(
                lambda: &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
    return _SemanticAction(lambda: charseq)</code></pre>
<p>The complete diff can be viewed online <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/d32dfb7235b2d1353d8045dc1999a6dc07f493bf#diff-f500390afaa13cfd96d938b9065dc0c1">here</a> and <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/dd3d3b8c35744b6d5e5ef42dbd46aafa9e1331ad#diff-f500390afaa13cfd96d938b9065dc0c1">here</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.370s
user  0m0.336s
sys 0m0.034s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         268387 function calls (231525 primitive calls) in 0.204 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4177/252    0.020    0.000    0.194    0.001 rlmeta.py:12(_or)
  11129/2    0.019    0.000    0.199    0.100 rlmeta.py:48(_match_rule)
     8460    0.013    0.000    0.021    0.000 rlmeta.py:219(fail)
     7021    0.010    0.000    0.050    0.000 rlmeta.py:79(_match_charseq)
     9099    0.010    0.000    0.021    0.000 rlmeta.py:269(_advance)
   9010/2    0.009    0.000    0.199    0.100 rlmeta.py:21(_and)
    10540    0.008    0.000    0.038    0.000 rlmeta.py:251(next)
     9100    0.007    0.000    0.011    0.000 rlmeta.py:261(__init__)
     8460    0.006    0.000    0.006    0.000 rlmeta.py:227(__init__)
     1443    0.005    0.000    0.008    0.000 rlmeta.py:161(write)
    10908    0.004    0.000    0.004    0.000 rlmeta.py:243(__init__)
     8460    0.004    0.000    0.025    0.000 rlmeta.py:248(fail)
    10993    0.004    0.000    0.005    0.000 rlmeta.py:256(is_at_end)
    885/5    0.004    0.000    0.199    0.040 rlmeta.py:27(_star)
 3274/747    0.004    0.000    0.005    0.000 rlmeta.py:141(create)
    12616    0.003    0.000    0.003    0.000 {method &#39;write&#39; of &#39;cStringIO.StringO&#39; objects}
    17881    0.002    0.000    0.002    0.000 rlmeta.py:266(position)
     1802    0.002    0.000    0.014    0.000 rlmeta.py:59(_match_range)
     6225    0.002    0.000    0.002    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.392s</strong> to <strong>0.370s</strong>. The compilation time for a single grammar went from <strong>0.220s</strong> to <strong>0.204s</strong>. Time spent formatting strings went from <strong>0.006s</strong> to <strong>0.002s</strong>.</p>
<p>When we take another look at <code>_match_charseq</code>, which is still taking much time, we see that the <code>next</code> function is called, resulting in a tuple being created and returned. But if the check fails, we have done some unnecessary work like assigning to <code>self._stream</code> and advancing the stream. Let's see if we can avoid that by implementing a peek function.</p>
<h2 id="ec92a13304692857a6d4de445e4d2peek">[]{#898ec92a13304692857a6d4de445e4d2}Peek</h2>
<p>Streams implement a <code>next</code> function which returns the next object and a new stream representing the rest of the objects. If a matcher fails after examining the next object, the rest of the objects are never used. We therefore split the <code>next</code> function into two: <code>peek</code> and <code>advance</code>. The <code>_match_charseq</code> function then looks like this:</p>
<pre class="text"><code>def _match_charseq(self, charseq):
    for char in charseq:
        next_object = self._stream.peek()
        if next_object != char:
            self._stream.fail(
                lambda: &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
        self._stream = self._stream.advance()
    return _SemanticAction(lambda: charseq)</code></pre>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/6bcd1457c0fc4726c0d7bc5020a77dcef7f05ed3#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.351s
user  0m0.319s
sys 0m0.031s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         248506 function calls (211644 primitive calls) in 0.187 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  11129/2    0.019    0.000    0.182    0.091 rlmeta.py:48(_match_rule)
 4177/252    0.018    0.000    0.177    0.001 rlmeta.py:12(_or)
     8460    0.013    0.000    0.022    0.000 rlmeta.py:221(fail)
     7021    0.010    0.000    0.037    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.009    0.000    0.182    0.091 rlmeta.py:21(_and)
     8460    0.006    0.000    0.006    0.000 rlmeta.py:229(__init__)
    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)
     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)
    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)
    885/5    0.004    0.000    0.182    0.036 rlmeta.py:27(_star)
     8460    0.004    0.000    0.025    0.000 rlmeta.py:250(fail)
 3274/747    0.003    0.000    0.005    0.000 rlmeta.py:143(create)
     1802    0.003    0.000    0.011    0.000 rlmeta.py:59(_match_range)
     2574    0.003    0.000    0.006    0.000 rlmeta.py:271(advance)
    17881    0.002    0.000    0.002    0.000 rlmeta.py:268(position)
    12616    0.002    0.000    0.002    0.000 {method &#39;write&#39; of &#39;cStringIO.StringO&#39; objects}
     2575    0.002    0.000    0.004    0.000 rlmeta.py:263(__init__)
     6225    0.002    0.000    0.002    0.000 {method &#39;format&#39; of &#39;str&#39; objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.370s</strong> to <strong>0.351s</strong>. The compilation time for a single grammar went from <strong>0.204s</strong> to <strong>0.187s</strong>.</p>
<p>The <code>_or</code> and <code>fail</code> functions are still high on the list. We think of one more optimization we can do there.</p>
<h2 id="d9e890742c41d48fc1afc2009815c7no-exception-for-last-or">[]{#84d9e890742c41d48fc1afc2009815c7}No exception for last or</h2>
<p>The <code>_or</code> function looks like this:</p>
<pre class="text"><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    original_stream.fail(lambda: &quot;no choice matched&quot;)</code></pre>
<p>If it gets three matchers that all fail, the <code>fail</code> function will be called four times. This is unnecessary. If all but the last matchers have failed, there is no need to catch the exception from the last matcher. We can just let it fail and the failure will be handled higher up the call stack. We rewrite the <code>_or</code> function so that it instead looks like this:</p>
<pre class="text"><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers[:-1]:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    return matchers[-1]()</code></pre>
<p>This could have been done earlier as well, but we didn't see it then.</p>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/079d437dee27cca6cf7aa18d4fffdb5b2dd26172#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.344s
user  0m0.312s
sys 0m0.030s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         240951 function calls (204089 primitive calls) in 0.185 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  11129/2    0.019    0.000    0.180    0.090 rlmeta.py:48(_match_rule)
 4177/252    0.017    0.000    0.175    0.001 rlmeta.py:12(_or)
     6949    0.011    0.000    0.017    0.000 rlmeta.py:221(fail)
     7021    0.010    0.000    0.038    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.010    0.000    0.180    0.090 rlmeta.py:21(_and)
    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)
     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)
     6949    0.004    0.000    0.004    0.000 rlmeta.py:229(__init__)
    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)
    885/5    0.004    0.000    0.180    0.036 rlmeta.py:27(_star)
...</code></pre>
<p>The overall compilation time went from <strong>0.351s</strong> to <strong>0.344s</strong>. The compilation time for a single grammar went from <strong>0.187s</strong> to <strong>0.185s</strong>.</p>
<p>We can't tell if it is better or worse. But it should reduce one exception catch/throw. We therefore keep it.</p>
<p>We are seeing mostly small performance gains now, so we will stop here.</p>
<h2 id="eda03f5c40458ac9439def097739conclusions">[]{#3616eda03f5c40458ac9439def097739}Conclusions</h2>
<p>The overall compilation time went from <strong>0.756s</strong> to <strong>0.344s</strong>. The compilation time for a single grammar went from <strong>0.476s</strong> to <strong>0.185s</strong>. This is roughly twice as fast. Not that bad. Below is a graph that shows how performance improved with the different optimizations:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
</center>
<p>Some of the optimizations were significant, others not. Should we have focused only on the ones that were significant and discarded the rest? Usually better performance means less readable code. So if the performance gain is not significant, but the code becomes less readable, is it worth it? In particular, did we fall in love with the and/or optimization? We have read that <a href="http://www.vpri.org/pdf/tr2008003_experimenting.pdf">OMeta</a> uses it, so we wanted to be equally cool, but our measurements showed only slight performance increase.</p>
<p>Sometimes it was difficult to determine if a change led to faster compilation or not. The <code>time</code> command is not a reliable tool for performance measurements. We could perhaps have gotten better results by compiling bigger grammars so that small changes in time had been less significant.</p>
<p>There are probably many more optimizations that can be done to RLMeta that we didn't think of in this article. If you find any, let me know.</p>
<h2 id="aafb64996414339b01b0d407e6e1810code-listings-for-rlmeta">[]{#3aafb64996414339b01b0d407e6e1810}Code listings for RLMeta</h2>
<h3 id="e1c4c119f90be842c1b9577parser.rlmeta">[]{#496100180e1c4c119f90be842c1b9577}parser.rlmeta</h3>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  grammar =
    | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space &#39;=&#39; choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space &#39;|&#39;)?
      sequence:x (space &#39;|&#39; sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space &#39;:&#39; name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space &#39;*&#39;                        -&gt; [&quot;Star&quot; x]
    | expr2:x space &#39;?&#39;                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space &#39;!&#39; expr2:x                        -&gt; [&quot;Not&quot; x]
    | space &#39;%&#39;                                -&gt; [&quot;MatchCallRule&quot;]
    | expr2
  expr2 =
    | space &#39;-&gt;&#39; hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space &#39;=&#39;)                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x &#39;-&#39; char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space &#39;.&#39;                                -&gt; [&quot;MatchAny&quot;]
    | space &#39;(&#39; choice:x space &#39;)&#39;             -&gt; x
    | space &#39;[&#39; expr*:xs space &#39;]&#39;             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space &#39;[&#39; hostExprListItem*:xs space &#39;]&#39; -&gt; [&quot;List&quot; ~xs]
    | space &#39;{&#39; buildExpr*:xs space &#39;}&#39;        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space &#39;~&#39; hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space &#39;&gt;&#39;                                -&gt; [&quot;IndentBuilder&quot;]
    | space &#39;&lt;&#39;                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;   -&gt; join(xs)
  charseq   = &#39;\&#39;&#39; (!&#39;\&#39;&#39; innerChar)*:xs &#39;\&#39;&#39;  -&gt; join(xs)
  char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39;  -&gt; x
  innerChar = &#39;\\&#39; escape | .
  escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
            | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
  nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;
  space     = (&#39; &#39; | &#39;\n&#39;)*
}</code></pre>
<h3 id="bd8846187ad478aa17439370f0da1e6codegenerator.rlmeta">[]{#7bd8846187ad478aa17439370f0da1e6}codegenerator.rlmeta</h3>
<pre><code>1.  codegenerator.rlmeta</code></pre>
<pre class="rlmeta"><code>CodeGenerator {
  Grammar        = .:x ast*:ys     -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;                       }
  Rule           = .:x ast:y       -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt;     }
  MatchAny       =                 -&gt; { &quot;self._match_any&quot;                                       }
  MatchCallRule  =                 -&gt; { &quot;self._match_call_rule&quot;                                 }
  String         = .:x             -&gt; { repr(x)                                                 }
  List           = astList:x       -&gt; { x                                                       }
  Builder        = astItems:x      -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot;                              }
  IndentBuilder  =                 -&gt; { &quot;_IndentBuilder()&quot;                                      }
  DedentBuilder  =                 -&gt; { &quot;_DedentBuilder()&quot;                                      }
  FnCall         = .:x astItems:y  -&gt; { x &quot;(&quot; y &quot;)&quot;                                             }
  VarLookup      = .:x             -&gt; { &quot;_vars.lookup(&quot; repr(x) &quot;).eval()&quot;                      }
  Or             =
    | ast:x !.                     -&gt; x
    | astItems:x                   -&gt; { &quot;(lambda: self._or([&quot; x &quot;]))&quot;                           }
  Scope          = ast:x           -&gt; { &quot;(lambda: (lambda _vars:\n&quot; &gt; x &lt; &quot;()\n)(_Vars()))&quot;     }
  And            =
    | ast:x !.                     -&gt; x
    | astItems:x                   -&gt; { &quot;(lambda: self._and([&quot; x &quot;]))&quot;                          }
  Bind           = .:x ast:y       -&gt; { &quot;(lambda: _vars.bind(&quot; repr(x) &quot;, &quot; y &quot;()))&quot;            }
  Star           = ast:x           -&gt; { &quot;(lambda: self._star(&quot; x &quot;))&quot;                           }
  Not            = ast:x           -&gt; { &quot;(lambda: self._not(&quot; x &quot;))&quot;                            }
  SemanticAction = ast:x           -&gt; { &quot;(lambda: _SemanticAction(lambda: &quot; x &quot;))&quot;              }
  MatchRule      = .:x             -&gt; { &quot;(lambda: self._match_rule(&quot; repr(x) &quot;))&quot;               }
  MatchRange     = .:x .:y         -&gt; { &quot;(lambda: self._match_range(&quot; repr(x) &quot;, &quot; repr(y) &quot;))&quot; }
  MatchString    = .:x             -&gt; { &quot;(lambda: self._match_string(&quot; repr(x) &quot;))&quot;             }
  MatchCharseq   = .:x             -&gt; { &quot;(lambda: self._match_charseq(&quot; repr(x) &quot;))&quot;            }
  MatchList      = ast:x           -&gt; { &quot;(lambda: self._match_list(&quot; x &quot;))&quot;                     }
  ast            = [%:x]           -&gt; x
  astItems       = astItem*:xs     -&gt; { &quot;\n&quot; &gt; xs &lt;                                             }
  astItem        = ast:x           -&gt; { x &quot;,\n&quot;                                                 }
  astList        = astListItem*:xs -&gt; { &quot;(&quot; xs &quot;[])&quot;                                            }
  astListItem    =
    | [&quot;ListItemSplice&quot; ast:x]     -&gt; {     x  &quot;+&quot;                                              }
    | ast:x                        -&gt; { &quot;[&quot; x &quot;]+&quot;                                              }
}</code></pre>
<h3 id="support.py"><span id="ecfe26a58495420b8871e522c6859a4a"></span>support.py</h3>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="cf">try</span>:</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>    <span class="im">from</span> cStringIO <span class="im">import</span> StringIO</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a><span class="cf">except</span>:</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>    <span class="im">from</span> StringIO <span class="im">import</span> StringIO</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a><span class="kw">class</span> _Grammar(<span class="bu">object</span>):</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>    <span class="kw">def</span> _or(<span class="va">self</span>, matchers):</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>        original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>        <span class="cf">for</span> matcher <span class="kw">in</span> matchers[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a>            <span class="cf">try</span>:</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true"></a>                <span class="cf">return</span> matcher()</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true"></a>            <span class="cf">except</span> _MatchError:</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true"></a>                <span class="va">self</span>._stream <span class="op">=</span> original_stream</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true"></a>        <span class="cf">return</span> matchers[<span class="op">-</span><span class="dv">1</span>]()</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true"></a></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true"></a>    <span class="kw">def</span> _and(<span class="va">self</span>, matchers):</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true"></a>        result <span class="op">=</span> <span class="va">None</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true"></a>        <span class="cf">for</span> matcher <span class="kw">in</span> matchers:</span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true"></a>            result <span class="op">=</span> matcher()</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true"></a>        <span class="cf">return</span> result</span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true"></a></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true"></a>    <span class="kw">def</span> _star(<span class="va">self</span>, matcher):</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true"></a>        result <span class="op">=</span> []</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true"></a>            original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true"></a>            <span class="cf">try</span>:</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true"></a>                result.append(matcher())</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true"></a>            <span class="cf">except</span> _MatchError:</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true"></a>                <span class="va">self</span>._stream <span class="op">=</span> original_stream</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true"></a>                <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: [x.<span class="bu">eval</span>() <span class="cf">for</span> x <span class="kw">in</span> result])</span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true"></a></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true"></a>    <span class="kw">def</span> _not(<span class="va">self</span>, matcher):</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true"></a>        original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true"></a>            matcher()</span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true"></a>        <span class="cf">except</span> _MatchError:</span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true"></a>            <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: <span class="va">None</span>)</span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true"></a>            original_stream.fail(<span class="kw">lambda</span>: <span class="st">&quot;match found&quot;</span>)</span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true"></a>        <span class="cf">finally</span>:</span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> original_stream</span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true"></a></span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true"></a>    <span class="kw">def</span> _match_rule(<span class="va">self</span>, rule_name):</span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true"></a>        key <span class="op">=</span> (rule_name, <span class="va">self</span>._stream.position())</span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true"></a>        <span class="cf">if</span> key <span class="kw">in</span> <span class="va">self</span>._memo:</span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true"></a>            result, _, <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._memo[key]</span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true"></a>            start <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true"></a>            result <span class="op">=</span> <span class="bu">getattr</span>(<span class="va">self</span>, <span class="st">&quot;_rule_</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(rule_name))()</span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true"></a>            end <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true"></a>            <span class="va">self</span>._memo[key] <span class="op">=</span> (result, start, end)</span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true"></a>        <span class="cf">return</span> result</span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true"></a></span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true"></a>    <span class="kw">def</span> _match_range(<span class="va">self</span>, start, end):</span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true"></a>        next_objext <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true"></a>        <span class="cf">if</span> next_objext <span class="op">&gt;=</span> start <span class="kw">and</span> next_objext <span class="op">&lt;=</span> end:</span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true"></a>            <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: next_objext)</span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-61"><a href="#cb57-61" aria-hidden="true"></a>            <span class="va">self</span>._stream.fail(</span>
<span id="cb57-62"><a href="#cb57-62" aria-hidden="true"></a>                <span class="kw">lambda</span>: <span class="st">&quot;expected range </span><span class="sc">{!r}</span><span class="st">-</span><span class="sc">{!r}</span><span class="st"> but found </span><span class="sc">{!r}</span><span class="st">&quot;</span>.<span class="bu">format</span>(start, end, next_objext)</span>
<span id="cb57-63"><a href="#cb57-63" aria-hidden="true"></a>            )</span>
<span id="cb57-64"><a href="#cb57-64" aria-hidden="true"></a></span>
<span id="cb57-65"><a href="#cb57-65" aria-hidden="true"></a>    <span class="kw">def</span> _match_string(<span class="va">self</span>, string):</span>
<span id="cb57-66"><a href="#cb57-66" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-67"><a href="#cb57-67" aria-hidden="true"></a>        <span class="cf">if</span> next_object <span class="op">==</span> string:</span>
<span id="cb57-68"><a href="#cb57-68" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-69"><a href="#cb57-69" aria-hidden="true"></a>            <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: string)</span>
<span id="cb57-70"><a href="#cb57-70" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-71"><a href="#cb57-71" aria-hidden="true"></a>            <span class="va">self</span>._stream.fail(</span>
<span id="cb57-72"><a href="#cb57-72" aria-hidden="true"></a>                <span class="kw">lambda</span>: <span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st"> but found </span><span class="sc">{!r}</span><span class="st">&quot;</span>.<span class="bu">format</span>(string, next_object)</span>
<span id="cb57-73"><a href="#cb57-73" aria-hidden="true"></a>            )</span>
<span id="cb57-74"><a href="#cb57-74" aria-hidden="true"></a></span>
<span id="cb57-75"><a href="#cb57-75" aria-hidden="true"></a>    <span class="kw">def</span> _match_charseq(<span class="va">self</span>, charseq):</span>
<span id="cb57-76"><a href="#cb57-76" aria-hidden="true"></a>        <span class="cf">for</span> char <span class="kw">in</span> charseq:</span>
<span id="cb57-77"><a href="#cb57-77" aria-hidden="true"></a>            next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-78"><a href="#cb57-78" aria-hidden="true"></a>            <span class="cf">if</span> next_object <span class="op">!=</span> char:</span>
<span id="cb57-79"><a href="#cb57-79" aria-hidden="true"></a>                <span class="va">self</span>._stream.fail(</span>
<span id="cb57-80"><a href="#cb57-80" aria-hidden="true"></a>                    <span class="kw">lambda</span>: <span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st"> but found </span><span class="sc">{!r}</span><span class="st">&quot;</span>.<span class="bu">format</span>(char, next_object)</span>
<span id="cb57-81"><a href="#cb57-81" aria-hidden="true"></a>                )</span>
<span id="cb57-82"><a href="#cb57-82" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-83"><a href="#cb57-83" aria-hidden="true"></a>        <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: charseq)</span>
<span id="cb57-84"><a href="#cb57-84" aria-hidden="true"></a></span>
<span id="cb57-85"><a href="#cb57-85" aria-hidden="true"></a>    <span class="kw">def</span> _match_any(<span class="va">self</span>):</span>
<span id="cb57-86"><a href="#cb57-86" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-87"><a href="#cb57-87" aria-hidden="true"></a>        <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-88"><a href="#cb57-88" aria-hidden="true"></a>        <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: next_object)</span>
<span id="cb57-89"><a href="#cb57-89" aria-hidden="true"></a></span>
<span id="cb57-90"><a href="#cb57-90" aria-hidden="true"></a>    <span class="kw">def</span> _match_call_rule(<span class="va">self</span>):</span>
<span id="cb57-91"><a href="#cb57-91" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-92"><a href="#cb57-92" aria-hidden="true"></a>        <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-93"><a href="#cb57-93" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._match_rule(<span class="bu">str</span>(next_object))</span>
<span id="cb57-94"><a href="#cb57-94" aria-hidden="true"></a></span>
<span id="cb57-95"><a href="#cb57-95" aria-hidden="true"></a>    <span class="kw">def</span> _match_list(<span class="va">self</span>, matcher):</span>
<span id="cb57-96"><a href="#cb57-96" aria-hidden="true"></a>        original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-97"><a href="#cb57-97" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-98"><a href="#cb57-98" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(next_object, <span class="bu">list</span>):</span>
<span id="cb57-99"><a href="#cb57-99" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.nested(next_object)</span>
<span id="cb57-100"><a href="#cb57-100" aria-hidden="true"></a>            matcher()</span>
<span id="cb57-101"><a href="#cb57-101" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>._stream.is_at_end():</span>
<span id="cb57-102"><a href="#cb57-102" aria-hidden="true"></a>                <span class="va">self</span>._stream <span class="op">=</span> original_stream.advance()</span>
<span id="cb57-103"><a href="#cb57-103" aria-hidden="true"></a>                <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: next_object)</span>
<span id="cb57-104"><a href="#cb57-104" aria-hidden="true"></a>        original_stream.fail(<span class="kw">lambda</span>: <span class="st">&quot;list match failed&quot;</span>)</span>
<span id="cb57-105"><a href="#cb57-105" aria-hidden="true"></a></span>
<span id="cb57-106"><a href="#cb57-106" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule_name, input_object):</span>
<span id="cb57-107"><a href="#cb57-107" aria-hidden="true"></a>        <span class="va">self</span>._memo <span class="op">=</span> _Memo()</span>
<span id="cb57-108"><a href="#cb57-108" aria-hidden="true"></a>        <span class="va">self</span>._stream <span class="op">=</span> _Stream.from_object(<span class="va">self</span>._memo, input_object)</span>
<span id="cb57-109"><a href="#cb57-109" aria-hidden="true"></a>        result <span class="op">=</span> <span class="va">self</span>._match_rule(rule_name).<span class="bu">eval</span>()</span>
<span id="cb57-110"><a href="#cb57-110" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(result, _Builder):</span>
<span id="cb57-111"><a href="#cb57-111" aria-hidden="true"></a>            <span class="cf">return</span> result.build_string()</span>
<span id="cb57-112"><a href="#cb57-112" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-113"><a href="#cb57-113" aria-hidden="true"></a>            <span class="cf">return</span> result</span>
<span id="cb57-114"><a href="#cb57-114" aria-hidden="true"></a></span>
<span id="cb57-115"><a href="#cb57-115" aria-hidden="true"></a><span class="kw">class</span> _Vars(<span class="bu">dict</span>):</span>
<span id="cb57-116"><a href="#cb57-116" aria-hidden="true"></a></span>
<span id="cb57-117"><a href="#cb57-117" aria-hidden="true"></a>    <span class="kw">def</span> bind(<span class="va">self</span>, name, value):</span>
<span id="cb57-118"><a href="#cb57-118" aria-hidden="true"></a>        <span class="va">self</span>[name] <span class="op">=</span> value</span>
<span id="cb57-119"><a href="#cb57-119" aria-hidden="true"></a>        <span class="cf">return</span> value</span>
<span id="cb57-120"><a href="#cb57-120" aria-hidden="true"></a></span>
<span id="cb57-121"><a href="#cb57-121" aria-hidden="true"></a>    <span class="kw">def</span> lookup(<span class="va">self</span>, name):</span>
<span id="cb57-122"><a href="#cb57-122" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>[name]</span>
<span id="cb57-123"><a href="#cb57-123" aria-hidden="true"></a></span>
<span id="cb57-124"><a href="#cb57-124" aria-hidden="true"></a><span class="kw">class</span> _SemanticAction(<span class="bu">object</span>):</span>
<span id="cb57-125"><a href="#cb57-125" aria-hidden="true"></a></span>
<span id="cb57-126"><a href="#cb57-126" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn):</span>
<span id="cb57-127"><a href="#cb57-127" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb57-128"><a href="#cb57-128" aria-hidden="true"></a></span>
<span id="cb57-129"><a href="#cb57-129" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb57-130"><a href="#cb57-130" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn()</span>
<span id="cb57-131"><a href="#cb57-131" aria-hidden="true"></a></span>
<span id="cb57-132"><a href="#cb57-132" aria-hidden="true"></a><span class="kw">class</span> _Builder(<span class="bu">object</span>):</span>
<span id="cb57-133"><a href="#cb57-133" aria-hidden="true"></a></span>
<span id="cb57-134"><a href="#cb57-134" aria-hidden="true"></a>    <span class="kw">def</span> build_string(<span class="va">self</span>):</span>
<span id="cb57-135"><a href="#cb57-135" aria-hidden="true"></a>        output <span class="op">=</span> _Output()</span>
<span id="cb57-136"><a href="#cb57-136" aria-hidden="true"></a>        <span class="va">self</span>.write(output)</span>
<span id="cb57-137"><a href="#cb57-137" aria-hidden="true"></a>        <span class="cf">return</span> output.value</span>
<span id="cb57-138"><a href="#cb57-138" aria-hidden="true"></a></span>
<span id="cb57-139"><a href="#cb57-139" aria-hidden="true"></a>    <span class="at">@classmethod</span></span>
<span id="cb57-140"><a href="#cb57-140" aria-hidden="true"></a>    <span class="kw">def</span> create(<span class="va">self</span>, item):</span>
<span id="cb57-141"><a href="#cb57-141" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(item, _Builder):</span>
<span id="cb57-142"><a href="#cb57-142" aria-hidden="true"></a>            <span class="cf">return</span> item</span>
<span id="cb57-143"><a href="#cb57-143" aria-hidden="true"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>):</span>
<span id="cb57-144"><a href="#cb57-144" aria-hidden="true"></a>            <span class="cf">return</span> _ListBuilder([_Builder.create(x) <span class="cf">for</span> x <span class="kw">in</span> item])</span>
<span id="cb57-145"><a href="#cb57-145" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-146"><a href="#cb57-146" aria-hidden="true"></a>            <span class="cf">return</span> _AtomBuilder(item)</span>
<span id="cb57-147"><a href="#cb57-147" aria-hidden="true"></a></span>
<span id="cb57-148"><a href="#cb57-148" aria-hidden="true"></a><span class="kw">class</span> _Output(<span class="bu">object</span>):</span>
<span id="cb57-149"><a href="#cb57-149" aria-hidden="true"></a></span>
<span id="cb57-150"><a href="#cb57-150" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb57-151"><a href="#cb57-151" aria-hidden="true"></a>        <span class="va">self</span>.<span class="bu">buffer</span> <span class="op">=</span> StringIO()</span>
<span id="cb57-152"><a href="#cb57-152" aria-hidden="true"></a>        <span class="va">self</span>.indentation <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb57-153"><a href="#cb57-153" aria-hidden="true"></a>        <span class="va">self</span>.on_newline <span class="op">=</span> <span class="va">True</span></span>
<span id="cb57-154"><a href="#cb57-154" aria-hidden="true"></a></span>
<span id="cb57-155"><a href="#cb57-155" aria-hidden="true"></a>    <span class="at">@property</span></span>
<span id="cb57-156"><a href="#cb57-156" aria-hidden="true"></a>    <span class="kw">def</span> value(<span class="va">self</span>):</span>
<span id="cb57-157"><a href="#cb57-157" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">buffer</span>.getvalue()</span>
<span id="cb57-158"><a href="#cb57-158" aria-hidden="true"></a></span>
<span id="cb57-159"><a href="#cb57-159" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, value):</span>
<span id="cb57-160"><a href="#cb57-160" aria-hidden="true"></a>        <span class="cf">for</span> ch <span class="kw">in</span> value:</span>
<span id="cb57-161"><a href="#cb57-161" aria-hidden="true"></a>            is_linebreak <span class="op">=</span> ch <span class="op">==</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb57-162"><a href="#cb57-162" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>.indentation <span class="kw">and</span> <span class="va">self</span>.on_newline <span class="kw">and</span> <span class="kw">not</span> is_linebreak:</span>
<span id="cb57-163"><a href="#cb57-163" aria-hidden="true"></a>                <span class="va">self</span>.<span class="bu">buffer</span>.write(<span class="st">&quot;    &quot;</span><span class="op">*</span><span class="va">self</span>.indentation)</span>
<span id="cb57-164"><a href="#cb57-164" aria-hidden="true"></a>            <span class="va">self</span>.<span class="bu">buffer</span>.write(ch)</span>
<span id="cb57-165"><a href="#cb57-165" aria-hidden="true"></a>            <span class="va">self</span>.on_newline <span class="op">=</span> is_linebreak</span>
<span id="cb57-166"><a href="#cb57-166" aria-hidden="true"></a></span>
<span id="cb57-167"><a href="#cb57-167" aria-hidden="true"></a><span class="kw">class</span> _ListBuilder(_Builder):</span>
<span id="cb57-168"><a href="#cb57-168" aria-hidden="true"></a></span>
<span id="cb57-169"><a href="#cb57-169" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, builders):</span>
<span id="cb57-170"><a href="#cb57-170" aria-hidden="true"></a>        <span class="va">self</span>.builders <span class="op">=</span> builders</span>
<span id="cb57-171"><a href="#cb57-171" aria-hidden="true"></a></span>
<span id="cb57-172"><a href="#cb57-172" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-173"><a href="#cb57-173" aria-hidden="true"></a>        <span class="cf">for</span> builder <span class="kw">in</span> <span class="va">self</span>.builders:</span>
<span id="cb57-174"><a href="#cb57-174" aria-hidden="true"></a>            builder.write(output)</span>
<span id="cb57-175"><a href="#cb57-175" aria-hidden="true"></a></span>
<span id="cb57-176"><a href="#cb57-176" aria-hidden="true"></a><span class="kw">class</span> _AtomBuilder(_Builder):</span>
<span id="cb57-177"><a href="#cb57-177" aria-hidden="true"></a></span>
<span id="cb57-178"><a href="#cb57-178" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, atom):</span>
<span id="cb57-179"><a href="#cb57-179" aria-hidden="true"></a>        <span class="va">self</span>.atom <span class="op">=</span> atom</span>
<span id="cb57-180"><a href="#cb57-180" aria-hidden="true"></a></span>
<span id="cb57-181"><a href="#cb57-181" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-182"><a href="#cb57-182" aria-hidden="true"></a>        output.write(<span class="bu">str</span>(<span class="va">self</span>.atom))</span>
<span id="cb57-183"><a href="#cb57-183" aria-hidden="true"></a></span>
<span id="cb57-184"><a href="#cb57-184" aria-hidden="true"></a><span class="kw">class</span> _IndentBuilder(_Builder):</span>
<span id="cb57-185"><a href="#cb57-185" aria-hidden="true"></a></span>
<span id="cb57-186"><a href="#cb57-186" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-187"><a href="#cb57-187" aria-hidden="true"></a>        output.indentation <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb57-188"><a href="#cb57-188" aria-hidden="true"></a></span>
<span id="cb57-189"><a href="#cb57-189" aria-hidden="true"></a><span class="kw">class</span> _DedentBuilder(_Builder):</span>
<span id="cb57-190"><a href="#cb57-190" aria-hidden="true"></a></span>
<span id="cb57-191"><a href="#cb57-191" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-192"><a href="#cb57-192" aria-hidden="true"></a>        output.indentation <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb57-193"><a href="#cb57-193" aria-hidden="true"></a></span>
<span id="cb57-194"><a href="#cb57-194" aria-hidden="true"></a><span class="kw">class</span> _Memo(<span class="bu">dict</span>):</span>
<span id="cb57-195"><a href="#cb57-195" aria-hidden="true"></a></span>
<span id="cb57-196"><a href="#cb57-196" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb57-197"><a href="#cb57-197" aria-hidden="true"></a>        <span class="bu">dict</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb57-198"><a href="#cb57-198" aria-hidden="true"></a>        <span class="va">self</span>._latest_stream <span class="op">=</span> _ObjectStream(<span class="va">self</span>, [], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb57-199"><a href="#cb57-199" aria-hidden="true"></a>        <span class="va">self</span>._latest_lazy_message <span class="op">=</span> <span class="kw">lambda</span>: <span class="st">&quot;&quot;</span></span>
<span id="cb57-200"><a href="#cb57-200" aria-hidden="true"></a></span>
<span id="cb57-201"><a href="#cb57-201" aria-hidden="true"></a>    <span class="kw">def</span> describe(<span class="va">self</span>):</span>
<span id="cb57-202"><a href="#cb57-202" aria-hidden="true"></a>        items <span class="op">=</span> []</span>
<span id="cb57-203"><a href="#cb57-203" aria-hidden="true"></a>        <span class="cf">for</span> (rule_name, _), (_, start, end) <span class="kw">in</span> <span class="va">self</span>.items():</span>
<span id="cb57-204"><a href="#cb57-204" aria-hidden="true"></a>            <span class="cf">if</span> end <span class="op">&gt;</span> start:</span>
<span id="cb57-205"><a href="#cb57-205" aria-hidden="true"></a>                items.append((rule_name, start, end))</span>
<span id="cb57-206"><a href="#cb57-206" aria-hidden="true"></a>        items.sort(key<span class="op">=</span><span class="kw">lambda</span> item: (item[<span class="dv">2</span>].position(), item[<span class="dv">1</span>].position()))</span>
<span id="cb57-207"><a href="#cb57-207" aria-hidden="true"></a>        message <span class="op">=</span> []</span>
<span id="cb57-208"><a href="#cb57-208" aria-hidden="true"></a>        <span class="cf">for</span> item <span class="kw">in</span> items:</span>
<span id="cb57-209"><a href="#cb57-209" aria-hidden="true"></a>            message.append(<span class="st">&quot;matched </span><span class="sc">{: &lt;20}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> -&gt; </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="op">*</span>item))</span>
<span id="cb57-210"><a href="#cb57-210" aria-hidden="true"></a>        message.append(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb57-211"><a href="#cb57-211" aria-hidden="true"></a>        message.append(<span class="st">&quot;ERROR: </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb57-212"><a href="#cb57-212" aria-hidden="true"></a>            <span class="va">self</span>._latest_stream,</span>
<span id="cb57-213"><a href="#cb57-213" aria-hidden="true"></a>            <span class="va">self</span>._latest_lazy_message()</span>
<span id="cb57-214"><a href="#cb57-214" aria-hidden="true"></a>        ))</span>
<span id="cb57-215"><a href="#cb57-215" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join(message)</span>
<span id="cb57-216"><a href="#cb57-216" aria-hidden="true"></a></span>
<span id="cb57-217"><a href="#cb57-217" aria-hidden="true"></a>    <span class="kw">def</span> fail(<span class="va">self</span>, stream, lazy_message):</span>
<span id="cb57-218"><a href="#cb57-218" aria-hidden="true"></a>        <span class="cf">if</span> stream.position() <span class="op">&gt;=</span> <span class="va">self</span>._latest_stream.position():</span>
<span id="cb57-219"><a href="#cb57-219" aria-hidden="true"></a>            <span class="va">self</span>._latest_stream <span class="op">=</span> stream</span>
<span id="cb57-220"><a href="#cb57-220" aria-hidden="true"></a>            <span class="va">self</span>._latest_lazy_message <span class="op">=</span> lazy_message</span>
<span id="cb57-221"><a href="#cb57-221" aria-hidden="true"></a>        <span class="cf">raise</span> _MatchError(<span class="va">self</span>)</span>
<span id="cb57-222"><a href="#cb57-222" aria-hidden="true"></a></span>
<span id="cb57-223"><a href="#cb57-223" aria-hidden="true"></a><span class="kw">class</span> _MatchError(<span class="pp">Exception</span>):</span>
<span id="cb57-224"><a href="#cb57-224" aria-hidden="true"></a></span>
<span id="cb57-225"><a href="#cb57-225" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo):</span>
<span id="cb57-226"><a href="#cb57-226" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb57-227"><a href="#cb57-227" aria-hidden="true"></a>        <span class="va">self</span>._memo <span class="op">=</span> memo</span>
<span id="cb57-228"><a href="#cb57-228" aria-hidden="true"></a></span>
<span id="cb57-229"><a href="#cb57-229" aria-hidden="true"></a>    <span class="kw">def</span> describe(<span class="va">self</span>):</span>
<span id="cb57-230"><a href="#cb57-230" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._memo.describe()</span>
<span id="cb57-231"><a href="#cb57-231" aria-hidden="true"></a></span>
<span id="cb57-232"><a href="#cb57-232" aria-hidden="true"></a><span class="kw">class</span> _Stream(<span class="bu">object</span>):</span>
<span id="cb57-233"><a href="#cb57-233" aria-hidden="true"></a></span>
<span id="cb57-234"><a href="#cb57-234" aria-hidden="true"></a>    <span class="at">@classmethod</span></span>
<span id="cb57-235"><a href="#cb57-235" aria-hidden="true"></a>    <span class="kw">def</span> from_object(cls, memo, input_object):</span>
<span id="cb57-236"><a href="#cb57-236" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(input_object, <span class="bu">basestring</span>):</span>
<span id="cb57-237"><a href="#cb57-237" aria-hidden="true"></a>            <span class="cf">return</span> _CharStream(memo, input_object, <span class="dv">0</span>)</span>
<span id="cb57-238"><a href="#cb57-238" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-239"><a href="#cb57-239" aria-hidden="true"></a>            <span class="cf">return</span> _ObjectStream(memo, [input_object], <span class="dv">0</span>)</span>
<span id="cb57-240"><a href="#cb57-240" aria-hidden="true"></a></span>
<span id="cb57-241"><a href="#cb57-241" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index):</span>
<span id="cb57-242"><a href="#cb57-242" aria-hidden="true"></a>        <span class="va">self</span>._memo <span class="op">=</span> memo</span>
<span id="cb57-243"><a href="#cb57-243" aria-hidden="true"></a>        <span class="va">self</span>._objects <span class="op">=</span> objects</span>
<span id="cb57-244"><a href="#cb57-244" aria-hidden="true"></a>        <span class="va">self</span>._index <span class="op">=</span> index</span>
<span id="cb57-245"><a href="#cb57-245" aria-hidden="true"></a></span>
<span id="cb57-246"><a href="#cb57-246" aria-hidden="true"></a>    <span class="kw">def</span> fail(<span class="va">self</span>, lazy_message):</span>
<span id="cb57-247"><a href="#cb57-247" aria-hidden="true"></a>        <span class="va">self</span>._memo.fail(<span class="va">self</span>, lazy_message)</span>
<span id="cb57-248"><a href="#cb57-248" aria-hidden="true"></a></span>
<span id="cb57-249"><a href="#cb57-249" aria-hidden="true"></a>    <span class="kw">def</span> peek(<span class="va">self</span>):</span>
<span id="cb57-250"><a href="#cb57-250" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.is_at_end():</span>
<span id="cb57-251"><a href="#cb57-251" aria-hidden="true"></a>            <span class="va">self</span>.fail(<span class="kw">lambda</span>: <span class="st">&quot;not eof&quot;</span>)</span>
<span id="cb57-252"><a href="#cb57-252" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._objects[<span class="va">self</span>._index]</span>
<span id="cb57-253"><a href="#cb57-253" aria-hidden="true"></a></span>
<span id="cb57-254"><a href="#cb57-254" aria-hidden="true"></a>    <span class="kw">def</span> is_at_end(<span class="va">self</span>):</span>
<span id="cb57-255"><a href="#cb57-255" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._index <span class="op">&gt;=</span> <span class="bu">len</span>(<span class="va">self</span>._objects)</span>
<span id="cb57-256"><a href="#cb57-256" aria-hidden="true"></a></span>
<span id="cb57-257"><a href="#cb57-257" aria-hidden="true"></a><span class="kw">class</span> _CharStream(_Stream):</span>
<span id="cb57-258"><a href="#cb57-258" aria-hidden="true"></a></span>
<span id="cb57-259"><a href="#cb57-259" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index, line<span class="op">=</span><span class="dv">1</span>, column<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb57-260"><a href="#cb57-260" aria-hidden="true"></a>        _Stream.<span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index)</span>
<span id="cb57-261"><a href="#cb57-261" aria-hidden="true"></a>        <span class="va">self</span>._line <span class="op">=</span> line</span>
<span id="cb57-262"><a href="#cb57-262" aria-hidden="true"></a>        <span class="va">self</span>._column <span class="op">=</span> column</span>
<span id="cb57-263"><a href="#cb57-263" aria-hidden="true"></a></span>
<span id="cb57-264"><a href="#cb57-264" aria-hidden="true"></a>    <span class="kw">def</span> position(<span class="va">self</span>):</span>
<span id="cb57-265"><a href="#cb57-265" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._index</span>
<span id="cb57-266"><a href="#cb57-266" aria-hidden="true"></a></span>
<span id="cb57-267"><a href="#cb57-267" aria-hidden="true"></a>    <span class="kw">def</span> advance(<span class="va">self</span>):</span>
<span id="cb57-268"><a href="#cb57-268" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>._objects[<span class="va">self</span>._index] <span class="op">==</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>:</span>
<span id="cb57-269"><a href="#cb57-269" aria-hidden="true"></a>            line <span class="op">=</span> <span class="va">self</span>._line <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb57-270"><a href="#cb57-270" aria-hidden="true"></a>            column <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb57-271"><a href="#cb57-271" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-272"><a href="#cb57-272" aria-hidden="true"></a>            line <span class="op">=</span> <span class="va">self</span>._line</span>
<span id="cb57-273"><a href="#cb57-273" aria-hidden="true"></a>            column <span class="op">=</span> <span class="va">self</span>._column <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb57-274"><a href="#cb57-274" aria-hidden="true"></a>        <span class="cf">return</span> _CharStream(<span class="va">self</span>._memo, <span class="va">self</span>._objects, <span class="va">self</span>._index<span class="op">+</span><span class="dv">1</span>, line, column)</span>
<span id="cb57-275"><a href="#cb57-275" aria-hidden="true"></a></span>
<span id="cb57-276"><a href="#cb57-276" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb57-277"><a href="#cb57-277" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;L</span><span class="sc">{:03d}</span><span class="st">:C</span><span class="sc">{:03d}</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="va">self</span>._line, <span class="va">self</span>._column)</span>
<span id="cb57-278"><a href="#cb57-278" aria-hidden="true"></a></span>
<span id="cb57-279"><a href="#cb57-279" aria-hidden="true"></a><span class="kw">class</span> _ObjectStream(_Stream):</span>
<span id="cb57-280"><a href="#cb57-280" aria-hidden="true"></a></span>
<span id="cb57-281"><a href="#cb57-281" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index, parent<span class="op">=</span>()):</span>
<span id="cb57-282"><a href="#cb57-282" aria-hidden="true"></a>        _Stream.<span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index)</span>
<span id="cb57-283"><a href="#cb57-283" aria-hidden="true"></a>        <span class="va">self</span>._parent_position <span class="op">=</span> parent</span>
<span id="cb57-284"><a href="#cb57-284" aria-hidden="true"></a>        <span class="va">self</span>._position <span class="op">=</span> <span class="va">self</span>._parent_position <span class="op">+</span> (<span class="va">self</span>._index,)</span>
<span id="cb57-285"><a href="#cb57-285" aria-hidden="true"></a></span>
<span id="cb57-286"><a href="#cb57-286" aria-hidden="true"></a>    <span class="kw">def</span> position(<span class="va">self</span>):</span>
<span id="cb57-287"><a href="#cb57-287" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._position</span>
<span id="cb57-288"><a href="#cb57-288" aria-hidden="true"></a></span>
<span id="cb57-289"><a href="#cb57-289" aria-hidden="true"></a>    <span class="kw">def</span> nested(<span class="va">self</span>, input_object):</span>
<span id="cb57-290"><a href="#cb57-290" aria-hidden="true"></a>        <span class="cf">return</span> _ObjectStream(<span class="va">self</span>._memo, input_object, <span class="dv">0</span>, <span class="va">self</span>._position)</span>
<span id="cb57-291"><a href="#cb57-291" aria-hidden="true"></a></span>
<span id="cb57-292"><a href="#cb57-292" aria-hidden="true"></a>    <span class="kw">def</span> advance(<span class="va">self</span>):</span>
<span id="cb57-293"><a href="#cb57-293" aria-hidden="true"></a>        <span class="cf">return</span> _ObjectStream(<span class="va">self</span>._memo, <span class="va">self</span>._objects, <span class="va">self</span>._index<span class="op">+</span><span class="dv">1</span>, <span class="va">self</span>._parent_position)</span>
<span id="cb57-294"><a href="#cb57-294" aria-hidden="true"></a></span>
<span id="cb57-295"><a href="#cb57-295" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb57-296"><a href="#cb57-296" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;[</span><span class="sc">{}</span><span class="st">]&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;, &quot;</span>.join(<span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.position()))</span></code></pre></div>
<h3 id="ee923adb0ed4f3b8a5cc72700aad2ddcompile.sh">[]{#1ee923adb0ed4f3b8a5cc72700aad2dd}compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

rlmeta_compiler=&quot;$(pwd)/$1&quot;

cd &quot;$(dirname &quot;$0&quot;)&quot;

to_python_string() {
    python -c &#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;
}

support_py_string=$(to_python_string &lt; support.py)
support_py=$(python &quot;$rlmeta_compiler&quot; --support)
parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
import sys

SUPPORT = $support_py_string

$support_py

$parser_py

$codegenerator_py

join = &quot;&quot;.join

def compile_grammar(grammar):
    parser = Parser()
    code_generator = CodeGenerator()
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))

if __name__ == &quot;__main__&quot;:
    if &quot;--support&quot; in sys.argv:
        sys.stdout.write(SUPPORT)
    else:
        try:
            sys.stdout.write(compile_grammar(sys.stdin.read()))
        except _MatchError as e:
            sys.stderr.write(e.describe())
            sys.exit(1)
EOF</code></pre>
<h3 id="meta_compile.sh"><span id="d09466ef920844788d5e63457decfd86"></span>meta_compile.sh</h3>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true"></a></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true"></a></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true"></a></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true"></a><span class="bu">echo</span> OK</span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>Modifying the RLMeta metacompiler</title>
    <link href="http://rickardlindberg.me/writing/modifying-rlmeta/" />
    <id>http://rickardlindberg.me/writing/modifying-rlmeta/</id>
    <published>2019-05-28T00:00:00Z</published>
    <updated>2019-05-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Modifying the RLMeta metacompiler</h1>

<p><em>Published on 28 May 2019.</em></p>

<p>In the first article about <a href="/writing/rlmeta/index.html">RLMeta</a> I wrote that its small implementation makes it feasible to understand and modify. But modifying the RLMeta metacompiler differs from modifying a regular program. In this article I explain how it differs and show examples of how different parts of RLMeta can be modified.</p>
<ul>
<li><a href="#39efe623ff374daba9830984300fcde2">Meta what?</a></li>
<li><a href="#93d9030e0e4849c5a8d8ca0fffdf7592">Modifying a metacompiler</a></li>
<li><a href="#bf2e6a99e41f478f884dd15ea243c111">Compiling RLMeta</a></li>
<li><a href="#75ad82923a2142789d01ca5be1d11942">Verifying metacompiler</a></li>
<li><a href="#5f6a1c91143146dbb3b865ac42562135">Modifying format of generated code</a></li>
<li><a href="#d54bbeda3d9846bca027f2c2995775a5">Meta compile script</a></li>
<li><a href="#6bfdc073cd4041238b169caa671c9652">Breaking modification</a></li>
<li><a href="#0130b76cb3d24f458bb47debb6fc2780">Modifying support library</a></li>
<li><a href="#1a090bb868154140a167968d8b4b15dc">Extending parser escape codes</a></li>
<li><a href="#22e574102e394218b874f03bb879c92f">Modifying parser</a></li>
<li><a href="#60cb5d0ff4ca4d94920bfe635ffd2142">Code listings for RLMeta</a>
<ul>
<li><a href="#df676d8cca604142bd1049c5e86c68a2">compile.sh</a></li>
<li><a href="#38ee00b5ef7c40f79d24fa61f052368f">meta_compile.sh</a></li>
<li><a href="#596acbaab3614dc787158be918bd9d32">is_metacompiler.sh</a></li>
</ul></li>
</ul>
<h2 id="efe623ff374daba9830984300fcde2meta-what">[]{#39efe623ff374daba9830984300fcde2}Meta what?</h2>
<p>What is a metacompiler and how does it differ from a regular compiler?</p>
<p>A compiler translates source code into an executable:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
</center>
<p>A C compiler translates source code written in C into an executable:</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
</center>
<p>A metacompiler translates source code written in a metalanguage into an executable:</p>
<p><img src="image3.png" /></p>
<!-- image text -->
<center>
</center>
<p>A metalanguage is a domain specific language for describing other languages. It can be used to describe what languages look like (their syntax) and how to translate them into executables (their semantics). In essence, it can be used to describe compilers.</p>
<p>Because a metalanguage can be used to describe any compiler, it can also be used to describe the metacompiler itself. The metacompiler translates such a description into itself:</p>
<p><img src="image4.png" /></p>
<!-- image text -->
<center>
</center>
<p>A metacompiler does not have to be implemented in the metalanguage itself, but I suspect that it is common that it is. RLMeta is indeed implemented in its own language. This is also known as self-hosting. For the rest of this article, I will assume that a metacompiler is also self-hosting.</p>
<p>A C compiler written in C is not a metacompiler because C is not a metalanguage. It is a general purpose programming language not designed specifically to describe other languages. Such a compiler is merely a self-hosting compiler.</p>
<h2 id="d9030e0e4849c5a8d8ca0fffdf7592modifying-a-metacompiler">[]{#93d9030e0e4849c5a8d8ca0fffdf7592}Modifying a metacompiler</h2>
<p>How is modifying a metacompiler different from modifying a regular program?</p>
<p>In general, to modify a program written in a compiled language, its source code and a compiler is needed. Modifying the program is a matter of modifying the source code and compiling it:</p>
<p><img src="image5.png" /></p>
<!-- image text -->
<center>
</center>
<p><img src="image6.png" /></p>
<!-- image text -->
<center>
</center>
<p>In the case of a metacompiler, the compiler and the executable is the same. However, if the source code is modified, the executable might not be the metacompiler itself:</p>
<p><img src="image7.png" /></p>
<!-- image text -->
<center>
</center>
<p><img src="image8.png" /></p>
<!-- image text -->
<center>
</center>
<p>At this point, the metacompiler is needed to keep maintaining the modified executable. But the source code for the metacompiler itself is "lost" because the metacompiler can not be reproduced from the modified source code:</p>
<p><img src="image9.png" /></p>
<!-- image text -->
<center>
</center>
<p>Because there is no source code, the original metacompiler can not be modified either.</p>
<p>When modifying a metacompiler, care has to be taken to ensure that, in the end, the executable is still a metacompiler. Otherwise the metacompiler can not be modified further. This is a key difference from modifying a regular program. (Similar care has to be taken when modifying a self-hosting compiler.)</p>
<h2 id="compiling-rlmeta"><span id="bf2e6a99e41f478f884dd15ea243c111"></span>Compiling RLMeta</h2>
<p>This is a recap of how RLMeta is compiled.</p>
<p>RLMeta is compiled with the <code>compile.sh</code> script. It takes one argument which is the path to the RLMeta compiler. The script uses that compiler to compile the source code and then assemble the output to a Python file that looks like this:</p>
<pre><code>1.  compile.sh
2.  [rlmeta template]{.cp}</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">import</span> sys</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ex">SUPPORT</span> = <span class="va">$support_py_string</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="fu">join</span> = <span class="st">&quot;&quot;</span>.join</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="ex">def</span> compile_grammar(grammar)<span class="bu">:</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>    <span class="ex">parser</span> = Parser()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="ex">code_generator</span> = CodeGenerator()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>    <span class="bu">return</span> code_generator.run(<span class="st">&quot;ast&quot;</span>, parser.run(<span class="st">&quot;grammar&quot;</span>, grammar))</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="kw">if</span> <span class="ex">__name__</span> == <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>    <span class="kw">if</span> <span class="st">&quot;--support&quot;</span> <span class="kw">in</span> <span class="ex">sys.argv</span>:</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>        <span class="ex">sys.stdout.write</span>(SUPPORT)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>    <span class="ex">else</span>:</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>        <span class="ex">try</span>:</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>            <span class="ex">sys.stdout.write</span>(compile_grammar(sys.stdin.read()))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>        <span class="ex">except</span> _MatchError as e:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>            <span class="ex">sys.stderr.write</span>(e.describe())</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>            <span class="ex">sys.exit</span>(1)</span></code></pre></div>
<p>The variables <code>$support_py</code>, <code>$parser_py</code>, and <code>$codegenerator_py</code> are produced by the RLMeta compiler. The variable <code>$support_py_string</code> is produced by converting the support library to a Python string. Here is the rest of the <code>compile.sh</code> script:</p>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">&#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>&lt;&lt;rlmeta template&gt;&gt;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<h2 id="ad82923a2142789d01ca5be1d11942verifying-metacompiler">[]{#75ad82923a2142789d01ca5be1d11942}Verifying metacompiler</h2>
<p>How can it be verified that RLMeta is a metacompiler?</p>
<p>The <code>is_metacompiler.sh</code> script checks if a given file is a metacompiler. It does so by comparing the file to the file generated by the <code>compile.sh</code> script. If they are equal, the file is a metacompiler because it reproduced itself exactly. Otherwise the two files differ.</p>
<pre><code>1.  is\_metacompiler.sh</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">if</span> <span class="fu">diff</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="op">&lt;(</span><span class="ex">./compile.sh</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span><span class="op">)</span><span class="kw">;</span> <span class="kw">then</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st"> is a metacompiler!&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">else</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st"> is not a metacompiler. See diff above.&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="kw">fi</span></span></code></pre></div>
<p>RLMeta is a metacompiler because its source code is written in a metalanguage and it is able to reproduce itself:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta.py
rlmeta.py is a metacompiler!</code></pre>
<p>The following sections show examples of how to make modifications to RLMeta that ensure that the modified version is still a metacompiler.</p>
<h2 id="f6a1c91143146dbb3b865ac42562135modifying-format-of-generated-code">[]{#5f6a1c91143146dbb3b865ac42562135}Modifying format of generated code</h2>
<p>The code generator in RLMeta generates lambda expressions with newlines and indentation:</p>
<pre class="text"><code>(lambda:
    ...
)</code></pre>
<p>This example shows how to modify it to generate equivalent lambda expressions without the additional punctuation like this:</p>
<pre class="text"><code>(lambda: ...)</code></pre>
<p>First, the following line in the code generator is changed from</p>
<pre class="text"><code>| astFnBody:x -&gt; { &quot;(lambda:\n&quot; &gt; x &lt; &quot;\n)&quot; }</code></pre>
<p>to</p>
<pre class="text"><code>| astFnBody:x -&gt; { &quot;(lambda: &quot; x &quot;)&quot; }</code></pre>
<p>The modified source code describes a metacompiler whose code generator generates lambda expressions without the additional punctuation. How is a new metacompiler created from this modified source code?</p>
<p>Compiling the modified source code gives a new executable:</p>
<pre class="text"><code>$ ./compile.sh rlmeta.py &gt; rlmeta1.py</code></pre>
<p><img src="image10.png" /></p>
<!-- image text -->
<center>
</center>
<p>With this modification, <code>rlmeta.py</code> is no longer a metacompiler because it differs from <code>rlmeta1.py</code>:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta.py
1685,1686c1685
&lt;                                         &#39;(lambda:\n&#39;,
&lt;                                         _IndentBuilder(),
---
&gt;                                         &#39;(lambda:&#39;,
1688,1689c1687
&lt;                                         _DedentBuilder(),
&lt;                                         &#39;\n)&#39;,
---
&gt;                                         &#39;)&#39;,
rlmeta.py is not a metacompiler. See diff above.</code></pre>
<p>The difference is that the code for generating lambda expressions is different. <code>rlmeta1.py</code> should still be a compiler that recognizes the same source language so it can be used to compile the modified source code again, giving yet another executable:</p>
<pre class="text"><code>$ ./compile.sh rlmeta1.py &gt; rlmeta2.py</code></pre>
<p><img src="image11.png" /></p>
<!-- image text -->
<center>
</center>
<p><code>rlmeta1.py</code> is not a metacompiler either because it differs from <code>rlmeta2.py</code>:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta1.py
287,325c287,299
&lt;         return (lambda:
&lt;             self._or([
&lt;                 (lambda:
&lt;                     (lambda _vars:
&lt;                         (lambda:
&lt;                             self._and([
&lt;                                 (lambda:
&lt;                                     _vars.bind(&#39;x&#39;, (lambda:
&lt;                                         self._match_rule(&#39;name&#39;)
&lt;                                     )())
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_rule(&#39;space&#39;)
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_charseq(&#39;{&#39;)
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     _vars.bind(&#39;ys&#39;, (lambda:
&lt;                                         self._star((lambda:
&lt;                                             self._match_rule(&#39;rule&#39;)
&lt;                                         ))
&lt;                                     )())
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_rule(&#39;space&#39;)
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_charseq(&#39;}&#39;)
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     _SemanticAction(lambda: ([&#39;Grammar&#39;]+[_vars.lookup(&#39;x&#39;).eval()]+_vars.lookup(&#39;ys&#39;).eval()+[]))
&lt;                                 ),
&lt;                             ])
&lt;                         )()
&lt;                     )(_Vars())
&lt;                 ),
&lt;             ])
&lt;         )()
---
&gt;         return (lambda: self._or([
&gt;             (lambda: (lambda _vars:
&gt;                 (lambda: self._and([
&gt;                     (lambda: _vars.bind(&#39;x&#39;, (lambda: self._match_rule(&#39;name&#39;))())),
&gt;                     (lambda: self._match_rule(&#39;space&#39;)),
&gt;                     (lambda: self._match_charseq(&#39;{&#39;)),
&gt;                     (lambda: _vars.bind(&#39;ys&#39;, (lambda: self._star((lambda: self._match_rule(&#39;rule&#39;))))())),
&gt;                     (lambda: self._match_rule(&#39;space&#39;)),
&gt;                     (lambda: self._match_charseq(&#39;}&#39;)),
&gt;                     (lambda: _SemanticAction(lambda: ([&#39;Grammar&#39;]+[_vars.lookup(&#39;x&#39;).eval()]+_vars.lookup(&#39;ys&#39;).eval()+[]))),
&gt;                 ]))()
&gt;             )(_Vars())),
&gt;         ]))()
...
rlmeta1.py is not a metacompiler. See diff above.</code></pre>
<p>This time the difference is only in formatting. The two programs should be semantically equivalent. The original modification set out to remove additional punctuation in lambda expressions and this can now be seen in the generated code. <code>rlmeta2.py</code> can be used to compile the modified source code again, giving yet another executable:</p>
<pre class="text"><code>$ ./compile.sh rlmeta2.py &gt; rlmeta3.py</code></pre>
<p><img src="image12.png" /></p>
<!-- image text -->
<center>
</center>
<p><code>rlmeta2.py</code> is now a metacompiler because it is the same as <code>rlmeta3.py</code>:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta2.py
rlmeta2.py is a metacompiler!</code></pre>
<p><code>rlmeta2.py</code> together with the modified source becomes the next version of the RLMeta metacompiler. All other intermediate compilers can be discarded.</p>
<p><img src="image13.png" /></p>
<!-- image text -->
<center>
</center>
<h2 id="meta-compile-script"><span id="d54bbeda3d9846bca027f2c2995775a5"></span>Meta compile script</h2>
<p>The steps to create the next version of RLMeta can be scripted like this:</p>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a><span class="bu">echo</span> OK</span></code></pre></div>
<p>It starts with a <code>set -e</code> directive that makes the script stop immediately when a command fails. Then it changes directory to the same directory as the script itself is in. That directory is assumed to also contain the <code>compile.sh</code> script. It then uses the <code>compile.sh</code> script to create the intermediate compilers. If all compile commands succeed, the two last compilers are compared. If they differ, it was not possible to create a metacompiler. The <code>diff</code> command then fails and the script fails. The intermediate compilers are left on disk for inspection. If the two last compilers are the same, a sanity check that the support libraries are the same is done. Then intermediate compilers are removed. At the end, an 'OK' is printed, signifying that a new version of RLMeta was successfully created.</p>
<p>This script will be used in the following examples.</p>
<h2 id="bfdc073cd4041238b169caa671c9652breaking-modification">[]{#6bfdc073cd4041238b169caa671c9652}Breaking modification</h2>
<p>This example shows what happens if the source code is modified so that it no longer correctly describes a metacompiler.</p>
<p>A dummy modification that should break things is changing the following line that generates code for rules from</p>
<pre class="text"><code>| [&quot;Rule&quot; .:x ast:y] -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt; }</code></pre>
<p>to</p>
<pre class="text"><code>| [&quot;Rule&quot; .:x ast:y] -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;pass\n&quot; &lt; }</code></pre>
<p>Instead of generating a function body, the <code>y</code> ast node is ignored and a <code>pass</code> statement is generated instead.</p>
<p>Running the meta compile script on the modified source code indeed gives an error:</p>
<pre class="text"><code>$ ./meta_compile.sh
Traceback (most recent call last):
  File &quot;rlmeta2.py&quot;, line 375, in &lt;module&gt;
    sys.stdout.write(compile_grammar(sys.stdin.read()))
  File &quot;rlmeta2.py&quot;, line 368, in compile_grammar
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))
  File &quot;rlmeta2.py&quot;, line 102, in run
    result = self._match_rule(rule_name).eval()
AttributeError: &#39;NoneType&#39; object has no attribute &#39;eval&#39;</code></pre>
<p>This means that a new metacompiler could not be created. Why?</p>
<p>The error happens in <code>rlmeta2.py</code> when the following compilation step is run:</p>
<pre class="text"><code>./compile.sh rlmeta2.py &gt; rlmeta3.py</code></pre>
<p>It means that both <code>rlmeta1.py</code> and <code>rlmeta2.py</code> were successfully created, but it failed to create <code>rlmeta3.py</code>. The difference between <code>rlmeta.py</code> and <code>rlmeta1.py</code> is that the code for generating code for rules is different:</p>
<pre class="text"><code>$ diff rlmeta.py rlmeta1.py
1453,1455c1453
&lt;                                         &#39;return &#39;,
&lt;                                         _vars.lookup(&#39;y&#39;).eval(),
&lt;                                         &#39;()\n&#39;,
---
&gt;                                         &#39;pass\n&#39;,</code></pre>
<p><code>rlmeta1.py</code> is still a compiler that recognizes the same source language so it was successfully used to create <code>rlmeta2.py</code>. The difference between <code>rlmeta1.py</code> and <code>rlmeta2.py</code> is that the code for rules just have a <code>pass</code> statement instead of code for doing matching and returning results:</p>
<pre class="text"><code>$ diff rlmeta1.py rlmeta2.py 
287,325c287
&lt;         return (lambda:
&lt;             self._or([
...
&lt;             ])
&lt;         )()
---
&gt;         pass
...</code></pre>
<p>So <code>rlmeta2.py</code> will not work because all rules return <code>None</code>. When <code>_match_rule</code> is called it will get <code>None</code> back but expect a semantic action. When <code>eval</code> is run it will fail because the result is not a semantic action, but instead <code>None</code>.</p>
<p>Because the modified source code does not correctly describe how code for rules should be generated, it does not describe a metacompiler, and it can never be used to create a new metacompiler.</p>
<h2 id="b76cb3d24f458bb47debb6fc2780modifying-support-library">[]{#0130b76cb3d24f458bb47debb6fc2780}Modifying support library</h2>
<p>This example shows how to make a modification that requires modifying both the support library and the code generator. It shows how the arguments to the <code>bind</code> function can be swapped.</p>
<p>In the support library, the following line that defines the <code>bind</code> function is changed from</p>
<pre class="text"><code>def bind(self, name, value):</code></pre>
<p>to</p>
<pre class="text"><code>def bind(self, value, name):</code></pre>
<p>In the code generator, the following line that generates calls to <code>bind</code> is changed from</p>
<pre class="text"><code>| [&quot;Bind&quot; .:x ast:y] -&gt; { &quot;_vars.bind(&quot; repr(x) &quot;, &quot; y &quot;())&quot; }</code></pre>
<p>to</p>
<pre class="text"><code>| [&quot;Bind&quot; .:x ast:y] -&gt; { &quot;_vars.bind(&quot; y &quot;(), &quot; repr(x) &quot;)&quot; }</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The difference between the two metacompilers is that the two versions of the support library are modified, all <code>bind</code> calls have swapped arguments, and code that generates calls to <code>bind</code> have swapped arguments:</p>
<pre class="text"><code>$ diff rlmeta.py.orig rlmeta.py
3c3
&lt; SUPPORT = ...
---
&gt; SUPPORT = ...
110c110
&lt;     def bind(self, name, value):
---
&gt;     def bind(self, value, name):
294c294
&lt;                                     _vars.bind(&#39;x&#39;, (lambda:
---
&gt;                                     _vars.bind((lambda:
296c296
&lt;                                     )())
---
&gt;                                     )(), &#39;x&#39;)
1814a1815,1816
&gt;                                         _vars.lookup(&#39;y&#39;).eval(),
&gt;                                         &#39;(), &#39;,
1818,1820c1820
&lt;                                         &#39;, &#39;,
&lt;                                         _vars.lookup(&#39;y&#39;).eval(),
&lt;                                         &#39;())&#39;,
---
&gt;                                         &#39;)&#39;,
...</code></pre>
<p>This modification creates a new version of RLMeta that works exactly the same as the previous version, but internally the <code>bind</code> function has a different signature.</p>
<p>These compilation steps were not possible in the first version of RLMeta because the <code>compile.sh</code> script generated the support library incorrectly. All RLMeta compilers have two versions of the support library: the one that it generates (stored in the <code>SUPPORT</code> variable), and the one it uses itself. If the compiler is a metacompiler, the two versions are the same, but in intermediate compilers they might differ.</p>
<p>The first version of RLMeta generated the support library like this:</p>
<pre class="text"><code>support_py=$(cat support.py)</code></pre>
<p>It meant that the intermediate compilers always had the latest support library, and the two versions of the support library were always the same.</p>
<p>Running the meta compile script on the modified source code with the old version of <code>compile.sh</code> gives an error:</p>
<pre class="text"><code>$ ./meta_compile.sh
Traceback (most recent call last):
  File &quot;rlmeta1.py&quot;, line 2217, in &lt;module&gt;
    sys.stdout.write(compile_grammar(sys.stdin.read()))
  File &quot;rlmeta1.py&quot;, line 2210, in compile_grammar
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))
  File &quot;rlmeta1.py&quot;, line 102, in run
    result = self._match_rule(rule_name).eval()
  File &quot;rlmeta1.py&quot;, line 123, in eval
    return self.fn()
  File &quot;rlmeta1.py&quot;, line 318, in &lt;lambda&gt;
    _SemanticAction(lambda: ([&#39;Grammar&#39;]+[_vars.lookup(&#39;x&#39;).eval()]+_vars.lookup(&#39;ys&#39;).eval()+[]))
  File &quot;rlmeta1.py&quot;, line 115, in lookup
    return self[name]
KeyError: &#39;x&#39;</code></pre>
<p>Now <code>rlmeta1.py</code> has swapped arguments in the support library, but the generated code (generated by <code>rlmeta.py</code>) still expects not swapped arguments. Notice the absence of swapped arguments in <code>bind</code> calls in the diff:</p>
<pre class="text"><code>$ diff rlmeta.py rlmeta1.py
3c3
&lt; SUPPORT = ...
---
&gt; SUPPORT = ...
110c110
&lt;     def bind(self, name, value):
---
&gt;     def bind(self, value, name):
1814a1815,1816
&gt;                                         _vars.lookup(&#39;y&#39;).eval(),
&gt;                                         &#39;(), &#39;,
1818,1820c1820
&lt;                                         &#39;, &#39;,
&lt;                                         _vars.lookup(&#39;y&#39;).eval(),
&lt;                                         &#39;())&#39;,
---
&gt;                                         &#39;)&#39;,</code></pre>
<p>This in turn leads to <code>rlmeta1.py</code> not functioning because its <code>bind</code> calls have not stored the name as key, but the value. Hence the key error.</p>
<p>The version of RLMeta in this article fixes the generation of the <code>$support_py</code> variable like this:</p>
<pre class="text"><code>support_py=$(python &quot;$rlmeta_compiler&quot; --support)</code></pre>
<p>This ensures that the code that the code generator generates is always in sync with the support library.</p>
<h2 id="a090bb868154140a167968d8b4b15dcextending-parser-escape-codes">[]{#1a090bb868154140a167968d8b4b15dc}Extending parser escape codes</h2>
<p>The escape codes possible in strings in RLMeta are '<code>\\</code>', '<code>\'</code>', '<code>\"</code>', and '<code>\n</code>':</p>
<pre class="text"><code>escape = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
       | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;</code></pre>
<p>This example shows how a new escape code, '<code>\t</code>', can be added.</p>
<p>A first attempt might be to extend the <code>escape</code> rule in the parser like this:</p>
<pre class="text"><code>escape = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
       | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
       | &#39;t&#39;  -&gt; &quot;\t&quot;</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The code generated for the tab case looks like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        (lambda:
            self._and([
                (lambda:
                    self._match_charseq(&#39;t&#39;)
                ),
                (lambda:
                    _SemanticAction(lambda: &#39;\\t&#39;)
                ),
            ])
        )()
    )(_Vars())
),</code></pre>
<p>It doesn't look quite right. The semantic action does not return a tab character but rather two characters: '<code>\</code>' and '<code>t</code>'. The reason for this is that the modified source code tries to use the new escape code before the parser understands it. Since the parser does not recognize the new escape code, it will treat it as two separate characters.</p>
<p>How can the semantic action be modified to return an single tab character? The escape code can not be used until it is implemented, so the only solution is to call a function that returns a tab character:</p>
<pre class="text"><code>escape = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
       | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
       | &#39;t&#39;  -&gt; tab()</code></pre>
<p>The <code>tab</code> function is added to the Python template to give generated code access to it:</p>
<pre class="text"><code>tab = lambda: &quot;\t&quot;</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The code generated for the tab case now looks like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        (lambda:
            self._and([
                (lambda:
                    self._match_charseq(&#39;t&#39;)
                ),
                (lambda:
                    _SemanticAction(lambda: tab(
                    ))
                ),
            ])
        )()
    )(_Vars())
),</code></pre>
<p>The semantic action now correctly generates a tab character by calling the <code>tab</code> function.</p>
<p>Now the new escape code can be used inside strings and the <code>tab</code> function can be discarded:</p>
<pre class="text"><code>escape = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
       | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
       | &#39;t&#39;  -&gt; &quot;\t&quot;</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The code generated for the tab case now looks like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        (lambda:
            self._and([
                (lambda:
                    self._match_charseq(&#39;t&#39;)
                ),
                (lambda:
                    _SemanticAction(lambda: &#39;\t&#39;)
                ),
            ])
        )()
    )(_Vars())
),</code></pre>
<p>The semantic action now returns a single tab character without using the <code>tab</code> function.</p>
<p>Adding the tab escape code required two passes: one to recognize it and one to use it.</p>
<h2 id="e574102e394218b874f03bb879c92fmodifying-parser">[]{#22e574102e394218b874f03bb879c92f}Modifying parser</h2>
<p>The syntax for introducing a semantic action in RLMeta is <code>-&gt;</code>. This example shows how it can be changed to <code>=&gt;</code>. A first attempt might be to change the following line in the parser from</p>
<pre class="text"><code>| space &#39;-&gt;&#39; hostExpr:x -&gt; [&quot;SemanticAction&quot; x]</code></pre>
<p>to</p>
<pre class="text"><code>| space &#39;=&gt;&#39; hostExpr:x -&gt; [&quot;SemanticAction&quot; x]</code></pre>
<p>Running the meta compile script on the modified source code gives an error:</p>
<pre class="text"><code>$ ./meta_compile.sh
...
ERROR: L003:C048: expected &#39;}&#39; but found &#39;-&#39;</code></pre>
<p>What happened? The first compiler generated by the meta compile script (<code>rlmeta1.py</code>) has a parser that expects the syntax to be <code>=&gt;</code> for semantic actions. When the meta compile script tries to run that compiler on the modified source code it fails because the modified source code is still using the old <code>-&gt;</code> syntax. The source code can not be changed to the new syntax before the parser recognizes it, so the meta compile script does not work for this modification.</p>
<p>This can be solved in two ways. Either the parser can be changed to allow both syntaxes like this:</p>
<pre class="text"><code>| space (&#39;-&#39;|&#39;=&#39;)&#39;&gt;&#39; hostExpr:x -&gt; [&quot;SemanticAction&quot; x]</code></pre>
<p>Once a new metacompiler has been created, the source code can be changed to use <code>=&gt;</code>, and then the choice in the parser can be removed to allow only <code>=&gt;</code>.</p>
<p>Or the source code must be changed again before creating <code>rlmeta2.py</code> like this:</p>
<pre class="text"><code>$ # make parser change
$ ./compile.sh rlmeta.py &gt; rlmeta1.py
$ # change syntax from `-&gt;` to `=&gt;`
$ ./compile.sh rlmeta1.py &gt; rlmeta2.py
$ ./is_metacompiler.sh rlmeta2.py
rlmeta2.py is a metacompiler!</code></pre>
<p><img src="image14.png" /></p>
<!-- image text -->
<center>
</center>
<h2 id="cb5d0ff4ca4d94920bfe635ffd2142code-listings-for-rlmeta">[]{#60cb5d0ff4ca4d94920bfe635ffd2142}Code listings for RLMeta</h2>
<p>The only modifications from the original <a href="../rlmeta/index.html#388bb1e8ccbd4d55b89b391c08452c33">RLMeta</a> are the tweaked <code>compile.sh</code> script and the additional <code>meta_compile.sh</code> and <code>is_metacompiler.sh</code> scripts. They are shown fully here. For the rest of the source code, see the original article.</p>
<h3 id="compile.sh"><span id="df676d8cca604142bd1049c5e86c68a2"></span>compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

rlmeta_compiler=&quot;$(pwd)/$1&quot;

cd &quot;$(dirname &quot;$0&quot;)&quot;

to_python_string() {
    python -c &#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;
}

support_py_string=$(to_python_string &lt; support.py)
support_py=$(python &quot;$rlmeta_compiler&quot; --support)
parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
import sys

SUPPORT = $support_py_string

$support_py

$parser_py

$codegenerator_py

join = &quot;&quot;.join

def compile_grammar(grammar):
    parser = Parser()
    code_generator = CodeGenerator()
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))

if __name__ == &quot;__main__&quot;:
    if &quot;--support&quot; in sys.argv:
        sys.stdout.write(SUPPORT)
    else:
        try:
            sys.stdout.write(compile_grammar(sys.stdin.read()))
        except _MatchError as e:
            sys.stderr.write(e.describe())
            sys.exit(1)
EOF</code></pre>
<h3 id="ee00b5ef7c40f79d24fa61f052368fmeta_compile.sh">[]{#38ee00b5ef7c40f79d24fa61f052368f}meta_compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

cd &quot;$(dirname &quot;$0&quot;)&quot;

./compile.sh rlmeta.py &gt; rlmeta1.py

./compile.sh rlmeta1.py &gt; rlmeta2.py

./compile.sh rlmeta2.py &gt; rlmeta3.py

diff rlmeta2.py rlmeta3.py

diff support.py &lt;(python rlmeta3.py --support)

mv rlmeta3.py rlmeta2.py

mv rlmeta2.py rlmeta1.py

mv rlmeta1.py rlmeta.py

echo OK</code></pre>
<h3 id="acbaab3614dc787158be918bd9d32is_metacompiler.sh">[]{#596acbaab3614dc787158be918bd9d32}is_metacompiler.sh</h3>
<pre class="text"><code>#!/bin/bash

if diff &quot;$1&quot; &lt;(./compile.sh &quot;$1&quot;); then
    echo &quot;$1 is a metacompiler!&quot;
else
    echo &quot;$1 is not a metacompiler. See diff above.&quot;
fi</code></pre>
]]></summary>
</entry>
<entry>
    <title>A meta approach to implementing programming languages</title>
    <link href="http://rickardlindberg.me/writing/rlmeta/" />
    <id>http://rickardlindberg.me/writing/rlmeta/</id>
    <published>2018-12-02T00:00:00Z</published>
    <updated>2018-12-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>A meta approach to implementing programming languages</h1>

<p><em>Published on  2 December 2018.</em></p>

<p><em>28 May 2019: Added link to next article in</em> <a href="#2c78e9d9104c4bddbdd1dfe6314506c9"><em>Putting it together</em></a>.</p>
<p>How does the computer know what to do with the following expression?</p>
<pre class="text"><code>1+2*3</code></pre>
<p>How does it know how to recognize the sequence of characters as an arithmetic expression? How does it know that <code>2*3</code> should be computed first? How does it translate it to instructions that execute on the CPU?</p>
<p>In this article I present a metalanguage that I've developed that can help answer those questions.</p>
<ul>
<li><a href="#3f00cf52d91a411d941312539a15cc32">Metalanguages</a></li>
<li><a href="#ee16dcaf86a7402e9ca78edc620caacb">Interpreting expressions</a></li>
<li><a href="#61e10d1de6624255a4406572fef4b413">Compiling expressions</a></li>
<li><a href="#f5f122c94d3d4fa0b3a7e64a7fa0a724">RLMeta implementation</a>
<ul>
<li><a href="#1e01a8bdd22d48f2a7e8533d552bc264">Parser</a>
<ul>
<li><a href="#a757df1ad1764cc996d9d3e0a0ce4d25">Grammar</a></li>
<li><a href="#e1799ddc14ce4a7f83c8f390f9bf8720">Rule</a></li>
<li><a href="#c2a43ebb9a7d477f8dd7126f94bd33de">Choice</a></li>
<li><a href="#08818eb200d0482f8feb9104e1ae2ea7">Sequence</a></li>
<li><a href="#5fca8ddb3f88457bbe5217fa1ebf4383">Expression</a></li>
<li><a href="#cdeac4c7bcb84261a3d194c1183c9dd7">Expression of level 1</a></li>
<li><a href="#4e76262e4c9841db8c0b79401ac7a8ff">Expression of level 2</a></li>
<li><a href="#768d143c206146ca8efba292c6e9169b">Host expression</a></li>
<li><a href="#2057abb618bf4209950acd87fa49da5d">Character related</a></li>
<li><a href="#19acecc9fbc44023a69cea9eadbe734d">Name</a></li>
<li><a href="#d729731e037a4a5aafa6da77d2b8bdb1">Space</a></li>
</ul></li>
<li><a href="#c3f29fa523f341a487ebc07209c471f9">Code generator</a>
<ul>
<li><a href="#b225bd1638614a808495e33a63797beb">Note on target language</a></li>
<li><a href="#69841ad3d1044db18591fe09cdf1caee">Parsing algorithm</a></li>
<li><a href="#0d8a472a5c844a729b866f2c2c64794b">Structure of code generator</a></li>
<li><a href="#ed6931f4eeca4d43aaee1e9f5485a295">Grammar</a></li>
<li><a href="#3c542ba5b0104273805b227aeab84c04">Rule</a></li>
<li><a href="#696631bc029c47949b2ad97ce78ea32c">Or</a></li>
<li><a href="#86438bda56d342bc9d1f2c62e632a72d">Scope</a></li>
<li><a href="#487e675a013c45e3aee8b6c068e226df">And</a></li>
<li><a href="#4309ca572367401bb6c4561f273b8c85">Bind</a></li>
<li><a href="#244f0754be514ae88e0f581f3ab58c59">Star</a></li>
<li><a href="#44d3b166c62d43e38d2a781fb9f06b6d">Not</a></li>
<li><a href="#07530ffd21784561bd8594c98fcd050a">Semantic action</a></li>
<li><a href="#c10aabed8057404e97ef8cd6ac1b113d">Match rule</a></li>
<li><a href="#3ba5893bb7094ece96e853f869df9456">Match range</a></li>
<li><a href="#82022cc15d944579825b52559b1ee469">Match string</a></li>
<li><a href="#3eff70b8911e4b4e9bd520a7d25624e7">Match character sequence</a></li>
<li><a href="#5edd25f746a94b8392834343dce57370">Match any</a></li>
<li><a href="#c3b58d2d7b024fa4a0e5ff0bcf06d154">Match list</a></li>
<li><a href="#74804e4e0ee643ac95210d7aa17ae7c6">String</a></li>
<li><a href="#03d7a70d44fe4470967acd15d51ad56a">List</a></li>
<li><a href="#166dffacb2ca4911908584d77f30b21f">Builder</a></li>
<li><a href="#f5372dab8e084ca386297eb9575052e8">Function call</a></li>
<li><a href="#d9f73bdeb5c447dbaf5b8fe0bf3b67ba">Variable lookup</a></li>
<li><a href="#4397d20868fa4c08ac289e463725f18e">Final support methods</a></li>
</ul></li>
<li><a href="#2c78e9d9104c4bddbdd1dfe6314506c9">Putting it together</a></li>
<li><a href="#313b147a2f574ea09d76d9c7371bdf18">Bootstrapping</a></li>
</ul></li>
<li><a href="#5f558623cfce441fb3e61033299d1419">Implementing programming languages</a></li>
<li><a href="#4c6af1a11ed440d2bf31a497032c9c0b">Resources</a></li>
<li><a href="#388bb1e8ccbd4d55b89b391c08452c33">Code listings for RLMeta</a>
<ul>
<li><a href="#a56c54f42c00473091d7c8295ff4e0f1">parser.rlmeta</a></li>
<li><a href="#d9ea64bbdad3465897667ebec9d5ace1">codegenerator.rlmeta</a></li>
<li><a href="#983e606587034a0a9c8e8b5c714e7ef8">support.py</a></li>
<li><a href="#193d8f0ff47f4edcb201139df8cd9520">compile.sh</a></li>
</ul></li>
</ul>
<h2 id="f00cf52d91a411d941312539a15cc32metalanguages">[]{#3f00cf52d91a411d941312539a15cc32}Metalanguages</h2>
<p>Metalanguages are used to reason about languages. In metalanguages you can make statements about statements in a different language.</p>
<p>The metalanguage I've developed is called RLMeta. It is inspired by a metalanguage from the sixties called <a href="https://en.wikipedia.org/wiki/META_II">META II</a>. I wanted to develop my own version of META II to understand it deeply. RLMeta is also inspired by <a href="https://en.wikipedia.org/wiki/OMeta">OMeta</a> (another META II derivative).</p>
<p>RLMeta is a programming language in which you write grammars. Grammars have rules that specify how to match objects from an input stream and specify what should happen when objects are matched. The RLMeta compiler translates grammars into programs that recognize the objects specified in the grammar and evaluates the semantic actions when the objects are matched.</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
Overview of RLMeta compiler.
</center>
<h2 id="interpreting-expressions"><span id="ee16dcaf86a7402e9ca78edc620caacb"></span>Interpreting expressions</h2>
<p>How can RLMeta be used to give meaning to arithmetic expressions of the kind presented in the introductory example? Here is a grammar:</p>
<pre><code>1.  calculator
2.  calculator.rlmeta</code></pre>
<pre><code>Calculator {
  expression =
    | additive
  additive =
    | multitive:x &#39;+&#39; additive:y -&gt; add(x y)
    | multitive
  multitive =
    | digit:x &#39;*&#39; multitive:y    -&gt; mul(x y)
    | digit
  digit =
    | &#39;0&#39;-&#39;9&#39;:x                  -&gt; int(x)
}</code></pre>
<p>This grammar is called <code>Calculator</code>. It has four rules. The first rule says that an expression is an additive. The second rule says that an additive is either a multitive followed by the character '+' followed by another additive or just a multitive. The second case is only tried if the first does not match. The third rule says that a multitive is either a digit followed by the character '*' followed by another multitive or just a digit. The fourth rule says that a digit is a character in the range 0-9. The <code>:</code> followed by a name binds the result of a match to a variable. The expressions to the right of <code>-&gt;</code> are semantic actions. They specify what should happen on a match. They can refer to variables. In this grammar they say that whenever an additive is matched, call the host language function <code>add</code> with the left and right side, and whenever a multitive is matched, call the host language function <code>mul</code> with the left and right side, and whenever a digit is matched, call the host language function <code>int</code> with the digit character. The host language function <code>int</code> converts a digit character to an integer and the <code>add</code> and <code>mul</code> functions perform addition and multiplication.</p>
<p>This grammar describes how to recognize an arithmetic expression in a sequence of characters. Precedence is encoded by the order of the rules. An additive is <code>x1 + x2 + x3 + ..</code> where the xes are multitives. Therefore multiplication is performed before addition. It gives meaning to the expression by calling host language functions when parts are matched.</p>
<p>When the calculator grammar is fed to the RLMeta compiler, a program is output that is an interpreter for arithmetic expressions.</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
Overview of calculator compilation.
</center>
<p>More specifically, this program is a Python class that implements interpretation of arithmetic expressions. The class depends on a support library and also on the host language functions that were called from the grammar (<code>add</code>, <code>mul</code>, and <code>int</code>). Host language refers to the language that grammars are compiled to. In this case Python. The pieces must be assembled to form an executable program. Here is a template for the final Python file that implements a read-eval-print loop (REPL) for arithmetic expressions:</p>
<pre><code>1.  calculator
2.  compile.sh
3.  [python file template]{.cp}</code></pre>
<pre><code>from operator import add, mul

$support_py

$calculator_py

if __name__ == &quot;__main__&quot;:
    calculator = Calculator()
    while True:
        line = raw_input(&quot;&gt; &quot;)
        result = calculator.run(&quot;expression&quot;, line)
        print(result)</code></pre>
<p>First the host language functions are imported (<code>int</code> is always available). Then the support library and the compiled calculator grammar snippets are inserted. Finally the main method which is the REPL is implemented. Compiled grammars are used by instantiating them and calling their <code>run</code> method with the name of the rule and the input object. This template is rendered with a Bash script:</p>
<pre><code>1.  calculator
2.  compile.sh</code></pre>
<pre><code>#!/bin/bash

set -e

cd &quot;$(dirname &quot;$0&quot;)&quot;

support_py=$(python ../rlmeta/rlmeta.py --support)
calculator_py=$(python ../rlmeta/rlmeta.py &lt; calculator.rlmeta)

cat &lt;&lt;EOF
&lt;&lt;python file template&gt;&gt;
EOF</code></pre>
<p>First the <code>set -e</code> directive ensures that the script exits as soon as there is an error. Then the directory is changed to the one where the compile script lives. Then the output of two calls to the RLMeta compiler (<code>rlmeta.py</code>) are captured in two variables. The RLMeta compiler reads a grammar from stdin and writes a Python class to stdout. If the <code>--support</code> flag is given, it writes the support library to stdout instead. The <code>command &lt; file</code> syntax redirects the contents of the file to the command's stdin. Finally the Python file template is rendered and written to stdout using a <a href="https://en.wikipedia.org/wiki/Here_document#Unix_shells">here document</a> which has access to the previously captured variables.</p>
<p>Example usage on the command line:</p>
<pre class="text"><code>$ python &lt;(./calculator/compile.sh)
&gt; 1+2*3
7</code></pre>
<p>The compile script writes a Python file to stdout. The <code>&lt;(command)</code> syntax is <a href="https://en.wikipedia.org/wiki/Process_substitution">process substitution</a> and turns the output of the command into a temporary file which can then be run with Python.</p>
<p>In this example, the input stream to the calculator becomes a list of characters:</p>
<pre class="text"><code>[&#39;1&#39;, &#39;+&#39;, &#39;2&#39;, &#39;*&#39;, &#39;3&#39;]</code></pre>
<p>When the calculator matches the expression, the following host language functions will be called:</p>
<pre class="text"><code>add(int(&#39;1&#39;), mul(int(&#39;2&#39;), int(&#39;3&#39;)))</code></pre>
<h2 id="e10d1de6624255a4406572fef4b413compiling-expressions">[]{#61e10d1de6624255a4406572fef4b413}Compiling expressions</h2>
<p>The previous example relied on host language functions to perform addition and multiplication. The meaning of an expression was defined in terms of the meaning of Python functions. To understand what an expression means, you need to understand how Python implements those functions. The next example compiles an expression down to a kind of assembly language that eliminates the need for Python.</p>
<p>For this compilation, two grammars are written: a parser and a code generator. The parser looks similar to the calculator grammar but instead of evaluating the expression, it creates an abstract syntax tree (AST) describing the expression:</p>
<pre><code>1.  expression
2.  parser.rlmeta</code></pre>
<pre><code>Parser {
  expression =
    | additive
  additive =
    | multitive:x &#39;+&#39; additive:y -&gt; [&quot;add&quot; x y]
    | multitive
  multitive =
    | digit:x &#39;*&#39; multitive:y    -&gt; [&quot;mul&quot; x y]
    | digit
  digit =
    | &#39;0&#39;-&#39;9&#39;:x                  -&gt; [&quot;digit&quot; x]
}</code></pre>
<p>The bracket notation in the semantic actions creates lists. Nodes in the AST are represented as lists where the first item is a string denoting the type of node.</p>
<p>The code generator takes as input an AST from the parser and generates assembly language code for an imaginary stack machine:</p>
<pre><code>1.  expression
2.  codegenerator.rlmeta</code></pre>
<pre><code>CodeGenerator {
  ast =
    | [&quot;add&quot; ast:x ast:y] -&gt; { x y &quot;add&quot;     &quot;\n&quot; }
    | [&quot;mul&quot; ast:x ast:y] -&gt; { x y &quot;mul&quot;     &quot;\n&quot; }
    | [&quot;digit&quot; .:x]       -&gt; {     &quot;push &quot; x &quot;\n&quot; }
}</code></pre>
<p>This grammar has only one rule: <code>ast</code>. It says that an AST is either a list that starts with the string 'add', or a list that starts with the string 'mul', or a list that starts with the string 'digit'. The add and mul cases recursively match AST nodes as their left and right side whereas the digit matches anything (<code>.</code>) which is the digit stored in the AST node. The semantic actions in this grammar generate string output which is denoted by the curly braces. When a digit AST node is matched, the string 'push [digit]\n' is generated. It instructs the stack machine to push the given digit to the stack. For add and mul, instructions for the operands are first output followed by an 'add\n' or 'mul\n' instruction. They instruct the stack machine to pop two numbers off the stack, add or multiply them, and push the result.</p>
<p>This grammar describes how to recognize and AST in a sequence of objects. It gives meaning to the AST by generating assembly language code when AST nodes are matched.</p>
<p>When the expression grammars are fed to the RLMeta compiler, programs are output whose combination is a compiler for arithmetic expressions.</p>
<p><img src="image3.png" /></p>
<!-- image text -->
<center>
Overview of expression compilation.
</center>
<p>Here is a template for the final Python file that implements a REPL for arithmetic expression compilation:</p>
<pre><code>1.  expression
2.  compile.sh
3.  [python file template]{.cp}</code></pre>
<pre><code>import sys

$support_py

$parser_py

$codegenerator_py

if __name__ == &quot;__main__&quot;:
    parser = Parser()
    codegenerator = CodeGenerator()
    while True:
        line = raw_input(&quot;&gt; &quot;)
        ast = parser.run(&quot;expression&quot;, line)
        assembly = codegenerator.run(&quot;ast&quot;, ast)
        sys.stdout.write(assembly)</code></pre>
<p>First the <code>sys</code> module is imported because the main method needs it. Then the support library, compiled parser grammar, and compiled code generator grammar snippets are inserted. Finally the main method which is the REPL is implemented. The output of the parser is fed to the code generator and its output is finally written to stdout. This template is rendered with a Bash script:</p>
<pre><code>1.  expression
2.  compile.sh</code></pre>
<pre><code>#!/bin/bash

set -e

cd &quot;$(dirname &quot;$0&quot;)&quot;

support_py=$(python ../rlmeta/rlmeta.py --support)
parser_py=$(python ../rlmeta/rlmeta.py &lt; parser.rlmeta)
codegenerator_py=$(python ../rlmeta/rlmeta.py &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
&lt;&lt;python file template&gt;&gt;
EOF</code></pre>
<p>First the <code>set -e</code> directive ensures that the script exits as soon as there is an error. Then the directory is changed to the one where the compile script lives. Then the output of three calls to the RLMeta compiler are captured in three variables. Finally the Python file template is rendered and written to stdout.</p>
<p>Example usage on the command line:</p>
<pre class="text"><code>$ python &lt;(./expression/compile.sh)
&gt; 1+2*3
push 1
push 2
push 3
mul
add
&gt; 1*2+3
push 1
push 2
mul
push 3
add</code></pre>
<p>In the first example, the input stream to the parser becomes a list of characters (same as for the calculator):</p>
<pre class="text"><code>[&#39;1&#39;, &#39;+&#39;, &#39;2&#39;, &#39;*&#39;, &#39;3&#39;]</code></pre>
<p>The input stream to the code generator becomes a list with a single object which is a list (the root AST node):</p>
<pre class="text"><code>[
    [
        &#39;add&#39;,
        [&#39;digit&#39;, &#39;1&#39;],
        [
            &#39;mul&#39;,
            [&#39;digit&#39;, &#39;2&#39;],
            [&#39;digit&#39;, &#39;3&#39;]
        ]
    ]
]</code></pre>
<p>The generated assembly language code is much closer to CPU instructions than the Python-based interpreter. A grammar could be written to convert these assembly instructions to assembly instructions of a real CPU. But I will not do that here. The point is that the meaning of an expression can be described by a series of transformations that eventually output machine instructions.</p>
<h2 id="rlmeta-implementation"><span id="f5f122c94d3d4fa0b3a7e64a7fa0a724"></span>RLMeta implementation</h2>
<p>So far I've just given informal descriptions of how RLMeta works. To fully understand how arithmetic expressions are evaluated and compiled, you need to understand how RLMeta is implemented.</p>
<p>The RLMeta compiler translates a grammar to a Python class. This translation is implemented in RLMeta itself. A grammar is, like an expression, translated in two steps: the parser translates grammar syntax to an AST and the code generator translates the AST to a Python class. The generated Python class depends on a support library.</p>
<p><img src="image4.png" /></p>
<!-- image text -->
<center>
RLMeta compiler internals illustrated.
</center>
<p>The RLMeta compiler thus comprises three pieces: the parser, the code generator, and the support library.</p>
<h3 id="e01a8bdd22d48f2a7e8533d552bc264parser">[]{#1e01a8bdd22d48f2a7e8533d552bc264}Parser</h3>
<p>This section defines the parser:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta</code></pre>
<pre><code>Parser {
  &lt;&lt;rules&gt;&gt;
}</code></pre>
<h4 id="grammar"><span id="a757df1ad1764cc996d9d3e0a0ce4d25"></span>Grammar</h4>
<p>The top level syntactic element is a grammar. A grammar has a <a href="#19acecc9fbc44023a69cea9eadbe734d"><em>name</em></a> followed by <a href="#e1799ddc14ce4a7f83c8f390f9bf8720"><em>rules</em></a> enclosed in curly braces. When this is matched, a <code>Grammar</code> AST node is created containing the name of the grammar and the rule AST nodes:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>grammar =
  | name:x space &#39;{&#39; rule*:ys space &#39;}&#39; -&gt; [&quot;Grammar&quot; x ~ys]</code></pre>
<p>Throughout the parser, <a href="#d729731e037a4a5aafa6da77d2b8bdb1"><em>space</em></a> is ignored. As a rule of thumb, it is inserted before matching a character sequence (and not before matching other rules).</p>
<p>The <code>*</code> operator after <code>rule</code> means match the preceding expression zero or more times. The result is a list.</p>
<p>The <code>~</code> operator in the semantic action means splice the list in-line into the enclosing list. The <code>Grammar</code> AST node thus has the name as element one, the first rule AST node as element two, the second rule AST node as element three, and so on.</p>
<h4 id="rule"><span id="e1799ddc14ce4a7f83c8f390f9bf8720"></span>Rule</h4>
<p>A rule has a <a href="#19acecc9fbc44023a69cea9eadbe734d"><em>name</em></a> followed by an equal sign followed by a <a href="#c2a43ebb9a7d477f8dd7126f94bd33de"><em>choice</em></a>. When this is matched, a <code>Rule</code> AST node is created containing the name and the choice AST node:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>rule =
  | name:x space &#39;=&#39; choice:y -&gt; [&quot;Rule&quot; x y]</code></pre>
<h4 id="choice"><span id="c2a43ebb9a7d477f8dd7126f94bd33de"></span>Choice</h4>
<p>A choice has <a href="#08818eb200d0482f8feb9104e1ae2ea7"><em>sequences</em></a> separated by vertical bars. Optionally the first sequence can start with a vertical bar to allow all sequence lines to look the same. When this is matched, an <code>Or</code> AST node is created containing the sequence AST nodes:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>choice =
  | (space &#39;|&#39;)?
    sequence:x (space &#39;|&#39; sequence)*:xs -&gt; [&quot;Or&quot; x ~xs]</code></pre>
<p>The <code>?</code> operator means match the preceding expression zero or one time.</p>
<p>The result of <code>xs</code> is a list of sequences since the expression inside parenthesis returns the last match (which is a sequence).</p>
<h4 id="eb200d0482f8feb9104e1ae2ea7sequence">[]{#08818eb200d0482f8feb9104e1ae2ea7}Sequence</h4>
<p>A sequence has one or more <a href="#5fca8ddb3f88457bbe5217fa1ebf4383"><em>expressions</em></a>. When this is matched, a <code>Scope</code> AST node is created containing an <code>And</code> AST node containing the expression AST nodes:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>sequence =
  | expr:x expr*:xs -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]</code></pre>
<h4 id="fca8ddb3f88457bbe5217fa1ebf4383expression">[]{#5fca8ddb3f88457bbe5217fa1ebf4383}Expression</h4>
<p>An expression is one of the following sequences:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>expr =
  | expr1:x space &#39;:&#39; name:y -&gt; [&quot;Bind&quot; y x]
  | expr1</code></pre>
<p>The first sequence is an <a href="#cdeac4c7bcb84261a3d194c1183c9dd7"><em>expression of level 1</em></a> followed by a colon followed by a <a href="#19acecc9fbc44023a69cea9eadbe734d"><em>name</em></a>. When this is matched, a <code>Bind</code> AST node is created containing the name and the expression AST node.</p>
<p>The second sequence is an <a href="#cdeac4c7bcb84261a3d194c1183c9dd7"><em>expression of level 1</em></a>.</p>
<h4 id="expression-of-level-1"><span id="cdeac4c7bcb84261a3d194c1183c9dd7"></span>Expression of level 1</h4>
<p>An expression of level 1 is one of the following sequences:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>expr1 =
  | expr2:x space &#39;*&#39; -&gt; [&quot;Star&quot; x]
  | expr2:x space &#39;?&#39; -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
  | space &#39;!&#39; expr2:x -&gt; [&quot;Not&quot; x]
  | expr2</code></pre>
<p>The first sequence is an <a href="#4e76262e4c9841db8c0b79401ac7a8ff"><em>expression of level 2</em></a> followed by an asterisk. When this is matched, a <code>Star</code> AST node is created containing the expression AST node.</p>
<p>The second sequence is an <a href="#4e76262e4c9841db8c0b79401ac7a8ff"><em>expression of level 2</em></a> followed by a question mark. When this is matched, an <code>Or</code> AST node is created containing the expression AST node and an empty <code>And</code> AST node. There is no dedicated AST node for the <code>?</code> operator, but it is equivalent to matching the expression or zero expressions and'ed.</p>
<p>The third sequence is an exclamation mark followed by an <a href="#4e76262e4c9841db8c0b79401ac7a8ff"><em>expression of level 2</em></a>. When this is matched, a <code>Not</code> AST node is created containing the expression AST node.</p>
<p>The fourth sequence is an <a href="#4e76262e4c9841db8c0b79401ac7a8ff"><em>expression of level 2</em></a>.</p>
<h4 id="e76262e4c9841db8c0b79401ac7a8ffexpression-of-level-2">[]{#4e76262e4c9841db8c0b79401ac7a8ff}Expression of level 2</h4>
<p>An expression of level 2 is one of the following sequences:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>expr2 =
  | space &#39;-&gt;&#39; hostExpr:x        -&gt; [&quot;SemanticAction&quot; x]
  | name:x !(space &#39;=&#39;)          -&gt; [&quot;MatchRule&quot; x]
  | space char:x &#39;-&#39; char:y      -&gt; [&quot;MatchRange&quot; x y]
  | space string:x               -&gt; [&quot;MatchString&quot; x]
  | space charseq:x              -&gt; [&quot;MatchCharseq&quot; x]
  | space &#39;.&#39;                    -&gt; [&quot;MatchAny&quot;]
  | space &#39;(&#39; choice:x space &#39;)&#39; -&gt; x
  | space &#39;[&#39; expr*:xs space &#39;]&#39; -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]</code></pre>
<p>The first sequence is the characters '-&gt;' followed by a <a href="#768d143c206146ca8efba292c6e9169b"><em>host expression</em></a>. When this is matched, a <code>SemanticAction</code> AST node is created containing the expression AST node.</p>
<p>The second sequence is a <a href="#19acecc9fbc44023a69cea9eadbe734d"><em>name</em></a> that is not followed by an equal sign (otherwise it would also match the start of a rule). When this is matched, a <code>MatchRule</code> AST node is created containing the name.</p>
<p>The third sequence is a <a href="#2057abb618bf4209950acd87fa49da5d"><em>character</em></a> followed by a dash followed by another character. When this is matched, a <code>MatchRange</code> AST node is created containing the two characters.</p>
<p>The fourth sequence is a <a href="#2057abb618bf4209950acd87fa49da5d"><em>string</em></a>. When this is matched, a <code>MatchString</code> AST node is created containing the string.</p>
<p>The fifth sequence is a <a href="#2057abb618bf4209950acd87fa49da5d"><em>character sequence</em></a>. When this is matched, a <code>MatchCharseq</code> AST node is created containing the character sequence.</p>
<p>The sixth sequence is a dot. When this is matched, a <code>MatchAny</code> AST node is created.</p>
<p>The seventh sequence is an open parenthesis followed by a <a href="#c2a43ebb9a7d477f8dd7126f94bd33de"><em>choice</em></a> followed by a closing parenthesis. When this is matched, the choice AST node is returned.</p>
<p>The eighth sequence is an open bracket followed by <a href="#5fca8ddb3f88457bbe5217fa1ebf4383"><em>expressions</em></a> followed by a closing bracket. When this is matched, a <code>MatchList</code> AST node is created containing an <code>And</code> AST node containing the expressions.</p>
<h4 id="d143c206146ca8efba292c6e9169bhost-expression">[]{#768d143c206146ca8efba292c6e9169b}Host expression</h4>
<p>A host expression is one of the following sequences:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>hostExpr =
  | space string:x                           -&gt; [&quot;String&quot; x]
  | space &#39;[&#39; hostExprListItem*:xs space &#39;]&#39; -&gt; [&quot;List&quot; ~xs]
  | space &#39;{&#39; buildExpr*:xs space &#39;}&#39;        -&gt; [&quot;Builder&quot; ~xs]
  | name:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;FnCall&quot; x ~ys]
  | name:x                                   -&gt; [&quot;VarLookup&quot; x]</code></pre>
<p>The first sequence is a <a href="#2057abb618bf4209950acd87fa49da5d"><em>string</em></a>. When this is matched, a <code>String</code> AST node is created containing the string.</p>
<p>The second sequence is an open bracket followed by host expression list items followed by a closing bracket. When this is matched, a <code>List</code> AST node is created containing the list item AST nodes.</p>
<p>A list item is either a host expression preceded by the <code>~</code> operator, in which case a <code>ListItemSplice</code> AST node is created containing the expression, or a host expression:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>hostExprListItem =
  | space &#39;~&#39; hostExpr:x -&gt; [&quot;ListItemSplice&quot; x]
  | hostExpr</code></pre>
<p>The third sequence is an open curly brace followed by build expressions followed by a closing curly brace. When this is matched, a <code>Builder</code> AST node is created containing the expression AST nodes.</p>
<p>A build expression is either a greater than character, in which case an <code>IndentBuilder</code> AST node is created, or a less than character, in which case a <code>DedentBuilder</code> AST node is created, or a host expression.</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>buildExpr =
  | space &#39;&gt;&#39; -&gt; [&quot;IndentBuilder&quot;]
  | space &#39;&lt;&#39; -&gt; [&quot;DedentBuilder&quot;]
  | hostExpr</code></pre>
<p>The fourth sequence is a <a href="#19acecc9fbc44023a69cea9eadbe734d"><em>name</em></a> followed by an open parenthesis followed by host expressions followed by a closing parenthesis. When this is matched, a <code>FnCall</code> AST node is created containing the name and expression AST nodes.</p>
<p>The fifth sequence is a <a href="#19acecc9fbc44023a69cea9eadbe734d"><em>name</em></a>. When this is matched, a <code>VarLookup</code> AST node is created containing the name.</p>
<h4 id="abb618bf4209950acd87fa49da5dcharacter-related">[]{#2057abb618bf4209950acd87fa49da5d}Character related</h4>
<p>Character related rules capture strings, character sequences, and single characters. Inside all of them a few escape codes are possible. When this is matched, the characters inside the delimiters are joined together to create the string:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;  -&gt; join(xs)
charseq   = &#39;\&#39;&#39; (!&#39;\&#39;&#39; innerChar)*:xs &#39;\&#39;&#39; -&gt; join(xs)
char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39; -&gt; x
innerChar = &#39;\\&#39; escape | .
escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
          | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;</code></pre>
<h4 id="acecc9fbc44023a69cea9eadbe734dname">[]{#19acecc9fbc44023a69cea9eadbe734d}Name</h4>
<p>A name has at least one alphabetic character followed by any number of alphanumeric characters. When this is matched, the individual characters are joined together to create a string:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>name      = space nameStart:x nameChar*:xs -&gt; join([x ~xs])
nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;</code></pre>
<h4 id="space"><span id="d729731e037a4a5aafa6da77d2b8bdb1"></span>Space</h4>
<p>A space is any number of space characters or newlines:</p>
<pre><code>1.  rlmeta
2.  parser.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>space = (&#39; &#39; | &#39;\n&#39;)*</code></pre>
<h3 id="code-generator"><span id="c3f29fa523f341a487ebc07209c471f9"></span>Code generator</h3>
<p>This section defines the code generator and the support library:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta</code></pre>
<pre><code>CodeGenerator {
  &lt;&lt;rules&gt;&gt;
}</code></pre>
<pre><code>1.  rlmeta
2.  support.py</code></pre>
<pre><code>&lt;&lt;classes&gt;&gt;</code></pre>
<h4 id="note-on-target-language"><span id="b225bd1638614a808495e33a63797beb"></span>Note on target language</h4>
<p>The choice of Python as the target language for code generation is an implementation detail. A different target language could easily be used. Say for example that you would like to use RLMeta in a web browser. In that case JavaScript must be used as the target language. RLMeta could be ported to JavaScript by modifying the code generator and the support library.</p>
<h4 id="ad3d1044db18591fe09cdf1caeeparsing-algorithm">[]{#69841ad3d1044db18591fe09cdf1caee}Parsing algorithm</h4>
<p>The parsing algorithm that RLMeta implements is based on <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">parsing expression grammars</a> (PEG), but is extended to match arbitrary objects, not just characters. Another way to describe the parsing algorithm is that it is a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> with backtracking an <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>. Details of the algorithm is shown in the remainder of this section.</p>
<h4 id="d8a472a5c844a729b866f2c2c64794bstructure-of-code-generator">[]{#0d8a472a5c844a729b866f2c2c64794b}Structure of code generator</h4>
<p>The code generator has two main rules: <code>ast</code> and <code>astFnBody</code>:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>ast =
  &lt;&lt;ast&gt;&gt;
  | astFnBody:x -&gt; { &quot;(lambda:\n&quot; &gt; x &lt; &quot;\n)&quot; }
astFnBody =
  &lt;&lt;astFnBody&gt;&gt;</code></pre>
<p>Sometimes generated code for an AST node should be wrapped in a lambda. Those AST nodes are added to the <code>astFnBody</code> rule. The <code>astFnBody</code> rule is not strictly needed, but without it, many rules would have to wrap its output in a lambda.</p>
<p>The greater than and less than characters in the string output expression cause an indent and a dedent like this:</p>
<pre class="text"><code>(lambda:
    x
)</code></pre>
<h4 id="grammar-1"><span id="ed6931f4eeca4d43aaee1e9f5485a295"></span>Grammar</h4>
<p>When a <code>Grammar</code> AST node is matched, a Python class inheriting <code>_Grammar</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt; }</code></pre>
<p>The name of the class is the same as the name of the grammar and the child AST nodes are assumed to generate methods in the class.</p>
<p>The <code>_Grammar</code> class is defined in the support library:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _Grammar(object):

    &lt;&lt;_Grammar&gt;&gt;</code></pre>
<p>Names of support classes start with underscore to not collide with generated grammar names (which can not contain underscores).</p>
<h4 id="c542ba5b0104273805b227aeab84c04rule">[]{#3c542ba5b0104273805b227aeab84c04}Rule</h4>
<p>When a <code>Rule</code> AST node is matched, a Python method with a name prefixed with <code>_rule_</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;Rule&quot; .:x ast:y] -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt; }</code></pre>
<p>The method name ends with the same name as the rule. The child AST node is assumed to generate a matcher. A matcher is a function that tries to match objects from the input stream and return a semantic action if it succeeds or raise an exception if it fails. That function is called from the generated method and the semantic action is returned.</p>
<h4 id="bc029c47949b2ad97ce78ea32cor">[]{#696631bc029c47949b2ad97ce78ea32c}Or</h4>
<p>When an <code>Or</code> AST node is matched, a matcher that calls the built-in <code>_or</code> method is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;Or&quot; astItems:x] -&gt; { &quot;self._or([&quot; x &quot;])&quot; }</code></pre>
<p>Rules to generate a list of items:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>astItems = astItem*:xs -&gt; { &quot;\n&quot; &gt; xs &lt; }
astItem  = ast:x       -&gt; { x &quot;,\n&quot;     }</code></pre>
<p>The generated string is wrapped in a lambda because the code is added to the <code>astFnBody</code> rule and will thus look like this:</p>
<pre class="text"><code>(lambda:
    self._or([
        matcher1,
        matcher2,
        ...
    ])
)</code></pre>
<p>The <code>_or</code> method expects a list of matchers which are tried in sequence:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    original_stream.fail(&quot;no choice matched&quot;)</code></pre>
<p>The result of the first succeeding matcher is returned. The input stream is stored in <code>_stream</code>. Streams are immutable, so resetting the stream upon failure is just a matter of saving and restoring <code>_stream</code>. <code>_MatchError</code> is the name of the exception that is raised when a match fails. Streams have a <code>fail</code> method that generates that exception and adds context to it that is useful for error reporting.</p>
<h4 id="bda56d342bc9d1f2c62e632a72dscope">[]{#86438bda56d342bc9d1f2c62e632a72d}Scope</h4>
<p>When a <code>Scope</code> AST node is matched, a matcher that creates a new scope is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;Scope&quot; ast:x] -&gt; { &quot;(lambda _vars:\n&quot; &gt; x &lt; &quot;()\n)(_Vars())&quot; }</code></pre>
<p>A scope is a set of variables that do not interfere with variables in other scopes. The name <code>_vars</code> is used to refer to variables in the current scope. The child AST node is assumed to generate a matcher which is called to return a semantic action. The generated string will thus look like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        matcher()
    )(_Vars())
)</code></pre>
<p>The <code>_Vars</code> class is a subclass of a Python dictionary:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _Vars(dict):

    &lt;&lt;_Vars&gt;&gt;</code></pre>
<h4 id="e675a013c45e3aee8b6c068e226dfand">[]{#487e675a013c45e3aee8b6c068e226df}And</h4>
<p>When an <code>And</code> AST node is matched, a matcher that calls the built-in <code>_and</code> method is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;And&quot; astItems:x] -&gt; { &quot;self._and([&quot; x &quot;])&quot; }</code></pre>
<p>The <code>_and</code> method expects a list of matchers which are called in sequence:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _and(self, matchers):
    result = None
    for matcher in matchers:
        result = matcher()
    return result</code></pre>
<p>The result of the last matcher is returned.</p>
<h4 id="ca572367401bb6c4561f273b8c85bind">[]{#4309ca572367401bb6c4561f273b8c85}Bind</h4>
<p>When a <code>Bind</code> AST node is matched, a matcher that binds the name to a value in the current scope is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;Bind&quot; .:x ast:y] -&gt; { &quot;_vars.bind(&quot; repr(x) &quot;, &quot; y &quot;())&quot; }</code></pre>
<p>The child AST node is assumed to generate a matcher which is called to make the value a semantic action.</p>
<p>The <code>bind</code> method stores and returns a value with the given name:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Vars]{.cp}</code></pre>
<pre><code>def bind(self, name, value):
    self[name] = value
    return value</code></pre>
<h4 id="f0754be514ae88e0f581f3ab58c59star">[]{#244f0754be514ae88e0f581f3ab58c59}Star</h4>
<p>When a <code>Star</code> AST node is matched, a matcher that calls the built-in <code>_star</code> method is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;Star&quot; ast:x] -&gt; { &quot;self._star(&quot; x &quot;)&quot; }</code></pre>
<p>The <code>_star</code> method expects a matcher and calls it for as long as it succeeds:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _star(self, matcher):
    result = []
    while True:
        original_stream = self._stream
        try:
            result.append(matcher())
        except _MatchError:
            self._stream = original_stream
            return _SemanticAction(lambda: [x.eval() for x in result])</code></pre>
<p>The return value is a semantic action. When evaluated, it returns a list of all match results evaluated.</p>
<p>A semantic action is a wrapper for a function:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _SemanticAction(object):

    def __init__(self, fn):
        self.fn = fn

    def eval(self):
        return self.fn()</code></pre>
<p>Its <code>eval</code> method calls the function. The reason for wrapping semantic actions in functions is to prevent them from being evaluated before a parse is complete. If a parse fails, no semantic actions are evaluated.</p>
<h4 id="d3b166c62d43e38d2a781fb9f06b6dnot">[]{#44d3b166c62d43e38d2a781fb9f06b6d}Not</h4>
<p>When a <code>Not</code> AST node is matched, a matcher that calls the built-in <code>_not</code> method is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;Not&quot; ast:x] -&gt; { &quot;self._not(&quot; x &quot;)&quot; }</code></pre>
<p>The <code>_not</code> method expects a matcher and succeeds if that matcher fails:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _not(self, matcher):
    original_stream = self._stream
    try:
        matcher()
    except _MatchError:
        return _SemanticAction(lambda: None)
    else:
        original_stream.fail(&quot;match found&quot;)
    finally:
        self._stream = original_stream</code></pre>
<p>It never consumes any input. The original stream is always reset.</p>
<h4 id="ffd21784561bd8594c98fcd050asemantic-action">[]{#07530ffd21784561bd8594c98fcd050a}Semantic action</h4>
<p>When a <code>SemanticAction</code> AST node is matched, a matcher that creates a <code>_SemanticAction</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;SemanticAction&quot; ast:x] -&gt; { &quot;_SemanticAction(lambda: &quot; x &quot;)&quot; }</code></pre>
<p>The child AST node is assumed to generate a Python expression that will be returned when the semantic action is evaluated.</p>
<h4 id="match-rule"><span id="c10aabed8057404e97ef8cd6ac1b113d"></span>Match rule</h4>
<p>When a <code>MatchRule</code> AST node is matched, a matcher that calls the built-in <code>_match_rule</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;MatchRule&quot; .:x] -&gt; { &quot;self._match_rule(&quot; repr(x) &quot;)&quot;}</code></pre>
<p>The <code>_match_rule</code> method expects the name of the rule to call:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _match_rule(self, rule_name):
    key = (rule_name, self._stream.position())
    if key in self._memo:
        result, _, self._stream = self._memo[key]
    else:
        start = self._stream
        result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
        end = self._stream
        self._memo[key] = (result, start, end)
    return result</code></pre>
<p>If the given rule has been matched at the current position before, the memoized result is returned and the input stream is changed to where the previous match ended. If there has been no previous match, the rule is matched by calling the method. The result of the match is stored in the memoization table for later retrieval.</p>
<h4 id="ba5893bb7094ece96e853f869df9456match-range">[]{#3ba5893bb7094ece96e853f869df9456}Match range</h4>
<p>When a <code>MatchRange</code> AST node is matched, a matcher that calls the built-in <code>_match_range</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;MatchRange&quot; .:x .:y] -&gt; { &quot;self._match_range(&quot; repr(x) &quot;, &quot; repr(y) &quot;)&quot; }</code></pre>
<p>The <code>_match_range</code> method expects two objects defining a range to match:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _match_range(self, start, end):
    original_stream = self._stream
    next_objext, self._stream = self._stream.next()
    if next_objext &gt;= start and next_objext &lt;= end:
        return _SemanticAction(lambda: next_objext)
    else:
        original_stream.fail(
            &quot;expected range {!r}-{!r} but found {!r}&quot;.format(start, end, next_objext)
        )</code></pre>
<p>If the next object from the input stream is in that range, it succeeds, otherwise it fails.</p>
<h4 id="cc15d944579825b52559b1ee469match-string">[]{#82022cc15d944579825b52559b1ee469}Match string</h4>
<p>When a <code>MatchString</code> AST node is matched, a matcher that calls the built-in <code>_match_string</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;MatchString&quot; .:x] -&gt; { &quot;self._match_string(&quot; repr(x) &quot;)&quot; }</code></pre>
<p>The <code>_match_string</code> method expects the string to match:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _match_string(self, string):
    original_stream = self._stream
    next_object, self._stream = self._stream.next()
    if next_object == string:
        return _SemanticAction(lambda: string)
    else:
        original_stream.fail(
            &quot;expected {!r} but found {!r}&quot;.format(string, next_object)
        )</code></pre>
<p>If the next object from the input stream is that string, it succeeds, otherwise it fails.</p>
<h4 id="eff70b8911e4b4e9bd520a7d25624e7match-character-sequence">[]{#3eff70b8911e4b4e9bd520a7d25624e7}Match character sequence</h4>
<p>When a <code>MatchCharseq</code> AST node is matched, a matcher that calls the built-in <code>_match_charseq</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;MatchCharseq&quot; .:x] -&gt; { &quot;self._match_charseq(&quot; repr(x) &quot;)&quot; }</code></pre>
<p>The <code>_match_charseq</code> method expects a string with characters to match:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _match_charseq(self, charseq):
    for char in charseq:
        original_stream = self._stream
        next_object, self._stream = self._stream.next()
        if next_object != char:
            original_stream.fail(
                &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
    return _SemanticAction(lambda: charseq)</code></pre>
<p>If the next objects from the input stream are those characters, it succeeds, otherwise it fails.</p>
<h4 id="edd25f746a94b8392834343dce57370match-any">[]{#5edd25f746a94b8392834343dce57370}Match any</h4>
<p>When a <code>MatchAny</code> AST node is matched, the built-in <code>_match_any</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;MatchAny&quot;] -&gt; { &quot;self._match_any&quot; }</code></pre>
<p>The <code>_match_any</code> method expects no arguments and always matches the next object from the input stream:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _match_any(self):
    next_object, self._stream = self._stream.next()
    return _SemanticAction(lambda: next_object)</code></pre>
<p>It only fails if there are no more objects.</p>
<h4 id="match-list"><span id="c3b58d2d7b024fa4a0e5ff0bcf06d154"></span>Match list</h4>
<p>When a <code>MatchList</code> AST node is matched, a matcher that calls the built-in <code>_match_list</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [astFnBody]{.cp}</code></pre>
<pre><code>| [&quot;MatchList&quot; ast:x] -&gt; { &quot;self._match_list(&quot; x &quot;)&quot; }</code></pre>
<p>The <code>_match_list</code> method expects a matcher that should match the contents of the list:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def _match_list(self, matcher):
    original_stream = self._stream
    next_object, next_stream = self._stream.next()
    if isinstance(next_object, list):
        self._stream = self._stream.nested(next_object)
        matcher()
        if self._stream.is_at_end():
            self._stream = next_stream
            return _SemanticAction(lambda: next_object)
    original_stream.fail(&quot;list match failed&quot;)</code></pre>
<p>If the next object is a list, a new stream is created with the <code>nested</code> call that contains all child objects. It is set to be the input stream, and the matcher is then called. The matcher must match all child objects, or the match fails.</p>
<h4 id="e4e0ee643ac95210d7aa17ae7c6string">[]{#74804e4e0ee643ac95210d7aa17ae7c6}String</h4>
<p>When a <code>String</code> AST node is matched, a Python string is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;String&quot; .:x] -&gt; { repr(x) }</code></pre>
<h4 id="d7a70d44fe4470967acd15d51ad56alist">[]{#03d7a70d44fe4470967acd15d51ad56a}List</h4>
<p>When a <code>List</code> AST node is matched, a Python list is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;List&quot; astList:x] -&gt; { x }</code></pre>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}</code></pre>
<pre><code>astList = astListItem*:xs    -&gt; { &quot;(&quot; xs &quot;[])&quot; }
astListItem =
  | [&quot;ListItemSplice&quot; ast:x] -&gt; {     x  &quot;+&quot;   }
  | ast:x                    -&gt; { &quot;[&quot; x &quot;]+&quot;   }</code></pre>
<p>The Python list is generated by concatenating sub-lists. If an item should be spliced, it is assumed to be a list already and is not wrapped in brackets.</p>
<h4 id="dffacb2ca4911908584d77f30b21fbuilder">[]{#166dffacb2ca4911908584d77f30b21f}Builder</h4>
<p>When a <code>Builder</code> AST node is matched, a <code>_Builder</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;Builder&quot; astItems:x] -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot; }</code></pre>
<p>The child AST nodes are assumed to generate Python expressions.</p>
<p>When an <code>IndentBuilder</code> AST node is matched, an <code>_IndentBuilder</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;IndentBuilder&quot;] -&gt; { &quot;_IndentBuilder()&quot; }</code></pre>
<p>When a <code>DedentBuilder</code> AST node is matched, a <code>_DedentBuilder</code> is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;DedentBuilder&quot;] -&gt; { &quot;_DedentBuilder()&quot; }</code></pre>
<p>All builders inherit from <code>_Builder</code>:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _Builder(object):

    &lt;&lt;_Builder&gt;&gt;</code></pre>
<p>A builder can build a string with the <code>build_string</code> method:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Builder]{.cp}</code></pre>
<pre><code>def build_string(self):
    output = _Output()
    self.write(output)
    return output.value</code></pre>
<p>All builders must implement the <code>write</code> method that is passed an instance of <code>_Output</code>. The <code>_Output</code> class has functionality to build a string with appropriate indentation:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _Output(object):

    def __init__(self):
        self.value = &quot;&quot;
        self.indentation = 0

    def write(self, value):
        for ch in value:
            if self.value and ch != &quot;\n&quot; and self.value[-1] == &quot;\n&quot;:
                self.value += &quot;    &quot;*self.indentation
            self.value += ch</code></pre>
<p>The <code>create</code> method of a builder creates an instance of a builder depending on the type of object passed in:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Builder]{.cp}</code></pre>
<pre><code>@classmethod
def create(self, item):
    if isinstance(item, _Builder):
        return item
    elif isinstance(item, list):
        return _ListBuilder([_Builder.create(x) for x in item])
    else:
        return _AtomBuilder(item)</code></pre>
<p>A <code>_ListBuilder</code> calls the <code>write</code> method on all child builders:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _ListBuilder(_Builder):

    def __init__(self, builders):
        self.builders = builders

    def write(self, output):
        for builder in self.builders:
            builder.write(output)</code></pre>
<p>An <code>_AtomBuilder</code> converts its object to a string and writes it to the output:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _AtomBuilder(_Builder):

    def __init__(self, atom):
        self.atom = atom

    def write(self, output):
        output.write(str(self.atom))</code></pre>
<p>An <code>_IndentBuilder</code> changes the indentation of the output:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _IndentBuilder(_Builder):

    def write(self, output):
        output.indentation += 1</code></pre>
<p>A <code>_DedentBuilder</code> changes the indentation of the output:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _DedentBuilder(_Builder):

    def write(self, output):
        output.indentation -= 1</code></pre>
<h4 id="function-call"><span id="f5372dab8e084ca386297eb9575052e8"></span>Function call</h4>
<p>When a <code>FnCall</code> AST node is matched, a Python function call is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;FnCall&quot; .:x astItems:y] -&gt; { x &quot;(&quot; y &quot;)&quot; }</code></pre>
<p>The child AST nodes are assumed to generate Python expressions.</p>
<h4 id="variable-lookup"><span id="d9f73bdeb5c447dbaf5b8fe0bf3b67ba"></span>Variable lookup</h4>
<p>When a <code>VarLookup</code> AST node is matched, a Python expression that looks up the variable and evaluates it is generated:</p>
<pre><code>1.  rlmeta
2.  codegenerator.rlmeta
3.  [rules]{.cp}
4.  [ast]{.cp}</code></pre>
<pre><code>| [&quot;VarLookup&quot; .:x] -&gt; { &quot;_vars.lookup(&quot; repr(x) &quot;).eval()&quot; }</code></pre>
<p>The <code>lookup</code> method returns the stored value:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Vars]{.cp}</code></pre>
<pre><code>def lookup(self, name):
    return self[name]</code></pre>
<p>Every time a variable is referenced, the <code>eval</code> method is called. Consider this grammar:</p>
<pre class="text"><code>AGrammar {
  foo = bar:x -&gt; { x x }
  bar = .     -&gt; a_side_effect()
}</code></pre>
<p>If evaluating <code>x</code> has a side effect, it will be executed twice. The <code>eval</code> method of <code>_SemanticAction</code> could be modified so that the function is only called once if needed.</p>
<h4 id="d20868fa4c08ac289e463725f18efinal-support-methods">[]{#4397d20868fa4c08ac289e463725f18e}Final support methods</h4>
<p>Grammars in Python have a single entry point, <code>run</code>, which expects the name of the rule to match and the input object:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}
4.  [\_Grammar]{.cp}</code></pre>
<pre><code>def run(self, rule_name, input_object):
    self._memo = _Memo()
    self._stream = _Stream.from_object(self._memo, input_object)
    result = self._match_rule(rule_name).eval()
    if isinstance(result, _Builder):
        return result.build_string()
    else:
        return result</code></pre>
<p>It initializes the memoization table and the input stream, matches the rule, and returns the evaluated result. If the result is a builder, the string that the builder builds is returned.</p>
<p>The memoization table is a subclass of a Python dictionary:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _Memo(dict):

    def __init__(self):
        dict.__init__(self)
        self._latest_stream = _ObjectStream(self, [], position=-1)
        self._latest_message = &quot;&quot;

    def describe(self):
        items = []
        for (rule_name, _), (_, start, end) in self.items():
            if end &gt; start:
                items.append((rule_name, start, end))
        items.sort(key=lambda item: (item[2].position(), item[1].position()))
        message = []
        for item in items:
            message.append(&quot;matched {: &lt;20} {} -&gt; {}\n&quot;.format(*item))
        message.append(&quot;\n&quot;)
        message.append(&quot;ERROR: {}: {}\n&quot;.format(
            self._latest_stream,
            self._latest_message
        ))
        return &quot;&quot;.join(message)

    def fail(self, stream, message):
        if stream.position() &gt;= self._latest_stream.position():
            self._latest_stream = stream
            self._latest_message = message
        raise _MatchError(self)</code></pre>
<p>Its <code>describe</code> method returns a string that describes what has been matched so far and what the latest error message was. It is used for error reporting. It keeps track of match failures via the <code>fail</code> method which is always called to raise a <code>_MatchError</code>.</p>
<p>A <code>_MatchError</code> is a Python exception that also has a reference to a memoization table so that the <code>describe</code> method can be exposed:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _MatchError(Exception):

    def __init__(self, memo):
        Exception.__init__(self)
        self._memo = memo

    def describe(self):
        return self._memo.describe()</code></pre>
<p>A <code>_Stream</code> is an immutable object that has a list of objects:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _Stream(object):

    @classmethod
    def from_object(cls, memo, input_object):
        if isinstance(input_object, basestring):
            return _CharStream(memo, list(input_object))
        else:
            return _ObjectStream(memo, [input_object])

    def __init__(self, memo, objects):
        self._memo = memo
        self._objects = objects

    def fail(self, message):
        self._memo.fail(self, message)

    def next(self):
        if self.is_at_end():
            self.fail(&quot;not eof&quot;)
        next_object = self._objects[0]
        return (
            next_object,
            self._advance(next_object, self._objects[1:]),
        )

    def is_at_end(self):
        return len(self._objects) == 0</code></pre>
<p>Its <code>next</code> method returns a tuple with the next object and the next stream. There are two kinds of streams: character streams and object streams. They are subclasses of <code>_Stream</code> and implement the <code>position</code> and <code>_advance</code> methods. The appropriate stream is chosen in the <code>from_object</code> method.</p>
<p>A character steam stores the position as a line + column:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _CharStream(_Stream):

    def __init__(self, memo, objects, line=1, column=1):
        _Stream.__init__(self, memo, objects)
        self._line = line
        self._column = column

    def position(self):
        return (self._line, self._column)

    def _advance(self, next_object, objects):
        if next_object == &quot;\n&quot;:
            return _CharStream(self._memo, objects, self._line+1, 1)
        else:
            return _CharStream(self._memo, objects, self._line, self._column+1)

    def __str__(self):
        return &quot;L{:03d}:C{:03d}&quot;.format(self._line, self._column)</code></pre>
<p>An object stream stores the position as a tuple of indices:</p>
<pre><code>1.  rlmeta
2.  support.py
3.  [classes]{.cp}</code></pre>
<pre><code>class _ObjectStream(_Stream):

    def __init__(self, memo, objects, parent=(), position=0):
        _Stream.__init__(self, memo, objects)
        self._parent = parent
        self._position = position

    def position(self):
        return self._parent + (self._position,)

    def nested(self, input_object):
        return _ObjectStream(self._memo, input_object, self._parent+(self._position,))

    def _advance(self, next_object, objects):
        return _ObjectStream(self._memo, objects, self._parent, self._position+1)

    def __str__(self):
        return &quot;[{}]&quot;.format(&quot;, &quot;.join(str(x) for x in self.position()))</code></pre>
<p>The <code>nested</code> method will only be called on object streams since character streams do not nest.</p>
<h3 id="c78e9d9104c4bddbdd1dfe6314506c9putting-it-together">[]{#2c78e9d9104c4bddbdd1dfe6314506c9}Putting it together</h3>
<p>Here is a template for the final Python file that implements the RLMeta compiler:</p>
<pre><code>1.  rlmeta
2.  compile.sh
3.  [python file template]{.cp}</code></pre>
<pre><code>import sys

SUPPORT = $support_py_string

$support_py

$parser_py

$codegenerator_py

join = &quot;&quot;.join

def compile_grammar(grammar):
    parser = Parser()
    code_generator = CodeGenerator()
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))

if __name__ == &quot;__main__&quot;:
    if &quot;--support&quot; in sys.argv:
        sys.stdout.write(SUPPORT)
    else:
        try:
            sys.stdout.write(compile_grammar(sys.stdin.read()))
        except _MatchError as e:
            sys.stderr.write(e.describe())
            sys.exit(1)</code></pre>
<p>First the <code>sys</code> module is imported because the main method needs it. Then the support library snippet is stored in a variable so that it can be output when the <code>--support</code> flag is given. Then the support library, compiled parser grammar, and compiled code generator grammar snippets are inserted. Then the host language function <code>join</code> is defined. Then a function to compile a grammar is defined. Finally the main method that reads a grammar from stdin and writes a Python class to stdout is implemented. If an error occurs, it is written to stderr using the exception's <code>describe</code> method. This template is rendered with a Bash script:</p>
<pre><code>1.  rlmeta
2.  compile.sh</code></pre>
<pre><code>#!/bin/bash

set -e

rlmeta_compiler=&quot;$(pwd)/$1&quot;

cd &quot;$(dirname &quot;$0&quot;)&quot;

to_python_string() {
    python -c &#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;
}

support_py=$(cat support.py)
support_py_string=$(to_python_string &lt; support.py)
parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
&lt;&lt;python file template&gt;&gt;
EOF</code></pre>
<p>First the <code>set -e</code> directive ensures that the script exits as soon as there is an error. Then a variable containing the path to the RLMeta compiler is defined. The path must be given to the compile script as the first argument. Then the directory is changed to the one where the compile script lives. Then a function is defined that turns its stdin into a Python string with correct quoting. Then the support library is captured in a variable. Then the output of passing the support library to <code>to_python_string</code> is captured in a variable. Then the output of two calls to the RLMeta compiler are captured in two variables. Finally the Python file template is rendered and written to stdout.</p>
<p>If the compile script is run with the current RLMeta compiler (<code>rlmeta/rlmeta.py</code>), a new Python file is output that is exactly the same as the <code>rlmeta/rlmeta.py</code> file. It can be seen by diffing the two files:</p>
<pre class="text"><code>$ diff &lt;(./rlmeta/compile.sh rlmeta/rlmeta.py) rlmeta/rlmeta.py &amp;&amp; echo EQUAL
EQUAL</code></pre>
<p>The <code>rlmeta.py</code> file never needs to be changed manually. The next version can always be produced using the previous version. Sometimes the next version must be produced in steps and intermediate compilers must be created. That is why the path to the compiler must be given to the compile script. (More on modifying RLMeta in the <a href="/writing/modifying-rlmeta/index.html">next article</a>.) If you want to see what the <code>rlmeta.py</code> file looks like, it is <a href="https://github.com/rickardlindberg/rickardlindberg.me/blob/master/writing/rlmeta/rlmeta/rlmeta.py">here</a>.</p>
<h3 id="b147a2f574ea09d76d9c7371bdf18bootstrapping">[]{#313b147a2f574ea09d76d9c7371bdf18}Bootstrapping</h3>
<p>In the previous section, a version of the RLMeta compiler was needed to compile the RLMeta compiler:</p>
<pre class="text"><code>parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)</code></pre>
<p>But how can the RLMeta compiler be run before it exists? How was the first version of <code>rlmeta.py</code> created? This is a bootstrapping problem. In this case I solved it by translating the parser and the code generator to Python code manually according the rules specified in the grammars. I did manually what the compiler would do.</p>
<p>I started translating the parser that looks like this:</p>
<pre class="text"><code>Parser {
  ...
}</code></pre>
<p>This is matched by the <code>grammar</code> rule in the parser and turned into a <code>Grammar</code> AST node:</p>
<pre class="text"><code>grammar =
  | name:x space &#39;{&#39; rule*:ys space &#39;}&#39; -&gt; [&quot;Grammar&quot; x ~ys]</code></pre>
<p>The <code>Grammar</code> AST node is then turned into a Python class definition by the code generator:</p>
<pre class="text"><code>| [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt; }</code></pre>
<p>The parser is thus turned into the following Python code:</p>
<pre class="text"><code>class Parser(_Grammar):
    ...</code></pre>
<p>I then went on to translate the rules in the parser. The first rule is <code>grammar</code>:</p>
<pre class="text"><code>grammar =
  | name:x space &#39;{&#39; rule*:ys space &#39;}&#39; -&gt; [&quot;Grammar&quot; x ~ys]</code></pre>
<p>It is matched by the <code>rule</code> rule in the parser and turned into a <code>Rule</code> AST node:</p>
<pre class="text"><code>rule =
  | name:x space &#39;=&#39; choice:y -&gt; [&quot;Rule&quot; x y]</code></pre>
<p>The <code>Rule</code> AST node is then turned into a Python method definition by the code generator:</p>
<pre class="text"><code>| [&quot;Rule&quot; .:x ast:y] -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt; }</code></pre>
<p>The <code>grammar</code> rule is thus turned into the following Python code:</p>
<pre class="text"><code>def _rule_grammar(self):
    return ...()</code></pre>
<p>The body of the <code>grammar</code> rule is matched by the <code>choice</code> rule in the parser and turned into an <code>Or</code> AST node:</p>
<pre class="text"><code>choice =
  | (space &#39;|&#39;)?
    sequence:x (space &#39;|&#39; sequence)*:xs -&gt; [&quot;Or&quot; x ~xs]</code></pre>
<p>The <code>Or</code> AST node is then turned into a Python lambda expression by the code generator:</p>
<pre class="text"><code>| [&quot;Or&quot; astItems:x] -&gt; { &quot;self._or([&quot; x &quot;])&quot; }</code></pre>
<p>The body of the <code>grammar</code> rule is thus turned into the following Python code:</p>
<pre class="text"><code>(lambda:
    self._or([...])
)</code></pre>
<p>I continued this process until all dots had been expanded. Then I did the same for all remaining rules. Finally I repeated the process for the code generator. Once I had the manually translated versions of <code>parser.py</code> and <code>codegenerator.py</code>, I could temporarily replace</p>
<pre class="text"><code>parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)</code></pre>
<p>with</p>
<pre class="text"><code>parser_py=$(cat parser.py)
codegenerator_py=$(cat codegenerator.py)</code></pre>
<p>to create the initial version of <code>rlmeta.py</code>.</p>
<p>With the initial version of <code>rlmeta.py</code> I could run the compile script to generate the second version of <code>rlmeta.py</code>. The second version did not match the first version exactly. The complete diff can be seen in the commit <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/134c3a360160a2b978cd742a935df1c3a85de546#diff-7687f8856e0607ca8e0247b6cd77cf7b">Get rid of bootstrapped compiler</a>. Mostly I had used a different character for strings and forgotten some commas that were not strictly necessary. Once the second version replaced the first, the compile script reproduced <code>rlmeta.py</code> exactly. At this point the manually translated versions could be discarded. The RLMeta compiler was bootstrapped. This was a tremendously rewarding experience.</p>
<p>Did the first version work on the first run? No. In the translation process I noticed incorrect behavior in the grammars that I had to fix. And some manual translations were done incorrectly. But all fixes were relatively minor. Before the translation I had also carefully debugged the grammars in my head to decrease the risk of them having bugs.</p>
<p>To avoid making mistakes in the manual translation process, I created snippets for the Vim text editor for each AST node. So when I encountered a <code>Rule</code> AST node, I could type "rule", hit tab, and the following snippet would be inserted placing the cursor where the rule name should be inserted:</p>
<pre class="text"><code>def _rule_${1:name}(self):
    return ${2:matcher}()</code></pre>
<p>I could then type the name ("grammar" for example), hit tab, write the name of the next AST node, and hit tab. If the next AST node was <code>Or</code> for example, the following snipped would be inserted, placing the cursor inside the list:</p>
<pre class="text"><code>(lambda:
    self._or([
        ${1:matchers}
    ])
)</code></pre>
<p>The Vim snippets saved me a lot of typing and made manual translation feasible. Getting all commas and parenthesis right would have been difficult otherwise.</p>
<h2 id="f558623cfce441fb3e61033299d1419implementing-programming-languages">[]{#5f558623cfce441fb3e61033299d1419}Implementing programming languages</h2>
<p>When I read <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a> I remember thinking that it described what programming was all about. The following quote from <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-25.html#%_chap_4">chapter 4</a> I think summarizes it:</p>
<blockquote>
<p>However, as we confront increasingly complex problems, we will find that Lisp, or indeed any fixed programming language, is not sufficient for our needs. We must constantly turn to new languages in order to express our ideas more effectively. Establishing new languages is a powerful strategy for controlling complexity in engineering design; we can often enhance our ability to deal with a complex problem by adopting a new language that enables us to describe (and hence to think about) the problem in a different way, using primitives, means of combination, and means of abstraction that are particularly well suited to the problem at hand.</p>
</blockquote>
<p>In this article I set out to explain how a metalanguage could be used to give meaning to arithmetic expressions. But RLMeta is more powerful than that. It can be used to implement itself and also many other programming languages because matching and transforming is at the heart of programming language implementation. Its small implementation, just over 400 lines of code, also makes it feasible to understand and modify:</p>
<pre class="text"><code> 51 parser.rlmeta
 33 codegenerator.rlmeta
278 support.py
 45 compile.sh
407 total</code></pre>
<p>I hope this article inspires you to experiment with implementing programming languages so that you can solve complex problems elegantly.</p>
<h2 id="c6af1a11ed440d2bf31a497032c9c0bresources">[]{#4c6af1a11ed440d2bf31a497032c9c0b}Resources</h2>
<p>I was helped by the following resources when implementing RLMeta:</p>
<ul>
<li><a href="http://www.hcs64.com/files/pd1-3-schorre.pdf">META II paper</a></li>
<li><a href="http://www.vpri.org/pdf/tr2008003_experimenting.pdf">OMeta thesis</a></li>
<li><a href="http://www.bayfronttechnologies.com/mc_tutorial.html">Tutorial: Metacompilers Part 1</a></li>
<li><a href="https://www.youtube.com/watch?v=L1rwVBLHGiU">META II: A Syntax-Oriented Compiler Writing Language - Papers We Love Singapore</a></li>
</ul>
<h2 id="bb1e8ccbd4d55b89b391c08452c33code-listings-for-rlmeta">[]{#388bb1e8ccbd4d55b89b391c08452c33}Code listings for RLMeta</h2>
<h3 id="parser.rlmeta"><span id="a56c54f42c00473091d7c8295ff4e0f1"></span>parser.rlmeta</h3>
<pre class="text"><code>Parser {
  grammar =
    | name:x space &#39;{&#39; rule*:ys space &#39;}&#39;      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space &#39;=&#39; choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space &#39;|&#39;)?
      sequence:x (space &#39;|&#39; sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space &#39;:&#39; name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space &#39;*&#39;                        -&gt; [&quot;Star&quot; x]
    | expr2:x space &#39;?&#39;                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space &#39;!&#39; expr2:x                        -&gt; [&quot;Not&quot; x]
    | expr2
  expr2 =
    | space &#39;-&gt;&#39; hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space &#39;=&#39;)                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x &#39;-&#39; char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space &#39;.&#39;                                -&gt; [&quot;MatchAny&quot;]
    | space &#39;(&#39; choice:x space &#39;)&#39;             -&gt; x
    | space &#39;[&#39; expr*:xs space &#39;]&#39;             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space &#39;[&#39; hostExprListItem*:xs space &#39;]&#39; -&gt; [&quot;List&quot; ~xs]
    | space &#39;{&#39; buildExpr*:xs space &#39;}&#39;        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space &#39;(&#39; hostExpr*:ys space &#39;)&#39;  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space &#39;~&#39; hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space &#39;&gt;&#39;                                -&gt; [&quot;IndentBuilder&quot;]
    | space &#39;&lt;&#39;                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = &#39;&quot;&#39;  (!&#39;&quot;&#39;  innerChar)*:xs &#39;&quot;&#39;   -&gt; join(xs)
  charseq   = &#39;\&#39;&#39; (!&#39;\&#39;&#39; innerChar)*:xs &#39;\&#39;&#39;  -&gt; join(xs)
  char      = &#39;\&#39;&#39;  !&#39;\&#39;&#39; innerChar  :x  &#39;\&#39;&#39;  -&gt; x
  innerChar = &#39;\\&#39; escape | .
  escape    = &#39;\\&#39; -&gt; &quot;\\&quot; | &#39;\&#39;&#39; -&gt; &quot;&#39;&quot;
            | &#39;&quot;&#39;  -&gt; &quot;\&quot;&quot; | &#39;n&#39;  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39;
  nameChar  = &#39;a&#39;-&#39;z&#39; | &#39;A&#39;-&#39;Z&#39; | &#39;0&#39;-&#39;9&#39;
  space     = (&#39; &#39; | &#39;\n&#39;)*
}</code></pre>
<h3 id="codegenerator.rlmeta"><span id="d9ea64bbdad3465897667ebec9d5ace1"></span>codegenerator.rlmeta</h3>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys]   -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;                   }
    | [&quot;Rule&quot; .:x ast:y]        -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt; }
    | [&quot;MatchAny&quot;]              -&gt; { &quot;self._match_any&quot;                                   }
    | [&quot;String&quot; .:x]            -&gt; { repr(x)                                             }
    | [&quot;List&quot; astList:x]        -&gt; { x                                                   }
    | [&quot;Builder&quot; astItems:x]    -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot;                          }
    | [&quot;IndentBuilder&quot;]         -&gt; { &quot;_IndentBuilder()&quot;                                  }
    | [&quot;DedentBuilder&quot;]         -&gt; { &quot;_DedentBuilder()&quot;                                  }
    | [&quot;FnCall&quot; .:x astItems:y] -&gt; { x &quot;(&quot; y &quot;)&quot;                                         }
    | [&quot;VarLookup&quot; .:x]         -&gt; { &quot;_vars.lookup(&quot; repr(x) &quot;).eval()&quot;                  }
    | astFnBody:x               -&gt; { &quot;(lambda:\n&quot; &gt; x &lt; &quot;\n)&quot; }
  astFnBody =
    | [&quot;Or&quot; astItems:x]         -&gt; { &quot;self._or([&quot; x &quot;])&quot;                                 }
    | [&quot;Scope&quot; ast:x]           -&gt; { &quot;(lambda _vars:\n&quot; &gt; x &lt; &quot;()\n)(_Vars())&quot;           }
    | [&quot;And&quot; astItems:x]        -&gt; { &quot;self._and([&quot; x &quot;])&quot;                                }
    | [&quot;Bind&quot; .:x ast:y]        -&gt; { &quot;_vars.bind(&quot; repr(x) &quot;, &quot; y &quot;())&quot;                  }
    | [&quot;Star&quot; ast:x]            -&gt; { &quot;self._star(&quot; x &quot;)&quot;                                 }
    | [&quot;Not&quot; ast:x]             -&gt; { &quot;self._not(&quot; x &quot;)&quot;                                  }
    | [&quot;SemanticAction&quot; ast:x]  -&gt; { &quot;_SemanticAction(lambda: &quot; x &quot;)&quot;                    }
    | [&quot;MatchRule&quot; .:x]         -&gt; { &quot;self._match_rule(&quot; repr(x) &quot;)&quot;                     }
    | [&quot;MatchRange&quot; .:x .:y]    -&gt; { &quot;self._match_range(&quot; repr(x) &quot;, &quot; repr(y) &quot;)&quot;       }
    | [&quot;MatchString&quot; .:x]       -&gt; { &quot;self._match_string(&quot; repr(x) &quot;)&quot;                   }
    | [&quot;MatchCharseq&quot; .:x]      -&gt; { &quot;self._match_charseq(&quot; repr(x) &quot;)&quot;                  }
    | [&quot;MatchList&quot; ast:x]       -&gt; { &quot;self._match_list(&quot; x &quot;)&quot;                           }
  astItems = astItem*:xs        -&gt; { &quot;\n&quot; &gt; xs &lt;                                         }
  astItem  = ast:x              -&gt; { x &quot;,\n&quot;                                             }
  astList  = astListItem*:xs    -&gt; { &quot;(&quot; xs &quot;[])&quot;                                        }
  astListItem =
    | [&quot;ListItemSplice&quot; ast:x]  -&gt; {     x  &quot;+&quot;                                          }
    | ast:x                     -&gt; { &quot;[&quot; x &quot;]+&quot;                                          }
}</code></pre>
<h3 id="e606587034a0a9c8e8b5c714e7ef8support.py">[]{#983e606587034a0a9c8e8b5c714e7ef8}support.py</h3>
<pre class="text"><code>class _Grammar(object):

    def _or(self, matchers):
        original_stream = self._stream
        for matcher in matchers:
            try:
                return matcher()
            except _MatchError:
                self._stream = original_stream
        original_stream.fail(&quot;no choice matched&quot;)

    def _and(self, matchers):
        result = None
        for matcher in matchers:
            result = matcher()
        return result

    def _star(self, matcher):
        result = []
        while True:
            original_stream = self._stream
            try:
                result.append(matcher())
            except _MatchError:
                self._stream = original_stream
                return _SemanticAction(lambda: [x.eval() for x in result])

    def _not(self, matcher):
        original_stream = self._stream
        try:
            matcher()
        except _MatchError:
            return _SemanticAction(lambda: None)
        else:
            original_stream.fail(&quot;match found&quot;)
        finally:
            self._stream = original_stream

    def _match_rule(self, rule_name):
        key = (rule_name, self._stream.position())
        if key in self._memo:
            result, _, self._stream = self._memo[key]
        else:
            start = self._stream
            result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
            end = self._stream
            self._memo[key] = (result, start, end)
        return result

    def _match_range(self, start, end):
        original_stream = self._stream
        next_objext, self._stream = self._stream.next()
        if next_objext &gt;= start and next_objext &lt;= end:
            return _SemanticAction(lambda: next_objext)
        else:
            original_stream.fail(
                &quot;expected range {!r}-{!r} but found {!r}&quot;.format(start, end, next_objext)
            )

    def _match_string(self, string):
        original_stream = self._stream
        next_object, self._stream = self._stream.next()
        if next_object == string:
            return _SemanticAction(lambda: string)
        else:
            original_stream.fail(
                &quot;expected {!r} but found {!r}&quot;.format(string, next_object)
            )

    def _match_charseq(self, charseq):
        for char in charseq:
            original_stream = self._stream
            next_object, self._stream = self._stream.next()
            if next_object != char:
                original_stream.fail(
                    &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
                )
        return _SemanticAction(lambda: charseq)

    def _match_any(self):
        next_object, self._stream = self._stream.next()
        return _SemanticAction(lambda: next_object)

    def _match_list(self, matcher):
        original_stream = self._stream
        next_object, next_stream = self._stream.next()
        if isinstance(next_object, list):
            self._stream = self._stream.nested(next_object)
            matcher()
            if self._stream.is_at_end():
                self._stream = next_stream
                return _SemanticAction(lambda: next_object)
        original_stream.fail(&quot;list match failed&quot;)

    def run(self, rule_name, input_object):
        self._memo = _Memo()
        self._stream = _Stream.from_object(self._memo, input_object)
        result = self._match_rule(rule_name).eval()
        if isinstance(result, _Builder):
            return result.build_string()
        else:
            return result

class _Vars(dict):

    def bind(self, name, value):
        self[name] = value
        return value

    def lookup(self, name):
        return self[name]

class _SemanticAction(object):

    def __init__(self, fn):
        self.fn = fn

    def eval(self):
        return self.fn()

class _Builder(object):

    def build_string(self):
        output = _Output()
        self.write(output)
        return output.value

    @classmethod
    def create(self, item):
        if isinstance(item, _Builder):
            return item
        elif isinstance(item, list):
            return _ListBuilder([_Builder.create(x) for x in item])
        else:
            return _AtomBuilder(item)

class _Output(object):

    def __init__(self):
        self.value = &quot;&quot;
        self.indentation = 0

    def write(self, value):
        for ch in value:
            if self.value and ch != &quot;\n&quot; and self.value[-1] == &quot;\n&quot;:
                self.value += &quot;    &quot;*self.indentation
            self.value += ch

class _ListBuilder(_Builder):

    def __init__(self, builders):
        self.builders = builders

    def write(self, output):
        for builder in self.builders:
            builder.write(output)

class _AtomBuilder(_Builder):

    def __init__(self, atom):
        self.atom = atom

    def write(self, output):
        output.write(str(self.atom))

class _IndentBuilder(_Builder):

    def write(self, output):
        output.indentation += 1

class _DedentBuilder(_Builder):

    def write(self, output):
        output.indentation -= 1

class _Memo(dict):

    def __init__(self):
        dict.__init__(self)
        self._latest_stream = _ObjectStream(self, [], position=-1)
        self._latest_message = &quot;&quot;

    def describe(self):
        items = []
        for (rule_name, _), (_, start, end) in self.items():
            if end &gt; start:
                items.append((rule_name, start, end))
        items.sort(key=lambda item: (item[2].position(), item[1].position()))
        message = []
        for item in items:
            message.append(&quot;matched {: &lt;20} {} -&gt; {}\n&quot;.format(*item))
        message.append(&quot;\n&quot;)
        message.append(&quot;ERROR: {}: {}\n&quot;.format(
            self._latest_stream,
            self._latest_message
        ))
        return &quot;&quot;.join(message)

    def fail(self, stream, message):
        if stream.position() &gt;= self._latest_stream.position():
            self._latest_stream = stream
            self._latest_message = message
        raise _MatchError(self)

class _MatchError(Exception):

    def __init__(self, memo):
        Exception.__init__(self)
        self._memo = memo

    def describe(self):
        return self._memo.describe()

class _Stream(object):

    @classmethod
    def from_object(cls, memo, input_object):
        if isinstance(input_object, basestring):
            return _CharStream(memo, list(input_object))
        else:
            return _ObjectStream(memo, [input_object])

    def __init__(self, memo, objects):
        self._memo = memo
        self._objects = objects

    def fail(self, message):
        self._memo.fail(self, message)

    def next(self):
        if self.is_at_end():
            self.fail(&quot;not eof&quot;)
        next_object = self._objects[0]
        return (
            next_object,
            self._advance(next_object, self._objects[1:]),
        )

    def is_at_end(self):
        return len(self._objects) == 0

class _CharStream(_Stream):

    def __init__(self, memo, objects, line=1, column=1):
        _Stream.__init__(self, memo, objects)
        self._line = line
        self._column = column

    def position(self):
        return (self._line, self._column)

    def _advance(self, next_object, objects):
        if next_object == &quot;\n&quot;:
            return _CharStream(self._memo, objects, self._line+1, 1)
        else:
            return _CharStream(self._memo, objects, self._line, self._column+1)

    def __str__(self):
        return &quot;L{:03d}:C{:03d}&quot;.format(self._line, self._column)

class _ObjectStream(_Stream):

    def __init__(self, memo, objects, parent=(), position=0):
        _Stream.__init__(self, memo, objects)
        self._parent = parent
        self._position = position

    def position(self):
        return self._parent + (self._position,)

    def nested(self, input_object):
        return _ObjectStream(self._memo, input_object, self._parent+(self._position,))

    def _advance(self, next_object, objects):
        return _ObjectStream(self._memo, objects, self._parent, self._position+1)

    def __str__(self):
        return &quot;[{}]&quot;.format(&quot;, &quot;.join(str(x) for x in self.position()))</code></pre>
<h3 id="d8f0ff47f4edcb201139df8cd9520compile.sh">[]{#193d8f0ff47f4edcb201139df8cd9520}compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

rlmeta_compiler=&quot;$(pwd)/$1&quot;

cd &quot;$(dirname &quot;$0&quot;)&quot;

to_python_string() {
    python -c &#39;import sys; sys.stdout.write(repr(sys.stdin.read()))&#39;
}

support_py=$(cat support.py)
support_py_string=$(to_python_string &lt; support.py)
parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
import sys

SUPPORT = $support_py_string

$support_py

$parser_py

$codegenerator_py

join = &quot;&quot;.join

def compile_grammar(grammar):
    parser = Parser()
    code_generator = CodeGenerator()
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))

if __name__ == &quot;__main__&quot;:
    if &quot;--support&quot; in sys.argv:
        sys.stdout.write(SUPPORT)
    else:
        try:
            sys.stdout.write(compile_grammar(sys.stdin.read()))
        except _MatchError as e:
            sys.stderr.write(e.describe())
            sys.exit(1)
EOF</code></pre>
]]></summary>
</entry>

</feed>
