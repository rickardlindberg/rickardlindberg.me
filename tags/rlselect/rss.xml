<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Rickard's personal homepage: latest posts tagged "rlselect"</title>
        <link>http://rickardlindberg.me</link>
        <description><![CDATA[Rickard's personal homepage: latest posts tagged "rlselect"]]></description>
        <atom:link href="http://rickardlindberg.me/tags/rlselect/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 19 May 2017 00:00:00 UT</lastBuildDate>
        <item>
    <title>Evolution of recalling Bash history</title>
    <link>http://rickardlindberg.me/writing/evolution-recalling-bash-history/</link>
    <description><![CDATA[<h1>Evolution of recalling Bash history</h1>

<p><em>Published on 19 May 2017.</em></p>

<p>This article is about how I’ve become more efficient at using Bash, the interactive UNIX shell.</p>
<p>When I work in Bash, I often want to execute a command again. In the beginning I re-typed the command and pressed enter. This worked fine for short commands, but became tedious for longer commands.</p>
<p>In some shells this is the only way to enter a new command. But Bash remembers the recently executed commands and provides ways to recall them.</p>
<h2 id="cycle-with-arrow-keys">Cycle with arrow keys</h2>
<p>The first way I learned to recall history was with the arrow keys. If I pressed <kbd>Up</kbd> the previous command was inserted at the prompt. I could continue for as long as I wanted. If I pressed <kbd>Down</kbd> the next command was inserted at the prompt:</p>
<pre><code>$ ls&lt;Enter&gt;
bin         ...

$ date&lt;Enter&gt;
Wed May 10 08:14:46 CEST 2017

$ &lt;Up&gt;

$ date&lt;Up&gt;

$ ls&lt;Down&gt;

$ date&lt;Enter&gt;
Wed May 10 08:14:59 CEST 2017</code></pre>
<p>This worked fine for commands that I had executed recently, but tedious for commands that I had executed long ago because I had to press <kbd>Up</kbd> many times. I ended up pressing and holding <kbd>Up</kbd> so that history scrolled by and when I saw my command, I released the key and pressed <kbd>Down</kbd> until it appeared again.</p>
<h2 id="cycle-with-ctrl-pctrl-n">Cycle with Ctrl-P/Ctrl-N</h2>
<p>Later I learned that <kbd>Ctrl-P</kbd> (previous) had the same function as <kbd>Up</kbd> and that <kbd>Ctrl-N</kbd> (next) had the same function as <kbd>Down</kbd>.</p>
<p>These shortcuts were more comfortable for me because I like to keep my fingers as close to the home row as possible.</p>
<h2 id="searching-with-ctrl-r">Searching with Ctrl-R</h2>
<p>Then I learned about Bash’s interactive history search command. If I pressed <kbd>Ctrl-R</kbd> the prompt changed to this:</p>
<pre><code>(reverse-i-search)`&#39;:</code></pre>
<p>This special prompt allowed me to type parts of a command that I had executed previously. Say I wanted to execute the last find command again. I typed “find” and the prompt changed to this:</p>
<pre><code>(reverse-i-search)`find&#39;: find -name &#39;*.py&#39; -a -type f</code></pre>
<p>The text I typed, “find”, was present before the colon. After the colon the last command that I had executed that contained the string “find” was displayed. In this case I did a search for Python files. If this was not the match I was looking for, I could hit <kbd>Ctrl-R</kbd> again and the part to the right of the colon would change to the next command in the history that contained the string “find”. Once I found the command I was looking for I had two options: I could hit <kbd>Tab</kbd> to insert the command at the prompt:</p>
<pre><code>$ find -name &#39;*.py&#39; -a -type f</code></pre>
<p>This way I could edit the command before I executed it. Or I could hit <kbd>Enter</kbd> to execute the command directly.</p>
<p>Now I was able to recall commands that I had executed long ago. I almost replaced all my usages of <kbd>Ctrl-P</kbd>/<kbd>Ctrl-N</kbd> with <kbd>Ctrl-R</kbd>. Except for the cases where I knew that the command I wanted to recall was only a few entries back.</p>
<h2 id="frustrations-with-ctrl-r">Frustrations with Ctrl-R</h2>
<p>The interactive search worked great for me when I knew what I was looking for. It did not work so great when I was more uncertain or when I mistyped the name of a command.</p>
<p>The interactive search works by having a pointer to en entry in the history. When I typed a command it would move that pointer to the next item in the history that matched. But if I mistyped, the search might still match something further back in history. But when I erased a few characters to correct my mistake, the search would continue from there. Say this was my history:</p>
<ol style="list-style-type: decimal">
<li><code>tac ~/.bash_history</code></li>
<li><code>echo frustration</code></li>
<li><code>echo with</code></li>
<li><code>echo bash</code></li>
</ol>
<p>I hit <kbd>Ctrl-R</kbd> to to begin searching for “bash”:</p>
<pre><code>(reverse-i-search)`&#39;:</code></pre>
<p>But I mistyped. Instead of “b” I typed “f”:</p>
<pre><code>(reverse-i-search)`f&#39;: echo frustration</code></pre>
<p>The search matched item 2. I erased the incorrectly typed character:</p>
<pre><code>(reverse-i-search)`&#39;: echo frustration</code></pre>
<p>The match remained. I typed bash correctly:</p>
<pre><code>(reverse-i-search)`bash&#39;: tac ~/.bash_history</code></pre>
<p>It now matched item 1 instead of item 4. The search continued from the previous match. I would have wanted the search to always show the most recent match from history. The easiest way I found to reset the search after a failure to find what I was looking for was to just execute a dummy command. Usually I selected <code>ls</code> because it was short to type and had no side effects.</p>
<h2 id="interactively-filtering-with-external-program">Interactively filtering with external program</h2>
<p>Then I was introduced to <a href="https://github.com/dvorka/hstr">hstr</a> by a colleague. It worked like a replacement for <kbd>Ctrl-R</kbd>. When I invoked it, it dropped into a text UI where my last history entries were shown. I could also type part of a command to narrow down the list. If I changed the search string, the narrowed down list changed accordingly. When I found a match I could similarly press <kbd>Tab</kbd> to insert the command at the prompt or press <kbd>Enter</kbd> to execute it immediately. It looked like this:</p>
<p><a href="https://github.com/dvorka/hstr"><img src="/writing/evolution-recalling-bash-history/hh-animated-01.gif" alt="Demo of hstr (from their website)" /></a></p>
<p>This solved my frustrations with Bash’s interactive search. For me, this was a far easier way to find items from my history. The fact that it showed the last commands also helped me. I could visually inspect them, and they would guide my search.</p>
<p>hstr was so good that I wanted to use a similar selection mechanism for other things, but hstr was only for Bash history. I ended up writing my own selection program: <a href="/projects/rlselect/index.html">rlselect</a>. Partly because I wanted such a program, but also because it seemed like a fun program to write. The core selection program is called <code>rlselect</code> and then there are multiple programs that use it to allow selecting specific things. <code>rlselect-history</code> is a replacement for <kbd>Ctrl-R</kbd>/hstr:</p>
<p><a href="/projects/rlselect/index.html"><img src="/writing/evolution-recalling-bash-history/rlselect_history_demo.gif" alt="Demo of rlselect" /></a></p>
<p>There are some differences between hstr and <code>rlselect-history</code>. I took only the parts I personally wanted from hstr and put them into <code>rlselect-history</code>.</p>
<p>If you want to improve your Bash usage, I suggest taking a look at <a href="https://github.com/dvorka/hstr">hstr</a> or <a href="/projects/rlselect/index.html">rlselect</a>.</p>
]]></description>
    <pubDate>Fri, 19 May 2017 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/evolution-recalling-bash-history/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>

    </channel>
</rss>
