<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Rickard's personal homepage: latest posts tagged newsletter</title>
    <link href="http://rickardlindberg.me/tags/newsletter/atom.xml" rel="self" />
    <link href="http://rickardlindberg.me" />
    <id>http://rickardlindberg.me/tags/newsletter/atom.xml</id>
    <author>
        <name>Rickard Lindberg</name>
        <email>ricli85@gmail.com</email>
    </author>
    <updated>2019-11-02T00:00:00Z</updated>
    <entry>
    <title>Newsletter October 2019</title>
    <link href="http://rickardlindberg.me/writing/newsletter/october-2019/" />
    <id>http://rickardlindberg.me/writing/newsletter/october-2019/</id>
    <published>2019-11-02T00:00:00Z</published>
    <updated>2019-11-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Newsletter October 2019</h1>

<p><em>Published on  2 November 2019.</em></p>

<p>This is what I’ve been up to in October 2019:</p>
<ul>
<li><p>I read <a href="http://users.ece.cmu.edu/~koopman/stack_computers/">Stack Computers: the new wave</a> by Philip J. Koopman, Jr. I did not dig into details about the different computers, but the rest of the book gave me a good understanding stack computers.</p></li>
<li><p>I thought about how stack computers could support programming language features. In particular, I though about how they could support local variables. A calling convention could be used where function parameters are always put on the stack. If a function wants to, it can store those in a frame for later reference. But it does not have to. The compiler might also optimize away local variables in favor of pure stack operations.</p></li>
<li><p>I continued working on <a href="/writing/expr-to-x86-compiler/index.html">compiling expressions to x86 machine code</a>. I did debugging with gdb and learned some useful commands. I managed to compile a subset of expressions down to x86 machine code. It was satisfying. I was helped by <a href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-4-in-python/">Adventures in JIT compilation: Part 4 - in Python</a>.</p></li>
<li><p>I got an urge to do a rewrite of <a href="/projects/rliterate/index.html">RLiterate</a> to improve performance and fix bugs that make it annoying to use. I use RLiterate to write articles for my blog. I really like the features of it, but the poor performance makes it annoying to use. I had though of a slightly different architecture that would mitigate those problems. But it would require a complete rewrite. I have now successfully validated that the new architecture works better and I will continue to build the next version. You can see it <a href="/projects/rliterate/book2/index.html">here</a>.</p></li>
<li><p>I worked on RLiterate in small chunks. First I did some work and published that version on my homepage. Then at a later time I did review of what I had done. Then I went through and fixed comments from review. This workflow has worked quite well. Having time between the two activities has allowed me to rest and reflect.</p></li>
<li><p>Because I got distracted with RLiterate, I did not make progress on the article about <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures in RLMeta</a> that I said I would hoped have finished by now. I have not abandoned my drafts though. Something more interesting got in between. I will get back to writing at some point.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Newsletter September 2019</title>
    <link href="http://rickardlindberg.me/writing/newsletter/september-2019/" />
    <id>http://rickardlindberg.me/writing/newsletter/september-2019/</id>
    <published>2019-10-01T00:00:00Z</published>
    <updated>2019-10-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Newsletter September 2019</h1>

<p><em>Published on  1 October 2019.</em></p>

<p>This is what I’ve been up to in September 2019:</p>
<ul>
<li><p>I finished the article on <a href="/writing/rlmeta-left-associativity/index.html">parsing left associative operators in RLMeta</a>. I’m pleased with how it turned out.</p></li>
<li><p>I played with <a href="https://cython.org/">Cython</a> to see if RLMeta VM could be made faster if converted to a C extension module. (It could!) I might write a blog post about it.</p></li>
<li><p>I learned more about Python C extension modules from <a href="https://thomasnyberg.com/what_are_extension_modules.html">What are (c)python extension modules?</a>.</p></li>
<li><p>I watched <a href="https://cacm.acm.org/magazines/2018/11/232214-a-look-at-the-design-of-lua/fulltext">A Look at the Design of Lua</a>. I was inspired by the setting in which it seems to have been created. Small office. Whiteboard. Collaboration. I want to implement a minimal OOP-language in order to learn how to do it.</p></li>
<li><p>I finished porting <a href="/projects/timeline/index.html">Timeline</a> to Python 3.</p>
<ul>
<li><p>The most difficult part was to verify that division operations were still working the same. (Python 3 integer division gives float instead of integer as in Python 2.)</p></li>
<li><p>I concluded that maintaining software is hard work. Even if your program does not change, the external world changes, and you need to change your program accordingly.</p></li>
<li><p>I finished the article on the <a href="/writing/timeline-segfault-wxpython/index.html">segfault failure</a> that I found during porting.</p></li>
</ul></li>
<li><p>I learned about a trick help me get started on a task faster: leave work undone. Leave a test failing. Leave a sentence half written.</p></li>
<li><p>I learned that your number one priority is not what you write on top of the TODO list, but what you actually do.</p></li>
<li><p>I finished a post with my <a href="/writing/alan-kay-notes/index.html">notes on Alan Kay</a>. He is a big inspiration to me.</p></li>
<li><p>I read most parts of <a href="https://paulcavallaro.com/blog/common-systems-programming-optimizations-tricks/">Common Systems Programming Optimizations &amp; Tricks</a>. Low level optimizations are interesting. It reminded me of Bob Nystrom’s <a href="http://gameprogrammingpatterns.com/">game programming book</a> that discusses some <a href="http://gameprogrammingpatterns.com/optimization-patterns.html">similar topics</a>.</p></li>
<li><p>I continued with the article about <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures in RLMeta</a>. It is almost finished, but because I got distracted by other work, it is not. I hope to finish it next month.</p></li>
<li><p>I started working on <a href="/writing/expr-to-x86-compiler/index.html">compiling expressions to x86 machine code</a>:</p>
<ul>
<li><p>I don’t really know assembly, so I found <a href="https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming">A fundamental introduction to x86 assembly programming</a> useful.</p></li>
<li><p>I got segafults because of 32/64-bit mixup. It just shows that I don’t really know what I’m doing yet.</p></li>
<li><p>I learned that <code>add</code> and <code>imul</code> instructions do not work the same. <code>imul</code> can not store result back in memory but must go via register.</p></li>
<li><p>I learned that I subtracted operands in the wrong order.</p></li>
<li><p>I read <a href="https://csl.name/post/python-jit/">Writing a basic x86-64 JIT compiler from scratch in stock Python</a>.</p></li>
<li><p>I read <a href="https://csl.name/post/python-compiler/">JIT compiling a subset of Python to x86-64</a>.</p></li>
</ul></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Newsletter August 2019</title>
    <link href="http://rickardlindberg.me/writing/newsletter/august-2019/" />
    <id>http://rickardlindberg.me/writing/newsletter/august-2019/</id>
    <published>2019-08-31T00:00:00Z</published>
    <updated>2019-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Newsletter August 2019</h1>

<p><em>Published on 31 August 2019.</em></p>

<p>This is what I’ve been up to in August 2019:</p>
<ul>
<li><p>I finished the <a href="/writing/rlmeta-vm/index.html">RLMeta VM</a> article. When working on it, I noticed that error handling has not gotten much love. I want to improve it and write about it in another article.</p></li>
<li><p>I found <a href="https://viewsourcecode.org/snaptoken/kilo/index.html">Build Your Own Text Editor</a> that explains how to build a text editor by showing and explaining incremental patches. I found the approach interesting.</p>
<ul>
<li><p>This approach feels similar to what is described in <a href="http://akkartik.name/post/literate-programming">Literate programming: Knuth is doing it wrong</a> and <a href="http://akkartik.name/post/wart-layers">A new way to organize programs</a>.</p></li>
<li><p>The above made me think about if programs could be organized in features without the use of literate programming. That would require some kind of plugin architechture where features could be plugged in independent of eachother.</p></li>
</ul></li>
<li><p>I read Guido van Rossum’s article on <a href="https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9">Generating a PEG Parser</a>. This made me realize that RLMeta does not memoize correctly. I’m working on an <a href="/writing/rlmeta-memoize-failures/index.html">article</a> where I fix it.</p></li>
<li><p>I worked on porting <a href="/projects/timeline/index.html">Timeline</a> to Python 3. It is a work in progress, but the application now starts. I have a few items left on my TODO list that I want to complete before considering the port done. I ran into a problem that I <a href="/writing/timeline-doctest-wxpython/index.html">blogged about</a>. An another one <a href="/writing/timeline-segfault-wxpython/index.html">in progress</a>.</p></li>
<li><p>I found <a href="https://twitter.com/mfeathers/status/1159495761714769921">this tweet</a> by Michael Feathers interesting:</p>
<blockquote>
<p>Fred Brooks said that software is best when it looks like it was designed by one mind.</p>
<p>Mob programming is an attempt to create one mind of many.</p>
<p>Quality goes down as the number of people touching code independently goes up.</p>
<p>Interesting constraint problem.</p>
</blockquote>
<p>And a <a href="https://twitter.com/raganwald/status/1159498133635850240">follow up</a>:</p>
<blockquote>
<p>Interesting parallel to Alan Kay’s bifurcation of languages into “Agglutination of features” vs. “Crystallization of style.”</p>
<p>The former are almost always defined by committee, the latter by solo designers or very small, tight teams.</p>
</blockquote>
<p>And another <a href="https://twitter.com/jit_j/status/1159501352243998720">follow up</a>:</p>
<blockquote>
<p>There are quality OSS projects that are made up of individual contributors and a distributed review process. It’s possible for independent workers to maintain and extend a codebase, as long as they buy into a shared style and a shared philosophy. Process matters though.</p>
</blockquote>
<p>How can we build software so that it appears to be desgined by a single mind?</p></li>
<li><p>I wrote some code for an <a href="/writing/rlmeta-left-associativity/index.html">upcoming article</a> on parsing left associative operators in RLMeta.</p></li>
<li><p>I read some of Eli Bendersky’s articles on parsing:</p>
<ul>
<li><p><a href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers">Recursive descent, LL and predictive parsers</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">Some problems of recursive descent parsers</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator">A recursive descent parser with an infix expression evaluator</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing">Top-Down operator precedence parsing</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing">Parsing expressions by precedence climbing</a></p></li>
</ul></li>
<li><p>One of them led me to read Bob Nystrom’s article <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">Pratt Parsers: Expression Parsing Made Easy</a>.</p></li>
<li><p>I want to learn more about JIT compilation. As I read <a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html">Hello, JIT World: The Joy of Simple JITs</a> describing a JIT compiler for Brainfuck I thought: Is JIT-ing byte code just getting rid of the interpreter loop? I’m not completely sure of the big picture yet. And how does a tracing JIT compiler differ from a regular JIT compiler. Brainfuck seems to be a popular example in JIT articles.</p></li>
<li><p>I read about Cython and though that I should try it for RLMeta VM. Should be quite easy to port it to C and make incremental performance improvements.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Newsletter July 2019</title>
    <link href="http://rickardlindberg.me/writing/newsletter/july-2019/" />
    <id>http://rickardlindberg.me/writing/newsletter/july-2019/</id>
    <published>2019-07-31T00:00:00Z</published>
    <updated>2019-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Newsletter July 2019</h1>

<p><em>Published on 31 July 2019.</em></p>

<p>This is what I’ve been up to in July 2019:</p>
<ul>
<li><p>I continued work on the RLMeta VM post.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=oww7oB9rjgw">Steal Like An Artist: Austin Kleon at TEDxKC</a>. Main takeway was that every work is a mashup. Steal from others and show your mashup so that we can steal from you.</p></li>
<li><p>I reread parts of <em>The Art of Explanation</em> by Lee LeFever. He presents a way to explain things so that people understand. I will try to be inspired by this way when writing.</p></li>
<li><p>I thought about converting all posts on this site to “blog posts” and putting them under <code>rickardlindberg.me/blog/</code> and using tags for categories. Then allowing tags to also have explanations. Not sure if this structure is better or not.</p></li>
<li><p>I read parts of <em>Hackers and Painters</em> by Paul Graham. A few quotes that I liked:</p>
<blockquote>
<p>Programming languages are what programmers think in. Naturally, this has a big effect on the kind of thoughts they have.</p>
</blockquote>
<p>I fully agree with this, and this is one of the reasons I want to learn more about language design so that I can design ideal languages for problems.</p>
<blockquote>
<p>After a certain age, programmers rarely switch languages voluntarily. Whatever language people happen to be used to, they tend to consider just good enough.</p>
</blockquote>
<p>I don’t want to get stuck in a language. How can I avoid it?</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=ymiBDged-eQ">How to Start a Business or Podcast From Scratch | Tim Ferriss</a>. Main takeway was that it is easier to create a new category by finding a niche market to fill. Filling demand (in a new category) is easier than creating demand (in an existing category).</p></li>
<li><p>I started reading <em>The 22 Immutable Laws of Marketing</em> by Al Ries because it was recommended by Tim in the above video. Some quotes:</p>
<blockquote>
<p>The easy answer is to make sure your programs are in tune with the laws of marketing.</p>
</blockquote>
<blockquote>
<p>There are laws of nature, so why shouldn’t there be laws of marketing? You can build a great-looking airplane, but it’s not going to get off the ground unless it adheres to the laws of physics, especially the law of gravity. You can build an architectural masterpiece on a sand dune, but the first hurricane will undermine your creation. So it follows that you can build a brilliant marketing program only to have one of the immutable laws knock you flat if you don’t know what they are.</p>
</blockquote></li>
<li><p>I read about an incremental approach to compiler construction <a href="http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf">here</a>, <a href="https://generalproblem.net/">here</a>, and <a href="https://blog.sigplan.org/2019/07/09/my-first-fifteen-compilers/">here</a>. The incremental approach starts with a small language (just integers) and builds upon that. At each stage, there is a working compiler. I want to explore this approach more. Can such a compiler be written with <a href="/tags/rlmeta/index.html">RLMeta</a>?</p></li>
<li><p>I write articles about RLMeta in a literate programming style. Sometimes I think: Why is all this text needed? The code speaks for itself, right? Probably it doesn’t, but it is interesting to try to find the right balance.</p></li>
<li><p>I read <a href="https://medium.com/@gvanrossum_83706/peg-parsers-7ed72462f97c">PEG Parsers</a> by Guido van Rossum. He is experimenting with replacing Python’s parser with a PEG-version.</p></li>
<li><p>I found <a href="https://www.rascal-mpl.org/">Rascal - Metaprogramming Language</a>. I want to read more about it, but here is a good summary:</p>
<blockquote>
<p>You want to use the best tool for the job when analyzing, transforming or generating source code, so normally you will end up with many different tools, possibly even written in different languages. Now the problem is to integrate these tools again. Rascal solves this problem by integrating source code analysis, transformation, and generation primitives on the language level. Use it for any kind of metaprogramming task: to construct parsers for programming languages, to analyze and transform source code, or to define new DSLs with full IDE support.</p>
</blockquote></li>
<li><p>I read <a href="http://www.bbc.com/future/story/20190722-the-apple-software-that-inspired-the-internet">The forgotten software that inspired our modern world</a>. A quote I liked:</p>
<blockquote>
<p>But even more than that, HyperCard didn’t compromise between the easily usable and the creatively powerful.</p>
</blockquote>
<p>Something in that reminds me of what Alan Kay said. Something about simplifying but not dumbing down when teaching children.</p></li>
<li><p>I read <a href="https://technicalblogging.com/blogging-income-how-bloggers-make-money/">The Inverted Pyramid of Blogging Income: How Pro Bloggers Make Money</a>. Main takeaway was that if you want to make money blogging, you should convert readers into customers and you must therefore also have another product to sell.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Newsletter June 2019</title>
    <link href="http://rickardlindberg.me/writing/newsletter/june-2019/" />
    <id>http://rickardlindberg.me/writing/newsletter/june-2019/</id>
    <published>2019-06-30T00:00:00Z</published>
    <updated>2019-06-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Newsletter June 2019</h1>

<p><em>Published on 30 June 2019.</em></p>

<p>This is what I’ve been up to in June 2019:</p>
<ul>
<li><p>I was inspired to try writing a journal after stumbling across Derek Siver’s blog post <a href="https://sivers.org/dj">Benefits of a daily diary and topic journals</a>. The idea is to write for my future self to help me solve problems by recording my thoughts and reflecting on them.</p></li>
<li><p>I read <em>Poke the Box</em> by Seth Godin. My main takeaway was that <strong>initiative is scarce</strong>, and if you take initiative, you are valuable.</p></li>
<li><p>I read <a href="https://compilerbook.com/">Writing A Compiler In Go</a> by Thorsten Ball. It is a topic that interests me. I learned about designing virtual machines.</p></li>
<li><p>I learned a technique for parsing offside rule languages with PEG parsers via <a href="https://github.com/jgm/peg-markdown/">A PEG Markdown parser</a>. I plan to write a blog post about this technique.</p></li>
<li><p>I read <em>Show Your Work!</em> by Austin Kleon. Some takeaways:</p>
<ul>
<li><p>An amateur is sometimes better at explaining something than an expert because the amateur has recently encountered it and knows what is hard. An expert has forgotten. Therefore <strong>blogging about problems and solutions when I encounter them is useful</strong>.</p></li>
<li><p>It is useful to share the process of creating something, not just the finished work.</p></li>
<li><p>It inspired me to publish draft posts on this blog.</p></li>
<li><p>It inspired me to write these monthly newsletters.</p></li>
</ul></li>
<li><p>I finished writing <a href="/writing/optimizing-rlmeta/index.html">Optimizing RLMeta</a>. I struggled with grammar and usage (should I use past or present, active or passive, we or I, and so on). I read other articles to try to analyze what they did. But I also came to one important realization: if I find it hard to write, I can read what I’ve written, find something small to fix, and then I’m suddenly writing again. I will keep writing and hopefully keep improving.</p></li>
<li><p>I have tried to get into the habit of writing a bit at least every day. Even though some days I produced almost nothing, I kept doing it. Eventually it payed off, but sometimes I felt like I needed a longer session to get something useful done. Often times, short sessions worked as well. One thing that helped me continue was to take a note at the end of a session what to proceed with.</p></li>
<li><p>I read parts of <a href="https://beautifulracket.com/">Beautiful Racket</a>. Racket is a programming language designed for language-oriented programming. I have for a long time felt that this is a better way to program, but never fully put it into practice. I even started writing <a href="https://leanpub.com/ldd">a book</a> about it. I intend to continue pursuing this way of programming with the help of <a href="/tags/rlmeta/index.html">RLMeta</a>. I will most likely return to <em>Beautiful Racket</em>.</p></li>
<li><p>I read <em>4-Hour Work Week</em> by Timothy Ferris. Some takeaways:</p>
<ul>
<li><p>Unrealistic goals as easier to achieve because the competition is not as fierce.</p></li>
<li><p>80/20 rule. I can stop doing 80% of what I’m doing and still perform as well.</p></li>
<li><p>Batching work is sometimes more effective. Limit Twitter/Email/etc to once/twice a day to not be bothered with it the rest of the time.</p></li>
<li><p>If I did not have to work for money, what would I do? If this is the last day of my life, would I do what I’m doing?</p></li>
<li><blockquote>
<p>First, “expert” in the context of selling product means that you know more about the topic than the purchaser. No more.</p>
</blockquote></li>
</ul></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=o_ptYjf8Bes">(sixth RacketCon): Matthew Butterick – The Making of “Beautiful Racket”</a>. My main takeaway was that a DSL has two parts: the domain and the programming language. And the most important part is the domain. In order to create a good DLS you need to have much knowledge about the domain.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=eWJVvNptHZ4">Arnold Schwarzenegger 2019 - The speech that broke the internet - Motivational &amp; Inspiring</a>. In it he says that you should work hard and advertise. This felt similar to Austin Kleon’s advice that you should show your work.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=8J6HuvosP0s">Typography for Docs</a>. This is also by Matthew Butterick. I like this talk as well. It inspired me to try to improve typography on my blog. We’ll see if I get around to it.</p></li>
<li><p>I read <a href="https://m00natic.github.io/lisp/manual-jit.html">Uniform Structured Syntax, Metaprogramming and Run-time Compilation</a>. My main takeaway was that compilation happens at runtime. Just in time. Therefore the compiler must be shipped with the runtime. Common Lisp has hooks for different times during compilation: reader macro, macro, etc.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=viF1bVTOO6k">Steady Typing</a>. It shows a projectional editor. Those interest me. They are one inspiration for <a href="/projects/rliterate/index.html">RLiterate</a>.</p></li>
</ul>
]]></summary>
</entry>

</feed>
