<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Rickard's personal homepage: latest posts tagged newsletter</title>
        <link>http://rickardlindberg.me</link>
        <description><![CDATA[Rickard's personal homepage: latest posts tagged newsletter]]></description>
        <atom:link href="http://rickardlindberg.me/tags/newsletter/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 04 May 2020 00:00:00 UT</lastBuildDate>
        <item>
    <title>Newsletter April 2020</title>
    <link>http://rickardlindberg.me/writing/newsletter/april-2020/</link>
    <description><![CDATA[<h1>Newsletter April 2020</h1>

<p><em>Published on  4 May 2020.</em></p>

<p>This is what I’ve been up to in April 2020:</p>
<ul>
<li><p>I finished the blog post about <a href="/writing/wx-layout-update/index.html">Layout/Update problem in wxPython</a>.</p></li>
<li><p>I read <a href="http://journal.stuffwithstuff.com/2020/04/05/crafting-crafting-interpreters/">Crafting “Crafting Interpreters”</a>. It was fun to read about his process of writing the book.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=vtIzMaLkCaM&amp;t=1843s">LEADERSHIP LAB: The Craft of Writing Effectively</a>. Main takeaway was that the most important thing about writing is that it should be <strong>valuable</strong> to the reader. Everything else is secondary. A good structure to make it valuable is to first describe a problem (that the reader has) and then a solution.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=CnbVCNIh1NA">(ninth RacketCon): Andrew Blinn – Fructure: A Structured Editing Engine in Racket</a>. It inspired me.</p></li>
</ul>
]]></description>
    <pubDate>Mon, 04 May 2020 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/april-2020/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter March 2020</title>
    <link>http://rickardlindberg.me/writing/newsletter/march-2020/</link>
    <description><![CDATA[<h1>Newsletter March 2020</h1>

<p><em>Published on  2 April 2020.</em></p>

<p>This is what I’ve been up to in March 2020:</p>
<ul>
<li><p>I continued with <a href="/projects/rliterate/book2/index.html">RLiterate</a>:</p>
<ul>
<li><p>I tried <a href="https://pavelfatin.com/typometer/">Typometer</a> to measure the time it takes from a kepress to a character appearing on the screen.</p></li>
<li><p>My first approach to speed up drawing was to draw immediately with <code>Layout</code>/<code>Update</code>. That turned out to not work so well. I documented the problem in a <a href="/writing/wx-layout-update/index.html">blog post</a>.</p></li>
<li><p>I concluded that to draw fast in RLiterate, an approach that works quite well is to only draw the part where the cursor is first, and draw everything else a few milliseconds later if there are no additional input events. For example, if a title is edited in the workspace, the table of contents might have to be redrawn as well. But it can wait, since the focus is not on it right now. I documented this behavior quite well <a href="/projects/rliterate/book2/index.html#5fb3048d154d4f50af92d4cbe63db75a">here</a>.</p></li>
<li><p>I think RLiterate’s true potential has not yet been explored. I think more paragraph types could add much value. It is something that I hope to explore after I finish RLiterate 2. But I don’t want to rush it. I want to write RLiterate 2 as clean as possible while still being capable of roughly what RLiterate (1) is.</p></li>
<li><p>I’m also thinking that RLiterate must be a multi process program. There is only so much you can do in GUI thread without it being sluggish. And using threads in Python does not help much since they are not truly run in parallell. So I’m thinking a multi process worker architecture is needed for heavy tasks. Like syntax highlighting, spell checking, generating files, etc. Then a little worker icon in toolbar to let the user know that stuff is happening in the background.</p></li>
</ul></li>
<li><p>I read <a href="https://medium.com/s/story/lets-pretend-this-never-happened-8abf0bc9648c">The Flawed History of Graphical User Interfaces</a>. Computers don’t have to be what they are. We can make them to do anything. Including alternative user interfaces.</p></li>
<li><p>I read <a href="https://hackernoon.com/some-tentative-guidelines-for-gui-composability-2900abead1d9">Some tentative guidelines for GUI composability</a>. Isolated applications that can’t be composed is a bad idea. Yet the default.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=Pot9GnHFOVU&amp;t=1026s">Tudor Gîrba - Moldable development</a>. It is an interesting project that I want to explore more.</p></li>
<li><p>I read <a href="https://medium.com/feenk/one-rendering-tree-918eae49bcff">One rendering tree</a>.</p>
<blockquote>
<p>Well, the user interface framework has a tree, and somewhere in that tree, there is a canvas, and in that canvas … well, there is another world, with another tree. That these are different worlds, and different worlds means we cannot combine them easily. We do not want different worlds. We want just one. A seamless one.</p>
</blockquote>
<p>This is something that might be useful for RLiterate. But that would require yet another complete rewrite. I should finish RLiterate 2 and learn from it. Then study one rendering tree. Then see if a third rewrite is suitable or not. But it is far away in the future.</p></li>
<li><p>I read <a href="https://www.hillelwayne.com/post/influential-dead-languages/">10 Most(ly dead) Influential Programming Languages</a>. I would like to learn more APL. Perhaps implement my own APL to learn more.</p></li>
</ul>
]]></description>
    <pubDate>Thu, 02 Apr 2020 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/march-2020/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter February 2020</title>
    <link>http://rickardlindberg.me/writing/newsletter/february-2020/</link>
    <description><![CDATA[<h1>Newsletter February 2020</h1>

<p><em>Published on  2 March 2020.</em></p>

<p>This is what I’ve been up to in February 2020:</p>
<ul>
<li><p>I continued with <a href="/projects/rliterate/book2/index.html">RLiterate</a> and made some <a href="/projects/rliterate/book2/index.html#416f6a8d52f0452ea3be94fd18b7a90e">progress</a>. I started to flesh out the rest of the application and started with adding support for direct manipulation of titles and paragraph text.</p></li>
<li><p>I found out about <a href="http://nickgravgaard.com/elastic-tabstops/">Elastic tabstops - a better way to indent and align code</a>. It is a nice inspiration for tab stop handling in RLiterate.</p></li>
<li><p>I read <a href="http://blog.rfox.eu/en/Programmer_s_critique_of_missing_structure_of_oper.html">Programmer’s critique of missing structure of operating systems</a>. It reminds me of what Alan Kay has talked about and hints at what real objects might be like. Interesting.</p></li>
<li><p>I read <a href="https://buttondown.email/hillelwayne/archive/826fd056-1d76-4b1c-b9c8-96deabbec07d">Donald Knuth Was Framed</a>. I’m interested in all sources about literate programming.</p></li>
</ul>
]]></description>
    <pubDate>Mon, 02 Mar 2020 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/february-2020/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter January 2020</title>
    <link>http://rickardlindberg.me/writing/newsletter/january-2020/</link>
    <description><![CDATA[<h1>Newsletter January 2020</h1>

<p><em>Published on  3 February 2020.</em></p>

<p>This is what I’ve been up to in January 2020:</p>
<ul>
<li><p>I finished the article about <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures in RLMeta</a>.</p></li>
<li><p>I came across <a href="https://github.com/DoctorWkt/acwj">A Compiler Writing Journey</a>. It inspired me to write articles that explain things that I’m interested in.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">“Hello, world” from scratch on a 6502 — Part 1</a>. Low level hardware is fun.</p></li>
<li><p>I continued with <a href="/projects/rliterate/book2/index.html">RLiterate</a> and made great <a href="/projects/rliterate/book2/index.html#bdeda63252d440c3b3394c34671a9107">progress</a>. I’m now confident that the new architecture will work. Now it’s just a matter of fleshing out the rest of the application until it can edit itself.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=bnqkglrSqrg&amp;t=2281s">Sean McDirmid - The Future of Programming will be Live - Curry On</a>. It made me think about introducing “Live examples” in RLiterate. If I have a function I want to add an example paragraph that executes that function and be able to modify its parameters interactively. Sort of like an interactive test case to explore input/output.</p></li>
<li><p>I read about <a href="https://redux.js.org/">Redux</a> <a href="https://github.com/pshrmn/notes/blob/master/redux/redux.md">here</a> and <a href="https://randycoulman.com/blog/2016/11/22/taking-advantage-of-combinereducers/">here</a>. Its architecture can be an inspiration for how to handle state in RLiterate.</p></li>
</ul>
]]></description>
    <pubDate>Mon, 03 Feb 2020 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/january-2020/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter December 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/december-2019/</link>
    <description><![CDATA[<h1>Newsletter December 2019</h1>

<p><em>Published on  5 January 2020.</em></p>

<p>This is what I’ve been up to in December 2019:</p>
<ul>
<li><p>I read <a href="https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71/">WebAssembly: How and why</a> and watched <a href="https://www.youtube.com/watch?v=CMB6AlE1QuI">Rust, WebAssembly, and the future of Serverless by Steve Klabnik</a>. WebAssembly might be an interesting compilation target to experiment with.</p></li>
<li><p>I read <a href="https://michaelfeathers.silvrback.com/toward-a-galvanizing-definition-of-technical-debt">Toward a Galvanizing Definition of Technical Debt</a>. I found his definition of technical debt useful.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=r-TLSBdHe1A&amp;feature=emb_logo">“Performance Matters” by Emery Berger</a>. Low level details are interesting some times.</p></li>
<li><p>I read <a href="https://chelseatroy.com/2019/12/18/reviewing-pull-requests/">Reviewing Pull Requests</a>. I like the idea that more work is put on the reviewer and that the reviewer can also push fixes to the pull request. It reminds me of the <a href="https://rfc.unprotocols.org/spec:1/C4/">C4 process</a> where every patch is almost always immediately accepted. If anyone has comments on it, it is solved by creating another patch.</p></li>
<li><p>I read <a href="https://alexnixon.github.io/2019/12/10/writing.html">It’s time to start writing</a>. It inspired me to write more to think more clearly.</p></li>
<li><p>I read <a href="https://pavelfatin.com/typing-with-pleasure/">Typing with pleasure</a> and also watched the linked video <a href="https://www.youtube.com/watch?v=vOvQCPLkPt4">Applied Sciences Group: High Performance Touch</a>. This topic is relevant for RLiterate.</p></li>
</ul>
]]></description>
    <pubDate>Sun, 05 Jan 2020 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/december-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter November 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/november-2019/</link>
    <description><![CDATA[<h1>Newsletter November 2019</h1>

<p><em>Published on  3 December 2019.</em></p>

<p>This is what I’ve been up to in November 2019:</p>
<ul>
<li><p>I continued working on RLiterate. You can see the progress <a href="/projects/rliterate/book2/index.html#359aefc7fbb54cb4b8e43182efb241a0">here</a>.</p>
<ul>
<li><p>When implementing the text wrap algorithm, it was helpful to be able to change the page width interactively by mouse drag. It gave me quick feedback on the algorithm.</p></li>
<li><p>I fleshed out more parts of the application, and the new architecture seems to scale for what I need. There are still details to figure out, but overall I’m quite pleased.</p></li>
</ul></li>
<li><p>I watched <a href="https://channel9.msdn.com/Blogs/Seth-Juarez/Anders-Hejlsberg-on-Modern-Compiler-Construction">Anders Hejlsberg on Modern Compiler Construction</a>. The compiler he describes feels similar to how RLiterate operate in the sense that every time an even happens, the whole state is re-created. But some parts are cached. It also sparked the idea that RLiterate can use a “language server” to provide a better IDE experience.</p></li>
</ul>
]]></description>
    <pubDate>Tue, 03 Dec 2019 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/november-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter October 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/october-2019/</link>
    <description><![CDATA[<h1>Newsletter October 2019</h1>

<p><em>Published on  2 November 2019.</em></p>

<p>This is what I’ve been up to in October 2019:</p>
<ul>
<li><p>I read <a href="http://users.ece.cmu.edu/~koopman/stack_computers/">Stack Computers: the new wave</a> by Philip J. Koopman, Jr. I did not dig into details about the different computers, but the rest of the book gave me a good understanding stack computers.</p></li>
<li><p>I thought about how stack computers could support programming language features. In particular, I though about how they could support local variables. A calling convention could be used where function parameters are always put on the stack. If a function wants to, it can store those in a frame for later reference. But it does not have to. The compiler might also optimize away local variables in favor of pure stack operations.</p></li>
<li><p>I continued working on <a href="/writing/expr-to-x86-compiler/index.html">compiling expressions to x86 machine code</a>. I did debugging with gdb and learned some useful commands. I managed to compile a subset of expressions down to x86 machine code. It was satisfying. I was helped by <a href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-4-in-python/">Adventures in JIT compilation: Part 4 - in Python</a>.</p></li>
<li><p>I got an urge to do a rewrite of <a href="/projects/rliterate/index.html">RLiterate</a> to improve performance and fix bugs that make it annoying to use. I use RLiterate to write articles for my blog. I really like the features of it, but the poor performance makes it annoying to use. I had though of a slightly different architecture that would mitigate those problems. But it would require a complete rewrite. I have now successfully validated that the new architecture works better and I will continue to build the next version. You can see it <a href="/projects/rliterate/book2/index.html">here</a>.</p></li>
<li><p>I worked on RLiterate in small chunks. First I did some work and published that version on my homepage. Then at a later time I did review of what I had done. Then I went through and fixed comments from review. This workflow has worked quite well. Having time between the two activities has allowed me to rest and reflect.</p></li>
<li><p>Because I got distracted with RLiterate, I did not make progress on the article about <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures in RLMeta</a> that I said I would hoped have finished by now. I have not abandoned my drafts though. Something more interesting got in between. I will get back to writing at some point.</p></li>
</ul>
]]></description>
    <pubDate>Sat, 02 Nov 2019 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/october-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter September 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/september-2019/</link>
    <description><![CDATA[<h1>Newsletter September 2019</h1>

<p><em>Published on  1 October 2019.</em></p>

<p>This is what I’ve been up to in September 2019:</p>
<ul>
<li><p>I finished the article on <a href="/writing/rlmeta-left-associativity/index.html">parsing left associative operators in RLMeta</a>. I’m pleased with how it turned out.</p></li>
<li><p>I played with <a href="https://cython.org/">Cython</a> to see if RLMeta VM could be made faster if converted to a C extension module. (It could!) I might write a blog post about it.</p></li>
<li><p>I learned more about Python C extension modules from <a href="https://thomasnyberg.com/what_are_extension_modules.html">What are (c)python extension modules?</a>.</p></li>
<li><p>I watched <a href="https://cacm.acm.org/magazines/2018/11/232214-a-look-at-the-design-of-lua/fulltext">A Look at the Design of Lua</a>. I was inspired by the setting in which it seems to have been created. Small office. Whiteboard. Collaboration. I want to implement a minimal OOP-language in order to learn how to do it.</p></li>
<li><p>I finished porting <a href="/projects/timeline/index.html">Timeline</a> to Python 3.</p>
<ul>
<li><p>The most difficult part was to verify that division operations were still working the same. (Python 3 integer division gives float instead of integer as in Python 2.)</p></li>
<li><p>I concluded that maintaining software is hard work. Even if your program does not change, the external world changes, and you need to change your program accordingly.</p></li>
<li><p>I finished the article on the <a href="/writing/timeline-segfault-wxpython/index.html">segfault failure</a> that I found during porting.</p></li>
</ul></li>
<li><p>I learned about a trick help me get started on a task faster: leave work undone. Leave a test failing. Leave a sentence half written.</p></li>
<li><p>I learned that your number one priority is not what you write on top of the TODO list, but what you actually do.</p></li>
<li><p>I finished a post with my <a href="/writing/alan-kay-notes/index.html">notes on Alan Kay</a>. He is a big inspiration to me.</p></li>
<li><p>I read most parts of <a href="https://paulcavallaro.com/blog/common-systems-programming-optimizations-tricks/">Common Systems Programming Optimizations &amp; Tricks</a>. Low level optimizations are interesting. It reminded me of Bob Nystrom’s <a href="http://gameprogrammingpatterns.com/">game programming book</a> that discusses some <a href="http://gameprogrammingpatterns.com/optimization-patterns.html">similar topics</a>.</p></li>
<li><p>I continued with the article about <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures in RLMeta</a>. It is almost finished, but because I got distracted by other work, it is not. I hope to finish it next month.</p></li>
<li><p>I started working on <a href="/writing/expr-to-x86-compiler/index.html">compiling expressions to x86 machine code</a>:</p>
<ul>
<li><p>I don’t really know assembly, so I found <a href="https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming">A fundamental introduction to x86 assembly programming</a> useful.</p></li>
<li><p>I got segafults because of 32/64-bit mixup. It just shows that I don’t really know what I’m doing yet.</p></li>
<li><p>I learned that <code>add</code> and <code>imul</code> instructions do not work the same. <code>imul</code> can not store result back in memory but must go via register.</p></li>
<li><p>I learned that I subtracted operands in the wrong order.</p></li>
<li><p>I read <a href="https://csl.name/post/python-jit/">Writing a basic x86-64 JIT compiler from scratch in stock Python</a>.</p></li>
<li><p>I read <a href="https://csl.name/post/python-compiler/">JIT compiling a subset of Python to x86-64</a>.</p></li>
</ul></li>
</ul>
]]></description>
    <pubDate>Tue, 01 Oct 2019 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/september-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter August 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/august-2019/</link>
    <description><![CDATA[<h1>Newsletter August 2019</h1>

<p><em>Published on 31 August 2019.</em></p>

<p>This is what I’ve been up to in August 2019:</p>
<ul>
<li><p>I finished the <a href="/writing/rlmeta-vm/index.html">RLMeta VM</a> article. When working on it, I noticed that error handling has not gotten much love. I want to improve it and write about it in another article.</p></li>
<li><p>I found <a href="https://viewsourcecode.org/snaptoken/kilo/index.html">Build Your Own Text Editor</a> that explains how to build a text editor by showing and explaining incremental patches. I found the approach interesting.</p>
<ul>
<li><p>This approach feels similar to what is described in <a href="http://akkartik.name/post/literate-programming">Literate programming: Knuth is doing it wrong</a> and <a href="http://akkartik.name/post/wart-layers">A new way to organize programs</a>.</p></li>
<li><p>The above made me think about if programs could be organized in features without the use of literate programming. That would require some kind of plugin architechture where features could be plugged in independent of eachother.</p></li>
</ul></li>
<li><p>I read Guido van Rossum’s article on <a href="https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9">Generating a PEG Parser</a>. This made me realize that RLMeta does not memoize correctly. I’m working on an <a href="/writing/rlmeta-memoize-failures/index.html">article</a> where I fix it.</p></li>
<li><p>I worked on porting <a href="/projects/timeline/index.html">Timeline</a> to Python 3. It is a work in progress, but the application now starts. I have a few items left on my TODO list that I want to complete before considering the port done. I ran into a problem that I <a href="/writing/timeline-doctest-wxpython/index.html">blogged about</a>. An another one <a href="/writing/timeline-segfault-wxpython/index.html">in progress</a>.</p></li>
<li><p>I found <a href="https://twitter.com/mfeathers/status/1159495761714769921">this tweet</a> by Michael Feathers interesting:</p>
<blockquote>
<p>Fred Brooks said that software is best when it looks like it was designed by one mind.</p>
<p>Mob programming is an attempt to create one mind of many.</p>
<p>Quality goes down as the number of people touching code independently goes up.</p>
<p>Interesting constraint problem.</p>
</blockquote>
<p>And a <a href="https://twitter.com/raganwald/status/1159498133635850240">follow up</a>:</p>
<blockquote>
<p>Interesting parallel to Alan Kay’s bifurcation of languages into “Agglutination of features” vs. “Crystallization of style.”</p>
<p>The former are almost always defined by committee, the latter by solo designers or very small, tight teams.</p>
</blockquote>
<p>And another <a href="https://twitter.com/jit_j/status/1159501352243998720">follow up</a>:</p>
<blockquote>
<p>There are quality OSS projects that are made up of individual contributors and a distributed review process. It’s possible for independent workers to maintain and extend a codebase, as long as they buy into a shared style and a shared philosophy. Process matters though.</p>
</blockquote>
<p>How can we build software so that it appears to be desgined by a single mind?</p></li>
<li><p>I wrote some code for an <a href="/writing/rlmeta-left-associativity/index.html">upcoming article</a> on parsing left associative operators in RLMeta.</p></li>
<li><p>I read some of Eli Bendersky’s articles on parsing:</p>
<ul>
<li><p><a href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers">Recursive descent, LL and predictive parsers</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">Some problems of recursive descent parsers</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator">A recursive descent parser with an infix expression evaluator</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing">Top-Down operator precedence parsing</a></p></li>
<li><p><a href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing">Parsing expressions by precedence climbing</a></p></li>
</ul></li>
<li><p>One of them led me to read Bob Nystrom’s article <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">Pratt Parsers: Expression Parsing Made Easy</a>.</p></li>
<li><p>I want to learn more about JIT compilation. As I read <a href="http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html">Hello, JIT World: The Joy of Simple JITs</a> describing a JIT compiler for Brainfuck I thought: Is JIT-ing byte code just getting rid of the interpreter loop? I’m not completely sure of the big picture yet. And how does a tracing JIT compiler differ from a regular JIT compiler. Brainfuck seems to be a popular example in JIT articles.</p></li>
<li><p>I read about Cython and though that I should try it for RLMeta VM. Should be quite easy to port it to C and make incremental performance improvements.</p></li>
</ul>
]]></description>
    <pubDate>Sat, 31 Aug 2019 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/august-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter July 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/july-2019/</link>
    <description><![CDATA[<h1>Newsletter July 2019</h1>

<p><em>Published on 31 July 2019.</em></p>

<p>This is what I’ve been up to in July 2019:</p>
<ul>
<li><p>I continued work on the RLMeta VM post.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=oww7oB9rjgw">Steal Like An Artist: Austin Kleon at TEDxKC</a>. Main takeway was that every work is a mashup. Steal from others and show your mashup so that we can steal from you.</p></li>
<li><p>I reread parts of <em>The Art of Explanation</em> by Lee LeFever. He presents a way to explain things so that people understand. I will try to be inspired by this way when writing.</p></li>
<li><p>I thought about converting all posts on this site to “blog posts” and putting them under <code>rickardlindberg.me/blog/</code> and using tags for categories. Then allowing tags to also have explanations. Not sure if this structure is better or not.</p></li>
<li><p>I read parts of <em>Hackers and Painters</em> by Paul Graham. A few quotes that I liked:</p>
<blockquote>
<p>Programming languages are what programmers think in. Naturally, this has a big effect on the kind of thoughts they have.</p>
</blockquote>
<p>I fully agree with this, and this is one of the reasons I want to learn more about language design so that I can design ideal languages for problems.</p>
<blockquote>
<p>After a certain age, programmers rarely switch languages voluntarily. Whatever language people happen to be used to, they tend to consider just good enough.</p>
</blockquote>
<p>I don’t want to get stuck in a language. How can I avoid it?</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=ymiBDged-eQ">How to Start a Business or Podcast From Scratch | Tim Ferriss</a>. Main takeway was that it is easier to create a new category by finding a niche market to fill. Filling demand (in a new category) is easier than creating demand (in an existing category).</p></li>
<li><p>I started reading <em>The 22 Immutable Laws of Marketing</em> by Al Ries because it was recommended by Tim in the above video. Some quotes:</p>
<blockquote>
<p>The easy answer is to make sure your programs are in tune with the laws of marketing.</p>
</blockquote>
<blockquote>
<p>There are laws of nature, so why shouldn’t there be laws of marketing? You can build a great-looking airplane, but it’s not going to get off the ground unless it adheres to the laws of physics, especially the law of gravity. You can build an architectural masterpiece on a sand dune, but the first hurricane will undermine your creation. So it follows that you can build a brilliant marketing program only to have one of the immutable laws knock you flat if you don’t know what they are.</p>
</blockquote></li>
<li><p>I read about an incremental approach to compiler construction <a href="http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf">here</a>, <a href="https://generalproblem.net/">here</a>, and <a href="https://blog.sigplan.org/2019/07/09/my-first-fifteen-compilers/">here</a>. The incremental approach starts with a small language (just integers) and builds upon that. At each stage, there is a working compiler. I want to explore this approach more. Can such a compiler be written with <a href="/tags/rlmeta/index.html">RLMeta</a>?</p></li>
<li><p>I write articles about RLMeta in a literate programming style. Sometimes I think: Why is all this text needed? The code speaks for itself, right? Probably it doesn’t, but it is interesting to try to find the right balance.</p></li>
<li><p>I read <a href="https://medium.com/@gvanrossum_83706/peg-parsers-7ed72462f97c">PEG Parsers</a> by Guido van Rossum. He is experimenting with replacing Python’s parser with a PEG-version.</p></li>
<li><p>I found <a href="https://www.rascal-mpl.org/">Rascal - Metaprogramming Language</a>. I want to read more about it, but here is a good summary:</p>
<blockquote>
<p>You want to use the best tool for the job when analyzing, transforming or generating source code, so normally you will end up with many different tools, possibly even written in different languages. Now the problem is to integrate these tools again. Rascal solves this problem by integrating source code analysis, transformation, and generation primitives on the language level. Use it for any kind of metaprogramming task: to construct parsers for programming languages, to analyze and transform source code, or to define new DSLs with full IDE support.</p>
</blockquote></li>
<li><p>I read <a href="http://www.bbc.com/future/story/20190722-the-apple-software-that-inspired-the-internet">The forgotten software that inspired our modern world</a>. A quote I liked:</p>
<blockquote>
<p>But even more than that, HyperCard didn’t compromise between the easily usable and the creatively powerful.</p>
</blockquote>
<p>Something in that reminds me of what Alan Kay said. Something about simplifying but not dumbing down when teaching children.</p></li>
<li><p>I read <a href="https://technicalblogging.com/blogging-income-how-bloggers-make-money/">The Inverted Pyramid of Blogging Income: How Pro Bloggers Make Money</a>. Main takeaway was that if you want to make money blogging, you should convert readers into customers and you must therefore also have another product to sell.</p></li>
</ul>
]]></description>
    <pubDate>Wed, 31 Jul 2019 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/july-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>Newsletter June 2019</title>
    <link>http://rickardlindberg.me/writing/newsletter/june-2019/</link>
    <description><![CDATA[<h1>Newsletter June 2019</h1>

<p><em>Published on 30 June 2019.</em></p>

<p>This is what I’ve been up to in June 2019:</p>
<ul>
<li><p>I was inspired to try writing a journal after stumbling across Derek Siver’s blog post <a href="https://sivers.org/dj">Benefits of a daily diary and topic journals</a>. The idea is to write for my future self to help me solve problems by recording my thoughts and reflecting on them.</p></li>
<li><p>I read <em>Poke the Box</em> by Seth Godin. My main takeaway was that <strong>initiative is scarce</strong>, and if you take initiative, you are valuable.</p></li>
<li><p>I read <a href="https://compilerbook.com/">Writing A Compiler In Go</a> by Thorsten Ball. It is a topic that interests me. I learned about designing virtual machines.</p></li>
<li><p>I learned a technique for parsing offside rule languages with PEG parsers via <a href="https://github.com/jgm/peg-markdown/">A PEG Markdown parser</a>. I plan to write a blog post about this technique.</p></li>
<li><p>I read <em>Show Your Work!</em> by Austin Kleon. Some takeaways:</p>
<ul>
<li><p>An amateur is sometimes better at explaining something than an expert because the amateur has recently encountered it and knows what is hard. An expert has forgotten. Therefore <strong>blogging about problems and solutions when I encounter them is useful</strong>.</p></li>
<li><p>It is useful to share the process of creating something, not just the finished work.</p></li>
<li><p>It inspired me to publish draft posts on this blog.</p></li>
<li><p>It inspired me to write these monthly newsletters.</p></li>
</ul></li>
<li><p>I finished writing <a href="/writing/optimizing-rlmeta/index.html">Optimizing RLMeta</a>. I struggled with grammar and usage (should I use past or present, active or passive, we or I, and so on). I read other articles to try to analyze what they did. But I also came to one important realization: if I find it hard to write, I can read what I’ve written, find something small to fix, and then I’m suddenly writing again. I will keep writing and hopefully keep improving.</p></li>
<li><p>I have tried to get into the habit of writing a bit at least every day. Even though some days I produced almost nothing, I kept doing it. Eventually it payed off, but sometimes I felt like I needed a longer session to get something useful done. Often times, short sessions worked as well. One thing that helped me continue was to take a note at the end of a session what to proceed with.</p></li>
<li><p>I read parts of <a href="https://beautifulracket.com/">Beautiful Racket</a>. Racket is a programming language designed for language-oriented programming. I have for a long time felt that this is a better way to program, but never fully put it into practice. I even started writing <a href="https://leanpub.com/ldd">a book</a> about it. I intend to continue pursuing this way of programming with the help of <a href="/tags/rlmeta/index.html">RLMeta</a>. I will most likely return to <em>Beautiful Racket</em>.</p></li>
<li><p>I read <em>4-Hour Work Week</em> by Timothy Ferris. Some takeaways:</p>
<ul>
<li><p>Unrealistic goals as easier to achieve because the competition is not as fierce.</p></li>
<li><p>80/20 rule. I can stop doing 80% of what I’m doing and still perform as well.</p></li>
<li><p>Batching work is sometimes more effective. Limit Twitter/Email/etc to once/twice a day to not be bothered with it the rest of the time.</p></li>
<li><p>If I did not have to work for money, what would I do? If this is the last day of my life, would I do what I’m doing?</p></li>
<li><blockquote>
<p>First, “expert” in the context of selling product means that you know more about the topic than the purchaser. No more.</p>
</blockquote></li>
</ul></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=o_ptYjf8Bes">(sixth RacketCon): Matthew Butterick – The Making of “Beautiful Racket”</a>. My main takeaway was that a DSL has two parts: the domain and the programming language. And the most important part is the domain. In order to create a good DLS you need to have much knowledge about the domain.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=eWJVvNptHZ4">Arnold Schwarzenegger 2019 - The speech that broke the internet - Motivational &amp; Inspiring</a>. In it he says that you should work hard and advertise. This felt similar to Austin Kleon’s advice that you should show your work.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=8J6HuvosP0s">Typography for Docs</a>. This is also by Matthew Butterick. I like this talk as well. It inspired me to try to improve typography on my blog. We’ll see if I get around to it.</p></li>
<li><p>I read <a href="https://m00natic.github.io/lisp/manual-jit.html">Uniform Structured Syntax, Metaprogramming and Run-time Compilation</a>. My main takeaway was that compilation happens at runtime. Just in time. Therefore the compiler must be shipped with the runtime. Common Lisp has hooks for different times during compilation: reader macro, macro, etc.</p></li>
<li><p>I watched <a href="https://www.youtube.com/watch?v=viF1bVTOO6k">Steady Typing</a>. It shows a projectional editor. Those interest me. They are one inspiration for <a href="/projects/rliterate/index.html">RLiterate</a>.</p></li>
</ul>
]]></description>
    <pubDate>Sun, 30 Jun 2019 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/newsletter/june-2019/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>

    </channel>
</rss>
