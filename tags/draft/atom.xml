<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Rickard's personal homepage: latest posts tagged draft</title>
    <link href="http://rickardlindberg.me/tags/draft/atom.xml" rel="self" />
    <link href="http://rickardlindberg.me" />
    <id>http://rickardlindberg.me/tags/draft/atom.xml</id>
    <author>
        <name>Rickard Lindberg</name>
        <email>rickard@rickardlindberg.me</email>
    </author>
    <updated>2024-04-04T00:00:00Z</updated>
    <entry>
    <title>DRAFT: 'What is a user story?'</title>
    <link href="http://rickardlindberg.me/writing/what-is-a-user-story/" />
    <id>http://rickardlindberg.me/writing/what-is-a-user-story/</id>
    <published>2024-04-04T00:00:00Z</published>
    <updated>2024-04-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>DRAFT: 'What is a user story?'</h1>

<p><em>Published on  4 April 2024.</em></p>

<p><strong>This is a work in progress that will change. Like to see it finished? Let me know by sending me an email.</strong></p>
<p>I’ve been on a quest to learn “real agile”. Before I researched <a href="/writing/what-should-a-ci-server-do/index.html">CI</a>. Now its time for user stories.</p>
<h2 id="todo">TODO</h2>
<p>https://ronjeffries.com/articles/-y023/python/-w030/038/</p>
<p>What people say a story is:</p>
<p>…</p>
<p>“Do you put backlog refinement on the backlog?”</p>
<p>XP: “Write stories about improving your software development process. What is your budget for improvement?”</p>
<p>…</p>
<p>What value? To whom?</p>
<p>…</p>
<p>Ron: “What kinds of value does your project deliver to its users? To your organization? To the team? What value does it deliver to you?”</p>
<p>Information has value. (Spike solution.)</p>
<p>…</p>
<p>Acceptance test: when is a story done?</p>
<p>…</p>
<p>Adding features/capabilities to product needs story? Refacotring does not add any ability? Testing neither. Both increase quality, but not capability.</p>
<p>…</p>
<p>Example: SSL certs</p>
<p>Example: Testing</p>
<p>Example: Moving hosting provider</p>
<p>…</p>
<p>AI chronicels: stories show progress towards a larger goal.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>...</span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>DRAFT: Compiling expressions to x86 machine code</title>
    <link href="http://rickardlindberg.me/writing/expr-to-x86-compiler/" />
    <id>http://rickardlindberg.me/writing/expr-to-x86-compiler/</id>
    <published>2020-05-20T00:00:00Z</published>
    <updated>2020-05-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>DRAFT: Compiling expressions to x86 machine code</h1>

<p><em>Published on 20 May 2020.</em></p>

<p><strong>This is a work in progress that will change. Like to see it finished? Let me know by sending me an email.</strong></p>
<p>In <a href="/writing/rlmeta-left-associativity/index.html">Parsing left associative operators using RLMeta</a> we looked at how to parse a subset of mathematical expressions. In this article we will take it further and compile such expressions to x86 machine code. Thus creating a real compiler for expressions.</p>
<ul>
<li><a href="#969c195716e94c05ad23bd50f7dc061a">Overview</a></li>
<li><a href="#a83adf407dbd43929bfbb4ab7f7311e5">Parser</a></li>
<li><a href="#0488143f851349bf876169b04770e6bf">Abstract code generator</a></li>
<li><a href="#bb76bbbba48d4c23b982e5c90af36d86">X86 code generator</a></li>
<li><a href="#12e4e39c6b494b30a425f4570e8b8d53">GAS generator</a></li>
<li><a href="#d3ece5a4ba484033ac47d9190e513acd">Assembler</a></li>
<li><a href="#a047c1b417bc42799170c0e3632cc3f9">Appendix: All source code</a></li>
<li><a href="#ff74bacb76bf40f082f88738ebc5d8b0">Appendix: RLMeta</a></li>
<li><a href="#7790eca23f484ea7b7430ef607b491c2">Appendix: Test script</a></li>
</ul>
<h2 id="c195716e94c05ad23bd50f7dc061aoverview">[]{#969c195716e94c05ad23bd50f7dc061a}Overview</h2>
<p>The compiler is implemented by transforming an expression in different stages.</p>
<pre class="text"><code>Parser -&gt; Abstract codegen -&gt; X86 codegen -&gt; GAS
                                          -&gt; Assembler</code></pre>
<p>The parser turns an expression into an AST, which the abstract code generator turns it into instructions for an imaginary stack machine, which the X86 code generator turns into assembly instructions for the x86 architecture. The final stage either turns those instructions into textual assembly instructions suitable for compilation with the GNU assembler (GAS) or assembles them straight into machine code.</p>
<p>The style of this article is inspired by <a href="http://www.vpri.org/pdf/m2009011_chns_mng.pdf">Chains of meaning in the STEPS system</a> (<a href="http://rickardlindberg.me/writing/alan-kay-notes/m2009011_chns_mng.pdf">mirror</a>) where a compiler is explained by explaining all stages in it. Examples are shown throughout what the input and output of the different stages are.</p>
<h2 id="parser"><span id="a83adf407dbd43929bfbb4ab7f7311e5"></span>Parser</h2>
<p>The parser is the same as in the previous article. It turns an expression into an AST:</p>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; parseOps(x xs)
  digit = &#39;0&#39;-&#39;9&#39;:x                           -&gt; int(x)
  op    =
    | &#39;+&#39; -&gt; Op(makeAstNode(&quot;ADD&quot;) 1 &quot;left&quot;)
    | &#39;-&#39; -&gt; Op(makeAstNode(&quot;SUB&quot;) 1 &quot;left&quot;)
    | &#39;*&#39; -&gt; Op(makeAstNode(&quot;MUL&quot;) 2 &quot;left&quot;)
    | &#39;/&#39; -&gt; Op(makeAstNode(&quot;DIV&quot;) 2 &quot;left&quot;)
    | &#39;^&#39; -&gt; Op(makeAstNode(&quot;POW&quot;) 3 &quot;right&quot;)
}</code></pre>
<p>The support functions are also defined similarly:</p>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> Op(<span class="bu">object</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn, prec, assoc):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        <span class="va">self</span>.prec <span class="op">=</span> prec</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        <span class="va">self</span>.assoc <span class="op">=</span> assoc</span></code></pre></div>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">def</span> makeAstNode(name):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="kw">def</span> op(left, right):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>        <span class="cf">return</span> [name, left, right]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="cf">return</span> op</span></code></pre></div>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">def</span> parseOps(expr, items, min_level<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="cf">while</span> items <span class="kw">and</span> items[<span class="dv">0</span>][<span class="dv">0</span>].prec <span class="op">&gt;=</span> min_level:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="cf">if</span> op.assoc <span class="op">==</span> <span class="st">&quot;left&quot;</span>:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>            next_level <span class="op">=</span> op.prec <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>            next_level <span class="op">=</span> op.prec</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        expr <span class="op">=</span> op.fn(expr, parseOps(rhs, items, next_level))</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>Parsing the simple expression</p>
<pre class="text"><code>3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>3

=V========== Parser ============

3</code></pre>
<p>Parsing the slightly more complicated expression</p>
<pre class="text"><code>1+2*3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>1+2*3

=V========== Parser ============

[&#39;ADD&#39;,
 1,
 [&#39;MUL&#39;, 2, 3]]</code></pre>
<h2 id="f851349bf876169b04770e6bfabstract-code-generator">[]{#0488143f851349bf876169b04770e6bf}Abstract code generator</h2>
<p>The abstract code generator turns an AST into instructions for an imaginary stack machine:</p>
<pre><code>1.  abstractcodegen.rlmeta</code></pre>
<pre class="rlmeta"><code>AbstractCodeGen {
  expr =
    | [.:name expr:left expr:right] -&gt; [~right ~left name]
    | .:leaf                        -&gt; [&quot;PUSH&quot; leaf]
}</code></pre>
<p>The right hand side of an expression is generated before the left hand side. This order does not matter, but it turns out that it's a bit easier to generate x86 instructions if the right hand side comes first.</p>
<p>Generating stack machine instructions for the simple expression</p>
<pre class="text"><code>3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>3

=V========== Parser ============

3

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;, 3]</code></pre>
<p>Generating stack machine instructions for the slightly more complicated expression</p>
<pre class="text"><code>1+2*3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>1+2*3

=V========== Parser ============

[&#39;ADD&#39;,
 1,
 [&#39;MUL&#39;, 2, 3]]

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;,
 3,
 &#39;PUSH&#39;,
 2,
 &#39;MUL&#39;,
 &#39;PUSH&#39;,
 1,
 &#39;ADD&#39;]</code></pre>
<h2 id="x86-code-generator"><span id="bb76bbbba48d4c23b982e5c90af36d86"></span>X86 code generator</h2>
<p>The X86 code generator turns instructions for the imaginary stack machine into assembly instructions for the x86 architecture.</p>
<p>An assembly instruction is represented as a list with its mnemonic and operands:</p>
<pre class="text"><code>[&quot;mnemonic&quot; op1 op2 ..]</code></pre>
<p>For an instruction performing a binary operation, <code>op1</code> is the destination and <code>op2</code> is the source. The binary operation performed is therefore the following:</p>
<pre class="text"><code>op1 = op1 `operation` op2</code></pre>
<p>An operand can be either a constant, a register, or a memory location.</p>
<ul>
<li><code>rdi</code> is the stack pointer where the stack grows downwards (64-bit integer)</li>
<li><code>eax</code> is a TOS (top of stack) register (32-bit signed integer)</li>
<li>We are generating a function according to x64 calling conventions.</li>
</ul>
<p><strong>TODO: explain what registers and so on that we use</strong></p>
<pre><code>1.  x86codegen.rlmeta</code></pre>
<pre class="rlmeta"><code>X86CodeGen {
  expr = [%*:xs] -&gt; [~~xs [&quot;ret&quot;]]
  &lt;&lt;instructions&gt;&gt;
}</code></pre>
<pre><code>1.  x86codegen.rlmeta
2.  [instructions]{.cp}</code></pre>
<pre class="rlmeta"><code>ADD = -&gt; [
  [&quot;add&quot; [&quot;reg&quot; &quot;eax&quot;] [&quot;addr&quot; &quot;rdi&quot;]]
  [&quot;sub&quot; [&quot;reg&quot; &quot;rdi&quot;] [&quot;const&quot; 4   ]]
]</code></pre>
<pre><code>1.  x86codegen.rlmeta
2.  [instructions]{.cp}</code></pre>
<pre class="rlmeta"><code>SUB = -&gt; [
  [&quot;sub&quot; [&quot;reg&quot; &quot;eax&quot;] [&quot;addr&quot; &quot;rdi&quot;]]
  [&quot;sub&quot; [&quot;reg&quot; &quot;rdi&quot;] [&quot;const&quot; 4   ]]
]</code></pre>
<pre><code>1.  x86codegen.rlmeta
2.  [instructions]{.cp}</code></pre>
<pre class="rlmeta"><code>MUL = -&gt; [
  [&quot;imul&quot; [&quot;reg&quot; &quot;eax&quot;] [&quot;addr&quot; &quot;rdi&quot;]]
  [&quot;sub&quot;  [&quot;reg&quot; &quot;rdi&quot;] [&quot;const&quot; 4   ]]
]</code></pre>
<pre><code>1.  x86codegen.rlmeta
2.  [instructions]{.cp}</code></pre>
<pre class="rlmeta"><code>DIV = -&gt; [
  [&quot;cdq&quot;                                   ]
  [&quot;idiv&quot; &quot;long&quot; [&quot;addr&quot; &quot;rdi&quot;]            ]
  [&quot;sub&quot;         [&quot;reg&quot;  &quot;rdi&quot;] [&quot;const&quot; 4]]
]</code></pre>
<pre><code>1.  x86codegen.rlmeta
2.  [instructions]{.cp}</code></pre>
<pre class="rlmeta"><code>POW = -&gt; [
]</code></pre>
<pre><code>1.  x86codegen.rlmeta
2.  [instructions]{.cp}</code></pre>
<pre class="rlmeta"><code>PUSH = .:x -&gt; [
  [&quot;add&quot; [&quot;reg&quot;  &quot;rdi&quot;] [&quot;const&quot; 4    ]]
  [&quot;mov&quot; [&quot;addr&quot; &quot;rdi&quot;] [&quot;reg&quot;   &quot;eax&quot;]]
  [&quot;mov&quot; [&quot;reg&quot;  &quot;eax&quot;] [&quot;const&quot; x    ]]
]</code></pre>
<p>Generating assembly instructions for the simple expression</p>
<pre class="text"><code>3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>3

=V========== Parser ============

3

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;, 3]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;ret&#39;]]</code></pre>
<p>Generating assembly instructions for the slightly more complicated expression</p>
<pre class="text"><code>1+2*3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>1+2*3

=V========== Parser ============

[&#39;ADD&#39;,
 1,
 [&#39;MUL&#39;, 2, 3]]

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;,
 3,
 &#39;PUSH&#39;,
 2,
 &#39;MUL&#39;,
 &#39;PUSH&#39;,
 1,
 &#39;ADD&#39;]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;imul&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 1]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;ret&#39;]]</code></pre>
<h2 id="e4e39c6b494b30a425f4570e8b8d53gas-generator">[]{#12e4e39c6b494b30a425f4570e8b8d53}GAS generator</h2>
<p>The GAS generator turns assembly instructions into textual assembly instructions suitable for compilation with the GNU assembler (GAS): <code>gcc -nostdlib file.s</code>:</p>
<pre><code>1.  gas.rlmeta</code></pre>
<pre class="rlmeta"><code>GasGen {
  expr = [instr*:xs] -&gt; {
    &quot;.global expr\n&quot;
    &quot;expr:\n&quot;
    xs
  }
  instr =
    | [mnemonic:x op:target op:source] -&gt; { x &quot;  &quot; source &quot;,&quot; target &quot;\n&quot; }
    | [mnemonic:x op:arg]              -&gt; { x &quot;  &quot; arg &quot;\n&quot; }
    | [mnemonic:x]                     -&gt; { x &quot;\n&quot; }
  op =
    | [&quot;reg&quot;    .:name] -&gt; { &quot;%&quot; name      }
    | [&quot;addr&quot;   .:name] -&gt; { &quot;(%&quot; name &quot;)&quot; }
    | [&quot;const&quot; .:value] -&gt; { &quot;$&quot; value     }
  mnemonic = .:x size:y -&gt; pad(x y)
  size = &quot;long&quot; -&gt; &quot;l&quot; | -&gt; &quot;&quot;
}</code></pre>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="kw">def</span> pad(text, suffix):</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>    <span class="cf">return</span> (text<span class="op">+</span>suffix).ljust(<span class="dv">7</span>)</span></code></pre></div>
<pre><code>1.  driver.c</code></pre>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a><span class="dt">int</span> expr(<span class="dt">void</span>* mem);</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a>    <span class="dt">void</span>* mem = (<span class="dt">void</span>*)malloc(<span class="dv">32</span>*<span class="kw">sizeof</span>(<span class="dt">int</span>));</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a>    <span class="dt">int</span> result = expr(mem);</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a>    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, result);</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>Generating GAS instructions (and compiling and running them) for the simple expression</p>
<pre class="text"><code>3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>3

=V========== Parser ============

3

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;, 3]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;ret&#39;]]

=V========== GasGen ============

.global expr
expr:
add      $4,%rdi
mov      %eax,(%rdi)
mov      $3,%eax
ret

=V===== GccCompileAndRun =======

3</code></pre>
<p>Generating GAS instructions (and compiling and running them) for the slightly more complicated expression</p>
<pre class="text"><code>1+2*3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>1+2*3

=V========== Parser ============

[&#39;ADD&#39;,
 1,
 [&#39;MUL&#39;, 2, 3]]

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;,
 3,
 &#39;PUSH&#39;,
 2,
 &#39;MUL&#39;,
 &#39;PUSH&#39;,
 1,
 &#39;ADD&#39;]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;imul&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 1]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;ret&#39;]]

=V========== GasGen ============

.global expr
expr:
add      $4,%rdi
mov      %eax,(%rdi)
mov      $3,%eax
add      $4,%rdi
mov      %eax,(%rdi)
mov      $2,%eax
imul     (%rdi),%eax
sub      $4,%rdi
add      $4,%rdi
mov      %eax,(%rdi)
mov      $1,%eax
add      (%rdi),%eax
sub      $4,%rdi
ret

=V===== GccCompileAndRun =======

7</code></pre>
<p>Generating GAS instructions (and compiling and running them) for the expression that uses all operators</p>
<pre class="text"><code>2^4/2*3-4+5</code></pre>
<p>looks like this:</p>
<pre class="text"><code>2^4/2*3-4+5

=V========== Parser ============

[&#39;ADD&#39;,
 [&#39;SUB&#39;,
  [&#39;MUL&#39;,
   [&#39;DIV&#39;,
    [&#39;POW&#39;,
     2,
     4],
    2],
   3],
  4],
 5]

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;,
 5,
 &#39;PUSH&#39;,
 4,
 &#39;PUSH&#39;,
 3,
 &#39;PUSH&#39;,
 2,
 &#39;PUSH&#39;,
 4,
 &#39;PUSH&#39;,
 2,
 &#39;POW&#39;,
 &#39;DIV&#39;,
 &#39;MUL&#39;,
 &#39;SUB&#39;,
 &#39;ADD&#39;]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 5]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;cdq&#39;],
 [&#39;idiv&#39;,
  &#39;long&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;imul&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;ret&#39;]]

=V========== GasGen ============

.global expr
expr:
add      $4,%rdi
mov      %eax,(%rdi)
mov      $5,%eax
add      $4,%rdi
mov      %eax,(%rdi)
mov      $4,%eax
add      $4,%rdi
mov      %eax,(%rdi)
mov      $3,%eax
add      $4,%rdi
mov      %eax,(%rdi)
mov      $2,%eax
add      $4,%rdi
mov      %eax,(%rdi)
mov      $4,%eax
add      $4,%rdi
mov      %eax,(%rdi)
mov      $2,%eax
cdq    
idivl    (%rdi)
sub      $4,%rdi
imul     (%rdi),%eax
sub      $4,%rdi
sub      (%rdi),%eax
sub      $4,%rdi
add      (%rdi),%eax
sub      $4,%rdi
ret

=V===== GccCompileAndRun =======

1</code></pre>
<h2 id="assembler"><span id="d3ece5a4ba484033ac47d9190e513acd"></span>Assembler</h2>
<p>The assembler turns assembly instructions into machine code:</p>
<pre><code>1.  assembler.rlmeta</code></pre>
<pre class="rlmeta"><code>Assembler {
  expr   = [instr*:xs]       -&gt; [~~xs]
  instr  = [%:x]             -&gt; x
  add    =
    | reg64:r const:i        -&gt; [0x48 0x83 modRmDirect(r) ~littleEndian(i 1)]
    | reg32:r addr:m         -&gt; []
  sub    =
    | reg64:r const:i        -&gt; []
    | reg32:r addr:m         -&gt; []
  imul   =
    | reg32:r addr:m         -&gt; []
  cdq    =                   -&gt; []
  idiv   =
    | &quot;long&quot; addr:m          -&gt; []
  mov    =
    | addr:m  reg32:r        -&gt; [0x89 modRmAddr(m r)]
    | reg32:r const:i        -&gt; [add(0xb8 r) ~littleEndian(i 4)]
  ret    =                   -&gt; [0xc3]
  addr   = [&quot;addr&quot; reg64n:n] -&gt; n
  reg64  = [&quot;reg&quot;  reg64n:n] -&gt; n
  reg64n =
    | &quot;rdi&quot; -&gt; 7
  reg32  = [&quot;reg&quot;  reg32n:n] -&gt; n
  reg32n =
    | &quot;eax&quot; -&gt; 0
  const  = [&quot;const&quot; .:i]     -&gt; i
}</code></pre>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a><span class="kw">def</span> modRmDirect(register):</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bn">0xc0</span> <span class="op">|</span> register</span></code></pre></div>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="kw">def</span> modRmAddr(addrRegister, desinationRegister):</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bn">0x00</span> <span class="op">|</span> (desinationRegister <span class="op">&lt;&lt;</span> <span class="dv">3</span>) <span class="op">|</span> addrRegister</span></code></pre></div>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb59"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a><span class="kw">def</span> add(x, y):</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>    <span class="cf">return</span> x <span class="op">+</span> y</span></code></pre></div>
<pre><code>1.  support.py
2.  [compiler]{.cp}</code></pre>
<div class="sourceCode" id="cb61"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="kw">def</span> littleEndian(number, numBytes):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>    <span class="cf">if</span> number <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> number <span class="op">&gt;=</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">8</span><span class="op">*</span>numBytes):</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> is not in range [0, max]&quot;</span>.<span class="bu">format</span>(number))</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>    values <span class="op">=</span> []</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(numBytes):</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true"></a>        values.append(number <span class="op">&amp;</span> <span class="bn">0xff</span>)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true"></a>        number <span class="op">&gt;&gt;=</span> <span class="dv">8</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true"></a>    <span class="cf">return</span> values</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb63"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a><span class="im">import</span> ctypes</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a><span class="im">import</span> mmap</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a>libc <span class="op">=</span> ctypes.cdll.LoadLibrary(<span class="va">None</span>)</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb67"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a>fn_mmap <span class="op">=</span> libc.mmap</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>fn_mmap.restype <span class="op">=</span> ctypes.c_void_p</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a>fn_mmap.argtypes <span class="op">=</span> (</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true"></a>    ctypes.c_void_p,</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true"></a>    ctypes.c_size_t,</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true"></a>    ctypes.c_int,</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true"></a>    ctypes.c_int,</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true"></a>    ctypes.c_int,</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true"></a>    ctypes.c_size_t,</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true"></a>)</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb69"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a>code <span class="op">=</span> <span class="st">&quot;&quot;</span>.join([<span class="bu">chr</span>(x) <span class="cf">for</span> x <span class="kw">in</span> machine_code])</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>code_address <span class="op">=</span> fn_mmap(</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a>    <span class="va">None</span>,</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a>    <span class="bu">len</span>(code),</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a>    mmap.PROT_READ<span class="op">|</span>mmap.PROT_WRITE<span class="op">|</span>mmap.PROT_EXEC,</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a>    mmap.MAP_PRIVATE<span class="op">|</span>mmap.MAP_ANONYMOUS,</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a>    <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a>    <span class="dv">0</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a>ctypes.memmove(code_address, code, <span class="bu">len</span>(code))</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a>fn_malloc <span class="op">=</span> libc.malloc</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a>fn_malloc.restype <span class="op">=</span> ctypes.c_void_p</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a>fn_malloc.argtypes <span class="op">=</span> (ctypes.c_size_t,)</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a>expr_fn_type <span class="op">=</span> ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_void_p)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a>expr_fn <span class="op">=</span> ctypes.cast(code_address, expr_fn_type)</span></code></pre></div>
<pre><code>1.  support.py
2.  [run machine code]{.cp}</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a>result <span class="op">=</span> expr_fn(fn_malloc(<span class="dv">1024</span>))</span></code></pre></div>
<p>Generating machine code (and running it) for the simple expression</p>
<pre class="text"><code>3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>3

=V========== Parser ============

3

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;, 3]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;ret&#39;]]

=V======== Assembler ===========

[72,
 131,
 199,
 4,
 137,
 7,
 184,
 3,
 0,
 0,
 0,
 195]

=V======== X86Runner ===========

3</code></pre>
<p>Generating machine code (and running it) for the slightly more complicated expression</p>
<pre class="text"><code>1+2*3</code></pre>
<p>looks like this:</p>
<pre class="text"><code>1+2*3

=V========== Parser ============

[&#39;ADD&#39;,
 1,
 [&#39;MUL&#39;, 2, 3]]

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;,
 3,
 &#39;PUSH&#39;,
 2,
 &#39;MUL&#39;,
 &#39;PUSH&#39;,
 1,
 &#39;ADD&#39;]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;imul&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 1]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;ret&#39;]]

=V======== Assembler ===========

[72,
 131,
 199,
 4,
 137,
 7,
 184,
 3,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 2,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 1,
 0,
 0,
 0,
 195]

=V======== X86Runner ===========

1</code></pre>
<p>Generating machine code (and running it) for the expression that uses all operators</p>
<pre class="text"><code>2^4/2*3-4+5</code></pre>
<p>looks like this:</p>
<pre class="text"><code>2^4/2*3-4+5

=V========== Parser ============

[&#39;ADD&#39;,
 [&#39;SUB&#39;,
  [&#39;MUL&#39;,
   [&#39;DIV&#39;,
    [&#39;POW&#39;,
     2,
     4],
    2],
   3],
  4],
 5]

=V===== AbstractCodeGen ========

[&#39;PUSH&#39;,
 5,
 &#39;PUSH&#39;,
 4,
 &#39;PUSH&#39;,
 3,
 &#39;PUSH&#39;,
 2,
 &#39;PUSH&#39;,
 4,
 &#39;PUSH&#39;,
 2,
 &#39;POW&#39;,
 &#39;DIV&#39;,
 &#39;MUL&#39;,
 &#39;SUB&#39;,
 &#39;ADD&#39;]

=V======== X86CodeGen ==========

[[&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 5]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 3]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;mov&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;],
  [&#39;reg&#39;, &#39;eax&#39;]],
 [&#39;mov&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;const&#39;, 2]],
 [&#39;cdq&#39;],
 [&#39;idiv&#39;,
  &#39;long&#39;,
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;imul&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;add&#39;,
  [&#39;reg&#39;, &#39;eax&#39;],
  [&#39;addr&#39;, &#39;rdi&#39;]],
 [&#39;sub&#39;,
  [&#39;reg&#39;, &#39;rdi&#39;],
  [&#39;const&#39;, 4]],
 [&#39;ret&#39;]]

=V======== Assembler ===========

[72,
 131,
 199,
 4,
 137,
 7,
 184,
 5,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 4,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 3,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 2,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 4,
 0,
 0,
 0,
 72,
 131,
 199,
 4,
 137,
 7,
 184,
 2,
 0,
 0,
 0,
 195]

=V======== X86Runner ===========

2</code></pre>
<h2 id="appendix-all-source-code"><span id="a047c1b417bc42799170c0e3632cc3f9"></span>Appendix: All source code</h2>
<p>Here is all source code needed to turn expressions into x86 machine code. Code to run machine code is dependent on situation, so it is not included here.</p>
<p>Parser:</p>
<pre class="text"><code>Parser {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; parseOps(x xs)
  digit = &#39;0&#39;-&#39;9&#39;:x                           -&gt; int(x)
  op    =
    | &#39;+&#39; -&gt; Op(makeAstNode(&quot;ADD&quot;) 1 &quot;left&quot;)
    | &#39;-&#39; -&gt; Op(makeAstNode(&quot;SUB&quot;) 1 &quot;left&quot;)
    | &#39;*&#39; -&gt; Op(makeAstNode(&quot;MUL&quot;) 2 &quot;left&quot;)
    | &#39;/&#39; -&gt; Op(makeAstNode(&quot;DIV&quot;) 2 &quot;left&quot;)
    | &#39;^&#39; -&gt; Op(makeAstNode(&quot;POW&quot;) 3 &quot;right&quot;)
}</code></pre>
<p>Abstract code generator:</p>
<pre class="text"><code>AbstractCodeGen {
  expr =
    | [.:name expr:left expr:right] -&gt; [~right ~left name]
    | .:leaf                        -&gt; [&quot;PUSH&quot; leaf]
}</code></pre>
<p>X86 code generator:</p>
<pre class="text"><code>X86CodeGen {
  expr = [%*:xs] -&gt; [~~xs [&quot;ret&quot;]]
  ADD = -&gt; [
    [&quot;add&quot; [&quot;reg&quot; &quot;eax&quot;] [&quot;addr&quot; &quot;rdi&quot;]]
    [&quot;sub&quot; [&quot;reg&quot; &quot;rdi&quot;] [&quot;const&quot; 4   ]]
  ]
  SUB = -&gt; [
    [&quot;sub&quot; [&quot;reg&quot; &quot;eax&quot;] [&quot;addr&quot; &quot;rdi&quot;]]
    [&quot;sub&quot; [&quot;reg&quot; &quot;rdi&quot;] [&quot;const&quot; 4   ]]
  ]
  MUL = -&gt; [
    [&quot;imul&quot; [&quot;reg&quot; &quot;eax&quot;] [&quot;addr&quot; &quot;rdi&quot;]]
    [&quot;sub&quot;  [&quot;reg&quot; &quot;rdi&quot;] [&quot;const&quot; 4   ]]
  ]
  DIV = -&gt; [
    [&quot;cdq&quot;                                   ]
    [&quot;idiv&quot; &quot;long&quot; [&quot;addr&quot; &quot;rdi&quot;]            ]
    [&quot;sub&quot;         [&quot;reg&quot;  &quot;rdi&quot;] [&quot;const&quot; 4]]
  ]
  POW = -&gt; [
  ]
  PUSH = .:x -&gt; [
    [&quot;add&quot; [&quot;reg&quot;  &quot;rdi&quot;] [&quot;const&quot; 4    ]]
    [&quot;mov&quot; [&quot;addr&quot; &quot;rdi&quot;] [&quot;reg&quot;   &quot;eax&quot;]]
    [&quot;mov&quot; [&quot;reg&quot;  &quot;eax&quot;] [&quot;const&quot; x    ]]
  ]
}</code></pre>
<p>Assembler:</p>
<pre class="text"><code>Assembler {
  expr   = [instr*:xs]       -&gt; [~~xs]
  instr  = [%:x]             -&gt; x
  add    =
    | reg64:r const:i        -&gt; [0x48 0x83 modRmDirect(r) ~littleEndian(i 1)]
    | reg32:r addr:m         -&gt; []
  sub    =
    | reg64:r const:i        -&gt; []
    | reg32:r addr:m         -&gt; []
  imul   =
    | reg32:r addr:m         -&gt; []
  cdq    =                   -&gt; []
  idiv   =
    | &quot;long&quot; addr:m          -&gt; []
  mov    =
    | addr:m  reg32:r        -&gt; [0x89 modRmAddr(m r)]
    | reg32:r const:i        -&gt; [add(0xb8 r) ~littleEndian(i 4)]
  ret    =                   -&gt; [0xc3]
  addr   = [&quot;addr&quot; reg64n:n] -&gt; n
  reg64  = [&quot;reg&quot;  reg64n:n] -&gt; n
  reg64n =
    | &quot;rdi&quot; -&gt; 7
  reg32  = [&quot;reg&quot;  reg32n:n] -&gt; n
  reg32n =
    | &quot;eax&quot; -&gt; 0
  const  = [&quot;const&quot; .:i]     -&gt; i
}</code></pre>
<p>Support functions:</p>
<pre class="text"><code>class Op(object):

    def __init__(self, fn, prec, assoc):
        self.fn = fn
        self.prec = prec
        self.assoc = assoc

def makeAstNode(name):
    def op(left, right):
        return [name, left, right]
    return op

def parseOps(expr, items, min_level=0):
    while items and items[0][0].prec &gt;= min_level:
        op, rhs = items.pop(0)
        if op.assoc == &quot;left&quot;:
            next_level = op.prec + 1
        else:
            next_level = op.prec
        expr = op.fn(expr, parseOps(rhs, items, next_level))
    return expr

def modRmDirect(register):
    return 0xc0 | register

def modRmAddr(addrRegister, desinationRegister):
    return 0x00 | (desinationRegister &lt;&lt; 3) | addrRegister

def add(x, y):
    return x + y

def littleEndian(number, numBytes):
    if number &lt; 0 or number &gt;= 2**(8*numBytes):
        raise ValueError(&quot;{} is not in range [0, max]&quot;.format(number))
    values = []
    for i in range(numBytes):
        values.append(number &amp; 0xff)
        number &gt;&gt;= 8
    return values</code></pre>
<h2 id="appendix-rlmeta"><span id="ff74bacb76bf40f082f88738ebc5d8b0"></span>Appendix: RLMeta</h2>
<p>In this article I use a version of RLMeta that builds upon the VM based version from <a href="/writing/rlmeta-memoize-failures/index.html">memoizing failures</a>, but has the following changes:</p>
<ul>
<li>It supports integers in semantic actions.</li>
<li>It support arbitrary many <code>~</code> operators.</li>
<li>It supports repeating the <code>%</code> operator.</li>
</ul>
<p>I will not explain how I made those changes here. The full source code is available on <a href="https://github.com/rickardlindberg/rickardlindberg.me/tree/master/writing/expr-to-x86-compiler/rlmeta">GitHub</a>.</p>
<h2 id="eca23f484ea7b7430ef607b491c2appendix-test-script">[]{#7790eca23f484ea7b7430ef607b491c2}Appendix: Test script</h2>
<p>I used the following script to run the examples:</p>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a><span class="fu">compile()</span> <span class="kw">{</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;import sys&quot;</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;import pprint&quot;</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a>    <span class="ex">python</span> rlmeta/rlmeta.py --support</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a>    <span class="fu">cat</span> <span class="st">&quot;support.py&quot;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true"></a>    <span class="ex">python</span> rlmeta/rlmeta.py <span class="op">&lt;</span> parser.rlmeta</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true"></a>    <span class="ex">python</span> rlmeta/rlmeta.py <span class="op">&lt;</span> abstractcodegen.rlmeta</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true"></a>    <span class="ex">python</span> rlmeta/rlmeta.py <span class="op">&lt;</span> x86codegen.rlmeta</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true"></a>    <span class="ex">python</span> rlmeta/rlmeta.py <span class="op">&lt;</span> gas.rlmeta</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true"></a>    <span class="ex">python</span> rlmeta/rlmeta.py <span class="op">&lt;</span> assembler.rlmeta</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;main()&quot;</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true"></a><span class="ex">python</span> <span class="op">&lt;(</span><span class="ex">compile</span><span class="op">)</span> <span class="st">&quot;</span><span class="va">$@</span><span class="st">&quot;</span></span></code></pre></div>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="kw">def</span> main():</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>    grammars <span class="op">=</span> {</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a>        <span class="st">&quot;parser&quot;</span>: Parser(),</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a>        <span class="st">&quot;acodegen&quot;</span>: AbstractCodeGen(),</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a>        <span class="st">&quot;xcodegen&quot;</span>: X86CodeGen(),</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a>        <span class="st">&quot;gas&quot;</span>: GasGen(),</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a>        <span class="st">&quot;assembler&quot;</span>: Assembler(),</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true"></a>        <span class="st">&quot;xrunner&quot;</span>: X86Runner(),</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true"></a>    }</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true"></a>    <span class="cf">try</span>:</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true"></a>        expr <span class="op">=</span> sys.stdin.read().strip()</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true"></a>        first <span class="op">=</span> <span class="va">True</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true"></a>        <span class="cf">for</span> grammar_name <span class="kw">in</span> sys.argv[<span class="dv">1</span>:]:</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true"></a>            <span class="cf">if</span> grammar_name.startswith(<span class="st">&quot;@&quot;</span>):</span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true"></a>                <span class="cf">with</span> <span class="bu">open</span>(grammar_name[<span class="dv">1</span>:], <span class="st">&quot;w&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true"></a>                    f.write(<span class="bu">str</span>(expr))</span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true"></a>            grammar <span class="op">=</span> grammars[grammar_name]</span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true"></a>            print_expr(expr)</span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true"></a>            print_box(grammar.__class__.<span class="va">__name__</span>)</span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true"></a>            expr <span class="op">=</span> grammar.run(<span class="st">&quot;expr&quot;</span>, expr)</span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true"></a>        print_expr(expr)</span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true"></a>    <span class="cf">except</span> _MatchError <span class="im">as</span> e:</span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true"></a>        sys.stderr.write(e.describe())</span></code></pre></div>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a><span class="kw">def</span> print_box(name):</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&quot;=V</span><span class="sc">{}</span><span class="st">==&quot;</span>.<span class="bu">format</span>(<span class="st">&quot; </span><span class="sc">{}</span><span class="st"> &quot;</span>.<span class="bu">format</span>(name).center(<span class="dv">28</span>, <span class="st">&quot;=&quot;</span>)))</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&quot;&quot;</span>)</span></code></pre></div>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="kw">def</span> print_expr(expr):</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(expr, <span class="bu">str</span>):</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a>        <span class="bu">print</span>(expr.strip())</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>        pprint.pprint(expr, width<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<pre><code>1.  gas.sh</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a><span class="fu">cat</span> <span class="kw">|</span> <span class="fu">bash</span> compile.sh parser acodegen xcodegen gas @expr.s</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a><span class="fu">gcc</span> driver.c expr.s -o expr</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;&quot;</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;=V===== GccCompileAndRun =======&quot;</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;&quot;</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true"></a></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true"></a><span class="ex">./expr</span></span></code></pre></div>
<pre><code>1.  native.sh</code></pre>
<div class="sourceCode" id="cb98"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a><span class="fu">bash</span> compile.sh parser acodegen xcodegen assembler xrunner</span></code></pre></div>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a><span class="kw">class</span> X86Runner(<span class="bu">object</span>):</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, name, machine_code):</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>run machine code<span class="op">&gt;&gt;</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true"></a>        <span class="cf">return</span> result</span></code></pre></div>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb102"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a><span class="op">&lt;&lt;</span>compiler<span class="op">&gt;&gt;</span></span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>DRAFT: Porting RLMeta to C++</title>
    <link href="http://rickardlindberg.me/writing/rlmeta-cpp/" />
    <id>http://rickardlindberg.me/writing/rlmeta-cpp/</id>
    <published>2020-04-10T00:00:00Z</published>
    <updated>2020-04-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>DRAFT: Porting RLMeta to C++</h1>

<p><em>Published on 10 April 2020.</em></p>

<p><strong>This is a work in progress that will change. Like to see it finished? Let me know by sending me an email.</strong></p>
<p>In this article I will port RLMeta to C++. The main reason for doing it is to learn C++. I have the impression that C++ is a large and complex language, but I think I should be able to grasp the basics pretty quickly because I know C quite well and I am also familiar with object oriented programming. This article will describe my learning journey as well as the port. Another reason for doing the port is to see how RLMeta looks like when C++ is the target language. Will it fit well? Will performance increase?</p>
<ul>
<li><a href="#f935efac99094d30b035430ba6c263cb">Representing data</a></li>
<li><a href="#8fe0f8cbf13f49c0a4d9aa4f92fa2540">Misc</a></li>
</ul>
<h2 id="representing-data"><span id="f935efac99094d30b035430ba6c263cb"></span>Representing data</h2>
<p>The first thing I think about is how to represent the data that RLMeta needs. In particular I think about how to store the mapping between rule names and their location in the program. The map in the C++ standard library looks like a dict in Python. But there is also something about an allocation strategy. I need to learn more about how memory is handled in C++.</p>
<p>I read about classes, constructors, destructors and initialisation. I create a small example to clarify my thinking. Here I also learn about basic C++ syntax.</p>
<pre class="text"><code>#include &lt;iostream&gt;

class Foo {
    private:
        int id;
    public:
        Foo(int id) : id(id) {
            std::cout &lt;&lt; &quot;Creating foo &quot; &lt;&lt; id &lt;&lt; &quot;\n&quot;;
        }
        ~Foo() {
            std::cout &lt;&lt; &quot;Destructing foo &quot; &lt;&lt; id &lt;&lt; &quot;\n&quot;;
        }
};

int main() {
    std::cout &lt;&lt; &quot;Entering main\n&quot;;
    Foo foo1(1);
    Foo *foo2 = new Foo(2);
    std::cout &lt;&lt; &quot;Exiting main\n&quot;;
    return 0;
}</code></pre>
<p>Output:</p>
<pre class="text"><code>Entering main
Creating foo 1
Creating foo 2
Exiting main
Destructing foo 1</code></pre>
<p>This shows me that objects are destructed automatically if allocated on the stack. But not when newed.</p>
<p>I go back to the map and make a small example to learn how to use it:</p>
<pre class="text"><code>#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::map&lt;std::string, int&gt; rules;
    rules.insert(std::pair&lt;std::string, int&gt;(&quot;foo&quot;, 10));
    rules.insert(std::pair&lt;std::string, int&gt;(&quot;bar&quot;, 15));
    std::cout &lt;&lt; &quot;foo = &quot; &lt;&lt; rules[&quot;foo&quot;] &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;bar = &quot; &lt;&lt; rules[&quot;bar&quot;] &lt;&lt; &quot;\n&quot;;
    return 0;
}</code></pre>
<p>Output:</p>
<pre class="text"><code>foo = 10
bar = 15</code></pre>
<p>I think the type declarations make the code hard to read. But the map seems to do what I want. So I'm happy. I also conclude that the map allocates memory to make space for all pairs. But at the end of <code>main</code> it will all be freed automatically. So no memory will leak.</p>
<p>Next I'm thinking about how to represent instructions. In the Python version an instruction is represented as a tuple <code>(name, arg1, arg2)</code>. Where the arguments can be of arbitrary type (string, integer, lambda, etc.).</p>
<p>Getting stuck. I think about how to represent the values that RLMeta works with instead. Lists, strings, integers, characters.</p>
<pre class="text"><code>#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;memory&gt;

class RLMetaObject {
    public:
        virtual ~RLMetaObject() {
        }
};

class RLMetaInteger : public RLMetaObject {
    private:
        int value;
    public:
        RLMetaInteger(int value) : value(value) {
        }
        ~RLMetaInteger() {
            std::cout &lt;&lt; &quot;Destructing integer &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
        }
};

class RLMetaString : public RLMetaObject {
    private:
        std::string value;
    public:
        RLMetaString(std::string value) : value(value) {
        }
        ~RLMetaString() {
            std::cout &lt;&lt; &quot;Destructing string &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
        }
};

int main() {
    std::list&lt;RLMetaObject&gt; objects;
    objects.push_back(RLMetaInteger(5));
    objects.push_back(RLMetaString(&quot;hello&quot;));
    std::list&lt;std::unique_ptr&lt;RLMetaObject&gt;&gt; objectPointers;
    objectPointers.push_back(
        std::make_unique&lt;RLMetaInteger&gt;(6)
    );
    objectPointers.push_back(
        std::make_unique&lt;RLMetaString&gt;(&quot;world&quot;)
    );
    return 0;
}</code></pre>
<pre class="text"><code>Destructing integer 5
Destructing string hello
Destructing integer 6
Destructing string world</code></pre>
<p>Since C++ containers can not store objects of arbitrary type, I introduce a base class. I also experiment with smart pointers. I find out that a virtual destructor is needed to make proper destruction. That really confused me.</p>
<p>Dynamic cast can work as <code>isinstance</code> in Python.</p>
<pre class="text"><code>#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;memory&gt;

class RLMetaObject {
    virtual bool matches(const RLMetaObject &amp;other) {
        return false;
    }
};

class RLMetaInteger : public RLMetaObject {
    private:
        int value;
    public:
        RLMetaInteger(int value) : value(value) {
        }
        bool matches(const RLMetaObject &amp;other) {
            try {
                const RLMetaInteger &amp;otherInt = dynamic_cast&lt;const RLMetaInteger&amp;&gt;(other);
                return otherInt.value == value;
            } catch (std::bad_cast) {}
            return false;
        }
};

int main() {
    RLMetaObject obj;
    RLMetaInteger int5(5);
    RLMetaInteger int6(6);
    std::cout &lt;&lt; &quot;Integer(5) matches Object?     &quot; &lt;&lt; int5.matches(obj)  &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;Integer(5) matches Integer(6)? &quot; &lt;&lt; int5.matches(int6)  &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;Integer(6) matches Integer(6)? &quot; &lt;&lt; int6.matches(int6)  &lt;&lt; &quot;\n&quot;;
    return 0;
}</code></pre>
<pre class="text"><code>Integer(5) matches Object?     0
Integer(5) matches Integer(6)? 0
Integer(6) matches Integer(6)? 1</code></pre>
<p>For this to work, there has to be some virtual member in the base class.</p>
<h2 id="fe0f8cbf13f49c0a4d9aa4f92fa2540misc">[]{#8fe0f8cbf13f49c0a4d9aa4f92fa2540}Misc</h2>
<pre><code>1.  runcpp.sh</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&gt;</span> tmp.cpp <span class="kw">&amp;&amp;</span> <span class="ex">g++</span> tmp.cpp -o tmp <span class="kw">&amp;&amp;</span> <span class="ex">./tmp</span> <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> tmp.cpp tmp</span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>DRAFT: Parsing off-side rule languages with RLMeta</title>
    <link href="http://rickardlindberg.me/writing/draft-rlmeta-offside/" />
    <id>http://rickardlindberg.me/writing/draft-rlmeta-offside/</id>
    <published>2019-06-27T00:00:00Z</published>
    <updated>2019-06-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>DRAFT: Parsing off-side rule languages with RLMeta</h1>

<p><em>Published on 2019-06-27.</em></p>

<strong>This is a work in progress that will change. Like to see it finished? Let me know by sending me an email.</strong>

<p>In this article I describe how to parse <a href="https://en.wikipedia.org/wiki/Off-side_rule">off-side rule</a> languages using RLMeta.</p>

<ul><li><a href="#d44bd1779e9f4cdab7ac14e0b23ad3bf">Markdown</a>

</li>

<li><a href="#c2cd13666c264ac2bcfde34ec81f77b5">Python</a>

</li>

<li><a href="#5cca99df2e2c4c78ab4bfe4cb946d89a">Notes</a>

</li>

</ul><h2><a name="d44bd1779e9f4cdab7ac14e0b23ad3bf"></a>Markdown</h2>

<h2><a name="c2cd13666c264ac2bcfde34ec81f77b5"></a>Python</h2>

<h2><a name="5cca99df2e2c4c78ab4bfe4cb946d89a"></a>Notes</h2>

<p>Got the idea from <a href="https://github.com/jgm/peg-markdown/">A PEG Markdown parser</a>.</p>

<p>Failure messages will have wrong location.</p>

]]></summary>
</entry>

</feed>
