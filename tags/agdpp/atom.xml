<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Rickard's personal homepage: latest posts tagged agdpp</title>
    <link href="http://rickardlindberg.me/tags/agdpp/atom.xml" rel="self" />
    <link href="http://rickardlindberg.me" />
    <id>http://rickardlindberg.me/tags/agdpp/atom.xml</id>
    <author>
        <name>Rickard Lindberg</name>
        <email>rickard@rickardlindberg.me</email>
    </author>
    <updated>2023-09-10T00:00:00Z</updated>
    <entry>
    <title>DevLog 013: Raspberry Pi game console</title>
    <link href="http://rickardlindberg.me/writing/devlog-013-raspberrypi-game-console/" />
    <id>http://rickardlindberg.me/writing/devlog-013-raspberrypi-game-console/</id>
    <published>2023-09-10T00:00:00Z</published>
    <updated>2023-09-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>DevLog 013: Raspberry Pi game console</h1>

<p><em>Published on 10 September 2023.</em></p>

<p>It is time to revisit the <a href="/projects/agdpp/index.html">balloon shooter</a>. I’m interested in building a “game console PC” so that my son can more easily play the balloon shooter and other games. Until now we have played all games on my laptop.</p>
<p>This will involve two main steps I think. The first is to get a Raspberry Pi and install all games on it. The second involves auto starting a custom application that can be used to select which game to play by using the gamepad. Ideally, you should not need to use a mouse or a keyboard. My plan for this custom application is to build it using the framework that we have in the balloon shooter.</p>
<p>Let’s get started.</p>
<h2 id="the-raspberry-pi">The Raspberry Pi</h2>
<p>At first, I’m not sure what hardware to get for this game console PC. I look around a bit, and then eventually settle on a Raspberry Pi starter kit.</p>
<p>
<center>
<img src="pibox.png" title="fig:" alt="Raspberry Pi starter kit." />
</center>
</p>
<p>I am bit concerned that it will not be powerful enough to play games. But it is relatively cheap, and if it can’t play all games, perhaps my son (or me) can have some fun with it in another way.</p>
<h2 id="assembly">Assembly</h2>
<p>The starter kit comes with everything you need to get started. That’s also one reason that I went with it. I’m not that interested in selecting hardware. I’m more interested in quickly prototyping this game console PC. If it turns out the Pi is not powerful enough, but the game console PC concept is a hit, we can look for better hardware. However, if the game console PC is not a hit, we have not wasted that much time or money.</p>
<p>And look. Apparently Raspberry Pis need heat sinks and fans nowadays. When I last played with a Pi, many, many years ago, I don’t remember that being the case. Let’s hope that means that they are more powerful now.</p>
<p>
<center>
<img src="assembly.png" title="fig:" alt="Assembling the starter kit." />
</center>
</p>
<p>I assemble the kit in about 15 minutes. Then I boot it up and install the operating system that comes preconfigured. I let it do its thing, and come back once it is installed.</p>
<h2 id="setup">Setup</h2>
<p>I want to install <a href="https://www.supertux.org/">SuperTux</a> and the balloon shooter on the Pi.</p>
<p>It seems like the version of SuperTux is older than what I have on my laptop. And my laptop is old. Furthermore, Python 2 seems to be the default Python. I learn that when trying to install all requirements for the balloon shooter. I also have to install a newer version of Pygame and for that I need to install some SDL build dependencies. Perhaps getting a newer operating system would be nice.</p>
<p>Eventually, I get everything working:</p>
<p>
<center>
<img src="setup.png" title="fig:" alt="Setting up games." />
</center>
</p>
<p>The versions might be a little old. The performance might be so so. But we have something setup that we can experiment with.</p>
<h2 id="a-note-on-performance">A note on performance</h2>
<p>Me and my son try to play SuperTux on the setup. It feels a little different. Part of it might be that it is slightly different version of the game. Part of it might be that the Pi has worse performance. We try to run the game at a lower resolution, and it seems to help a bit. We can probably try different things to get better performance, but this is absolutely fine for now. My son is still having fun playing.</p>
<h2 id="autostart">Autostart</h2>
<p>To start SuperTux on the Pi you first have to start the Pi and then you have to select SuperTux from the menu with the mouse. The balloon shooter is even more complicated to start. First you need to open a terminal and then run a command.</p>
<p>I don’t think that is good enough for a game console PC. I want to be able to operate it using the gamepad only.</p>
<p>The first tiny step in that direction is to configure SuperTux as the startup application. If we can do that, then SuperTux can be started and played without using the keyboard or mouse.</p>
<p>Once we have that working, we can work on our own startup application that let us select the game, and then we can start that one instead.</p>
<p>I search the internet for how to configure a startup application for the Pi.</p>
<p>I find an article that says that you can put a file in the autostart directory. I try this:</p>
<pre class="text"><code>$ cat /etc/xdg/autostart/game_console_start.desktop
[Desktop Entry]
Name=Game console start
Exec=supertux2</code></pre>
<p>I restart the Pi, and SuperTux actually starts automatically and you can start playing it using the gamepad. Fantastic!</p>
<h2 id="startup-application-idea">Startup application idea</h2>
<p>Let’s move on to our custom startup application. Here is the idea that I have for it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    subprocess.call(StartupApplication.create().run())</span></code></pre></div>
<p>This code runs the startup application in a loop. Its <code>run</code> method should return the command to run. (The game to play or shutdown command.)</p>
<p>I think we can test drive the <code>StartupApplication</code> and then we can hook it up in the loop above.</p>
<p>Perhaps we should even test drive the loop.</p>
<p>We’ll see.</p>
<h2 id="test-driving-the-application">Test driving the application</h2>
<p>I start with this in a new file:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">    I draw an application select screen:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; events = StartupApplication.run_in_test_mode(</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co">    ...     events=[</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co">    ...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="co">    ...     ]</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="co">    ... )</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span></code></pre></div>
<p>I create the bare minimum that the test complains about and get this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    ...</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="kw">def</span> run_in_test_mode(events<span class="op">=</span>[]):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        loop <span class="op">=</span> GameLoop.create_null(</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>            events<span class="op">=</span>events<span class="op">+</span>[</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>                [GameLoop.create_event_user_closed_window()],</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>            ]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>        )</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>        events <span class="op">=</span> loop.track_events()</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>        StartupApplication(loop).run()</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>        <span class="cf">return</span> events</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, loop):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>        <span class="va">self</span>.loop <span class="op">=</span> loop</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>):</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>        <span class="va">self</span>.loop.run(<span class="va">self</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>        <span class="cf">pass</span></span></code></pre></div>
<p>Now it doesn’t complain, but it seems to hang in an infinite loop.</p>
<p>I modify <code>event</code> to this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    ...</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span></code></pre></div>
<p>And we’re green. Let’s commit.</p>
<pre class="text"><code>$ git commit -a -m &#39;Emryo to new startup application.&#39;
[main a55d17e] Emryo to new startup application.
 2 files changed, 39 insertions(+)
 create mode 100644 startup.py</code></pre>
<p>The test is not yet fleshed out. It doesn’t test what it says it tests. But it drove out the skeleton of the application.</p>
<h2 id="reflecting-on-the-design">Reflecting on the design</h2>
<p>It’s been a while since I worked on the balloon shooter. What do I think when I work in this design again?</p>
<p>I got stuck in an infinite loop. That happens because we have a <code>while True:</code> in our game loop somewhere. I’ve always found testing infinite loops difficult. That’s one reason why I hesitated testing the loop for the startup application. But now I get another idea. What if we create the loop like this instead?</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="cf">while</span> <span class="va">self</span>.loop_condition.active():</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>Then we can create different versions of the loop condition maybe something like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> InfiniteLoopCondition:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">def</span> active(<span class="va">self</span>):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">True</span></span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">class</span> TestLoopCondition:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, iterations):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="va">self</span>.counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>        <span class="va">self</span>.iterations <span class="op">=</span> iterations</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="kw">def</span> active(<span class="va">self</span>):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        flag <span class="op">=</span> <span class="va">self</span>.counter <span class="op">&gt;=</span> <span class="va">self</span>.iterations</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>        <span class="va">self</span>.iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>        <span class="cf">return</span> flag</span></code></pre></div>
<p>Let’s see if we can try this out in the startup application. If it works out well, perhaps we can port it to the game loop as well?</p>
<h2 id="a-mistake">A mistake</h2>
<p>The test that we wrote does not assert anything on the events. Let’s fix that. I comment out the assignment of <code>events</code> and paste the expected test output:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">I draw an application select screen:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; StartupApplication.run_in_test_mode(</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<h2 id="the-looping-concept">The looping concept</h2>
<p>This startup application should run in an infinite loop. In each iteration it should init the game loop and show the game selection screen. Once the selection has been made, it should quit the game loop and run the command. Then it starts all over.</p>
<p>Let’s try the looping thing.</p>
<p>I start by TDDing the loop conditions:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> InifiteLoopCondition:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="kw">def</span> active(<span class="va">self</span>):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; InifiteLoopCondition().active()</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="co">        True</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span></code></pre></div>
<p>That fails. Fix by return true. The other:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> FiteLoopCondition:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, iterations):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>        <span class="va">self</span>.iterations <span class="op">=</span> iterations</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>        <span class="va">self</span>.count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    <span class="kw">def</span> active(<span class="va">self</span>):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; condition = FiteLoopCondition(iterations=2)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; condition.active()</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a><span class="co">        True</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; condition.active()</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="co">        True</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; condition.active()</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a><span class="co">        False</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>        flag <span class="op">=</span> <span class="va">self</span>.count <span class="op">&lt;</span> <span class="va">self</span>.iterations</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>        <span class="va">self</span>.count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>        <span class="cf">return</span> flag</span></code></pre></div>
<p>I actually got the condition wrong here at first. I’m glad I wrote a test for it. The previous example, <code>TestLoopCondition</code>, above is actually wrong. Even for really simple code like this, having tests is nice.</p>
<p>Let’s see if we can use a loop condition and have the test show us that two loops are actually made.</p>
<p>I change</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    ...</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    <span class="kw">def</span> run_in_test_mode(events<span class="op">=</span>[]):</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>        ...</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>        StartupApplication(loop).run()</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    ...</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    <span class="kw">def</span> run_in_test_mode(events<span class="op">=</span>[]):</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        ...</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        StartupApplication(</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>            loop<span class="op">=</span>loop,</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>            loop_condition<span class="op">=</span>FiteLoopCondition(<span class="dv">2</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>        ).run()</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>I also notice that i misspelled finite. I fix that and then add the parameter to the class. Test passes. Let’s add an actual loop:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    ...</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">self</span>.loop_condition.active():</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>            <span class="va">self</span>.loop.run(<span class="va">self</span>)</span></code></pre></div>
<p>This, expectedly, output another loop which I add to the assertion. Perfect!</p>
<pre class="text"><code>    GAMELOOP_INIT =&gt;
        resolution: (1280, 720)
        fps: 60
    GAMELOOP_QUIT =&gt;</code></pre>
<p>We are not yet using the <code>InfiniteLoopCondition</code>. Let’s change that by adding a <code>create</code> method:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    ...</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span class="kw">def</span> create():</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; isinstance(StartupApplication.create(), StartupApplication)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a><span class="co">        True</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>        <span class="cf">return</span> StartupApplication(</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>            loop<span class="op">=</span>GameLoop.create(),</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>            loop_condition<span class="op">=</span>InifiteLoopCondition()</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>        )</span></code></pre></div>
<p>I also add this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    StartupApplication.create().run()</span></code></pre></div>
<p>And when I run</p>
<pre class="text"><code>$ python startup.py</code></pre>
<p>It indeed creates a new window every time I close it.</p>
<pre class="text"><code>$ git commit -a -m &#39;Add startup entry point and have it loop.&#39;
[main aadd1a2] Add startup entry point and have it loop.
 1 file changed, 60 insertions(+), 5 deletions(-)</code></pre>
<h2 id="selecting-a-game">Selecting a game</h2>
<p>What is the simplest possible solution for selecting a game?</p>
<p>I imagine that the display shows an icon for each game that can be selected. Then you move a cursor over it and press a key to select it.</p>
<p>I start by getting some games on the screen:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>    <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>    <span class="va">self</span>.loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">100</span>), text<span class="op">=</span><span class="st">&quot;SuperTux&quot;</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>    <span class="va">self</span>.loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">200</span>), text<span class="op">=</span><span class="st">&quot;Balloon Shooter&quot;</span>)</span></code></pre></div>
<p>It looks like this:</p>
<p>
<center>
<img src="games.png" title="fig:" alt="Games in startup screen." />
</center>
</p>
<p>I think we also need a cursor:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="va">self</span>.loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">100</span>), text<span class="op">=</span><span class="st">&quot;SuperTux&quot;</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    <span class="va">self</span>.loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">200</span>), text<span class="op">=</span><span class="st">&quot;Balloon Shooter&quot;</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    <span class="va">self</span>.loop.draw_circle(Point(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="dv">500</span>), radius<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">&quot;pink&quot;</span>)</span></code></pre></div>
<p>It looks like this:</p>
<p>
<center>
<img src="cursor.png" title="fig:" alt="Cursor in startup screen." />
</center>
</p>
<p>Now I think two things are missing. The first is that at the press of a button, the game closest to the cursor should start. The second is that you also need to be able to move the cursor.</p>
<p>I think working on movement is secondary. It is more important to be able to start <strong>one</strong> game instead of nothing. So let’s work on that first.</p>
<h2 id="starting-a-game">Starting a game</h2>
<p>I want to write a test for the new behavior, but I find that testing at the top level is tedious and error prone. I would therefore like to start by refactoring and extracting a <code>StartupScene</code> maybe that has an interface that is easier to test. I end up with this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>        loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">100</span>), text<span class="op">=</span><span class="st">&quot;SuperTux&quot;</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>        loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">200</span>), text<span class="op">=</span><span class="st">&quot;Balloon Shooter&quot;</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>        loop.draw_circle(Point(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="dv">500</span>), radius<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">&quot;pink&quot;</span>)</span></code></pre></div>
<p>I’m sure this refactoring works because I have tests to cover it.</p>
<p>Commit!</p>
<p>Now, let’s see if we can write a test:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="co">When XBOX_A is pressed, I start the game that is closest to the cursor:</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; scene = StartupScene()</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; scene.event(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a><span class="co">SuperTux</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>I make it pass like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    ...</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>        ...</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_joystick_down(XBOX_A):</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>            <span class="bu">print</span>(<span class="st">&quot;SuperTux&quot;</span>)</span></code></pre></div>
<p>This is obviously faking it. It is not supposed to print the name of the game, it is supposed to run it, or, wait a minute. This class is not supposed to run it, the top-level class is.</p>
<p>Let’s scratch this and start over.</p>
<h2 id="starting-a-game-again">Starting a game (again)</h2>
<p>Let’s have a look at the top-level test:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="co">I draw an application select screen:</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; StartupApplication.run_in_test_mode(</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a><span class="co">DRAW_TEXT =&gt;</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a><span class="co">    x: 100</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a><span class="co">    y: 100</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a><span class="co">    text: &#39;SuperTux&#39;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a><span class="co">DRAW_TEXT =&gt;</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a><span class="co">    x: 100</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true"></a><span class="co">    y: 200</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true"></a><span class="co">    text: &#39;Balloon Shooter&#39;</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true"></a><span class="co">    radius: 20</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true"></a><span class="co">    color: &#39;pink&#39;</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true"></a><span class="co">DRAW_TEXT =&gt;</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true"></a><span class="co">    x: 100</span></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true"></a><span class="co">    y: 100</span></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true"></a><span class="co">    text: &#39;SuperTux&#39;</span></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true"></a><span class="co">DRAW_TEXT =&gt;</span></span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true"></a><span class="co">    x: 100</span></span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true"></a><span class="co">    y: 200</span></span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true"></a><span class="co">    text: &#39;Balloon Shooter&#39;</span></span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true"></a><span class="co">    radius: 20</span></span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true"></a><span class="co">    color: &#39;pink&#39;</span></span>
<span id="cb26-47"><a href="#cb26-47" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb26-48"><a href="#cb26-48" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>This shows our game loop runs twice, but there is no mention that a command is run. Let’s modify</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>    ...</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>):</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">self</span>.loop_condition.active():</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>            <span class="va">self</span>.loop.run(<span class="va">self</span>)</span></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>    ...</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>):</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">self</span>.loop_condition.active():</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>            <span class="va">self</span>.loop.run(<span class="va">self</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>            <span class="bu">print</span>(<span class="ss">f&quot;TODO: run </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>startup_scene<span class="sc">.</span>get_command()<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>It complains that <code>get_command</code> does not exist. Let’s add it:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>    <span class="kw">def</span> get_command(<span class="va">self</span>):</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>        <span class="cf">return</span> [<span class="st">&quot;supertux2&quot;</span>]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>We are now getting a somewhat expected test failure:</p>
<pre class="text"><code>Differences (ndiff with -expected +actual):
    + TODO: run [&#39;supertux2&#39;]
    + TODO: run [&#39;supertux2&#39;]
      GAMELOOP_INIT =&gt;
          resolution: (1280, 720)
          fps: 60
      CLEAR_SCREEN =&gt;</code></pre>
<p>I was thinking to fake this and postpone running the actual command. To do it properly we need an infrastructure wrapper for running commands. I’ll just do it.</p>
<p>Here is a first faked version:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">class</span> Command(Observable):</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>    <span class="kw">def</span> create():</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>        <span class="cf">return</span> Command()</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>    <span class="kw">def</span> create_null():</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>        <span class="cf">return</span> Command()</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, command):</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a>        <span class="va">self</span>.notify(<span class="st">&quot;COMMAND&quot;</span>, {<span class="st">&quot;command&quot;</span>: command})</span></code></pre></div>
<p>Instead of printing the command, it sends a notification so that we can assert that the event happens at the right time in the test. That is, we can assert that a command is run after the game loop is quit:</p>
<pre class="text"><code>...
GAMELOOP_QUIT =&gt;
COMMAND =&gt;
    command: [&#39;supertux2&#39;]
...</code></pre>
<p>This works. Let’s commit:</p>
<pre class="text"><code>$ git commit -a -m &#39;Run command from StartupScene when game loop is quit.&#39;
[main 4c47b18] Run command from StartupScene when game loop is quit.
 1 file changed, 31 insertions(+), 5 deletions(-)</code></pre>
<p>For this to actually do something, we need to flesh out <code>Command</code>. Here is what I end up with:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">class</span> Command(Observable):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; Command.create().run([&quot;echo&quot;, &quot;hello&quot;])</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; Command.create().run([&quot;command-that-does-not-exist&quot;])</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a><span class="co">    Traceback (most recent call last):</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a><span class="co">      ...</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a><span class="co">    FileNotFoundError: [Errno 2] No such file or directory: &#39;command-that-does-not-exist&#39;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; Command.create_null().run([&quot;command-that-does-not-exist&quot;])</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a>    <span class="kw">def</span> create():</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a>        <span class="cf">return</span> Command(subprocess<span class="op">=</span>subprocess)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a>    <span class="kw">def</span> create_null():</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a>        <span class="kw">class</span> NullSubprocess:</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a>            <span class="kw">def</span> run(<span class="va">self</span>, command):</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a>                <span class="cf">pass</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a>        <span class="cf">return</span> Command(subprocess<span class="op">=</span>NullSubprocess())</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, subprocess):</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a>        Observable.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a>        <span class="va">self</span>.subprocess <span class="op">=</span> subprocess</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, command):</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a>        <span class="va">self</span>.notify(<span class="st">&quot;COMMAND&quot;</span>, {<span class="st">&quot;command&quot;</span>: command})</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true"></a>        <span class="va">self</span>.subprocess.run(command)</span></code></pre></div>
<p>When the startup application is run and then quit, SuperTux is actually started.</p>
<p>This is actually some real progress.</p>
<pre class="text"><code>$ git commit -a -m &#39;Command actually runs commands.&#39;
[main 270440e] Command actually runs commands.
 1 file changed, 23 insertions(+), 2 deletions(-)</code></pre>
<h2 id="selection-behavior">Selection behavior</h2>
<p>Let’s review the <code>StartupScene</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    <span class="kw">def</span> get_command(<span class="va">self</span>):</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>        <span class="cf">return</span> [<span class="st">&quot;supertux2&quot;</span>]</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true"></a>        loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">100</span>), text<span class="op">=</span><span class="st">&quot;SuperTux&quot;</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true"></a>        loop.draw_text(Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">200</span>), text<span class="op">=</span><span class="st">&quot;Balloon Shooter&quot;</span>)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true"></a>        loop.draw_circle(Point(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="dv">500</span>), radius<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">&quot;pink&quot;</span>)</span></code></pre></div>
<p>We have higher-level tests in place that checks that whatever <code>get_command</code> returns is run when the game loop quits.</p>
<p>I think it should now be fairly easy to write tests for selection behavior. Let’s first modify the event handler to also exit the game loop when <code>XBOX_A</code> is pressed:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>    ...</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; StartupScene().event(GameLoop.create_event_user_closed_window())</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a><span class="co">        Traceback (most recent call last):</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a><span class="co">          ...</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a><span class="co">        gameloop.ExitGameLoop</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; StartupScene().event(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true"></a><span class="co">        Traceback (most recent call last):</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true"></a><span class="co">          ...</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true"></a><span class="co">        gameloop.ExitGameLoop</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window() <span class="kw">or</span> event.is_joystick_down(XBOX_A):</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span></code></pre></div>
<p>Now let’s think about what <code>get_command</code> should return. It should return the command of the game that is closest to the cursor. Let’s write two tests for that:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>    ...</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>    <span class="kw">def</span> get_command(<span class="va">self</span>):</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; scene = StartupScene()</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; scene.move_cursor(x=100, y=100)</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; scene.get_command()</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true"></a><span class="co">        [&#39;supertux2&#39;]</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true"></a></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; scene.move_cursor(x=100, y=200)</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; scene.get_command()</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true"></a><span class="co">        [&#39;python&#39;, &#39;/home/.../agdpp/agdpp.py&#39;]</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span></code></pre></div>
<p>It complains that <code>move_cursor</code> does not exist. I add it like this:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>        <span class="va">self</span>.cursor <span class="op">=</span> Point(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="dv">500</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>    <span class="kw">def</span> move_cursor(<span class="va">self</span>, x, y):</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a>        <span class="va">self</span>.cursor <span class="op">=</span> Point(x<span class="op">=</span>x, y<span class="op">=</span>y)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>I also modify the drawing code to use this point for the cursor.</p>
<p>Now the second test case fails:</p>
<pre class="text"><code>Failed example:
    scene.get_command()
Differences (ndiff with -expected +actual):
    - [&#39;python&#39;, &#39;/home/.../agdpp/agdpp.py&#39;]
    + [&#39;supertux2&#39;]</code></pre>
<p>I make a quick and dirty fix, because I want to go quickly to green so that I can refactor and generalize the solution:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>    <span class="kw">def</span> get_command(<span class="va">self</span>):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.cursor.y <span class="op">==</span> <span class="dv">200</span>:</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>            <span class="cf">return</span> [<span class="st">&quot;python&quot;</span>, <span class="st">&quot;/home/.../agdpp/agdpp.py&quot;</span>]</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>        <span class="cf">return</span> [<span class="st">&quot;supertux2&quot;</span>]</span></code></pre></div>
<p>And this is my favorite state of programming. This is actually where some design happens. I have the safety net of the tests and I can push code around until I think it looks good and the next thing is easy to add.</p>
<p>Here is what I come up with this time:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>        <span class="va">self</span>.cursor <span class="op">=</span> Point(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="dv">500</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>        <span class="va">self</span>.games <span class="op">=</span> [</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a>            Game(</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a>                name<span class="op">=</span><span class="st">&quot;SuperTux&quot;</span>,</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>                position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">100</span>),</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>                command<span class="op">=</span>[<span class="st">&quot;supertux2&quot;</span>],</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true"></a>            ),</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true"></a>            Game(</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true"></a>                name<span class="op">=</span><span class="st">&quot;Balloon Shooter&quot;</span>,</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true"></a>                position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">200</span>),</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true"></a>                command<span class="op">=</span>[<span class="st">&quot;python&quot;</span>, <span class="st">&quot;/home/.../agdpp/agdpp.py&quot;</span>],</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true"></a>            ),</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true"></a>        ]</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true"></a></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true"></a>    <span class="kw">def</span> get_command(<span class="va">self</span>):</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">min</span>(</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true"></a>            <span class="va">self</span>.games,</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true"></a>            key<span class="op">=</span><span class="kw">lambda</span> game: game.distance_to(<span class="va">self</span>.cursor)</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true"></a>        ).command</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true"></a>        <span class="cf">for</span> game <span class="kw">in</span> <span class="va">self</span>.games:</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true"></a>            game.draw(loop)</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.cursor, radius<span class="op">=</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">&quot;pink&quot;</span>)</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true"></a></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>And here is the <code>Game</code> class:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="kw">class</span> Game:</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, name, position, command):</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>        <span class="va">self</span>.name <span class="op">=</span> name</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>        <span class="va">self</span>.position <span class="op">=</span> position</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a>        <span class="va">self</span>.command <span class="op">=</span> command</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true"></a>        loop.draw_text(<span class="va">self</span>.position, text<span class="op">=</span><span class="va">self</span>.name)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true"></a></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true"></a>    <span class="kw">def</span> distance_to(<span class="va">self</span>, point):</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.position.distance_to(point)</span></code></pre></div>
<p>This implementation still passes all tests and is also generalized. Nice!</p>
<pre class="text"><code>$ git commit -a -m &#39;Run the command closest to the cursor.&#39;
[main 921c71f] Run the command closest to the cursor.
 1 file changed, 64 insertions(+), 7 deletions(-)</code></pre>
<h2 id="cursor-movement">Cursor movement</h2>
<p>Next I want to work on cursor movement so that we can actually select different games.</p>
<p>I’m not quite sure how to write a low-level test for this in <code>GameScene</code>, so I write a top-level test instead:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; StartupApplication.run_in_test_mode(</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_joystick_motion(axis=1, value=1.0)],</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a><span class="co">...     ],</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a><span class="co">...     iterations=1</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a><span class="co">... ).filter(&quot;DRAW_CIRCLE&quot;)</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true"></a><span class="co">    radius: 20</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true"></a><span class="co">    color: &#39;pink&#39;</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true"></a><span class="co">    y: 501</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true"></a><span class="co">    radius: 20</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true"></a><span class="co">    color: &#39;pink&#39;</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We assert that the cursor is drawn in two different positions given a joystick motion event.</p>
<p>The gist of the implementation is here:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>    ...</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a>        ...</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_joystick_motion():</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true"></a>            <span class="cf">if</span> event.get_axis() <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true"></a>                <span class="va">self</span>.dx <span class="op">=</span> event.get_value()</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true"></a>            <span class="cf">elif</span> event.get_axis() <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true"></a>                <span class="va">self</span>.dy <span class="op">=</span> event.get_value()</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true"></a>        delta <span class="op">=</span> Point(x<span class="op">=</span><span class="va">self</span>.dx, y<span class="op">=</span><span class="va">self</span>.dy)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true"></a>        <span class="cf">if</span> delta.length() <span class="op">&gt;</span> <span class="fl">0.05</span>:</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true"></a>            <span class="va">self</span>.cursor <span class="op">=</span> <span class="va">self</span>.cursor.add(delta.times(dt))</span></code></pre></div>
<p>The <code>update</code> method did not exist on <code>StartupScene</code> before. The pattern how it is called is here:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a><span class="kw">class</span> StartupApplication:</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>    ...</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a>        <span class="va">self</span>.startup_scene.event(event)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a>        <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a>        <span class="va">self</span>.startup_scene.update(dt)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a>        <span class="va">self</span>.startup_scene.draw(<span class="va">self</span>.loop)</span></code></pre></div>
<p>So the scene will receive these calls in order:</p>
<ul>
<li><code>event</code></li>
<li><code>update</code></li>
<li><code>draw</code></li>
</ul>
<p>This represents one game loop cycle. If this pattern becomes more permanent, we can move the top-level test down to <code>StartupApplication</code> and have that test call <code>event</code> + <code>update</code> and assert that the cursor moved. But for now, I want the confidence that the high-level test gives, that everything is actually working together.</p>
<p>I also test this in game to fist of all make sure that I got the axis right and also to tweak numbers so that speed feels good. The length check is needed because joystick movement events rarely return a value of 0. If we only move the joystick a tiny bit, we don’t want the cursor to move.</p>
<p>Also, we should probably add constant names for the axis to not compare to numbers. Maybe <code>XBOX_AXIS_Y</code> for example.</p>
<p>Anyway, when I try this out, it actually works. I can move the cursor around, and when I press <code>XBOX_A</code> the game closest to the cursor is started.</p>
<h2 id="finishing-touches">Finishing touches</h2>
<p>I want to visualize the game that is closest to the cursor. Let’s do it with another color.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>    ...</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a>        <span class="cf">for</span> game <span class="kw">in</span> <span class="va">self</span>.games:</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>            game.draw(loop, <span class="va">self</span>.game_closest_to_cursor())</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true"></a>    <span class="kw">def</span> game_closest_to_cursor(<span class="va">self</span>):</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">min</span>(</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true"></a>            <span class="va">self</span>.games,</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true"></a>            key<span class="op">=</span><span class="kw">lambda</span> game: game.distance_to(<span class="va">self</span>.cursor)</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true"></a>        )</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="kw">class</span> Game:</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>    ...</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop, closest):</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a>        loop.draw_text(</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true"></a>            <span class="va">self</span>.position,</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true"></a>            text<span class="op">=</span><span class="va">self</span>.name,</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true"></a>            color<span class="op">=</span><span class="st">&quot;lightblue&quot;</span> <span class="cf">if</span> closest <span class="kw">is</span> <span class="va">self</span> <span class="cf">else</span> <span class="st">&quot;black&quot;</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true"></a>        )</span></code></pre></div>
<p>I modify tests to assert the correct color. This works perfectly.</p>
<p>Next I want to fix the games that are configured. I want them to display evenly on the screen, and I want to have a “QUIT” game that runs a shutdown command to shut down the Pi.</p>
<p>Here it is:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="kw">class</span> StartupScene:</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>        <span class="va">self</span>.cursor <span class="op">=</span> Point(x<span class="op">=</span><span class="dv">400</span>, y<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>        <span class="va">self</span>.games <span class="op">=</span> [</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>            Game(</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>                name<span class="op">=</span><span class="st">&quot;SuperTux&quot;</span>,</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>                position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">100</span>, y<span class="op">=</span><span class="dv">100</span>),</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>                command<span class="op">=</span>[<span class="st">&quot;supertux2&quot;</span>],</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>            ),</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>            Game(</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>                name<span class="op">=</span><span class="st">&quot;Balloon Shooter&quot;</span>,</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true"></a>                position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">400</span>, y<span class="op">=</span><span class="dv">300</span>),</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true"></a>                command<span class="op">=</span>[<span class="st">&quot;python3&quot;</span>, <span class="st">&quot;agdpp.py&quot;</span>],</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true"></a>            ),</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true"></a>            Game(</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true"></a>                name<span class="op">=</span><span class="st">&quot;QUIT&quot;</span>,</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true"></a>                position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">1000</span>, y<span class="op">=</span><span class="dv">600</span>),</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true"></a>                command<span class="op">=</span>[<span class="st">&quot;shutdown&quot;</span>, <span class="st">&quot;now&quot;</span>],</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true"></a>            ),</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true"></a>        ]</span></code></pre></div>
<p>And it looks like this:</p>
<p>
<center>
<img src="final.png" title="fig:" alt="Final startup screen." />
</center>
</p>
<h2 id="trying-on-the-pi">Trying on the Pi</h2>
<p>I change the startup script, <code>/etc/xdg/autostart/game_console_start.desktop</code>, to this:</p>
<pre class="text"><code>[Desktop Entry]
Name=Game console start
Exec=/home/pi/game_console_pc.sh</code></pre>
<p>Where <code>/home/pi/game_console_pc.sh</code> is this:</p>
<pre class="shell"><code>#!/usr/bin/env bash

exec &gt; /home/pi/game_console_pc.log

exec 2&gt;&amp;1

cd /home/pi/agdpp

for retry in 1 2 5 10 giveup; do
	if [ $retry = giveup ]; then
		echo giving up
		break
	elif git pull --ff-only; then
		break
	else
		echo Retrying in $retry
		sleep $retry
	fi
done

python3 startup.py</code></pre>
<p>And it works beautifully.</p>
<p>Why did I not test drive this startup script? Good question. I for sure spend some time debugging the loop, which, by the way, is needed to give the Pi time to connect to the wireless network before it can download the latest version of the startup application and balloon shooter.</p>
<pre class="text"><code>pi@raspberrypi:~ $ cat game_console_pc.log
fatal: unable to access &#39;https://github.com/rickardlindberg/agdpp.git/&#39;: Could not resolve host: github.com
Retrying in 1
fatal: unable to access &#39;https://github.com/rickardlindberg/agdpp.git/&#39;: Could not resolve host: github.com
Retrying in 2
fatal: unable to access &#39;https://github.com/rickardlindberg/agdpp.git/&#39;: Could not resolve host: github.com
Retrying in 5
Already up to date.</code></pre>
<p>I feel like this script is maybe not part of the game itself. So that is one reason why I just “hacked” it together on the Pi. But I’m not entirely happy that it exists only there, and not in some repo, and doesn’t have any tests.</p>
<p>However, for now, it works fine, but there is another problem. It is not possible to quit the balloon shooter with the gamepad. So once you start it, you are stuck in it.</p>
<h2 id="add-balloon-shooter-quit">Add balloon shooter quit</h2>
<p>I modify <code>GameScene</code> by adding a check for <code>XBOX_START</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="kw">class</span> GameScene:</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a>    ...</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window() <span class="kw">or</span> event.is_joystick_down(XBOX_START):</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>And by printing events, I figure out the value of <code>XBOX_START</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>XBOX_START <span class="op">=</span> <span class="dv">7</span></span></code></pre></div>
<h2 id="summary">Summary</h2>
<p>Finally, I have the first version of the setup that I had in mind.</p>
<p>I find it a little difficult to document all my thinking in this DevLog format. I feel like I make hundreds of decisions every minute when programming, and writing about all of them seems impossible. I think one solution would be to cover smaller changes in each DevLog. Your questions and commends are very welcome.</p>
<p>Even if these DevLogs are not valuable to anyone else, they are valuable to me because I get to practice writing and explaining my thinking.</p>
<p>See you next time!</p>
]]></summary>
</entry>
<entry>
    <title>The end?</title>
    <link href="http://rickardlindberg.me/writing/agdpp-the-end/" />
    <id>http://rickardlindberg.me/writing/agdpp-the-end/</id>
    <published>2023-08-21T00:00:00Z</published>
    <updated>2023-08-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>The end?</h1>

<p><em>Published on 21 August 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>When I started this series, my intention was to document my journey of creating a game using agile methods. I think I have mostly succeeded in this regard, but at the moment I’ve done some development that I have not documented. Furthermore, I did that development many months ago, so documenting it gets harder and harder because I forget what I was thinking when I did the development.</p>
<p>Recently though, I’ve experimented with a new format which I call <a href="/tags/devlog/index.html">DevLog</a>. It is basically the same thing but a little less polished. I write a DevLog while doing the development, so there is no risk of falling behind. I write about what is going on in my mind as I do the development. Also, I’m not strict about documenting everything in a DevLog. It’s OK to do something and not write about it.</p>
<p>In this post I will briefly mention the development that I’ve done on the balloon shooter but not documented and then talk a little about future plans for this project.</p>
<h2 id="particle-effects">Particle effects</h2>
<p>I polish the game a little by adding a particle effect system that I use to render a splashing animation when a balloon is hit.</p>
<p>It looks a little something like this (although it is hard to show in a single image):</p>
<p>
<center>
<img src="particles.png" title="fig:" alt="Particles when a balloon is hit." />
</center>
</p>
<p>The most interesting piece of code is this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> get_hit_particles(<span class="va">self</span>):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        number_of_particles <span class="op">=</span> random.randint(<span class="dv">4</span>, <span class="dv">8</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="cf">return</span> [</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>            BalloonParticle(</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>                position<span class="op">=</span><span class="va">self</span>.position.move(</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>                    dx<span class="op">=</span>random.randint(<span class="dv">0</span>, <span class="va">self</span>.radius),</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>                    dy<span class="op">=</span>random.randint(<span class="dv">0</span>, <span class="va">self</span>.radius)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>                ),</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>                radius<span class="op">=</span><span class="va">self</span>.radius<span class="op">*</span>(random.randint(<span class="dv">30</span>, <span class="dv">70</span>)<span class="op">/</span><span class="dv">100</span>),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>                velocity<span class="op">=</span>Angle.fraction_of_whole(random.random()).to_unit_point().times(<span class="va">self</span>.speed<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>            )</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>            <span class="cf">for</span> x</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>            <span class="kw">in</span> <span class="bu">range</span>(number_of_particles)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        ]</span></code></pre></div>
<p>It generates a list of particles when a balloon is hit. The particles have a randomized position, radius, and velocity. The radius keeps decreasing as time passes, and when it reaches a low enough value, the particle is removed.</p>
<p>The complete diff for this change can be seen on <a href="https://github.com/rickardlindberg/agdpp/compare/b5261a939505c203cd1ffb21462a6772f0381faf...7533ec079dbdeba713526469535a1cc0fc915449">GitHub</a>.</p>
<h2 id="sound-effects">Sound effects</h2>
<p>Me and my son record sound effects that are played when a balloon is hit. We go to the store, buy some balloons, rig up the mic, and pop them. It is much fun.</p>
<p>The code for integrating the sound can be seen on <a href="https://github.com/rickardlindberg/agdpp/compare/7533ec079dbdeba713526469535a1cc0fc915449...fcb1757f9b219be55d65d8588c259b96b9dc26ce">GitHub</a>.</p>
<p>This change include adding the <code>load_sound</code> method to <code>GameLoop</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> GameLoop(Observable):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    ...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">def</span> load_sound(<span class="va">self</span>, path):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        <span class="cf">return</span> Sound(<span class="va">self</span>.pygame.mixer.Sound(path))</span></code></pre></div>
<p>Does it really make sense that you load a sound from the game loop? I’m not sure. The game loop is the only abstraction that we have for accessing pygame. That’s why it ended up there. But the design here feels a little off to me. Something to keep in mind for the future. Next time we touch this area of the code, we might feel the same thing again and have an idea about how to improve.</p>
<h2 id="medals">Medals</h2>
<p>When I ask my son what he wants the game to do next, he says that he wants to get a medal for every 100 balloon that you shoot down.</p>
<p>I add a fun little particle effect again for the animation when you get a medal:</p>
<p>
<center>
<img src="medal1.png" title="fig:" alt="Medal animation." />
</center>
</p>
<p>The medals stack up in the upper left corner like this:</p>
<p>
<center>
<img src="medal2.png" title="fig:" alt="Medals stacking up." />
</center>
</p>
<p>The complete diff for this change can be seen on <a href="https://github.com/rickardlindberg/agdpp/compare/fcb1757f9b219be55d65d8588c259b96b9dc26ce...0c8e713a6d938898ddb92164cc86dcb1db19aa0c">GitHub</a>.</p>
<h2 id="test-scene">Test scene</h2>
<p>Testing the medal particle effect is tedious. You have to shoot down 100 balloons, then you can see the effect for a split second, and then you have to shoot down 100 more.</p>
<p>When I have done that enough times, I come up with a better idea. And that is to allow the game to be started in “test mode” where we can trigger the animation with a press of a button.</p>
<p>We can do it like this:</p>
<pre class="text"><code>$ ./make.py rundev test-scene-score</code></pre>
<p>Instead of starting the game, it starts a test scene:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="cf">if</span> sys.argv[<span class="dv">1</span>:] <span class="op">==</span> [<span class="st">&quot;test-scene-score&quot;</span>]:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        scene <span class="op">=</span> TestSceneScore()</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        scene <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    BalloonShooter.create(scene).run()</span></code></pre></div>
<p>This test scene is only used for test purposes and looks like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> TestSceneScore:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        <span class="va">self</span>.score <span class="op">=</span> Score()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown(KEY_SPACE):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>            <span class="va">self</span>.score.add_points(<span class="dv">100</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        <span class="va">self</span>.score.update(dt)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>        <span class="va">self</span>.score.draw(loop)</span></code></pre></div>
<p>It uses the score object (which is used in the real game) and adds 100 points when we press the space key.</p>
<p>It looks like this:</p>
<p>
<center>
<img src="test-scene.png" title="fig:" alt="Test scene." />
</center>
</p>
<p>This way, I can quickly exercise the animation and validate that it looks good.</p>
<h2 id="future-plans">Future plans</h2>
<p>This project has been inactive for a few months. With my hobby projects, I follow my interest. And my interest has lately been about writing my own <a href="/projects/rlvideo/index.html">video editor</a>. And also, after the medals in place, my son said that the game was finished.</p>
<p>However, right now, I have two ideas that I’m interested in doing. One is trying a decentralized design that <a href="https://www.ronjeffries.com/categories/python/">Ron</a> has been writing about and doing in his Asteroids Python series.</p>
<p>Another is to create a “game console PC” where I customize this game to first show a start screen where the game to play can be selected. One game will be the balloon shooter. Another will be <a href="https://www.supertux.org/">SuperTux</a> (which me and my son have played a lot).</p>
<h2 id="summary">Summary</h2>
<p>This post probably marks the end of this series in the current format. When I continue this project, it will be in the form of a <a href="/tags/devlog/index.html">DevLog</a>. See you there!</p>
]]></summary>
</entry>
<entry>
    <title>Multiplayer</title>
    <link href="http://rickardlindberg.me/writing/agdpp-multiplayer/" />
    <id>http://rickardlindberg.me/writing/agdpp-multiplayer/</id>
    <published>2023-06-29T00:00:00Z</published>
    <updated>2023-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Multiplayer</h1>

<p><em>Published on 29 June 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>For every story that we work on, the balloon shooter feels more and more like a real game. The initial goal of this project was to create a game that me and my son will enjoy playing <em>together</em>. At this point, I think the most valuable thing we can work on towards that goal is adding support for multiplayer. So that’s the topic for this episode.</p>
<h2 id="a-new-layer">A new layer</h2>
<p>The entry point for the balloon shooter looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    BalloonShooter.create().run()</span></code></pre></div>
<p>The balloon shooter class instantiates a game scene which implements the logic of our game:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, loop):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        ...</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>        <span class="va">self</span>.game_scene <span class="op">=</span> GameScene(Rectangle.from_size(<span class="op">*</span><span class="va">self</span>.resolution))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>        <span class="va">self</span>.game_scene.update(dt)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>        <span class="va">self</span>.game_scene.draw(<span class="va">self</span>.loop)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>This means that as soon as we start the game, we enter the gameplay mode and can start playing right away.</p>
<p>I imagine that multiplayer mode works by first selecting which players should participate in shooting balloons, and after that, the gameplay mode is entered and each player gets their own bow to shoot with.</p>
<p>We want to go from this structure:</p>
<pre class="text"><code>BalloonShooter
    GameScene</code></pre>
<p>To something like this:</p>
<pre class="text"><code>BalloonShooter
    NewGameScene
        StartScene
        GameScene</code></pre>
<p>We want to add another level that first directs calls to a start scene (or player select scene) and once players are selected, initializes the game scene and directs call to that.</p>
<p>The current tests for <code>GameScene</code> should pass unchanged, but tests for <code>BalloonShooter</code> will need some modifications. I imagine that those tests need to select a player before asserting something from the gameplay mode. We’ll see later.</p>
<h2 id="refactor-to-new-structure">Refactor to new structure</h2>
<p>Let’s start by slowly and carefully refactor towards this new structure, using our tests as a safety net to give us feedback about how we’re doing.</p>
<p>I want to call the new layer <code>GameScene</code>, but that name is already taken. The current game scene is really the gameplay scene, so we rename it to that. Then we create the new game scene which just forwards its calls to the gameplay scene:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> GameScene:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, screen_area):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        <span class="va">self</span>.gameplay <span class="op">=</span> GameplayScene(screen_area<span class="op">=</span>screen_area)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="va">self</span>.gameplay.event(event)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>        <span class="va">self</span>.gameplay.update(dt)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        <span class="va">self</span>.gameplay.draw(loop)</span></code></pre></div>
<p>We insert this new layer in <code>BalloonShooter</code> like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">@@ -113,7 +113,7 @@ class BalloonShooter:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>     def __init__(self, loop):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>         self.loop = loop</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>         self.resolution = (1280, 720)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="st">-        self.game_scene = GameplayScene(Rectangle.from_size(*self.resolution))</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="va">+        self.game_scene = GameScene(screen_area=Rectangle.from_size(*self.resolution))</span></span></code></pre></div>
<p>The new layer is now added, all tests are passing, and we have a point in our code (<code>GameScene</code>) where we can put functionality to choose between a start scene and a gameplay scene.</p>
<p>Before we can work on that behavior, we need a start scene.</p>
<h2 id="start-scene">Start scene</h2>
<p>We write the initial version of the start scene like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> StartScene(SpriteGroup):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">    I report players when on player has shot twice:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start = StartScene(screen_area=Rectangle.from_size(500, 500))</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.get_players() is None</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.event(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.update(0)</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.get_players() is None</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.event(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.update(0)</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; start.get_players()</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="co">    [&#39;one&#39;]</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, screen_area):</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        <span class="va">self</span>.input_handler <span class="op">=</span> InputHandler()</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>        <span class="va">self</span>.shots <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.action(event)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a>        SpriteGroup.update(<span class="va">self</span>, dt)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a>        <span class="va">self</span>.shots <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a>    <span class="kw">def</span> get_players(<span class="va">self</span>):</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.shots <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a>            <span class="cf">return</span> [<span class="st">&quot;one&quot;</span>]</span></code></pre></div>
<p>The idea is that a player (keyboard or gamepad) selects to be part of the game by shooting. When all players have entered, one of them can shoot again to start the game. This functionality is not yet fully implemented above. But this will do for now.</p>
<p>When writing this blog post and looking at the code, I notice two problems. First of all “on” should be “one” in the test description. Second of all, the implementation does not check events at all, so if the test does not simulate any events, it will still pass. If we were to take this start scene into play now, we just need to wait for two iterations (2/60th of a second) and it would report players <code>['one']</code>. That does not seem correct.</p>
<p>Let’s fix that. We modify the test to do two updates and the assertions should be the same:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.event(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.update(0)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.update(0)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.get_players() is None</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.event(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.update(0)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.update(0)</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.get_players()</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="co">[&#39;one&#39;]</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>I wonder how common the event + update pattern is in our tests. Perhaps we can benefit from a test helper something like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">def</span> cycle(sprite, events<span class="op">=</span>[], dt<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>        sprite.event(event)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    sprite.update(dt)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    sprite.update(dt)</span></code></pre></div>
<p>We might try it in a few places and see if the tests read better. But not now. The modification to the tests forces us to check events. We do it like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">class</span> StartScene(SpriteGroup):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        SpriteGroup.update(<span class="va">self</span>, dt)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.update(dt)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.input_handler.get_shoot():</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>            <span class="va">self</span>.shots <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>With that fix out of the way, let’s work on integrating the start scene.</p>
<h2 id="take-start-scene-into-play">Take start scene into play</h2>
<p>The game scene currently forwards all calls to the gameplay scene. To take the start scene into play, we first want the start scene to be active, and have the game scene forward calls to it. Once players have been selected, we want the game scene to switch the active scene to the gameplay scene.</p>
<p>We express that in the following test:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> GameScene:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="co">    Initially, I draw the start scene:</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game = GameScene(screen_area=Rectangle.from_size(500, 500))</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; isinstance(game.active_scene, StartScene)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="co">    When players have been selected, I draw the gameplay scene:</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game.event(GameLoop.create_event_keydown(KEY_SPACE))</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game.update(0)</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; isinstance(game.active_scene, StartScene)</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game.event(GameLoop.create_event_keydown(KEY_SPACE))</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game.update(0)</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; isinstance(game.active_scene, StartScene)</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a><span class="co">    False</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span></code></pre></div>
<p>This is an example of an overlapping, sociable test. To make the scene switch happen, we need <code>StartScene.get_players</code> to return something. Since the game scene uses the real start scene, and not a mock, the only way to make it return something is to perform the same actions as we did in the start scene tests.</p>
<p>To make this test pass, we initialize an active scene variable to the start scene and switch it to the gameplay scene once we have selected players:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> GameScene:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, screen_area):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>        <span class="va">self</span>.screen_area <span class="op">=</span> screen_area</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>        <span class="va">self</span>.active_scene <span class="op">=</span> StartScene(screen_area<span class="op">=</span><span class="va">self</span>.screen_area)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>        <span class="va">self</span>.active_scene.update(dt)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.active_scene, StartScene):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>.active_scene.get_players():</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>                <span class="va">self</span>.active_scene <span class="op">=</span> GameplayScene(screen_area<span class="op">=</span><span class="va">self</span>.screen_area)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>The test talks about switching to a gameplay scene, but it only asserts that the start scene is <em>not</em> active anymore. We could probably clarify that.</p>
<p>I’m also not sure how I feel about the assertions that checks the type of the active scene. But I don’t have any ideas for a better way to express that. If you do, please let me know.</p>
<p>When we run the game now, it shows a blank purple screen. If we shoot twice we enter the gameplay scene and the game starts as before. Perfect!</p>
<p>We do not yet take players into account and we can still not have multiple players. What we do have is a skeleton with a few more places where this new functionality can be added.</p>
<p>The game works fine now (if we know that we have to shoot twice to get passed the start scene), but a test fails. It is the test for the balloon shooter. Here it is:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="co">    We run the game for a few frames, then quit:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="co">    ...     events=[</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="co">    ...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a><span class="co">    ...     ]</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a><span class="co">    ... )</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a><span class="co">    The game loop is initialized and cleaned up:</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; events.filter(&quot;GAMELOOP_INIT&quot;, &quot;GAMELOOP_QUIT&quot;)</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a><span class="co">    GAMELOOP_INIT =&gt;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a><span class="co">        resolution: (1280, 720)</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a><span class="co">        fps: 60</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a><span class="co">    GAMELOOP_QUIT =&gt;</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a><span class="co">    ...</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span></code></pre></div>
<p>This test is at the outermost level, so it includes all objects. Before, the gameplay scene received the events from the test, but now the start scene receives them. The start scene does not handle the user closed window event which results in this test just hanging.</p>
<p>That failure teaches us that we can’t quit the application when we are in the start scene, only when we are in the gameplay scene. That is probably not correct. Thank you test for pointing that out. However, the assertions that follow check for example that a balloon is drawn, so the test expects to be in the gameplay mode. We modify the test to include two shoot events so that we end up in the gameplay scene:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_keydown(KEY_SPACE)],</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_keydown(KEY_SPACE)],</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>And, we are back to green!</p>
<p>Here is yet another example of overlapping, sociable testing. We yet again have to simulate two shoot events to select players.</p>
<p>One downside of this approach is that if we were to change the logic for selecting players, say that we first need to shoot and then turn left, then we would have to modify three test I think. One way to make that less of a problem in this particular situation is to create a test helper something like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">def</span> events_to_select_one_player():</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="cf">return</span> [</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>        GameLoop.create_event_keydown(KEY_SPACE),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>        GameLoop.create_event_keydown(KEY_SPACE),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    ]</span></code></pre></div>
<p>We could use that test helper in all tests (with some modification) and now there is only one place in the tests that knows about what events that gets us from the start scene to the gameplay scene with one player.</p>
<h2 id="pass-players-to-game-scene">Pass players to game scene</h2>
<p>Our skeleton for the new feature is not quite complete. The gameplay scene does not know about players. Let’s fix that by passing the players from the start scene to the gameplay scene like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="dt">@@ -162,7 +162,10 @@ class GameScene:</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>         self.active_scene.update(dt)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>         if isinstance(self.active_scene, StartScene):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>             if self.active_scene.get_players():</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span class="st">-                self.active_scene = GameplayScene(screen_area=self.screen_area)</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="va">+                self.active_scene = GameplayScene(</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a><span class="va">+                    screen_area=self.screen_area,</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a><span class="va">+                    players=self.active_scene.get_players()</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a><span class="va">+                )</span></span></code></pre></div>
<p>To make this work we also add that argument to the constructor of the gameplay scene:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="dt">@@ -333,11 +336,13 @@ class GameplayScene(SpriteGroup):</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>     []</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>     &quot;&quot;&quot;</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="st">-    def __init__(self, screen_area, balloons=[], arrows=[]):</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="va">+    def __init__(self, screen_area, balloons=[], arrows=[], players=[&quot;default&quot;]):</span></span></code></pre></div>
<p>Now, I think our skeleton is complete. What do I mean by that? I mean that all the pieces are connected they way we think they should be. Now we can work individually on the start scene and the gameplay scene. The start scene needs to be able to select multiple players and should return those players in the list. The gameplay scene should take players into account and create one bow per player that it can control.</p>
<h2 id="make-input-handler-player-aware">Make input handler player aware</h2>
<p>The start scene uses the input handler’s <code>get_shoot</code> to detect shots:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">class</span> StartScene(SpriteGroup):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    ...</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>        SpriteGroup.update(<span class="va">self</span>, dt)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.update(dt)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.input_handler.get_shoot():</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>            <span class="va">self</span>.shots <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div>
<p>However, to select multiple players, the start scene must know <em>who</em> shot. Let’s modify the input handler to support that. We write this test:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i = InputHandler()</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(0)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shots()</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="co">[]</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.event(GameLoop.create_event_keydown(KEY_SPACE))</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.event(GameLoop.create_event_joystick_down(XBOX_A, instance_id=7))</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(0)</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shots()</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="co">[&#39;keyboard&#39;, &#39;joystick7&#39;]</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(0)</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shots()</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a><span class="co">[]</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We create a new <code>get_shots</code> method that returns a list of player/input identifiers. If the shot is triggered by the keyboard, the player identifier is <code>keyboard</code>. If the shot is triggered by a gamepad, the player identifier is <code>joystick</code> plus the unique id of that joystick. We implement it like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">class</span> InputHandler:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>        <span class="va">self</span>.shots_triggered <span class="op">=</span> []</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>        ...</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>        <span class="cf">if</span> event.is_keydown(KEY_SPACE):</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>            <span class="va">self</span>.shots_triggered.append(<span class="st">&quot;keyboard&quot;</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_joystick_down(XBOX_A):</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>            <span class="va">self</span>.shots_triggered.append(<span class="va">self</span>.joystick_id(event))</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>        ...</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>    <span class="kw">def</span> joystick_id(<span class="va">self</span>, event):</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>        <span class="cf">return</span> <span class="ss">f&quot;joystick</span><span class="sc">{</span>event<span class="sc">.</span>get_instance_id()<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>        <span class="va">self</span>.shots <span class="op">=</span> <span class="va">self</span>.shots_triggered</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>        <span class="va">self</span>.shots_triggered <span class="op">=</span> []</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>        ...</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>    <span class="kw">def</span> get_shots(<span class="va">self</span>):</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.shots</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>    ...</span></code></pre></div>
<h2 id="start-scene-returns-players">Start scene returns players</h2>
<p>Now, let’s see if we can make <code>StartScene.get_players</code> to return actual player identifiers instead of hard coded <code>['one']</code>. As usual, we start with a test:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start = StartScene(screen_area=Rectangle.from_size(500, 500))</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.get_players() is None</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.event(GameLoop.create_event_joystick_down(XBOX_A, instance_id=7))</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.event(GameLoop.create_event_joystick_down(XBOX_A, instance_id=7))</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.update(0)</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; start.get_players()</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a><span class="co">[&#39;joystick7&#39;]</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We make the test pass like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">class</span> StartScene(SpriteGroup):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, screen_area):</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>        ...</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>        <span class="va">self</span>.pending_players <span class="op">=</span> []</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>        <span class="va">self</span>.players <span class="op">=</span> <span class="va">None</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>        ...</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>        <span class="cf">for</span> player <span class="kw">in</span> <span class="va">self</span>.input_handler.get_shots():</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>            <span class="cf">if</span> player <span class="kw">in</span> <span class="va">self</span>.pending_players:</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>                <span class="va">self</span>.players <span class="op">=</span> <span class="va">self</span>.pending_players</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a>                <span class="va">self</span>.pending_players.append(player)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>    <span class="kw">def</span> get_players(<span class="va">self</span>):</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.players</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a>    ...</span></code></pre></div>
<h2 id="multiple-bows-in-game-scene">Multiple bows in game scene</h2>
<p>At this point, the start scene returns a correct list of players selected and the only piece missing is for the gameplay scene to create multiple bows and direct events to the correct bow.</p>
<p>Instead of having just a single bow, we create multiple bows like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="st">-        self.bow = self.add(Bow())</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="va">+        self.bows = {}</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="va">+        bow_position = self.screen_area.bottomleft.move(dy=-120)</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="va">+        bow_increment = self.screen_area.width / (len(players)+1)</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="va">+        for player in players:</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a><span class="va">+            bow_position = bow_position.move(dx=bow_increment)</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a><span class="va">+            self.bows[player] = self.add(Bow(position=bow_position))</span></span></code></pre></div>
<p>Then we forward events to the correct bow like this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="st">-        if self.input_handler.get_shoot():</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="st">-            self.flying_arrows.add(self.bow.shoot())</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="st">-        self.bow.turn(self.input_handler.get_turn_angle())</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="va">+        for player in self.input_handler.get_shots():</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="va">+            self.flying_arrows.add(self.bow_for_player(player).shoot())</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a><span class="va">+        for player, turn_angle in self.input_handler.get_turn_angles().items():</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="va">+            self.bow_for_player(player).turn(turn_angle)</span></span></code></pre></div>
<p>Here we use <code>InputHandler.get_turn_angles</code> to get turn angles per player. It is implemented similarly to how we implemented <code>InputHandler.get_shots</code>.</p>
<p>To get the correct bow, we use this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">def</span> bow_for_player(<span class="va">self</span>, player):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    <span class="cf">for</span> input_id, bow <span class="kw">in</span> <span class="va">self</span>.bows.items():</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>        <span class="cf">if</span> input_id <span class="op">==</span> player:</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>            <span class="cf">return</span> bow</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    <span class="cf">return</span> bow</span></code></pre></div>
<p>If no player is found, the last bow is returned. So if you attach another gamepad after the gameplay mode has entered, it will control the last bow. Not sure if that is right. We’ll have to ask our product owner.</p>
<p>We didn’t write any tests for this new behavior. We do have tests that check that a single player can shoot and turn. That gives us confidence that the new for loops work. There could be an error in <code>bow_for_player</code> so that an input event controls the wrong bow. The tests would not catch that. But I find that unlikely, and I’m not worried about it happening.</p>
<h2 id="end-result">End result</h2>
<p>If we start the game now, we are greeted, again, with a blank purple screen:</p>
<p>
<center>
<img src="empty-start.png" title="fig:" alt="Empty start scene." />
</center>
</p>
<p>If we shoot once with the keyboard, then twice with the gamepad, we are taken to this scene where the keyboard and the gamepad can control their own bow:</p>
<p>
<center>
<img src="multiplayer-first.png" title="fig:" alt="First version of multiplayer." />
</center>
</p>
<p>And we have the first version of a working multiplayer mode!</p>
<h2 id="polishing">Polishing</h2>
<p>An empty start scene does not feel polished. Let’s add some instructions to inform players how to get passed it. It mostly involves doing <code>loop.draw_text</code> in the draw method. Not very interesting. However, let’s also add some animated balloons in the background to make the scene a little more interesting. Thanks to the extraction of <code>Balloons</code> that we did in the <a href="/writing/agdpp-spawn-multiple-balloons/index.html">previous</a> episode, we can do this with the following lines:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">class</span> StartScene(SpriteGroup):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, screen_area):</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>        positions <span class="op">=</span> [</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>            Point(</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>                x<span class="op">=</span>screen_area.get_random_x(),</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>                y<span class="op">=</span>random.randint(screen_area.topleft.y, screen_area.bottomright.y)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>            )</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a>            <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">15</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>        ]</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>        <span class="va">self</span>.add(Balloons(</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>            positions<span class="op">=</span>positions,</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>            number_of_balloons<span class="op">=</span><span class="bu">len</span>(positions),</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>            screen_area<span class="op">=</span>screen_area</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a>        ))</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>        ...</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>I really should have created <code>screen_area.get_random_x()</code> or even <code>screen_area.get_random_position()</code>. But I got carried away and wanted a result quickly. We add a note about that and might address it in a future refactoring.</p>
<p>Anyway, here is the final result of the start scene:</p>
<p>
<center>
<img src="start-instructions.png" title="fig:" alt="Start scene with instructions." />
</center>
</p>
<p>Here we have selected two players: one with the keyboard and one with a gamepad. If any of them shoot again, we enter the gameplay mode, or we can continue to add players by shooting with a different gamepad.</p>
<p>As a final polish we will make different players have different colors. The result:</p>
<p>
<center>
<img src="multiplayer-colors.png" title="fig:" alt="Players with different colors." />
</center>
</p>
<h2 id="a-reflection-on-stories">A reflection on stories</h2>
<p>How many stories have we worked on in this episode?</p>
<p>Well, we have added support for multiplayer, isn’t that just one story?</p>
<p>But we also did some polishing. Polishing could easily be its own story. Polish adds value to the players of the game.</p>
<p>So the stories might be</p>
<ul>
<li>Add multiplayer support</li>
<li>Nicer looking, more informative start scene</li>
<li>Different player colors</li>
</ul>
<p>The first one is a lot bigger than the others. Is it possible to split it so that all stories that we work on have roughly the same size? I’m not sure. Let’s think about it.</p>
<p>Let’s think about the state that the game was in when we had a start scene but the players could not be selected. We had visible change in behavior. There was now a start scene that wasn’t there before. But had we added value? Players expecting multiplayer would be disappointed. Other players would have to shoot a couple of times extra before they can play the game. That doesn’t seem like value. However, players could see this new start scene and ask questions like “what is this?” and “what am I supposed to do here?” We can tell them our idea and they can give us feedback if we are on the right track. Perhaps they want to start a multiplayer session in a different way? Perhaps they think a descriptive text on the start scene is more important? That feedback has value.</p>
<p>So we could at least split the first story into two:</p>
<ul>
<li>Player selection start scene</li>
<li>One bow per player</li>
</ul>
<p>As long as we can show visible progress, I think the story has value.</p>
<h2 id="summary">Summary</h2>
<p>With the new start scene and multiplayer mode, the balloon shooter feels even more like a real game. I find myself wanting to go play the game and enjoy what we have created. That is a really nice feeling.</p>
<p>I am a bit surprised what you can achieve with the only graphics primitives being circles and text. I mean, the look of the game is pretty bad, the colors are horrible, and yet the idea comes across nicely and game mechanics can be felt anyway. I wonder how much of an improvement it would be to improve graphics. Probably a lot. But I am still surprised how far circles and text have taken us.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Spawn multiple balloons</title>
    <link href="http://rickardlindberg.me/writing/agdpp-spawn-multiple-balloons/" />
    <id>http://rickardlindberg.me/writing/agdpp-spawn-multiple-balloons/</id>
    <published>2023-06-17T00:00:00Z</published>
    <updated>2023-06-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Spawn multiple balloons</h1>

<p><em>Published on 17 June 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>We <a href="/writing/agdpp-game-over/index.html">previously</a> had a story about balloons moving downwards. We scratched that because other stories were more important for the first version of the balloon shooter. With those stories done, I think a more realistic balloon spawning and movement pattern is the most valuable thing we can work on.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/unYD_bPyadc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="code-review">Code review</h2>
<p>Let’s review our code and look at how balloons are managed.</p>
<p>Our game scene has a sprite group for balloons which by default contains only one balloon:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, balloons<span class="op">=</span>[(<span class="dv">50</span>, <span class="dv">50</span>)], ...):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        ...</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="va">self</span>.balloons <span class="op">=</span> <span class="va">self</span>.add(SpriteGroup([</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>            Balloon(Point(x<span class="op">=</span>x, y<span class="op">=</span>y)) <span class="cf">for</span> (x, y) <span class="kw">in</span> balloons</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>        ]))</span></code></pre></div>
<p>This sprite group is modified in the <code>update</code> method if an arrows hits a balloon:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    ...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        ...</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="cf">for</span> arrow <span class="kw">in</span> <span class="va">self</span>.flying_arrows.get_sprites():</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>            ...</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>            <span class="cf">for</span> balloon <span class="kw">in</span> <span class="va">self</span>.balloons.get_sprites():</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>                <span class="cf">if</span> arrow.hits_baloon(balloon):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>                    <span class="va">self</span>.balloons.remove(balloon)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>                    <span class="va">self</span>.balloons.add(Balloon(position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">50</span>, y<span class="op">=</span><span class="dv">50</span>)))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>                    ...</span></code></pre></div>
<p>So the hit balloon is removed, and a new one is added.</p>
<p>How do balloons move?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    ...</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, position, radius<span class="op">=</span><span class="dv">40</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        <span class="va">self</span>.position <span class="op">=</span> position</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="va">self</span>.radius <span class="op">=</span> radius</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.position.x <span class="op">&gt;</span> <span class="dv">1200</span>:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>            <span class="va">self</span>.position <span class="op">=</span> <span class="va">self</span>.position.<span class="bu">set</span>(x<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>            <span class="va">self</span>.position <span class="op">=</span> <span class="va">self</span>.position.move(dx<span class="op">=</span>dt<span class="op">*</span><span class="fl">0.3</span>)</span></code></pre></div>
<p>They move from left to right and wrap around at x=1200.</p>
<h2 id="strategy">Strategy</h2>
<p>To be able to write more isolated tests for balloon behavior, I want to start with a few refactorings. I want to extract a <code>Balloons</code> class which contains most logic related to balloons. Then I want to write tests for new behavior. This is also known as make the change easy, then make the easy change.</p>
<p>We begin by creating the class and using it like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="st">-        self.balloons = self.add(SpriteGroup([</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="st">-            Balloon(Point(x=x, y=y)) for (x, y) in balloons</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="st">-        ]))</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="va">+        self.balloons = self.add(Balloons(balloons))</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> Balloons(SpriteGroup):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, positions):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>, [</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>            Balloon(Point(x<span class="op">=</span>x, y<span class="op">=</span>y)) <span class="cf">for</span> (x, y) <span class="kw">in</span> positions</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        ])</span></code></pre></div>
<p>We continue to move some behavior into this new class:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">class</span> Balloons(SpriteGroup):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    ...</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="kw">def</span> get_balloon_hit_by_arrow(<span class="va">self</span>, arrow):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        <span class="cf">for</span> balloon <span class="kw">in</span> <span class="va">self</span>.get_sprites():</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>            <span class="cf">if</span> arrow.hits_baloon(balloon):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>                <span class="cf">return</span> balloon</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    <span class="kw">def</span> spawn_new(<span class="va">self</span>):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span class="va">self</span>.add(Balloon(position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">50</span>, y<span class="op">=</span><span class="dv">50</span>)))</span></code></pre></div>
<p>With that in place, we can simplify the update code like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="st">-            for balloon in self.balloons.get_sprites():</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="st">-                if arrow.hits_baloon(balloon):</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="st">-                    self.balloons.remove(balloon)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="st">-                    self.balloons.add(Balloon(position=Point(x=50, y=50)))</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="st">-                    self.score.add(1)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="va">+            hit_balloon = self.balloons.get_balloon_hit_by_arrow(arrow)</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="va">+            if hit_balloon:</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="va">+                self.balloons.remove(hit_balloon)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="va">+                self.balloons.spawn_new()</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="va">+                self.score.add(1)</span></span></code></pre></div>
<p>There is probably some more functionality that we can move into the new balloons class, but let’s stop here for now and focus on the new behavior.</p>
<p>(If you want to see this refactoring happening in smaller steps and in real time, check out the video version.)</p>
<h2 id="stories">Stories</h2>
<p>Here is some new behavior that we would like to have:</p>
<ul>
<li>balloons move downwards</li>
<li>balloons appear at different x positions</li>
<li>multiple balloons are in the air at the same time</li>
</ul>
<p>Let’s start with the first one and write a test for the new movement pattern:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> Balloons(SpriteGroup):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; balloons = Balloons([(50, 50)])</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; balloons.get_sprites()[0].get_position()</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="co">    (50, 50)</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; balloons.update(5)</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; x, y = balloons.get_sprites()[0].get_position()</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; x</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="co">    50</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; y &gt; 50</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>First we make sure that the first balloon in the sprite group is at the initial position that we gave it. Then we assert that it has moved downward after an update.</p>
<p>To make this test pass, we make this change:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a> class Balloon:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>     ...</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>     def update(self, dt):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="st">-       if self.position.x &gt; 1200:</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="st">-           self.position = self.position.set(x=50)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="st">-       else:</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="st">-           self.position = self.position.move(dx=dt*0.3)</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="va">+       self.position = self.position.move(dy=dt*self.speed)</span></span></code></pre></div>
<p>We only needed to modify the <code>Balloon</code> class. Does that mean that we should put the test in this class instead? I don’t know. For now, I think it’s nice if we can keep all balloon related tests in the same place.</p>
<p>If we run the game now, a single balloon will move downwards and then disappear at the bottom of the screen. That’s no fun. No more balloon to shoot down. Let’s fix that.</p>
<p>Here is a test that checks that there are always 3 balloons in the air:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; balloons = Balloons([(50, 50)], space)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(balloons.get_sprites())</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; balloons.update(5)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(balloons.get_sprites())</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="co">3</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We make this pass by adding spawn logic in the update method:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> Balloons(SpriteGroup):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    ...</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>        SpriteGroup.update(<span class="va">self</span>, dt)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>        <span class="cf">while</span> <span class="bu">len</span>(<span class="va">self</span>.get_sprites()) <span class="op">&lt;</span> <span class="dv">3</span>:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>            <span class="va">self</span>.spawn_new()</span></code></pre></div>
<p>As long as we shoot down balloons, new ones will be spawned. But if we miss three balloons, they will continue to move downwards outside the screen, and no new balloons will be spawned. Let’s work on removing balloons outside the screen.</p>
<p>Here is a test describing this behavior:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; space = OutsideScreenSpace(500, 500)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; balloons = Balloons([(1000, 1000)], space)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; (balloon,) = balloons.get_sprites()</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; balloons.update(5)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; balloon in balloons.get_sprites()</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="co">False</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>The idea is that we place a balloon outside the screen. Then we call update and make sure that it is no longer in the sprite group.</p>
<p>We have used the <code>OutsideScreenSpace</code> before to remove arrows that are outside the screen. When we add it here to <code>Balloons</code> we have to update all instantiations of it to include it. Once that is done, we make the test pass like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a> class Balloons(SpriteGroup):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>     ...</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>     def update(self, dt):</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>         SpriteGroup.update(self, dt)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="va">+        for balloon in self.get_sprites():</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="va">+            if self.space.hits(Point(*balloon.get_position()), 10):</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="va">+                self.remove(balloon)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>         while len(self.get_sprites()) &lt; 3:</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>             self.spawn_new()</span></code></pre></div>
<p>The game now plays without problems, however, it’s a little boring that balloons are always spawned at the same position.</p>
<p>We modify the spawning code like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a> class Balloons(SpriteGroup):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>     ...</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>     def spawn_new(self):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="st">-        self.add(Balloon(position=Point(x=50, y=50)))</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="va">+        self.add(Balloon(position=Point(x=self.space.get_random_x(50), y=50)))</span></span></code></pre></div>
<p>And add the corresponding method in <code>OutsideScreenSpace</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> OutsideScreenSpace:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    ...</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    <span class="kw">def</span> get_random_x(<span class="va">self</span>, margin):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>        <span class="cf">return</span> random.randint(margin, <span class="va">self</span>.width<span class="op">-</span>margin<span class="op">*</span><span class="dv">2</span>)</span></code></pre></div>
<p>We don’t write any tests for this. Why? I guess because I feel confident that this will work. And maybe because testing random is not straight forward. Perhaps we should add a test for <code>get_random_x</code> that checks that the x we get back is within the width minus margin. We make a note of that.</p>
<p>Here is what the game looks like now:</p>
<p>
<center>
<img src="multiple-balloons.png" title="fig:" alt="Multiple balloons." />
</center>
</p>
<p>We have accomplished what we set out to do. I think the game is a little more fun to play now. Success!</p>
<h2 id="summary">Summary</h2>
<p>We began by doing some refactoring to make the new behavior easy to add. It was easy to add and it went smoothly. However, after adding new functionality and working with an area of the code, we have probably noticed things that can improve. We might even have ignored it to focus on adding the new behavior.</p>
<p>What I like to do in those situations is to take a break and come back and review the code a little later.</p>
<p>This time I came up with many small changes to improve the clarity of the code. Here are some examples from that session:</p>
<ul>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/782cda7032896b15d89058b0fe3bc4ccbb54da8c">Replace (x, y) with position in Arrow and Balloon.</a></li>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/7d6c884d727bef96b1efcc524e4c8956cfd41c72">Move balloon space hit check to balloon where radius can be used for better hit test.</a></li>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/fe4b477a7ad4c89a56af58dceac84cfc100b2f8f">Replace OutsideScreenSpace with a more generic Rectangle.</a></li>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/c4f8ff4924f1ee4a83ece0d0360ed44e512af194">Make spawning unaware of where its region is (no hard coded y=50).</a></li>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/7faddca9ad82c1bde8d6ea0d00bbbc8cfb5d6fbf">No need to spawn balloon when shot down since it happens anyway.</a></li>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/19e51efe110e81e398a5f9a7401608f870afb4ff">Balloons positions are points instead of tuples.</a></li>
<li><a href="https://github.com/rickardlindberg/agdpp/commit/18a9a5af49966f9b2c7e8841495687181e7fedfb">Clean up shooting arrow tests.</a></li>
</ul>
<p>Making these tiny improvements feels so good. They are all quite small changes, but they make a huge impact. Ok, maybe not huge, but the improvements compound. The point is that if you keep making tiny improvements, the code base gets easier and easier to work with.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Does TDD work when building a game?</title>
    <link href="http://rickardlindberg.me/writing/agdpp-tdd-and-games/" />
    <id>http://rickardlindberg.me/writing/agdpp-tdd-and-games/</id>
    <published>2023-06-12T00:00:00Z</published>
    <updated>2023-06-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Does TDD work when building a game?</h1>

<p><em>Published on 12 June 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>When I <a href="/writing/agdpp-introduction/index.html">started</a> this series, one of the areas that I wanted to explore was how well TDD works when building a game.</p>
<p>The short answer is that I find that it works equally well as on any other project I’ve done.</p>
<p>The longer answer is that TDD might not be enough. There are some things which are hard to test in a game. That’s what I want to talk about in this blog post and also how we can overcome the limits of TDD in those situations.</p>
<h2 id="example-joystick-movement">Example: joystick movement</h2>
<p>What is hard to test with TDD? Here is an example.</p>
<p>A <a href="/writing/agdpp-logitech-gamepad-f310/index.html">few episodes ago</a>, we worked on controlling the game with a gamepad. The gamepad has a little joystick (correct name?) and when we push it to the left, we want the arrow to turn left, and likewise for right. That logic works well to implement with TDD, however, that is not enough. It is also important that it “feels good” to turn the arrow. That it responds fast enough, that it turns with an appropriate speed, and so on. That part, I think, is impossible to work out with TDD since we don’t know the correct answer. The only way to get the correct answer is to experiment. Try turning with different parameters and see which ones feel better.</p>
<p>We can still use TDD for the first part if we relax the assertions. For example, we can’t assert that the arrow is turned by a specific amount, but we can assert that it is turned more to the left than before. Here is an example of that:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; initial_angle = game.get_arrow_angle()</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.event(GameLoop.create_event_joystick_motion(axis=0, value=-0.5))</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(1)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_arrow_angle() &lt; initial_angle</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We assert the basic functionality in the test, and then we can play the game and adjust parameters for turning until it feels good, and this test will continue to work without modification.</p>
<h2 id="testing-in-game">Testing in-game?</h2>
<p>What are you saying Rickard? That we can’t verify the behavior of the game with tests and that we need to play the game to make sure it works? And do this repeatedly? That sounds like a very long feedback loop. What about if we have to tweak numbers for an effect that only happens after you score 100 points? Should we play the game, score 100 points, look at the effect, tweak a parameter, and do it all over again?</p>
<p>You certainly need to play the game to be able to get some details right. But we should not need to play “unnecessary parts” over and over again until we reach the point in the game that we are interested in testing.</p>
<p>So far, the balloon shooter is not that complex. If we want to test turn speed for example, we can start the game and start turning. No additional steps needed. However, when the game becomes more complex (start screen, player selection, etc) and requires more interaction to get to where we want to go, I think we should approach it differently.</p>
<h2 id="test-applications">Test applications</h2>
<p>The idea that I have, that I have not yet tested, is to create small test applications or sub-games that can only be run in development.</p>
<p>For the case with the effect after 100 points, perhaps we can create a custom game that starts immediately with 99 points. We can shoot down one more balloon and observe the effect. That is a faster feedback loop.</p>
<p>This approach might require our design to change a bit. It must be easy to start the game with a particular scene and configuration for example.</p>
<h2 id="applications-outside-games">Applications outside games</h2>
<p>I have used this approach in <a href="/projects/timeline/index.html">Timeline</a>. Timeline is a GUI application, so a different domain than games. But the GUI elements have the same problem: you can’t assert in tests that they “look good”.</p>
<p>Instead of running the application and opening the correct dialog, we implemented a <code>--halt-gui</code> flag in our test runner. When that flag is present, the tests will open GUI dialogs with mock data and you can visually inspect that they look good:</p>
<p>
<center>
<img src="timeline-halt-gui.png" title="fig:" alt="Timeline halt GUI." />
</center>
</p>
<p>Your workflow for modifying a dialog can than be</p>
<ol type="1">
<li>run test suite with specific test and <code>--halt-gui</code> flag</li>
<li>inspect the dialog</li>
<li>tweak layout</li>
<li>repeat</li>
</ol>
<p>This makes the feedback loop a little faster. There is no need to constantly run the application and click your way to the correct dialog.</p>
<h2 id="what-about-real-application-testing">What about real application testing?</h2>
<p>Should we never run our application for real? Should we only get feedback from tests and test applications?</p>
<p>No, I believe it is also important to use the application to get a sense of what needs improving.</p>
<p>In <a href="https://ronjeffries.com/articles/-y023/python/-o110/110/">Python 110 - Now Fleets?</a>, Ron writes</p>
<blockquote>
<p>And it seems to me that with a video-oriented game, we always wind up needing to watch it run, both for confidence and because, every now and then, we discover a problem.</p>
</blockquote>
<p>My goal is to not have to run the game for confidence. I want faster feedback for confidence.</p>
<p>However, I do agree that you will discover problems when running the game. But I think that is true for any kind of application, not just games.</p>
<h2 id="summary">Summary</h2>
<p>Those are my reflections on using TDD for a game so far. Do you believe that creating test applications for faster feedback is a good idea? Please <a href="/contact/index.html">let me know</a>.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Score as text</title>
    <link href="http://rickardlindberg.me/writing/agdpp-score-as-text/" />
    <id>http://rickardlindberg.me/writing/agdpp-score-as-text/</id>
    <published>2023-05-24T00:00:00Z</published>
    <updated>2023-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Score as text</h1>

<p><em>Published on 24 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>Currently, the game keeps track of the score by drawing yellow point markers. One for each point:</p>
<p>
<center>
<img src="points.png" title="fig:" alt="Point markers." />
</center>
</p>
<p>I find it tedious to count them when my son wants to know the score, and I think he also expressed that he wants to have the score as a number in the upper right corner.</p>
<p>That’s what we will work on in this episode. The end result will look like this:</p>
<p>
<center>
<img src="score-text.png" title="fig:" alt="Score text." />
</center>
</p>
<h2 id="drawing-text">Drawing text</h2>
<p>The reason that we implemented score display with point markers was that it was quicker. There was no way to draw text and it was therefore quicker to use point markers. But that has to change now. Let’s see if we can draw some text.</p>
<p>We start by adding a test case to the top-level, initial state test that asserts that the text ‘0’ is drawn on the screen:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">    I am a balloon shooter game!</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">    Initial state</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">    =============</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">    We run the game for a few frames, then quit:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="co">    ...     events=[</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="co">    ...         [],</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="co">    ...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="co">    ...     ]</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="co">    ... )</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a><span class="co">    ...</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a><span class="co">    The score is drawn:</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; set(events.filter(&quot;DRAW_TEXT&quot;).collect(&quot;text&quot;))</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a><span class="co">    {(&#39;0&#39;,)}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>This fails because there is no event <code>DRAW_TEXT</code> yet.</p>
<p>We add a method to draw text and have it emit a <code>DRAW_TEXT</code> event like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> GameLoop(Observable):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    ...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">def</span> draw_text(<span class="va">self</span>, position, text):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        <span class="va">self</span>.notify(<span class="st">&quot;DRAW_TEXT&quot;</span>, {</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>            <span class="st">&quot;x&quot;</span>: position.x,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>            <span class="st">&quot;y&quot;</span>: position.y,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>            <span class="st">&quot;text&quot;</span>: text,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>        })</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>        f <span class="op">=</span> <span class="va">self</span>.pygame.font.Font(size<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>        surface <span class="op">=</span> f.render(text, <span class="va">True</span>, <span class="st">&quot;black&quot;</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>        <span class="va">self</span>.screen.blit(surface, (position.x, position.y))</span></code></pre></div>
<p>We test the pygame code manually to ensure that we use the text drawing api correctly and that text appears on the screen.</p>
<h2 id="keeping-track-of-score-to-draw">Keeping track of score to draw</h2>
<p>Before we kept track of the score by adding point markers to a sprite group. We replace this sprite group with a new <code>Score</code> object:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="st">-        self.points = self.add(SpriteGroup())</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="va">+        self.score = self.add(Score())</span></span></code></pre></div>
<p>Instead of adding point markers, we just add a number to increase the score:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="st">-                    self.points.add(PointMarker(position=Point(</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="st">-                        x=20+len(self.points.get_sprites())*12,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="st">-                        y=700</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="st">-                    )))</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="va">+                    self.score.add(1)</span></span></code></pre></div>
<p>The <code>Score</code> class looks like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> Score:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        <span class="va">self</span>.score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="kw">def</span> add(<span class="va">self</span>, points):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="va">self</span>.score <span class="op">+=</span> points</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        loop.draw_text(position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">1100</span>, y<span class="op">=</span><span class="dv">20</span>), text<span class="op">=</span><span class="bu">str</span>(<span class="va">self</span>.score))</span></code></pre></div>
<h2 id="adapting-tests">Adapting tests</h2>
<p>We already have tests that make sure that we count the score correctly. We have to modify them slightly to look at the score number instead of counting point markers in the sprite group. We change them like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="st">-    &gt;&gt;&gt; game.get_points()</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="st">-    []</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="va">+    &gt;&gt;&gt; game.get_score()</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="va">+    0</span></span></code></pre></div>
<p>Now all tests pass and the score is displayed with text instead of point markers. Success!</p>
<h2 id="summary">Summary</h2>
<p>This change went rather smoothly. Adding functionality to draw text was not that much work. Perhaps we could just as well have done that from the start. But point markers felt easier at the time.</p>
<p>Our customer is happy with the new score display. When we play the game, we sometimes decide to go for 100 points, then stop. Perhaps that could become a competitive aspect? How fast can you get to 100 points? And the time will be the “final” score? We’ll see.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Programming a Logitech Gamepad F310</title>
    <link href="http://rickardlindberg.me/writing/agdpp-logitech-gamepad-f310/" />
    <id>http://rickardlindberg.me/writing/agdpp-logitech-gamepad-f310/</id>
    <published>2023-05-19T00:00:00Z</published>
    <updated>2023-05-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Programming a Logitech Gamepad F310</h1>

<p><em>Published on 19 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>I recently bought a pair of Logitech gamepads that me and my son use when playing <a href="https://supertuxkart.net/Main_Page">SuperTuxKart</a>.</p>
<p>
<center>
<img src="logitech-gamepad-f310.png" title="fig:" alt="Logitech Gamepad F310." />
</center>
</p>
<p>I want to be able to use those gamepads in the balloon shooter as well. My suspicion is that the balloon shooter will feel many times more like a “real” game if we can control it using “real” game controllers. Even though we are all about having fun here and learning, we still want this to feel like a real game, not some toy example. So let’s get started.</p>
<h2 id="learning-about-events">Learning about events</h2>
<p>How do we capture events from a Logitech gamepad?</p>
<p>One way to find out is to print all the events that pygame generates. We can for example do that in the <code>tick</code> method:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>            <span class="bu">print</span>(event)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>            ...</span></code></pre></div>
<p>This makes the test suite fail since the print statement is outputting event information that the tests do not expect to find.</p>
<p>This might be a downside of doctest, that it captures stdout and asserts on it. Normally a print statement should not affect the function of the code, so it should be fine.</p>
<p>On the other hand, if we use print statements for debugging, maybe it’s a good thing that our test suite fails so that we are remembered to keep the debug session short and remove it once we are done.</p>
<p>Anyway, if we run the game now and press keys on the keyboard we can see things like this in the output:</p>
<pre class="text"><code>&lt;Event(771-TextInput {&#39;text&#39;: &#39; &#39;, &#39;window&#39;: None})&gt;
&lt;Event(769-KeyUp {&#39;unicode&#39;: &#39; &#39;, &#39;key&#39;: 32, &#39;mod&#39;: 0, &#39;scancode&#39;: 44, &#39;window&#39;: None})&gt;
&lt;Event(768-KeyDown {&#39;unicode&#39;: &#39;&#39;, &#39;key&#39;: 1073742049, &#39;mod&#39;: 1, &#39;scancode&#39;: 225, &#39;window&#39;: None})&gt;
&lt;Event(768-KeyDown {&#39;unicode&#39;: &#39;&#39;, &#39;key&#39;: 1073742050, &#39;mod&#39;: 257, &#39;scancode&#39;: 226, &#39;window&#39;: None})&gt;</code></pre>
<p>But when we press keys on the Logitech gamepad, nothing happens.</p>
<p>However, if we look at the beginning of the event log, we see this:</p>
<pre class="text"><code>&lt;Event(1541-JoyDeviceAdded {&#39;device_index&#39;: 0, &#39;guid&#39;: &#39;030000006d0400001dc2000014400000&#39;})&gt;</code></pre>
<p>Is this our Logitech gamepad?</p>
<h2 id="initializing-joysticks">Initializing joysticks</h2>
<p>We read about joysticks in the <a href="https://www.pygame.org/docs/ref/joystick.html">pygame documentation</a>. It seems like they must be initialized before events are generated for them.</p>
<blockquote>
<p>Joysticks are initialised on creation and are shut down when deallocated. Once the device is initialized the pygame event queue will start receiving events about its input.</p>
</blockquote>
<p>We try to mimic the example in the documentation to initialize joysticks:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> GameLoop(Observable):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    ...</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, game, resolution<span class="op">=</span>(<span class="dv">1280</span>, <span class="dv">720</span>), fps<span class="op">=</span><span class="dv">60</span>):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        ...</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        joysticks <span class="op">=</span> {}</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>            <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>                pygame_events <span class="op">=</span> <span class="va">self</span>.pygame.event.get()</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>                <span class="cf">for</span> event <span class="kw">in</span> pygame_events:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>                    <span class="cf">if</span> event.<span class="bu">type</span> <span class="op">==</span> pygame.JOYDEVICEADDED:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>                        joy <span class="op">=</span> <span class="va">self</span>.pygame.joystick.Joystick(event.device_index)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>                        joysticks[joy.get_instance_id()] <span class="op">=</span> joy</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>                    <span class="cf">else</span>:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>                        game.event(Event(event))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>                ...</span></code></pre></div>
<p>We don’t handle <code>JOYDEVICEREMOVED</code> yet. We probably should, but unless we unplug the gamepad while running the game, we should be fine I think.</p>
<p>This change passes all the tests. However, we are never simulating the <code>JOYDEVICEADDED</code> event, so the code is never executed.</p>
<p>I think we will get faster feedback by just testing this thing for real. We can come back and describe the joystick handling code in the form of tests later on if we feel the need. And maybe test the <code>JOYDEVICEREMOVED</code> as well.</p>
<p>Anyway, if we run the game now and press keys on the gamepad, we see events like this:</p>
<pre class="text"><code>&lt;Event(1536-JoyAxisMotion {&#39;joy&#39;: 0, &#39;instance_id&#39;: 0, &#39;axis&#39;: 0, &#39;value&#39;: 0.003906369212927641})&gt;
&lt;Event(1539-JoyButtonDown {&#39;joy&#39;: 0, &#39;instance_id&#39;: 0, &#39;button&#39;: 0})&gt;
&lt;Event(1540-JoyButtonUp {&#39;joy&#39;: 0, &#39;instance_id&#39;: 0, &#39;button&#39;: 0})&gt;</code></pre>
<p>I feel a disproportional sense of excitement and joy over this. We can now get input from the Logitech gamepad. We are real game developers now! Thanks pygame for making this relatively straight forward. Now it’s a matter of mapping events to actions in our game.</p>
<h2 id="isolating-input-handling">Isolating input handling</h2>
<p>We want to be able to play our game with both the keyboard and the Logitech gamepad. I will most likely use the gamepad 99% of the time, but if you don’t have it, we still want you to be able to play the game.</p>
<p>Input handling is therefore something that is starting to become a little complicated. It’s not just a matter of mapping one event to one action.</p>
<p>Now, we have this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    ...</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        ...</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>            <span class="va">self</span>.flying_arrows.add(<span class="va">self</span>.arrow.clone_shooting())</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_left():</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>            <span class="va">self</span>.arrow.angle_left()</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_right():</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>            <span class="va">self</span>.arrow.angle_right()</span></code></pre></div>
<p>That is a one to one mapping between events and actions.</p>
<p>We still want this code to look similar but allow multiple events to generate the same action.</p>
<p>Here is what we come up with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    ...</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.action(event)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.update(dt)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.input_handler.get_shoot():</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>            <span class="va">self</span>.flying_arrows.add(<span class="va">self</span>.bow.clone_shooting())</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>        <span class="va">self</span>.bow.turn(<span class="va">self</span>.input_handler.get_turn_angle())</span></code></pre></div>
<p>So we pass along events to an input handler, then we query it in the <code>update</code> method, asking it if a shot action was triggered (from either input device), and if so, modify <code>flying_arrows</code> as before. We do something similar for turning the arrow. But instead of asking the input handler if a left/right action was triggered, we ask it for an angle that we should turn the arrow. Since the arrow can be turned with variable speed with the Logitech gamepad, this makes more sense.</p>
<p>Before we look at the input handler, I want to discuss another thing that is new here: the bow.</p>
<h2 id="bow">Bow</h2>
<p>Instead of doing <code>arrow.angle_left/right()</code> we do <code>bow.turn(angle)</code>. We have extracted a concept called bow.</p>
<p>Right now it is a wrapper around an arrow, but the idea is that you might want to draw more graphics for the bow.</p>
<p>Here is what it looks like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> Bow(SpriteGroup):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> <span class="va">self</span>.add(Arrow())</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    <span class="kw">def</span> turn(<span class="va">self</span>, angle):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>        <span class="va">self</span>.arrow.set_angle(<span class="va">self</span>.arrow.angle.add(angle))</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span class="kw">def</span> clone_shooting(<span class="va">self</span>):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.arrow.clone_shooting()</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>I’m not sure that bow is the right name. Do we shoot arrows with a bow in our game? Or is it some kind of cannon? I think we need to ask our product owner.</p>
<p>At the moment we are not doing any drawing except the arrow, so the bow just acts as a placeholder to attract new functionality. But the concept of a bow makes sense. You need to shoot the arrow with something. And when you shoot, the arrow leaves the bow and goes into the list of flying arrows.</p>
<h2 id="input-handler">Input handler</h2>
<p>Ok, on to the input handler.</p>
<p>It is responsible for handling events and keeping some state of what those events should result in.</p>
<p>Let’s look at how it handles shooting:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">class</span> InputHandler:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        ...</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>        <span class="va">self</span>.shoot_down <span class="op">=</span> ResettableValue(<span class="va">False</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="kw">def</span> get_shoot(<span class="va">self</span>):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.shoot</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>        <span class="va">self</span>.shoot <span class="op">=</span> <span class="va">self</span>.shoot_down.get_and_reset()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>        ...</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>    <span class="kw">def</span> action(<span class="va">self</span>, event):</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>        <span class="cf">if</span> event.is_keydown(KEY_SPACE) <span class="kw">or</span> event.is_joystick_down(XBOX_A):</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>            <span class="va">self</span>.shoot_down.<span class="bu">set</span>(<span class="va">True</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>It will be called by the game scene like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="va">self</span>.input_handler.action(event)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="va">self</span>.input_handler.update(dt)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="cf">if</span> <span class="va">self</span>.input_handler.get_shoot():</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>The <code>shoot_down</code> variable remembers if a shoot key/button has been pressed since the last call to <code>update</code>. We only want <code>get_shoot</code> to return true one time when we press a shoot key/button. That’s why we use a resettable value, which looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> ResettableValue:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, default):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>        <span class="va">self</span>.default <span class="op">=</span> default</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> default</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span class="kw">def</span> get_and_reset(<span class="va">self</span>):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>        x <span class="op">=</span> <span class="va">self</span>.get()</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>        <span class="va">self</span>.reset()</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>        <span class="cf">return</span> x</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    <span class="kw">def</span> get(<span class="va">self</span>):</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.value</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">set</span>(<span class="va">self</span>, value):</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>    <span class="kw">def</span> reset(<span class="va">self</span>):</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> <span class="va">self</span>.default</span></code></pre></div>
<p>The <code>is_joystick_down</code> method on the event is new. We have added wrappers for new events <a href="/writing/agdpp-shooting-arrow/index.html">before</a>, and this is done the same way.</p>
<p>The logic for the turn angle is a little more complicated. The input handler remembers what state the keyboard and gamepad is in. For the keyboard, it is if a turn key is currently pressed or not. For the gamepad, it is the current x position of the joystick. We store that state in <code>arrow_turn_factor</code>. It is a value between -1 and 1. -1 means turn full speed to the left. 1 means turn full speed to the right. The keyboard can only turn with full speed but the gamepad can turn with variable speed by moving the joystick into different x positions. (We could imagine that the turn factor for the keyboard increase over time. So the speed increases the longer you have held a turn button down. That kind of logic would go in here and the game would still only query for the turn angle.)</p>
<p>Here is the implementation:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> InputHandler:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>        <span class="va">self</span>.arrow_turn_factor <span class="op">=</span> ResettableValue(<span class="dv">0</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>        ...</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    <span class="kw">def</span> get_turn_angle(<span class="va">self</span>):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.turn_angle</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>        ...</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>        <span class="va">self</span>.turn_angle <span class="op">=</span> Angle.fraction_of_whole(<span class="va">self</span>.arrow_turn_factor.get()<span class="op">*</span>dt<span class="op">*</span><span class="dv">1</span><span class="op">/</span><span class="dv">2000</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>    <span class="kw">def</span> action(<span class="va">self</span>, event):</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>        ...</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown(KEY_LEFT):</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>            <span class="va">self</span>.arrow_turn_factor.<span class="bu">set</span>(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keyup(KEY_LEFT):</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>            <span class="va">self</span>.arrow_turn_factor.reset()</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown(KEY_RIGHT):</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>            <span class="va">self</span>.arrow_turn_factor.<span class="bu">set</span>(<span class="dv">1</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keyup(KEY_RIGHT):</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>            <span class="va">self</span>.arrow_turn_factor.reset()</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_joystick_motion() <span class="kw">and</span> event.get_axis() <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">abs</span>(event.get_value()) <span class="op">&gt;</span> <span class="fl">0.01</span>:</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>                <span class="va">self</span>.arrow_turn_factor.<span class="bu">set</span>(event.get_value())</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>                <span class="va">self</span>.arrow_turn_factor.reset()</span></code></pre></div>
<p>We can test the details of this in isolation. The only thing we need to test in the game scene is that it turns the arrow by the amount that it gets from the input handler.</p>
<p>Also notice the new <code>Angle</code> class. We continue down the path of eliminating primitive obsession. I’m sure it will attract some functions.</p>
<h2 id="design-discussion">Design discussion</h2>
<p>Let’s have a look at the game scene again:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    ...</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.action(event)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        <span class="va">self</span>.input_handler.update(dt)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.input_handler.get_shoot():</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>            <span class="va">self</span>.flying_arrows.add(<span class="va">self</span>.bow.clone_shooting())</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>        <span class="va">self</span>.bow.turn(<span class="va">self</span>.input_handler.get_turn_angle())</span></code></pre></div>
<p>How do we test this? What is the behavior?</p>
<p>This is what I think of:</p>
<ul>
<li>Flying arrows stays the same if no shoot key is pressed</li>
<li>Flying arrows increment if shoot key is pressed</li>
<li>Bow turns with an angle indicated by input</li>
</ul>
<p>In order to test this, we need to simulate real events. But now that we allow multiple events for shooting for example, do we need to test them all? No. We can select any of them.</p>
<p>This is overlapping, sociable testing. (I think.)</p>
<p>Then we can write specific tests for the input handler that tests that all shoot keys result in <code>get_shoot</code> being true:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="co">Space shoots and resets:</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i = InputHandler()</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.action(GameLoop.create_event_keydown(KEY_SPACE))</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(1)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shoot()</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(1)</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shoot()</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="co">False</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a><span class="co">Xbox A shoots and resets:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i = InputHandler()</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.action(GameLoop.create_event_joystick_down(XBOX_A))</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(1)</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shoot()</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.update(1)</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; i.get_shoot()</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a><span class="co">False</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>The process to get to this design was a squiggly one with many refactorings. I initially had a different approach that I want to mention and talk about. It looked like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    ...</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>        <span class="kw">def</span> quit():</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>        actions <span class="op">=</span> {</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>            <span class="st">&quot;quit&quot;</span>: quit,</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>            <span class="st">&quot;shoot&quot;</span>: <span class="kw">lambda</span>: <span class="va">self</span>.flying_arrows.add(<span class="va">self</span>.arrow.clone_shooting()),</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>            <span class="st">&quot;turn_left&quot;</span>: <span class="kw">lambda</span>: <span class="va">self</span>.arrow.angle_left(),</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>            <span class="st">&quot;turn_right&quot;</span>: <span class="kw">lambda</span>: <span class="va">self</span>.arrow.angle_right(),</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>        }</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>        action <span class="op">=</span> <span class="va">self</span>.input_handler.action(event)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>        <span class="cf">if</span> action:</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>            actions[action[<span class="dv">0</span>]]()</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a><span class="kw">class</span> InputHandler:</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>    <span class="kw">def</span> action(<span class="va">self</span>, event):</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>            <span class="cf">return</span> (<span class="st">&#39;quit&#39;</span>,)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_space() <span class="kw">or</span> event.is_joystick_down(<span class="dv">0</span>):</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>            <span class="cf">return</span> (<span class="st">&#39;shoot&#39;</span>,)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_left():</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a>            <span class="cf">return</span> (<span class="st">&#39;turn_left&#39;</span>,)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_right():</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>            <span class="cf">return</span> (<span class="st">&#39;turn_right&#39;</span>,)</span></code></pre></div>
<p>In this design, the input handler returns the name of the action to perform. Then the game scene looks up that action, and if it finds it, runs it.</p>
<p>This makes the input handler easy to test, which was my goal.</p>
<p>The question is what to test in the game scene. I think I would like to test all cases here as well to make sure the right action names are used. So simulate any shooting event and make sure that flying arrows are added, and so on.</p>
<p>However, what if we use the keyboard event for that test, and then write our input handler like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">class</span> InputHandler:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="kw">def</span> action(<span class="va">self</span>, event):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>        <span class="cf">if</span> event.is_keydown_space():</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>            <span class="cf">return</span> (<span class="st">&#39;shoot&#39;</span>,)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_joystick_down(<span class="dv">0</span>):</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>            <span class="cf">return</span> (<span class="st">&#39;shot&#39;</span>,)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>That is, we misspell the action name for the joystick case. We even misspell it in the input handler test. All tests will pass, but the arrow will not shoot when using the joystick.</p>
<p>Do we need to test all cases in the game scene to ensure that? I really don’t want to do that. The whole point of the input handler was to be able to test details of input handling in isolation.</p>
<p>That’s when I slowly moved in the direction that I presented first:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    ...</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>        ...</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.input_handler.get_shoot():</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>            <span class="va">self</span>.flying_arrows.add(<span class="va">self</span>.bow.clone_shooting())</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>        <span class="va">self</span>.bow.turn(<span class="va">self</span>.input_handler.get_turn_angle())</span></code></pre></div>
<p>In this design it is still possible for <code>get_shoot</code> to return an incorrect boolean value for the joystick. But the likelihood of that happening, I think, is much less than we misspell an action.</p>
<p>This design is also cleaner I think. No need for an “action language” where strings are mapped to actions to do.</p>
<h2 id="summary">Summary</h2>
<p>Testing is hard. You don’t want to test everything from the outside since that gives difficult to read tests. But you <em>do</em> want to test from the outside to make sure things actually work for real. So you need to make a tradeoff. I suspect there is no “right” answer. One measure you can use is this: are you worried that things are not working? Test more or test smarter.</p>
<p>With the first design of the input handler, I was worried that the input handler returned “invalid” actions. Instead of testing more from the outside, I modified the design to reduce my worry. I’m no longer worried that the input handler returns the wrong things. I feel better.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>A case for the infrastructure wrapper</title>
    <link href="http://rickardlindberg.me/writing/agdpp-wrapper-pygame-draw-circle-bug/" />
    <id>http://rickardlindberg.me/writing/agdpp-wrapper-pygame-draw-circle-bug/</id>
    <published>2023-05-14T00:00:00Z</published>
    <updated>2023-05-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>A case for the infrastructure wrapper</h1>

<p><em>Published on 14 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>I noticed something strange when playing the game.</p>
<p>When shooting arrows out the left side of the screen, a blue horizontal line is drawn. It looks something like this:</p>
<center>
<img src="negative-x-draw-bug.png" title="fig:" alt="Bug with drawing circles on negative x positions." />
</center>
<p>But it only shows for a split second and then disappears. What’s going on?</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>We troubleshoot by playing the game and shooting wildly in different directions.</p>
<p>It seems like the blue horizontal line only appears when we shoot arrows to the left–not when we shoot up or to the right.</p>
<p>So why does it only show for a split second? Most likely because arrows outside the screen are removed. But they are only removed if they are far enough outside the screen. The idea is that arrows are only removed if they are completely outside the screen. However, I don’t think it’s working quite like that at the moment. But arrows can be partially outside the screen before being removed.</p>
<p>We modify the code to draw a static arrow just outside the screen to the left, and indeed the blue horizontal line stays on the screen forever. (That’s how I managed to get the screenshot. It was not timing.)</p>
<p>The problem can now be consistently reproduced. Good!</p>
<h2 id="bug-in-pygame">Bug in Pygame?</h2>
<p>At first I thought we might use Pygame wrong in some way. But now I’m starting to think that there might actually be an issue with Pygame.</p>
<p>Let’s ask DuckDuckGo.</p>
<p>It came back with this: <a href="https://github.com/pygame/pygame/issues/3778">Circles drawn using pygame.draw.circle with negative x positions are drawn as a horizontal line across the whole screen.</a></p>
<p>Ha! A bug in Pygame. It all makes sense now. And we are not at fault.</p>
<p>However, we still have an ugly, annoying graphics artifact in our game that we want to get rid of. How?</p>
<h2 id="infrastructure-to-the-rescue">Infrastructure to the rescue</h2>
<p>Any place in the code where we draw a circle we have to modify it to handle negative x values.</p>
<p>Let’s see how.</p>
<p>We have used the <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#infrastructure-wrappers">infrastructure wrapper</a> pattern in our game. That means that every time our code interacts with the outside world, it does so via an infrastructure wrapper.</p>
<p>Anytime we draw something on the screen, we do it via the game loop infrastructure wrapper. Here is how the arrow draws itself:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        v <span class="op">=</span> Point.from_angle(<span class="va">self</span>.angle <span class="op">+</span> <span class="dv">180</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position, color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position.add(v.times(<span class="dv">20</span>)), color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position.add(v.times(<span class="dv">40</span>)), color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<p><code>draw_circle</code> above is part of the infrastructure wrapper. In code that we control. It in turn makes calls to Pygame like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> GameLoop(Observable):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    ...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">def</span> draw_circle(<span class="va">self</span>, position, radius<span class="op">=</span><span class="dv">40</span>, color<span class="op">=</span><span class="st">&quot;red&quot;</span>):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        ...</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="va">self</span>.pygame.draw.circle(</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>            <span class="va">self</span>.screen,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>            color,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>            (<span class="bu">int</span>(position.x), <span class="bu">int</span>(position.y)),</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>            radius</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>        )</span></code></pre></div>
<p>So we are actually only calling Pygame’s <code>draw_circle</code> in one place in our code.</p>
<p>We patch it like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> GameLoop(Observable):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    ...</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="kw">def</span> draw_circle(<span class="va">self</span>, position, radius<span class="op">=</span><span class="dv">40</span>, color<span class="op">=</span><span class="st">&quot;red&quot;</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        ...</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="cf">if</span> position.x <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>            <span class="co"># https://github.com/pygame/pygame/issues/3778</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>            <span class="va">self</span>.pygame.draw.circle(</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>                <span class="va">self</span>.screen,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>                color,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>                (<span class="bu">int</span>(position.x), <span class="bu">int</span>(position.y)),</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>                radius</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>            )</span></code></pre></div>
<p>This means that circles drawn partially outside the screen to the left will not be drawn at all. Not ideal. But I very much prefer that to an annoying blue horizontal line.</p>
<p>And when I play the game, I don’t notice circles of the arrow disappearing a little to early. They move so fast anyway.</p>
<p>We could do something more fancy like checking for specific versions of Pygame where we know this bug exists. But this will do for now.</p>
<h2 id="summary">Summary</h2>
<p>We were able to fix an annoying graphics artifact by adding a single if-statement to our infrastructure wrapper.</p>
<p>Wrapping third party libraries might seem like unnecessary overhead sometimes, but the benefit shown in this episode makes me think that we should do it more often.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Turning arrow</title>
    <link href="http://rickardlindberg.me/writing/agdpp-turning-arrow/" />
    <id>http://rickardlindberg.me/writing/agdpp-turning-arrow/</id>
    <published>2023-05-12T00:00:00Z</published>
    <updated>2023-05-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Turning arrow</h1>

<p><em>Published on 12 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>We have a basic version of a balloon shooter in place. We have a balloon moving across the screen and an arrow that can be shot and hit the balloon to score a point.</p>
<center>
<img src="points.png" title="fig:" alt="Arrow shooting straight." />
</center>
<p>When I play the game now, I want to turn the arrow. I think that will make the game a little more fun. Then you have to control both angle and timing instead of just timing to hit a balloon. (If we implement that balloons fall downwards instead, turning will also be necessary to hit balloons that are not straight above the arrow.)</p>
<h2 id="how-does-arrow-movement-work">How does arrow movement work?</h2>
<p>Arrows move first when we press the space key to shoot. Then we create a new arrow and set its shooting attribute to true:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        ...</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>            <span class="va">self</span>.flying_arrows.add(Arrow(shooting<span class="op">=</span><span class="va">True</span>))</span></code></pre></div>
<p>An arrow that has the shooting attribute set to true moves like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    ...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.shooting:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>            <span class="va">self</span>.position <span class="op">=</span> <span class="va">self</span>.position.move(dy<span class="op">=-</span>dt)</span></code></pre></div>
<p>That is, it moves straight up in increments of <code>dt</code>. There is no concept of direction yet.</p>
<p>What we would like to have is some kind of direction attribute on the arrow that we can change. When we shoot, the arrow that we create should get that direction attribute so that it flies in the same direction that we aimed.</p>
<p>Let’s see if we can refactor towards that.</p>
<h2 id="clone-shooting">Clone shooting</h2>
<p>We start by creating a method <code>clone_shooting</code> on the arrow that should return a copy of itself (including all attributes) and have the shooting attribute set to true:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    ...</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="kw">def</span> clone_shooting(<span class="va">self</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        <span class="cf">return</span> Arrow(shooting<span class="op">=</span><span class="va">True</span>, position<span class="op">=</span><span class="va">self</span>.position)</span></code></pre></div>
<p>We modify how a flying arrow is added like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="st">- self.flying_arrows.add(Arrow(shooting=True))</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="va">+ self.flying_arrows.add(self.arrow.clone_shooting())</span></span></code></pre></div>
<p>One change here is that we also clone the arrow’s position attribute. The position of the arrow is always the same. Only when we shoot it, it changes. But should we choose to move the arrow to a different start position, the code now takes that into account and places shooting arrows at the right start positions.</p>
<p>I think this is still a pure refactoring. There is no change in visible behavior, but the code is more robust because we can now change the start position of the arrow, and it will shoot from the right position without we having to modify any other piece of code. The design is better.</p>
<h2 id="work-towards-arrow-velocity">Work towards arrow velocity</h2>
<p>Next we take a small step towards having an arrow velocity. We change the update method to this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    ...</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.shooting:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>            velocity <span class="op">=</span> Point(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=-</span>dt)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>            <span class="va">self</span>.position <span class="op">=</span> <span class="va">self</span>.position.add(velocity)</span></code></pre></div>
<p>Our relatively new <code>Point</code> class attracts more and more behavior. Here we added the <code>add</code> method:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">class</span> Point:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    ...</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="kw">def</span> add(<span class="va">self</span>, point):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; Point(0, 5).add(Point(1, 1))</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="co">        Point(1, 6)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.move(dx<span class="op">=</span>point.x, dy<span class="op">=</span>point.y)</span></code></pre></div>
<h2 id="derive-velocity-from-angle">Derive velocity from angle</h2>
<p>Now we could modify the velocity of the arrow and the update method would move it in the right direction.</p>
<p>However, I think it is better if we have a concept of an arrow angle that we can adjust left and right. That would fit our use case better.</p>
<p>We add and angle attribute to the arrow and derive the velocity vector from it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, shooting<span class="op">=</span><span class="va">False</span>, position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="dv">500</span>)):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        ...</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        <span class="va">self</span>.angle <span class="op">=</span> <span class="op">-</span><span class="dv">90</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.shooting:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>            <span class="va">self</span>.position <span class="op">=</span> <span class="va">self</span>.position.add(Point.from_angle(<span class="va">self</span>.angle).times(dt))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>The <code>Point</code> class again attracts functionality. This time for converting angles to unit vectors (vectors of length one) and for magnifying vectors:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> Point:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    ...</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="kw">def</span> from_angle(degrees):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; p = Point.from_angle(-90)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; int(p.x)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="co">        0</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; int(p.y)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="co">        -1</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; p = Point.from_angle(0)</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; int(p.x)</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">        1</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; int(p.y)</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="co">        0</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>        <span class="cf">return</span> Point(</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>            x<span class="op">=</span>math.cos(math.radians(degrees)),</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>            y<span class="op">=</span>math.sin(math.radians(degrees))</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>        )</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>    <span class="kw">def</span> times(<span class="va">self</span>, magnification):</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; Point(1, 5).times(2)</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true"></a><span class="co">        Point(2, 10)</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true"></a>        <span class="cf">return</span> Point(x<span class="op">=</span><span class="va">self</span>.x<span class="op">*</span>magnification, y<span class="op">=</span><span class="va">self</span>.y<span class="op">*</span>magnification)</span></code></pre></div>
<h2 id="base-drawing-on-angle">Base drawing on angle</h2>
<p>The arrow now moves correctly based on the angle, but it doesn’t draw its three circles correctly. It looks like this now:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    ...</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position, color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position.move(dy<span class="op">=</span><span class="dv">20</span>), color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position.move(dy<span class="op">=</span><span class="dv">40</span>), color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<p>That is, it draws the second two circles by moving them downwards, assuming that the arrow is pointing up.</p>
<p>Let’s instead draw them offset by the opposite direction of what the arrow points:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    ...</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>        v <span class="op">=</span> Point.from_angle(<span class="va">self</span>.angle <span class="op">+</span> <span class="dv">180</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position, color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position.add(v.times(<span class="dv">20</span>)), color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.position.add(v.times(<span class="dv">40</span>)), color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<p>We get the reverse angle by turning it 180 degrees.</p>
<p>Perhaps angle is another case of primitive obsession. If we had an angle class, we could have a <code>reverse</code> method that did this and we would no longer be required to know about degrees (the angle could be implemented with radians instead for example). We make a note about that.</p>
<p>Anyway, we can change the angle attribute of the arrow and it will fly in the right direction and draw correctly. Now there is only one thing left: control the angle with arrow keys.</p>
<h2 id="changing-angle-with-leftright">Changing angle with left/right</h2>
<p>Here is the test we write for changing arrow angle:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(space)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_arrow_angle()</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="co">-90</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_left())</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_arrow_angle()</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">-95</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_right())</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_arrow_angle()</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="co">-90</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>For this to work we need to create new event wrappers for keydown left/right and add a getter to expose the arrow angle. We have done similar things before. Same procedure this time.</p>
<p>We make it pass by handling the events and changing the angle:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    ...</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>        ...</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_left():</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>            <span class="va">self</span>.arrow.angle_left()</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_right():</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>            <span class="va">self</span>.arrow.angle_right()</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    ...</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    <span class="kw">def</span> angle_left(<span class="va">self</span>):</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        <span class="va">self</span>.angle <span class="op">-=</span> <span class="dv">5</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="kw">def</span> angle_right(<span class="va">self</span>):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        <span class="va">self</span>.angle <span class="op">+=</span> <span class="dv">5</span></span></code></pre></div>
<p>This almost works, but when we turn and arrow and shoot it, it still goes straight up. We need to fix the <code>clone_shooting</code> method to also clone the angle.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    ...</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="kw">def</span> clone_shooting(<span class="va">self</span>):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="co">        It preserves position and angle and set it to shooting:</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; arrow = Arrow(position=Point(x=5, y=5), angle=-45)</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; new_arrow = arrow.clone_shooting()</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; new_arrow.get_position()</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a><span class="co">        (5, 5)</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; new_arrow.angle</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a><span class="co">        -45</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; new_arrow.shooting</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a><span class="co">        True</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>        <span class="cf">return</span> Arrow(shooting<span class="op">=</span><span class="va">True</span>, position<span class="op">=</span><span class="va">self</span>.position, angle<span class="op">=</span><span class="va">self</span>.angle)</span></code></pre></div>
<h2 id="result">Result</h2>
<p>Now we can turn the arrow with left/right keys and shoot it in different directions. It looks like this:</p>
<center>
<img src="turning-arrow.png" title="fig:" alt="Turning arrow." />
</center>
<p>If you want to try it out, the full source code from this episode on <a href="https://github.com/rickardlindberg/agdpp/tree/turning-arrow">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>Testing continues to go smooth with state based testing and getters to expose internal state.</p>
<p>What I like to do after implementing a feature is to take a break and then come back later to review to code for possible improvements. Often times it is small things like renaming a variable to make it more clear. In this episode we also noted that angle might benefit being wrapped in an abstraction. Not sure they are too interesting to write about. Let me know if you think otherwise.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Hit balloon and score points</title>
    <link href="http://rickardlindberg.me/writing/agdpp-hit-balloon-and-score-points/" />
    <id>http://rickardlindberg.me/writing/agdpp-hit-balloon-and-score-points/</id>
    <published>2023-05-09T00:00:00Z</published>
    <updated>2023-05-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Hit balloon and score points</h1>

<p><em>Published on  9 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>We have two stories left before we think we have a first, minimal version of a balloon shooter game:</p>
<ul>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
</ul>
<p>In this episode we will work on both of them. We will start with collision detection between arrow and balloon.</p>
<h2 id="clarify-behavior-with-test">Clarify behavior with test</h2>
<p>To clarify what we mean by arrow can hit balloon, we want to write a test first that shows the lacking behavior. Then implement the thing. We use the test both as a design tool to figure out what we are actually going to implement and as a testing tool to verify that behavior.</p>
<p>Our game scene object currently inits like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, space):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>        <span class="va">self</span>.balloon <span class="op">=</span> <span class="va">self</span>.add(Balloon())</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> <span class="va">self</span>.add(Arrow())</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="va">self</span>.flying_arrows <span class="op">=</span> <span class="va">self</span>.add(SpriteGroup())</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="va">self</span>.space <span class="op">=</span> space</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>We would like to write a test where we shoot an arrow, make it collide with the balloon, and then assert that the balloon disappears.</p>
<p>With the current design, this is really difficult to do. It can only be done something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(...)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(??)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_balloon() is None</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>But this is really flaky and hard to understand. In order for this to work, we have to time the shooting and the updating so that the arrow actually hits the balloon. Even if we get it to work, it will start failing if we for example change the speed of the arrow. And this test should really not care about arrow speed.</p>
<p>Let’s see if we can do better.</p>
<p>We change the init method to this instead:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, space, balloons<span class="op">=</span>[(<span class="dv">50</span>, <span class="dv">50</span>)], arrows<span class="op">=</span>[]):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>        <span class="va">self</span>.balloons <span class="op">=</span> <span class="va">self</span>.add(SpriteGroup([</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>            Balloon(x<span class="op">=</span>x, y<span class="op">=</span>y) <span class="cf">for</span> (x, y) <span class="kw">in</span> balloons</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        ]))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> <span class="va">self</span>.add(Arrow())</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>        <span class="va">self</span>.flying_arrows <span class="op">=</span> <span class="va">self</span>.add(SpriteGroup([</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>            Arrow(x<span class="op">=</span>x, y<span class="op">=</span>y) <span class="cf">for</span> (x, y) <span class="kw">in</span> arrows</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>        ]))</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>        <span class="va">self</span>.space <span class="op">=</span> space</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>That is, we make it possible to create a game scene object where we specify where all the balloons should be and where all the flying arrows should be. We also change the balloon from a single object to a sprite group. This is not strictly necessary, but it will make removing hit balloons easier. The default values for the balloons and arrows mimics the current default. We have one balloon that starts at (50, 50) and zero flying arrows.</p>
<p>Here is the test that checks initial state:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(space, balloons=[(100, 100)], arrows=[(500, 500)])</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(game.get_balloons())</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(game.get_flying_arrows())</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>In order for it to work, we expose another getter for the balloon sprites:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">def</span> get_balloons(<span class="va">self</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="cf">return</span> <span class="va">self</span>.balloons.get_sprites()</span></code></pre></div>
<p>The test continues to check that we still have one balloon and one flying arrow after an update:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(0)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(game.get_balloons())</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(game.get_flying_arrows())</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We update with 0 to ensure that nothing moves. We need to call update to make the collision detection code run, but to ensure exact positions, we pass 0 as the delta time. All movements should take the delta time into account, so 0 should result in no movement.</p>
<p>We continue and write the test for hitting a balloon like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(game.get_balloons())</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(0)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_balloons()</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="co">[]</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We place the arrow at the center of the balloon, invoke the collision detection code with update, and assert that there are no longer any balloons.</p>
<h2 id="implement-arrow-hit">Implement arrow hit</h2>
<p>In the game update, we already loop over the arrows to remove the ones that are outside the screen. We add a loop that checks if any arrow hits any of the balloons. If so, we remove that balloon:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>        ...</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>        <span class="cf">for</span> arrow <span class="kw">in</span> <span class="va">self</span>.flying_arrows.get_sprites():</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>            ...</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>            <span class="cf">for</span> balloon <span class="kw">in</span> <span class="va">self</span>.balloons.get_sprites():</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>                <span class="cf">if</span> arrow.hits_baloon(balloon):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>                    <span class="va">self</span>.balloons.remove(balloon)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>We add <code>hits_baloon</code> to arrow:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="kw">def</span> hits_baloon(<span class="va">self</span>, balloon):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>        <span class="cf">return</span> balloon.inside(<span class="va">self</span>.x, <span class="va">self</span>.y)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>And implement <code>inside</code> in balloon like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="kw">def</span> inside(<span class="va">self</span>, x, y):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>        <span class="cf">return</span> (x<span class="op">-</span><span class="va">self</span>.x)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span><span class="va">self</span>.y)<span class="op">**</span><span class="dv">2</span> <span class="op">&lt;=</span> <span class="va">self</span>.radius<span class="op">**</span><span class="dv">2</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>This is a bit of a trick in OOP that I learned some time ago that I’m not sure what I think about. Let me explain.</p>
<p>We could have written the test like this instead:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="cf">if</span> balloon.inside(arrow.x, arrow.y):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="va">self</span>.balloons.remove(balloon)</span></code></pre></div>
<p>But then the game scene object would have to reach into the arrow object to access the x and y coordinates.</p>
<p>With <code>hits_baloon</code> we introduce one more step in the chain where the arrow itself pass its coordinates along to <code>inside</code>. No need to expose them to the outside.</p>
<p>I like this because objects can expose less details about themselves. I dislike this because I think the code sometimes becomes a little harder to read. I guess the solution is good naming. And I think <code>arrow.hits_baloon(balloon)</code> reads pretty well.</p>
<h2 id="demo-trick">Demo trick</h2>
<p>The game works and if we manage to hit a balloon, it disappears. Again, bummer. We can shoot infinitely many arrows, but if there are no more balloons to hit, the game is not that interesting.</p>
<p>We had a situation like this <a href="/writing/agdpp-shooting-arrow/index.html">before</a> where you shot the arrow and you could only get a new one by restarting the game.</p>
<p>One trick I used when I demoed this for the customer was to run the game in a loop like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>$ <span class="kw">while</span> <span class="fu">true</span><span class="kw">;</span> <span class="kw">do</span> <span class="ex">./zero.py</span> rundev<span class="kw">;</span> <span class="kw">done</span></span></code></pre></div>
<p>So when you have no more arrows to shoot or no more balloons to hit, you close the game window and a new one will immediately pop up.</p>
<p>That way, it is a little smoother to gather feedback on the current game functionality.</p>
<p>We fixed so that you get more arrows to shoot before. Let’s also fix so that a new balloon is spawned after one is hit so we don’t need to restart the game in a loop anymore.</p>
<h2 id="primitive-obsession-refactoring">Primitive obsession refactoring</h2>
<p>Before we start adding new functionality, let’s have a look at the code and see if there is anything that we can improve to make it more clear and make the future a little smoother.</p>
<p>One thing that I notice is that we are passing around (x, y) coordinates in a lot of places, and objects keep track of the x and y coordinates. Here is the balloon class for example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x, y, radius<span class="op">=</span><span class="dv">40</span>):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        <span class="va">self</span>.radius <span class="op">=</span> radius</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="kw">def</span> inside(<span class="va">self</span>, x, y):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>        <span class="cf">return</span> (x<span class="op">-</span><span class="va">self</span>.x)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(y<span class="op">-</span><span class="va">self</span>.y)<span class="op">**</span><span class="dv">2</span> <span class="op">&lt;=</span> <span class="va">self</span>.radius<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>This smell is called primitive obsession. It is when you pass around primitive objects (integers, strings encoding information, etc) instead of an abstraction. That leads to duplicated logic. Say for example that we want to move an object, we might do something like this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="va">self</span>.x <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="va">self</span>.y <span class="op">+=</span> <span class="dv">2</span></span></code></pre></div>
<p>And we probably need to move multiple objects, so this kind of code will be duplicated in many places.</p>
<p>The solution is to create and abstraction for the concept. In this case, I choose to call it point:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> Point:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x, y):</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>        <span class="va">self</span>.x <span class="op">=</span> x</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>        <span class="va">self</span>.y <span class="op">=</span> y</span></code></pre></div>
<p>We refactor in small, tiny steps to make use of this point.</p>
<p>Eventually, the inside check in the balloon looks like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="kw">def</span> inside(<span class="va">self</span>, position):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.position.distance_to(position) <span class="op">&lt;=</span> <span class="va">self</span>.radius</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>We are no longer dealing with separate x and y coordinates. We are dealing with positions.</p>
<p>A big chunk of the hit test has also moved into the new point class:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">class</span> Point:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    <span class="kw">def</span> distance_to(<span class="va">self</span>, point):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>        <span class="cf">return</span> math.sqrt((point.x<span class="op">-</span><span class="va">self</span>.x)<span class="op">**</span><span class="dv">2</span><span class="op">+</span>(point.y<span class="op">-</span><span class="va">self</span>.y)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>If we are concerned about the performance of the square root, we could write <code>inside</code> like this (equivalent to what we had before):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="kw">def</span> inside(<span class="va">self</span>, position):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.position.distance_squared_to(position) <span class="op">&lt;=</span> <span class="va">self</span>.radius<span class="op">**</span><span class="dv">2</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>I think this reads a little worse, and we don’t have performance issues yet.</p>
<p>What usually happens when you extract a concept like this point is that it starts attracting new functionality. Suddenly, there is a logical place to implement something instead of spreading it across the code base.</p>
<p>Another benefit of this abstraction is that we can now more easily test the behavior of <code>distance_to</code> in isolation. No need to involve a balloon.</p>
<h2 id="spawn-new-balloons">Spawn new balloons</h2>
<p>So it’s no fun to play the game after you hit the balloon, because then there are no more balloons to hit. We want to spawn new balloons.</p>
<p>We need to modify our test. It looks like this now:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(game.get_balloons())</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(0)</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_balloons()</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="co">[]</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We don’t want the balloon list to be empty. We still want it to contain a balloon. But not the balloon that we just shot down, but another one.</p>
<p>I think we can do it like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; balloons = game.get_balloons()</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(balloons)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(0)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; new_balloons = game.get_balloons()</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(new_balloons)</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; new_balloons == balloons</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a><span class="co">False</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We can make the test pass by adding another balloon after the one that has been shot down has been removed:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>        ...</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>        <span class="cf">for</span> arrow <span class="kw">in</span> <span class="va">self</span>.flying_arrows.get_sprites():</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>            ...</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>            <span class="cf">for</span> balloon <span class="kw">in</span> <span class="va">self</span>.balloons.get_sprites():</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>                <span class="cf">if</span> arrow.hits_baloon(balloon):</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>                    <span class="va">self</span>.balloons.remove(balloon)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>                    <span class="va">self</span>.balloons.add(Balloon(position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">50</span>, y<span class="op">=</span><span class="dv">50</span>)))</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>This now works, but it is a little hard to actually notice that we hit a balloon. It should be more clear if we include a score.</p>
<h2 id="add-score">Add score</h2>
<p>We have a place in the code where we have hit a balloon. When that happens we would also like to increase a score. What is the simplest implementation of that?</p>
<p>What if we just maintain a list of sprites where each sprites represents a point? Let’s see.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    ...</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, space, balloons<span class="op">=</span>[(<span class="dv">50</span>, <span class="dv">50</span>)], arrows<span class="op">=</span>[]):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>        ...</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>        <span class="va">self</span>.points <span class="op">=</span> <span class="va">self</span>.add(SpriteGroup())</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>        ...</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>        <span class="cf">for</span> arrow <span class="kw">in</span> <span class="va">self</span>.flying_arrows.get_sprites():</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>            ...</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a>            <span class="cf">for</span> balloon <span class="kw">in</span> <span class="va">self</span>.balloons.get_sprites():</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a>                <span class="cf">if</span> arrow.hits_baloon(balloon):</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a>                    ...</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>                    <span class="va">self</span>.points.add(PointMarker(position<span class="op">=</span>Point(x<span class="op">=</span><span class="dv">700</span>, y<span class="op">=</span><span class="dv">50</span><span class="op">+</span><span class="bu">len</span>(<span class="va">self</span>.points.get_sprites())<span class="op">*</span><span class="dv">10</span>)))</span></code></pre></div>
<p>We use the length of the point sprites to calculate the position of the next point marker.</p>
<p>We also add a getter for the points so that we can test this behavior:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    ...</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span class="kw">def</span> get_points(<span class="va">self</span>):</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.points.get_sprites()</span></code></pre></div>
<p>And here is the <code>PointMarker</code> that draws a circle at the given position:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">class</span> PointMarker:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, position):</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>        <span class="va">self</span>.position <span class="op">=</span> position</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>        loop.draw_circle(position<span class="op">=</span><span class="va">self</span>.position, radius<span class="op">=</span><span class="dv">5</span>, color<span class="op">=</span><span class="st">&quot;yellow&quot;</span>)</span></code></pre></div>
<p>This is what it looks like after a few balloons have been hit:</p>
<center>
<img src="points.png" title="fig:" alt="Point markers." />
</center>
<p>When I showed this to my son, he thought it was a little fun when point markers appeared on the screen. He also wanted to make the point markers go all across the screen, and also wanted me to count how many points we had about half way through. I don’t like counting small yellow circles, so we probably need a better solution for displaying points. We make a note about that.</p>
<p>If you want to try this version or look at the complete source code from this episode, it is on <a href="https://github.com/rickardlindberg/agdpp/tree/hit-balloon-and-score-points">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>The state based testing approach continues to work well. Tests are easy to write, and I don’t think the getters that we add to expose internal state are too problematic.</p>
<p>We now have a first version of a balloon shooter game. Now we have to show it to our customers, have them play it, gather feedback, and keep improving. One story at a time.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Game over?</title>
    <link href="http://rickardlindberg.me/writing/agdpp-game-over/" />
    <id>http://rickardlindberg.me/writing/agdpp-game-over/</id>
    <published>2023-05-06T00:00:00Z</published>
    <updated>2023-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Game over?</h1>

<p><em>Published on  6 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>When we worked on <a href="/writing/agdpp-shooting-arrow/index.html">shooting the arrow</a> we concluded that it was tedious to restart the game after each shot. When the arrow goes outside the screen, we want the game to be over instead and the arrow to be reset. Let’s work on that in this episode.</p>
<h2 id="do-we-really-need-game-over">Do we really need game over?</h2>
<p>If we implement game over now, there will be game over after every shot. Because there is no way to hit the balloon just yet.</p>
<p>If you play a game where it is game over immediately, would you enjoy it?</p>
<p>Perhaps game over is not the right story to work on? It is a solution to the problem that you don’t have any arrows to shoot after the first one.</p>
<p>How about if you get a new arrow immediately? So you can just keep firing?</p>
<p>From before, these are the stories we though about as needed for an initial balloon shooter:</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>Let’s think about this. For minimal, I don’t think we need real graphics. The circles convey the idea just fine.</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>I’m not sure the balloon needs to move downwards either. The current movement pattern is fine.</p>
<ul>
<li><del>Balloon moves downwards</del></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>And we can do something else instead of game over.</p>
<ul>
<li><del>Balloon moves downwards</del></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li><del>Game over when miss</del></li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>That leaves us with this:</p>
<ul>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>New arrow when the current one has been shot</li>
</ul>
<p>We can always make something smaller. And what we initially thought we needed, we don’t need. At least not yet. When we play the game, we quite quickly find out what is needed next. Working software. In the hands of its users. Powerful.</p>
<p>Let’s work on spawning arrows now so that we can enjoy shooting arrows for a longer time without having to restart our game.</p>
<h2 id="acceptance-criteria">Acceptance criteria</h2>
<p>I can think of two test:</p>
<ul>
<li>You get a new arrow when you shoot the current one</li>
<li>When an arrow goes outside the screen, we stop rendering it</li>
</ul>
<p>The second test is kind of internal. If we render thousands of arrows outside the screen, no one will notice. Until there is a performance issue or an out of memory crash or something like that.</p>
<p>On the other hand, it makes sense, from a gameplay perspective, to talk about arrows going off the screen as being deactivated. Otherwise it might be that they come back after a while, but now instead move downwards.</p>
<h2 id="how-to-write-the-tests">How to write the tests?</h2>
<p>All tests for our game are currently written at the top-level. Here is the test that checks for behavior when we press the space key:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">We run the game for a few frames, press the space key, let it run for a few</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">frames, then quit:</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_keydown_space()],</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="co">The arrow moves:</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow_head_positions = events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We filter out <code>DRAW_CIRCLE</code> events with radius 10 with the assumption that the only circle drawn with radius 10 is the arrow head.</p>
<p>This test assumes only one arrow.</p>
<p>If we were to draw another arrow, there would be no way of identifying the two different arrows in this test.</p>
<p>So writing the new tests at this level feels difficult and error prone.</p>
<p>Testing is so hard.</p>
<p>Let’s see if we can make a new attempt at extracting a subsystem where this new behavior is easier to test.</p>
<h2 id="sprite-group-and-game-scene-refactoring">Sprite group and game scene refactoring</h2>
<p>Our game currently looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, loop):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        ...</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>        <span class="va">self</span>.balloon <span class="op">=</span> Balloon()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> Arrow()</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="va">self</span>.sprites <span class="op">=</span> [<span class="va">self</span>.balloon, <span class="va">self</span>.arrow]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>        <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>            <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>                <span class="va">self</span>.loop.quit()</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>            <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>                <span class="va">self</span>.arrow.shoot()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>        <span class="cf">for</span> sprite <span class="kw">in</span> <span class="va">self</span>.sprites:</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>            sprite.tick(dt)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>        <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>        <span class="cf">for</span> sprite <span class="kw">in</span> <span class="va">self</span>.sprites:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>            sprite.draw(<span class="va">self</span>.loop)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>I have an idea for how to push much of this logic down one level so that it can more easily be tested. Let’s give it a try.</p>
<p>We keep all our sprites in a list. Managing a list of sprites seems like a good job for a new class. We create a <code>SpriteGroup</code> class that works like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; class TestSprite:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co">...     def update(self, dt):</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">...         print(f&quot;TEST SPRITE update {dt}&quot;)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="co">...     def draw(self, loop):</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co">...         print(f&quot;TEST SPRITE draw {loop}&quot;)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; group = SpriteGroup([TestSprite()])</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; x = TestSprite()</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; y = group.add(x)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; x is y</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; group.update(4)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a><span class="al">TEST</span><span class="co"> SPRITE update 4</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a><span class="al">TEST</span><span class="co"> SPRITE update 4</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; group.draw(None)</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a><span class="al">TEST</span><span class="co"> SPRITE draw None</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a><span class="al">TEST</span><span class="co"> SPRITE draw None</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>A sprite is any object that can respond to <code>update</code> and <code>draw</code> calls. When we update and draw the sprite group, it calls the corresponding methods on all its sprites.</p>
<p>We can use this new class in our game like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, loop):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        ...</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        <span class="va">self</span>.balloon <span class="op">=</span> Balloon()</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> Arrow()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        <span class="va">self</span>.all_sprites <span class="op">=</span> SpriteGroup([<span class="va">self</span>.balloon, <span class="va">self</span>.arrow])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>            <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>                <span class="va">self</span>.loop.quit()</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>            <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>                <span class="va">self</span>.arrow.shoot()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        <span class="va">self</span>.all_sprites.update(dt)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>        <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>        <span class="va">self</span>.all_sprites.draw(<span class="va">self</span>.loop)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>Not much of a difference. Mainly we moved the looping over the sprites from our game to the sprite group class. I think this is a bit cleaner, but it makes testing no easier.</p>
<p>But we are not done yet. Now, let’s extract a lower level object that we call <code>GameScene</code>.</p>
<p>The init of the game then changes to this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, loop):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    ...</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="va">self</span>.game_scene <span class="op">=</span> GameScene()</span></code></pre></div>
<p>And the tick method changes to this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>        <span class="va">self</span>.game_scene.event(event)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="va">self</span>.game_scene.update(dt)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="va">self</span>.game_scene.draw(<span class="va">self</span>.loop)</span></code></pre></div>
<p>That is, we defer event handling, updating, and drawing to the game scene.</p>
<p>The game scene looks like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        SpriteGroup.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        <span class="va">self</span>.balloon <span class="op">=</span> <span class="va">self</span>.add(Balloon())</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> <span class="va">self</span>.add(Arrow())</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    <span class="kw">def</span> event(<span class="va">self</span>, event):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>            <span class="cf">raise</span> ExitGameLoop()</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>        <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>            <span class="va">self</span>.arrow.shoot()</span></code></pre></div>
<p>It inherits from <code>SpriteGroup</code> so it gets the <code>update</code> and <code>draw</code> “for free”. And the event handling code is extracted from game. (Since the <code>event</code> method does not have access to the game loop, we can’t call <code>loop.quit()</code> to exit, so we instead raise the exception that <code>loop.quit()</code> would have raised. Initially I thought it would be nice if the loop hide the quit mechanism, and so I did not want to expose the exception. That made this part difficult to write, so I reverted that decision. We constantly adapt the design to the current needs. Perhaps hiding was not the right decision? Or perhaps it was. This will do for now.)</p>
<p>Now that we have a new lower-level object, has testing become any easier?</p>
<h2 id="slow-progress">Slow progress</h2>
<p>I feel like this feature we are working on is quite easy to implement. It will just be a couple of lines of code. Yet, here we are many hours into a sprite group refactoring that we are not sure will even pay off. Why? Only so that we can write a test that “allow” us to write those couple of lines that actually implement this feature.</p>
<p>When we work in an agile way, we constantly change our software, and having a good safety net in the form of a test suite allows us to make changes confidently.</p>
<p>But if it always takes x minutes to write the test and x/10 minutes to implement the thing, is it really worth it?</p>
<p>My suspicion and hope is that testing time varies. When a feature requires a design change, things will take a little longer. With a new design in place, new features can more easily be added (and tested). Until another design challenge comes a long.</p>
<h2 id="state-based-testing">State based testing</h2>
<p>Let’s see how we can test our lower-level game scene object. It is now responsible for some behavior that the balloon shooter class was previously responsible for, so we should be able to write some tests that check the same behavior.</p>
<p>Let’s try initial state: the balloon should animate and the arrow should stay still. Here are tests for that:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">    Initial state</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="co">    =============</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="co">    The balloon animates:</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game = GameScene()</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; first_position = game.get_balloon_position()</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game.update(10)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; second_position = game.get_balloon_position()</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; first_position == second_position</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a><span class="co">    False</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">    The arrow stays still:</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game = GameScene()</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; first_position = game.get_arrow_position()</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; game.update(10)</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; second_position = game.get_arrow_position()</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; first_position == second_position</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>We create a game scene, query some of its state, update it, query some it its state again and make some assertions.</p>
<p>When we wrote these test at the balloon shooter level, we had to assert that circles were drawn in specific locations. In this test, no drawing is involved.</p>
<p>In order for the tests above to work, we have to write getters to expose some internal state:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    ...</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="kw">def</span> get_balloon_position(<span class="va">self</span>):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.balloon.get_position()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="kw">def</span> get_arrow_position(<span class="va">self</span>):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.arrow.get_position()</span></code></pre></div>
<p>These are only used in tests.</p>
<p>For a long time, I was reluctant do this. Mainly because I’ve been taught that objects should not expose internals to the outside world. That is bad object oriented design.</p>
<p>But <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#visible-behavior">James writes</a></p>
<blockquote>
<p>For mutable objects, provide a way for changes in state to be observed, either with a getter method or an event.</p>
</blockquote>
<p>So if we don’t want to use mocks (which we are practicing), exposing state via getters is probably fine.</p>
<p>One thing that we are not testing with these new tests is that the balloon and the arrow are actually drawn at the positions that are returned by the getters.</p>
<p>We could probably write tests where we call the draw method as well and observe <code>DRAW_CIRCLE</code> events and see that they match. But I think the trade off is not worth it in this case. We still have the top-level tests that check that things are drawn on the screen, and the likelihood that we don’t draw at the position that the getter returns is quite small I think.</p>
<p>Anyway, now that we are (mostly) fine with writing getters to expose internal state, testing should be a little smoother.</p>
<h2 id="tests-for-new-arrow-behavior">Tests for new arrow behavior</h2>
<p>Let’s start with the initial state. We introduce the concept of flying arrows (arrows that have been shot) and check that there aren’t any in the beginning:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene()</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_flying_arrows()</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co">[]</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We make it work like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    ...</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>        ...</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>        <span class="va">self</span>.flying_arrows <span class="op">=</span> <span class="va">self</span>.add(SpriteGroup())</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    <span class="kw">def</span> get_flying_arrows(<span class="va">self</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.flying_arrows.get_sprites()</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>We also add the <code>get_sprites</code> getter in the <code>SpriteGroup</code> class. Again, this getter is only used in tests. This bothers me again. Not that it is only used in tests, but that this feels like bad object oriented design. Perhaps it would be cleaner it the sprite group only provided a <code>get_count</code> method? Or something more specific instead of just exposing its internal collection.</p>
<p>But we are fine with exposing internal state for testing purposes. So we don’t think too much about it now. But let’s keep it in the back of our minds for the future.</p>
<p>Let’s move on to shooting so that we get some flying arrows. Here is the test:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene()</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; initial_position = game.get_arrow_position()</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(10)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="co">It makes the arrow fire:</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; flying = game.get_flying_arrows()</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(flying)</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a><span class="co">1</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; flying[0].get_position() == initial_position</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="co">False</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a><span class="co">The initial arrow stays the same:</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_arrow_position() == initial_position</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We simulate a shot by sending a space keydown event followed by an update. We assert that we now have a flying arrow and that its position is not the original position of the arrow (it has moved). Furthermore we assert that the current arrow position is the same as the initial meaning that we still have an arrow that we can shoot.</p>
<p>The implementation: change the event handler for keydown space from this</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="va">self</span>.arrow.shoot()</span></code></pre></div>
<p>to this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="va">self</span>.flying_arrows.add(Arrow(shooting<span class="op">=</span><span class="va">True</span>))</span></code></pre></div>
<p>So the arrow that we shoot actually stays the same and we create a new arrow instance which will be the one shot.</p>
<p>At this point we can actually shoot multiple arrows in the game:</p>
<center>
<img src="multiple-arrows.png" title="fig:" alt="Multiple arrows." />
</center>
<h2 id="remove-arrows-outside-screen">Remove arrows outside screen</h2>
<p>We are almost there. But if we keep running the game for long enough, we will get an out of memory error. So we need to remove arrows that go outside the screen.</p>
<p>We write this test:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game = GameScene(space)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.update(10000)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.get_flying_arrows()</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="co">[]</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>If we decrease the number in <code>update</code> the flying arrows collection will not be empty because the arrow that we shoot has not had time to fly off screen yet.</p>
<p>We make this test pass by overriding the <code>update</code> method of the sprite group and doing the collision detection to remove flying arrows outside the screen:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">class</span> GameScene(SpriteGroup):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    ...</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>        SpriteGroup.update(<span class="va">self</span>, dt)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.flying_arrows.get_sprites():</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>            <span class="cf">if</span> x.hits_space(<span class="va">self</span>.space):</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>                <span class="va">self</span>.flying_arrows.sprites.remove(x)</span></code></pre></div>
<p>Now the <code>get_sprites</code> method that we wrote before, for testing purposes, comes in handy. Iterating over sprites in a collection seems like a reasonable behavior. I still don’t think we should expose the internal collection. That is bad. But we could expose some kind of iterator.</p>
<p>Oh, and to remove the sprite, we actually reach into the fields of the flying arrows group and call it’s <code>remove</code> method. Yikes. But the tests pass. Let’s commit and see if we can improve this.</p>
<p>We come up wit this instead:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">def</span> update(<span class="va">self</span>, dt):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>    SpriteGroup.update(<span class="va">self</span>, dt)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    <span class="cf">for</span> arrow <span class="kw">in</span> <span class="va">self</span>.flying_arrows.get_sprites():</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>        <span class="cf">if</span> arrow.hits_space(<span class="va">self</span>.space):</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>            <span class="va">self</span>.flying_arrows.remove(arrow)</span></code></pre></div>
<p><code>x</code> is not a very meaningful name, so we call it <code>arrow</code> instead. Then we call a new <code>remove</code> method on the sprite group. No more reaching into internal fields and modifying them.</p>
<p>The sprite group looks like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">class</span> SpriteGroup:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    ...</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    <span class="kw">def</span> get_sprites(<span class="va">self</span>):</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">list</span>(<span class="va">self</span>.sprites)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    <span class="kw">def</span> remove(<span class="va">self</span>, sprite):</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>        <span class="va">self</span>.sprites.remove(sprite)</span></code></pre></div>
<p>We ensure that <code>get_sprites</code> returns a new list so that the internal list is never exposed. This has two benefits:</p>
<ol type="1">
<li><p>The sprite group is in control of its own collection. No one on the outside can modify it.</p></li>
<li><p>It is safe to call <code>remove</code> at any time. Before we removed sprites from the collection we were iterating over. That is, in general, is a bad idea.</p></li>
</ol>
<p>I didn’t cover how the collision detection works or what <code>space</code> is. If you are curious, check out the details in <a href="https://github.com/rickardlindberg/agdpp/commit/4956769829b3426c9f0bb3fbe48ccde3150ca5a7">this commit</a>. The complete source code from this episode is on <a href="https://github.com/rickardlindberg/agdpp/tree/shoot-multiple-arrows">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>The big breakthrough in this episode was the realization that it’s OK to write getters to expose internal state for testing purposes. We saw that one of those getters turned out to be useful for the production code as well. I think this will make testing easier, and we will try to write as few getters as possible and only expose “sane” state. We still want to do good object oriented design.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Thinking about test design</title>
    <link href="http://rickardlindberg.me/writing/agdpp-thinking-about-test-setup/" />
    <id>http://rickardlindberg.me/writing/agdpp-thinking-about-test-setup/</id>
    <published>2023-04-28T00:00:00Z</published>
    <updated>2023-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Thinking about test design</h1>

<p><em>Published on 28 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In the <a href="/writing/agdpp-shooting-arrow/index.html">previous</a> episode we were not quite happy with the design of our tests. Are we testing things at the right level? Do we see any smells? Are we missing tests? We will take some time in this episode to reflect on those questions so that things will go smooth(er), testing wise, when working on the next story.</p>
<h2 id="a-concrete-problem">A concrete problem</h2>
<p>In the previous episode I had a feeling that everything was not alright with the tests. I poked around a bit and noticed that I could change some vital production code that would break the game without my tests noticing.</p>
<p>Let’s have a look.</p>
<p>The event handling in the game now looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>            <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>                <span class="va">self</span>.loop.quit()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>            <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>                <span class="va">self</span>.arrow.shoot()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>If we skip the check for the space key and always shoot the arrow, like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    ...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>            <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>                <span class="va">self</span>.loop.quit()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="va">self</span>.arrow.shoot()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>Then the arrow goes off immediately when the game starts, which is obviously not correct, but all tests still pass.</p>
<h2 id="coverage-and-expectation">Coverage and expectation</h2>
<p>The promise of TDD and automated testing is that you can have very high test coverage. What I aspire to is to create a test suite that within seconds tells me if I broke the production code with my change. It might not be realistic, but when I find a case where I could break my production code without my tests noticing, I want to look more closely.</p>
<p>Testing can for sure be seen as a trade off. At some point it probably costs more to test than what you gain.</p>
<p>One reason to not test is that you don’t know how. That can be solved by practicing. Another reason might be that you decide that the cost is not worth it. However, the cost of testing goes down the better you get at it.</p>
<p>And in this series I’m trying to learn as well and document that process. So let’s analyze the problem with the gap in the test suite and see what we can come up with.</p>
<h2 id="what-test-is-missing">What test is missing?</h2>
<p>The balloon shooter has two tests. Here are their descriptions:</p>
<ol type="1">
<li><p>I draw the initial scene of the game which consists of a balloon and an arrow and quit when the user closes the window.</p></li>
<li><p>The arrow moves when it is shot by pressing the space key.</p></li>
</ol>
<p>The first test is checking that the initial frame is drawn correctly.</p>
<p>The second test is checking that the arrow moves when we press space.</p>
<p>But there is no test checking that the arrow stays still if we don’t press space.</p>
<p>I think we tried to remedy that in the previous episode by adding these two “lower-level tests” to the arrow:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">    I stay still if I&#39;ve not been fired:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow = Arrow()</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; initial_y = arrow.y</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; initial_y == arrow.y</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a><span class="co">    I move upwards when fired:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow = Arrow()</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; initial_y = arrow.y</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.shoot()</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; arrow.y &lt; initial_y</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>The problem is that the event checking logic is not in the <code>Arrow</code> class, but in the <code>BalloonShooter</code> class. So what we want to test can’t be tested at this level.</p>
<h2 id="where-to-test">Where to test?</h2>
<p>Writing all tests as “top-level tests” which includes all objects is not a good idea. The test setup will get complicated. The asserts will get difficult to write. The test will be slower.</p>
<p>So we want to test at as a low level as possible.</p>
<p>So if we want to test the initial state of the arrow in the <code>Arrow</code> class, we need to move event handling logic into it, so that it’s its responsibility and does not need to be tested in <code>BalloonShooter</code>.</p>
<p>On the other hand, when you start writing tests for smaller subsystems, those subsystems become harder to refactor. Suppose you are not happy with the subsystems that you have created, and you want a different design. If you do that refactoring, you also have to modify the tests to fit. That makes refactoring and design harder. So you don’t want to do it too early.</p>
<p>In our case, I think we did it too early. Our game class only has one test, and we already started extracting subsystems and writing tests there.</p>
<p>Let’s see if we can fix that.</p>
<h2 id="testing-initial-state">Testing initial state</h2>
<p>Before we had this test for the initial state:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">I draw the initial scene of the game which consists of a balloon and an</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="co">arrow and quit when the user closes the window.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; BalloonShooter.run_in_test_mode(</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a><span class="co">    y: 50</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="co">    radius: 40</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="co">    color: &#39;red&#39;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a><span class="co">    radius: 10</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a><span class="co">    y: 520</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a><span class="co">    radius: 15</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a><span class="co">    y: 540</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a><span class="co">    radius: 20</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>This only captures the initial frame. Let’s see if we can rewrite this.</p>
<p>We start with this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="co">I am a balloon shooter game!</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co">Initial state</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="co">=============</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="co">We run the game for a few frames, then quit:</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>This is just the setup. We simulate that we start the game, run it for a couple of frames, then quit.</p>
<p>What are some behaviors that we expect to see here?</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">The game loop is initialized and cleaned up:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events.filter(&quot;GAMELOOP_INIT&quot;, &quot;GAMELOOP_QUIT&quot;)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co">The balloon is drawn animated:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=40).collect(&quot;x&quot;, &quot;y&quot;)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co">[(50, 50), (51, 50), (52, 50)]</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="co">The arrow is drawn in a fixed position:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;))</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="co">{(500, 500)}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=15).collect(&quot;x&quot;, &quot;y&quot;))</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="co">{(500, 520)}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=20).collect(&quot;x&quot;, &quot;y&quot;))</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">{(500, 540)}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>These new cases cover all the cases in the old test, so we can remove the old. Furthermore it also checks that the arrow doesn’t move so that we no longer can do the mistake of always shooting the arrow. Success!</p>
<h2 id="reflecting-on-new-test-setup">Reflecting on new test setup</h2>
<p>The test for the initial state is structured by simulating a run of the game, collecting events of what happened, and then making specific assertions about those events to check different behavior.</p>
<p>Let’s structure the rests of the test that way too:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="co">User presses space key</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="co">======================</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="co">We run the game for a few frames, press the space key, let it run for a few</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="co">frames, then quit:</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_keydown_space()],</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a><span class="co">The arrow moves:</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow_head_positions = events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>If there are more things that should happen when we press the space key, we can add asserts for it. But for now, I don’t think there is any.</p>
<h2 id="summary">Summary</h2>
<p>All our tests for the game are now written at the top-level. They include all the objects. And they are written close to the acceptance criteria for stories. Don’t we need lower-level tests as well?</p>
<p>We for sure can’t keep testing all aspects of the game with top-level tests. Subsystems must for sure emerge that are easier to test. We will keep that in mind for the future and look extra carefully at what those subsystems might be. But for now, we are happy that we closed the gap in our test suite.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Shooting the arrow</title>
    <link href="http://rickardlindberg.me/writing/agdpp-shooting-arrow/" />
    <id>http://rickardlindberg.me/writing/agdpp-shooting-arrow/</id>
    <published>2023-04-27T00:00:00Z</published>
    <updated>2023-04-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Shooting the arrow</h1>

<p><em>Published on 27 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we continue towards the first version of the balloon shooter. It’s time to shoot the arrow!</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/CfhEcp9Qghc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="recap">Recap</h2>
<p>We are trying to create an absolute minimum version of a balloon shooter game that we can show to our customer and ask if that was what he had in mind. Our idea for minimal is this:</p>
<ul>
<li>1 balloon falling down the screen</li>
<li>1 arrow pointing in a fixed direction</li>
<li>1 button to shoot that single arrow</li>
<li>Then game over</li>
</ul>
<p>In the <a href="/writing/agdpp-demo-and-game-idea/index.html">previous</a> episode, we took the first step by drawing a balloon and an arrow. Here is what it looks like:</p>
<center>
<img src="shooter.png" title="fig:" alt="Balloon shooter." />
</center>
<p>And here is a list of possible stories to work on next:</p>
<ul>
<li>Balloon moves downwards</li>
<li><strong>Arrow animates when shot</strong></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>I sometimes find it hard to look too far into the future. Perhaps that is true for our customer as well. I find it much easier to look at the current state of the software and ask myself “What to work on next?”</p>
<p>When I run the game now, all I want to do is fire that arrow and see it flying across the screen. So that is our next story!</p>
<h2 id="acceptance">Acceptance</h2>
<p>When working in an agile way, things might seem reversed from what you are used to. For example, when doing TDD, we write the test before we write the code. The same applies for stories. Before starting work on a story, we should figure out the acceptance criteria. How do we know when we are done?</p>
<p>For the story with shooting arrow I think the acceptance criteria is that you should see the arrow flying across the screen when you press the space key. Our customer agrees on that.</p>
<p>The next step is to figure out how to write an automated test for that.</p>
<h2 id="the-test-we-want-to-write">The test we want to write</h2>
<p>Just to recap, the test for the balloon shooter looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; loop = GameLoop.create_null(</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = loop.track_events()</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; BalloonShooter(loop).run()</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span class="co">    y: 50</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="co">    radius: 40</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="co">    color: &#39;red&#39;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="co">...</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>That is, we run the balloon shooter game, configure a set of events that should be simulated, and then assert that certain things happens (game loop inits, circles are drawn on screen, etc).</p>
<p>The test we want to write the for the shoot behavior starts like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co">The arrow moves when it is shot by pressing the space key:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; loop = GameLoop.create_null(</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_keydown_space()],</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = loop.track_events()</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; BalloonShooter(loop).run()</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We introduce a new event, keydown space, and simulate that it happens after one frame, and then we simulate a couple of more frames. The reason that we include a couple of frames is that we want to observe that the arrows moves between different frames.</p>
<p>This partial test fails because this new event does not yet exist, so let’s fix that.</p>
<h2 id="adding-a-new-event">Adding a new event</h2>
<p>We add the new event like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> GameLoop(Observable):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    ...</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="at">@staticmethod</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    <span class="kw">def</span> create_event_keydown_space():</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co">        &gt;&gt;&gt; GameLoop.create_event_keydown_space().is_keydown_space()</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="co">        True</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>        <span class="cf">return</span> Event(pygame.event.Event(pygame.KEYDOWN, key<span class="op">=</span>pygame.K_SPACE))</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> Event:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    ...</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="kw">def</span> is_keydown_space(<span class="va">self</span>):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.pygame_event.<span class="bu">type</span> <span class="op">==</span> pygame.KEYDOWN <span class="kw">and</span> <span class="va">self</span>.pygame_event.key <span class="op">==</span> pygame.K_SPACE</span></code></pre></div>
<p>We figure out the Pygame event parameters to use by reading the documentation.</p>
<p>We verify that we got it correct by printing something when we get the keydown space event when running the game. We press different keys to see if it correctly only captures the space key.</p>
<p>It seems to work.</p>
<h2 id="filtering-events">Filtering events</h2>
<p>The initial test now runs, but if we print all the events that we get, there is a lot of noise:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="co">    y: 50</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="co">    radius: 40</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="co">    color: &#39;red&#39;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a><span class="co">...</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>What we want to observe in that list of events is that the arrow has been drawn in different positions (indicating movement).</p>
<p>So first we want to filter out the <code>DRAW_CIRCLE</code> events that are for the head of the arrow.</p>
<p>We want to write like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=10)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>Filtering on event fields is not yet possible, but we own the library, and the fix goes smoothly.</p>
<p>Once that is done, we get this list of events:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co">    radius: 10</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="co">    radius: 10</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="co">    radius: 10</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a><span class="co">    radius: 10</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>This means that when we ran our game in test mode, four frames where drawn and here are all the circles with radius 10. We use 10 here because we know that the head of the arrow is the only circle that is drawn with radius 10. But it is not bullet proof. It would be better if we could pass an id to the draw method call that is included in the event as well so that we could more accurately identify objects. But this will do for now.</p>
<h2 id="extracting-positions">Extracting positions</h2>
<p>In the output above, we can look at the x and y coordinates and see if they change. But there are also other fields that we don’t care about in this test. Let’s filter out the position like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="co">[(500, 500), (500, 500), (500, 500), (500, 500)]</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>Again, the <code>collect</code> method does not exist, but we can extend our library with it.</p>
<p>Now we have a list of positions where the head of the arrow is drawn. It doesn’t seem to change, which we can see more clearly by making the collection into a set and seeing that it has only one element:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;))</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="co">{(500, 500)}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<h2 id="real-test-failure">Real test failure</h2>
<p>We want the arrow to move, so let’s write an assert like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>That is, we should get more than one position, and the set of all those positions should also be larger than one, indicating movement.</p>
<p>The first assertion passes, but the other one fails. That is expected. Finally we have the assertion failure that we wanted. Took a bit of time, huh? That might tell us something about the design of our system. We’ll talk about it in <a href="/writing/agdpp-thinking-about-test-setup/index.html">another episode</a>.</p>
<h2 id="implementation">Implementation</h2>
<p>First, we modify the event handler to check for the space key and shoot the arrow if so:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">class</span> BalloonShooter:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>        <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>            <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>                <span class="va">self</span>.loop.quit()</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>            <span class="cf">elif</span> event.is_keydown_space():</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>                <span class="va">self</span>.arrow.shoot()</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>        ...</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>The shooting mechanism, we implement like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>        <span class="va">self</span>.y <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>        <span class="va">self</span>.shooting <span class="op">=</span> <span class="va">False</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    <span class="kw">def</span> shoot(<span class="va">self</span>):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>        <span class="va">self</span>.shooting <span class="op">=</span> <span class="va">True</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.shooting:</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>            <span class="va">self</span>.y <span class="op">-=</span> dt</span></code></pre></div>
<p>We also adjust the drawing code so that all three circles that are drawn for the arrow are drawn relative to the now variable y position.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    loop.draw_circle(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="va">self</span>.y, color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    loop.draw_circle(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="va">self</span>.y<span class="op">+</span><span class="dv">20</span>, color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    loop.draw_circle(x<span class="op">=</span><span class="dv">500</span>, y<span class="op">=</span><span class="va">self</span>.y<span class="op">+</span><span class="dv">40</span>, color<span class="op">=</span><span class="st">&quot;blue&quot;</span>, radius<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<p>The arrow now moves when we press the space key. Success! Unfortunately we only have one shot. Then we need to restart the game to get a new arrow. We will fix that in another story.</p>
<h2 id="getting-tangled-up-in-tests">Getting tangled up in tests</h2>
<p>The shooting works, but I think we forgot to test the initial case. If we don’t press the space key, the arrow should stay still.</p>
<p>We can change the tick method of the arrow to this, and all tests still pass:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    <span class="va">self</span>.y <span class="op">-=</span> dt</span></code></pre></div>
<p>But that makes the arrow move immediately, even if not shot, which was not intended.</p>
<p>We write a few more specific tests for the behavior of the arrow:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="co">I stay still if I&#39;ve not been fired:</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow = Arrow()</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; initial_y = arrow.y</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; initial_y == arrow.y</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a><span class="co">I move upwards when fired:</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow = Arrow()</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; initial_y = arrow.y</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.shoot()</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.tick(1)</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; arrow.y &lt; initial_y</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a><span class="co">True</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>That forces us to add the if statement again.</p>
<p>I’m not sure I’m entirely happy that we access the y variable like that. I prefer to see all fields of a class in Python as private (unless it’s a pure data object). But we got the test working at least.</p>
<p>I’m not happy with the current tests. On the other hand, I’m not sure how to improve them either.</p>
<p>Maybe it’s time to go for a jog or spend some time off the computer with my notebook to see if any better ideas emerge. But for now, we leave it like this.</p>
<h2 id="summary">Summary</h2>
<p>The arrow now moves. So exciting! But it’s a bummer that you have to restart the game after each shot. Therefore I think the game over screen might be most interesting to work on next. When the arrow misses (goes outside the screen) the game should be over, and the arrow should be reset.</p>
<p>After that, I think collision check with balloon would be most interesting.</p>
<p>All those require tests of course. So we should probably work on getting comfortable with the test setup as well.</p>
<p>The source code from this episode is on <a href="https://github.com/rickardlindberg/agdpp/tree/shoot-arrow">GitHub</a>.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Demo and game idea</title>
    <link href="http://rickardlindberg.me/writing/agdpp-demo-and-game-idea/" />
    <id>http://rickardlindberg.me/writing/agdpp-demo-and-game-idea/</id>
    <published>2023-04-24T00:00:00Z</published>
    <updated>2023-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Demo and game idea</h1>

<p><em>Published on 24 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we demo the “game” for our customer. We get some feedback on it and start evolving the game to meet our customer’s vision.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z20IocFrKLY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="demo">Demo</h2>
<p>I mentioned to my son that I had started working on a game. He wanted to see it. I told him that there isn’t much to play yet, but that I can show him what it looks like.</p>
<p>I started the “game” and he watched the circle going back and forth.</p>
<p>For reference, this is what the “game” looks like now:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<p>Then he tried to interact with the circle. He grabbed the mouse and clicked away and was disappointed that nothing happened. I told him that you can’t do anything yet, that it’s just an animation.</p>
<p>He looked at me sad and said “Dad, this game is boring.”</p>
<p>Initially I wasn’t planning on showing him the game because in this early stage there is not much to play, and I knew he was not going to like it. Did I ruin it?</p>
<p>Then I asked him, “What would you like to do with the circle?”</p>
<p>The sadness in his face disappeared and he started talking about balloons. He said that he wanted the circle to be a balloon and that he wanted to shoot down balloons with arrows.</p>
<p>I think we have an idea for a game.</p>
<h2 id="on-early-feedback">On early feedback</h2>
<p>My initial idea for the game was some kind of tetris variant. I was thinking that you have two boards and that you could help each other out by clearing blocks on each other’s boards. Cooperation seems more fun that competition.</p>
<p>Turns out, the customer wants a balloon shooter. If we hadn’t shown the demo, we might have never found that out.</p>
<h2 id="simplest-possible-version">Simplest possible version</h2>
<p>In the spirit of <a href="https://www.artima.com/articles/the-simplest-thing-that-could-possibly-work#part3">Ward</a> we ask ourselves what the simplest possible balloon shooter could look like. What is the absolute minimum version that I can give to my son and he can somewhat enjoy playing or at least recognize as a balloon shooter? (The goal is to create a game that <em>we</em> can enjoy playing together. That means some kind of multiplayer mode. But that is another for a later story.)</p>
<p>Here is what I’m thinking:</p>
<ul>
<li>1 balloon falling down the screen</li>
<li>1 arrow pointing in a fixed direction</li>
<li>1 button to shoot that single arrow</li>
<li>Then game over</li>
</ul>
<p>So the only challenge will be to fire the arrow at the right time for it to hit the balloon. You will either hit and get a point or miss and it’ll be game over.</p>
<p>Oh, and circles for the graphics is probably fine. The balloon can be drawn with one big circle, and the arrow maybe with three smaller circles in a row. If I tell my son to imagine they are balloons and arrows, I think he’ll accept that.</p>
<h2 id="first-story">First story</h2>
<p>To make progress towards a balloon shooter, I want to work on a story that is about drawing a balloon and an arrow. Create the initial scene of the game sort of.</p>
<p>Our game already animates a circle. Let’s put all behavior related to that circle into its own class called <code>Balloon</code>. Here is how our game <code>tick</code> method looks like now:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    ...</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="cf">if</span> <span class="va">self</span>.x <span class="op">&gt;</span> <span class="dv">500</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="va">self</span>.x <span class="op">+=</span> dt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="va">self</span>.loop.draw_circle(<span class="va">self</span>.x)</span></code></pre></div>
<p>After we extract the balloon class, it looks like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    ...</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="va">self</span>.balloon.tick(dt)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="va">self</span>.balloon.draw(<span class="va">self</span>.loop)</span></code></pre></div>
<p>And here is the balloon class:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">class</span> Balloon:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        <span class="va">self</span>.x <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.x <span class="op">&gt;</span> <span class="dv">500</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>            <span class="va">self</span>.x <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>            <span class="va">self</span>.x <span class="op">+=</span> dt</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>        loop.draw_circle(<span class="va">self</span>.x)</span></code></pre></div>
<p>Any behavior that the balloon should have, we can now test at this lower level. We can instantiate a balloon, call its tick method, and observe that the right thing happens. There is no need to involve the game or the game loop. (At least if we accept exposing somewhat internal state like the x variable.)</p>
<p>With the balloon object in place, it is natural to create a new object called <code>Arrow</code> for our other piece in the balloon shooter game. We create a version that just draws a circle:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> Arrow:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="kw">def</span> draw(<span class="va">self</span>, loop):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        loop.draw_circle(<span class="dv">10</span>)</span></code></pre></div>
<p>We make sure it is included in the game by modifying the tick method of the game to also tick and draw the arrow:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    ...</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="va">self</span>.balloon.tick(dt)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="va">self</span>.arrow.tick(dt)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="va">self</span>.balloon.draw(<span class="va">self</span>.loop)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="va">self</span>.tick.draw(<span class="va">self</span>.loop)</span></code></pre></div>
<p>We notice a pattern here. It seems like the responsibility of the game is to call tick and draw on a set of objects. In games (or in Pygame) those objects are referred to as sprites. My understanding is that a sprite is any visual element that shows up in the game.</p>
<p>We refactor our game to reflect this new understanding:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">class</span> Game:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, loop):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>        ...</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>        <span class="va">self</span>.balloon <span class="op">=</span> Balloon()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        <span class="va">self</span>.arrow <span class="op">=</span> Arrow()</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>        <span class="va">self</span>.sprites <span class="op">=</span> [<span class="va">self</span>.balloon, <span class="va">self</span>.arrow]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        ...</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span class="cf">for</span> sprite <span class="kw">in</span> <span class="va">self</span>.sprites:</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>            sprite.tick(dt)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>        <span class="va">self</span>.loop.clear_screen()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>        <span class="cf">for</span> sprite <span class="kw">in</span> <span class="va">self</span>.sprites:</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>            sprite.draw(<span class="va">self</span>.loop)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>Is our game class just becoming a thing layer of loops? Can we move some of that responsibility to the game loop? I’m not certain yet, so we will leave it like this for now.</p>
<p>If we run the game now, this is what we see:</p>
<center>
<img src="scene1.png" title="fig:" alt="First scene of balloon shooter." />
</center>
<p>Not very pretty. What is that?</p>
<p>Let’s see if we can improve the drawing of the arrow. But remember, not perfection, but improvement. If I look at the game now, I don’t get an idea what the game is about. We just want to make the arrow slightly more realistic to convey the meaning of the object. We are still restricted to drawing circles. The current <code>draw_circle</code> looks like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">def</span> draw_circle(<span class="va">self</span>, x):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="va">self</span>.notify(<span class="st">&quot;DRAW_CIRCLE&quot;</span>, {<span class="st">&quot;x&quot;</span>: x})</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="va">self</span>.pygame.draw.circle(<span class="va">self</span>.screen, <span class="st">&quot;red&quot;</span>, (x, <span class="dv">50</span>), <span class="dv">40</span>)</span></code></pre></div>
<p>That’s stupid! Why is there no ability to specify anything but the x-coordinate? Well, until now, we haven’t needed that. Now that we do need it, let’s add it. No biggie:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">def</span> draw_circle(<span class="va">self</span>, x, y<span class="op">=</span><span class="dv">50</span>, radius<span class="op">=</span><span class="dv">40</span>, color<span class="op">=</span><span class="st">&quot;red&quot;</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="va">self</span>.notify(<span class="st">&quot;DRAW_CIRCLE&quot;</span>, {<span class="st">&quot;x&quot;</span>: x, <span class="st">&quot;y&quot;</span>: y, <span class="st">&quot;radius&quot;</span>: radius, <span class="st">&quot;color&quot;</span>: color})</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="va">self</span>.pygame.draw.circle(<span class="va">self</span>.screen, color, (x, y), radius)</span></code></pre></div>
<p>We experiment with three circles for the arrow and tweak the numbers until we think it looks good. Here is the result:</p>
<center>
<img src="scene2.png" title="fig:" alt="Improved drawing of arrow." />
</center>
<p>I don’t know about you, but when I see this, I want to press a button to fire that arrow so it hits the balloon. I’m convinced this is a balloon shooter now. I hope our customer is as well.</p>
<p>Right, balloon shooter. Before we didn’t know what game we should write, so our game class was just called <code>Game</code>. Let’s fix that:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a> from gameloop import GameLoop</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="st">-class Game:</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="va">+class BalloonShooter:</span></span></code></pre></div>
<p>There! Now the code more accurately represent the ideas that we have in our minds about this game.</p>
<p>I forget to mention anything about testing. (For the complete workflow, check out the video.) But here is what the test for the balloon shooter looks like now:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">I draw the initial scene of the game which consists of a balloon and an</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co">arrow and quit when the user closes the window.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; loop = GameLoop.create_null(</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = loop.track_events()</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; BalloonShooter(loop).run()</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a><span class="co">    y: 50</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a><span class="co">    radius: 40</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a><span class="co">    color: &#39;red&#39;</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a><span class="co">    y: 500</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a><span class="co">    radius: 10</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a><span class="co">    y: 520</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a><span class="co">    radius: 15</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a><span class="co">    x: 500</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a><span class="co">    y: 540</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a><span class="co">    radius: 20</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a><span class="co">    color: &#39;blue&#39;</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We both changed the description, becasue we have a balloon shooter now, not a generic game, and added checks for it drawing both the balloon and the arrow.</p>
<p>It might be too specific to assert on exact coordinates here. We have to visually inspect the output and see if we think it looks good. That’s what I did here. And when I was happy, I copied the coordinates into the test.</p>
<h2 id="summary">Summary</h2>
<p>We have completed a first vertical slice of our balloon shooter. There is now a balloon and an arrow on the screen. This is new behavior that we could show to our customer and get feedback on. Perhaps he doesn’t like the position of the arrow. If so, we can adjust. Perhaps he can’t imagine that the circle is actually a balloon. If so, we can work on improving the graphics.</p>
<p>What else do we think we need before we have the first version of the balloon shooter?</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow animates when shot</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>Which one is the most important one to work on next? We’ll tackle that one in the next episode!</p>
<p>You can browse the <a href="https://github.com/rickardlindberg/agdpp/tree/initial-balloon-shooter-story">complete source code</a> from this episode.</p>
<p>See you!</p>
]]></summary>
</entry>
<entry>
    <title>Separating pygame completely from the rest of the game</title>
    <link href="http://rickardlindberg.me/writing/agdpp-pygame-separation-design/" />
    <id>http://rickardlindberg.me/writing/agdpp-pygame-separation-design/</id>
    <published>2023-04-20T00:00:00Z</published>
    <updated>2023-04-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Separating pygame completely from the rest of the game</h1>

<p><em>Published on 20 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we reflect on our current design. I see something that bothers me. We talk about it and how to fix it.</p>
<h2 id="the-problem">The problem</h2>
<p>Right now our game is split up into two main classes: the game and the game loop. The game contains the logic of our game, while the game loop is responsible for setting up pygame and calling our game on every frame.</p>
<p>Almost all references to pygame are contained in the game loop class. Our game knows almost nothing about pygame. Almost. And that bothers me.</p>
<p>Let’s have a look at the test for our game:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">I draw an animated circle until the user closes the window.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; loop = GameLoop.create_null(</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co">...         [pygame.event.Event(pygame.QUIT)],</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events = loop.track_events()</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; Game(loop).run()</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="co">PYGAME_INIT =&gt;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="co">    x: 51</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="co">PYGAME_QUIT =&gt;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>We can see references to pygame in two places. First when we create the quit event. We create an instance of a pygame event and pass that to the null version of the game loop. Later in the events that we assert on, there are event names mentioning pygame (<code>PYGAME_INIT</code> and <code>PYGAME_QUIT</code>).</p>
<p>Why does this bother me?</p>
<p>One purpose of introducing the game loop class was to separate pygame code from our game. One reason to do that is that our game becomes easier to test. And if it’s easier to test, it suggests that the design is also better. (People claim at least. So let’s go with that here.)</p>
<p>But some details of pygame are leaking out.</p>
<p>If <code>GameLoop</code> were instead called <code>PygameGameLoop</code>, I would be more fine with this. But I think the design would be more clear if the game didn’t know anything at all about pygame.</p>
<p>Our game loop uses the <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#infrastructure-wrappers">infrastructure wrapper</a> pattern. One purpose of that pattern is to isolate and contain infrastructure code so that the user of it can be provided an interface that is optimal for its consumption. In our case we want to design our game loop to fit exactly what our game needs. And the loop should encapsulate all the details of how to make that happen (using pygame).</p>
<p>Our game now needs to know that the pygame quit event is fired when the user closes the window. But wouldn’t it be more clear if that could be expressed in the code something like this instead?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="va">self</span>.loop.quit()</span></code></pre></div>
<p>Above, the game does not need to know about pygame and can directly express the idea that if the user closes the window, the game loop should be quit.</p>
<p>Enough talking, let’s see if we can fix this.</p>
<h2 id="wrapping-events">Wrapping events</h2>
<p>The tick method of our game now looks like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>        <span class="cf">if</span> event.<span class="bu">type</span> <span class="op">==</span> pygame.QUIT:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>            <span class="va">self</span>.loop.quit()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>The interface is that events is a list of pygame event instances.</p>
<p>Let’s change that to instead be instances of a new event class that we control. Here is a first version:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> Event:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, pygame_event):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        <span class="va">self</span>.pygame_event <span class="op">=</span> pygame_event</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="kw">def</span> is_user_closed_window(<span class="va">self</span>):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.pygame_event.<span class="bu">type</span> <span class="op">==</span> pygame.QUIT</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">repr</span>(<span class="va">self</span>.pygame_event)</span></code></pre></div>
<p>Now we can change how the game loop calls the game from this</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>game.tick(dt, <span class="va">self</span>.pygame.event.get())</span></code></pre></div>
<p>to this</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>game.tick(dt, [Event(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.pygame.event.get()])</span></code></pre></div>
<p>This breaks our tests saying that</p>
<pre><code>AttributeError: &#39;Event&#39; object has no attribute &#39;type&#39;</code></pre>
<p>We modify our game to use our new method instead:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">def</span> tick(<span class="va">self</span>, dt, events):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>        <span class="cf">if</span> event.is_user_closed_window():</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>            <span class="va">self</span>.loop.quit()</span></code></pre></div>
<p>All tests are passing again.</p>
<p>We can rely on our tests for this refactoring.</p>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/ac00de877b8f4ee58716c0030c8b2ecab19a318e"><code>git commit -a -m ‘Wrap events to tick for a nicer interface.’</code></a></p>
<h2 id="test-still-mentions-pygame">Test still mentions pygame</h2>
<p>Our test for the game still creates pygame events:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; loop = GameLoop.create_null(</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="co">...         [pygame.event.Event(pygame.QUIT)],</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>Here we would like to instead express the idea that we want to simulate a user closes the window event without mentioning any more details.</p>
<p>Here is one attempt:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; loop = GameLoop.create_null(</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co">...     events=[</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">...         [],</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="co">...         [GameLoop.create_event_user_closed_window()],</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="co">...     ]</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="co">... )</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>And in game loop, we add this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="at">@staticmethod</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">def</span> create_event_user_closed_window():</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="cf">return</span> pygame.event.Event(pygame.QUIT)</span></code></pre></div>
<p>Now the game loop knows the details of how to create pygame events. I think this is better. But there is one thing that still bothers me.</p>
<p>The tick method expects a list of events with the interface that we make up, but <code>create_event_user_closed_window</code> creates a pygame event. So right now, there is no way for us to test the tick method in isolation, because there is no way to create events. If we expose the <code>Event</code> class we could do something like this in a test:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; game.tick(dt=1, events=[Event(GameLoop.create_user_close_window())])</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>I’m not sure I like that. I think I would feel better if <code>create_event_user_closed_window</code> returned an event with our interface. Let’s try that.</p>
<p>We modify it:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="at">@staticmethod</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">def</span> create_event_user_closed_window():</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="cf">return</span> Event(pygame.event.Event(pygame.QUIT))</span></code></pre></div>
<p>Test fail:</p>
<pre><code>AttributeError: &#39;Event&#39; object has no attribute &#39;type&#39;</code></pre>
<p>I think we are now wrapping events in events. Let’s unpack the pygame event when creating the null version, going from this</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> NullEvent:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="kw">def</span> get(<span class="va">self</span>):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>        <span class="cf">if</span> events:</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>            <span class="cf">return</span> events.pop(<span class="dv">0</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>        <span class="cf">return</span> []</span></code></pre></div>
<p>to this</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">class</span> NullEvent:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    <span class="kw">def</span> get(<span class="va">self</span>):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>        <span class="cf">if</span> events:</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>            <span class="cf">return</span> [x.pygame_event <span class="cf">for</span> x <span class="kw">in</span> events.pop(<span class="dv">0</span>)]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>        <span class="cf">return</span> []</span></code></pre></div>
<p>Now another test fails:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> GameLoop.create_null(events<span class="op">=</span>[[<span class="st">&quot;some event&quot;</span>]]).run(game)</span></code></pre></div>
<p>We just changed the interface of <code>create_null</code> to expect <code>Event</code> instances. Here we are passing a string. It should really be a pygame event. But we ignore that for now and just change to this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> GameLoop.create_null(events<span class="op">=</span>[[Event(<span class="st">&quot;some event&quot;</span>)]]).run(game)</span></code></pre></div>
<p>All tests are passing. Success!</p>
<p>We add a test to illustrate the usage of the factory method:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="at">@staticmethod</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="kw">def</span> create_event_user_closed_window():</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="co">    &gt;&gt;&gt; GameLoop.create_event_user_closed_window().is_user_closed_window()</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="co">    True</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    <span class="cf">return</span> Event(pygame.event.Event(pygame.QUIT))</span></code></pre></div>
<p>At this point our game no longer depends on pygame. It only depends on the game loop which provides the infrastructure needed for writing a game (graphics, user input, music, etc). We can remove the import of pygame so the top of the file now looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="im">from</span> gameloop <span class="im">import</span> GameLoop</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="kw">class</span> Game:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/3686e4d1f5740301f2177810cfa26fa093153c17"><code>git commit -a -m ‘Wrap events so that our game now longer knows about pygame.’</code></a></p>
<h2 id="get-rid-of-last-pygame-reference">Get rid of last pygame reference</h2>
<p>There is still one place left where our game test refers to pygame:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="co">...</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="co">PYGAME_INIT =&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span class="co">    x: 51</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span class="co">PYGAME_QUIT =&gt;</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p>Some events that the game loop emits have pygame in their name.</p>
<p>Imagine that we could plug any game loop implementation into our game and from the game’s perspective, they all worked the same. Then it doesn’t make sense for it to emit events that talk about the underlying technology to realize the game loop.</p>
<p>Let’s rename <code>PYGAME_INIT</code> to <code>GAMELOOP_INIT</code> and <code>PYGAME_QUIT</code> to <code>GAMELOOP_QUIT</code>. And while we are improving events, let’s also add the resolution and fps to the init event so that we can observe them.</p>
<p>Here is how the test reads then:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">...</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="co">&gt;&gt;&gt; events</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="co">GAMELOOP_INIT =&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="co">    resolution: (1280, 720)</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="co">    fps: 60</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="co">    x: 50</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a><span class="co">CLEAR_SCREEN =&gt;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="co">DRAW_CIRCLE =&gt;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="co">    x: 51</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="co">GAMELOOP_QUIT =&gt;</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/b6ef6430ee93bf9b933f5f06d69d9666ca2d1cd2"><code>git commit -a -m ‘Game loop emits events with clearer names.’</code></a></p>
<h2 id="unnecessary-work">Unnecessary work?</h2>
<p>At this point, our game knows nothing about pygame. It only relies on the interface of the game loop. That is something that we control and can design specifically for what our game needs. And should we want to switch out pygame for another graphics library, we only need to modify the game loop, not our game.</p>
<p>You might object that this seems like too much speculative design. What is the likelyhood that we want to switch graphics package? And can’t we deal with those problems when they arise?</p>
<p>On the one hand, I think that objection is valid. But I would like to see this from another angle. The purpose of this change was not to make pygame easily replaceable. The purpose of the change was to design a clean interface for our game where the different classes had different responsibilities. Only as a side effect pygame became more replaceable.</p>
<p>Had we designed a base class <code>GameLoop</code> and then derived a <code>PygameGameLoop</code> from it, then I think we would have designed speculatively. There is only one implementation of the game loop right now. We don’t even anticipate any more implementations, so why make a “placeholder” in our design where a second implementation could be plugged in?</p>
<h2 id="summary">Summary</h2>
<p>Making design changes in the beginning is generally easier. The further you go in the wrong direction, the harder it is to undo. (But with careful refactoring, it is always possible.) One problem is that it might be harder to see problems with the design early on. How are a few references to pygame problematic? I think thinking in terms of code smells instead of in terms of speculative design is useful here.</p>
<p>By the way, I’m not sure the design I choose here is the “correct” one. I’m just trying to learn and practice here and explain my thinking. But I think if I give attention to design early on, the future will be easier.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>

</feed>
