<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Rickard's personal homepage: latest posts tagged rlvideo</title>
        <link>http://rickardlindberg.me</link>
        <description><![CDATA[Rickard's personal homepage: latest posts tagged rlvideo]]></description>
        <atom:link href="http://rickardlindberg.me/tags/rlvideo/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 28 Jul 2023 00:00:00 UT</lastBuildDate>
        <item>
    <title>Writing my own video editor</title>
    <link>http://rickardlindberg.me/writing/writing-my-own-video-editor/</link>
    <description><![CDATA[<h1>Writing my own video editor</h1>

<p><em>Published on 28 July 2023.</em></p>

<p>On May 28 I write <a href="https://hachyderm.io/@rickardlindberg/110447282439624451">this</a>:</p>
<blockquote>
<p>Got the urge to write my own video editor. Tired of kdenlive’s instability. And I don’t need something that advanced. Reading a bit about the MLT framework makes me think that it might actually be possible to do in a reasonable time.</p>
<p>Sometimes I feel bad for starting more projects than i finish. On the other hand, every project I do teach me something. And I do this (believe it or not) for my enjoyment.</p>
</blockquote>
<p>It happens to me from time to time. I get an idea for something that I want to build. Sometimes the urge goes away. This time it doesn’t.</p>
<h2 id="why-write-a-video-editor">Why write a video editor?</h2>
<p>I like to build things. In particular I like to build things that I have a use for myself.</p>
<p>Currently, I use <a href="https://kdenlive.org/en/">Kdenlive</a> as my video editor. It has served me well. However, every time I work with it, I get a little frustrated. It often crashes on me, it often feels slow, and there are certain things that I want to do that I don’t know how.</p>
<p>The normal way of solving those problems I think would include</p>
<ul>
<li>Trying the latest version of Kdenlive (would require me to upgrade Fedora version as well)</li>
<li>Buying a faster computer</li>
<li>Learning Kdenlive better</li>
</ul>
<p>But I can program, and I like to build things. So from that point of view, the obvious solution is to build my own video editor specifically for my needs.</p>
<p>Even if it ends up being unusable as my video editor, I will have had a good time working on it and most likely learned a thing or two.</p>
<h2 id="more-ideas">More ideas</h2>
<p>On June 16 I sketch the following in my notebook:</p>
<p>
<center>
<img src="sketch-initial.png" title="fig:" alt="Initial sketch of a timeline." />
</center>
</p>
<p>I think about how to represent clips on a timeline in my ideal video editor. This sketch also tells me that the urge has not gone away.</p>
<h2 id="researching-mlt">Researching MLT</h2>
<p>Writing a video editor seems like a daunting task. The only reason that I think it will be possible is with help from <a href="https://www.mltframework.org/">MLT</a>. From their website:</p>
<blockquote>
<p>MLT is an open source multimedia framework, designed and developed for television broadcasting. It provides a toolkit for broadcasters, video editors, media players, transcoders, web streamers and many more types of applications.</p>
</blockquote>
<p>So a lot of the heavy lifting of a video editor can be done by MLT. That is my guess and hope anyway. What I can focus on is writing a nice frontend for it.</p>
<p>Instead of speculating, I do some spikes to learn how to use MLT from Python.</p>
<p>Here is one example how to put two clips next to each other on a timeline and preview the result:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">mlt</span>

<span class="n">mlt</span><span class="o">.</span><span class="n">Factory</span><span class="p">()</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">profile</span> <span class="o">=</span> <span class="n">mlt</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">playlist</span> <span class="o">=</span> <span class="n">mlt</span><span class="o">.</span><span class="n">Playlist</span><span class="p">()</span>
<span class="n">playlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlt</span><span class="o">.</span><span class="n">Producer</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;VID_20230611_120041.mp4&quot;</span><span class="p">))</span>
<span class="n">playlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mlt</span><span class="o">.</span><span class="n">Producer</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;VID_20230611_115932.mp4&quot;</span><span class="p">))</span>
<span class="n">consumer</span> <span class="o">=</span> <span class="n">mlt</span><span class="o">.</span><span class="n">Consumer</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;sdl&quot;</span><span class="p">)</span>
<span class="n">consumer</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;rescale&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)</span>
<span class="n">consumer</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">playlist</span><span class="p">)</span>
<span class="n">consumer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">while</span> <span class="n">consumer</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>More examples from my spikes can be found <a href="https://github.com/rickardlindberg/rlvideo/blob/91dd25a0d39cbe25e8ce85157115d023b4d2c78c/spikes/mlt_hello_world.py">here</a>.</p>
<p>To help me do the spikes, I use the following resources:</p>
<ul>
<li><p><a href="https://www.mltframework.org/docs/framework/">MLT Framework Design</a>: A good introduction to how MLT works.</p></li>
<li><p><a href="https://github.com/mltframework/mlt/tree/master/src/swig/python">Python examples</a>: Examples how to use MLT from Python. They are quite limited, but give you a good starting point.</p></li>
<li><p><a href="https://www.mltframework.org/doxygen/annotated.html">MLT API documentation</a>: The C API documentation. Translating this to Python has been mostly straight forward.</p></li>
<li><p><a href="https://github.com/jliljebl/flowblade">Flowblade</a>: Another video editor that is written in Python and MLT.</p></li>
</ul>
<h2 id="design-idea">Design idea</h2>
<p>By doing the spikes, I have a basic understanding of how to use MLT and how it could be used to build a video editor.</p>
<p>The design I have in mind for the video editor looks something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Timeline</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clips</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clip</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clips</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">clip</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_mlt_producer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>That is, I want to use custom data structures for representing clips on a timeline. I think that will give us a design which is clean and easy to work with. We can design those structures to be good for the kinds of operations that we want to perform.</p>
<p>However, somehow those structures must be turned into an MLT producer. That is what <code>to_mlt_producer</code> is for. Transforming from our world into the MLT world. When we have an MLT producer, we can preview the composition and render a final result. But all the edit operations will be done on our custom data structures.</p>
<h2 id="timeline-representation">Timeline representation</h2>
<p>So what representation of clips is best? It depends on how it’s going to be used. How do I want to work with clips on a timeline in my ideal video editor?</p>
<p>On June 28 I sketch this:</p>
<p>
<center>
<img src="sketch-timeline-visualization.png" title="fig:" alt="Sketch of a timeline visualization of overlap." />
</center>
</p>
<p>And on June 30 I sketch this:</p>
<p>
<center>
<img src="sketch-split-sections.png" title="fig:" alt="Sketch of a timeline splits." />
</center>
</p>
<p>I don’t think that I want to have multiple tracks in the timeline. There should only be one track. When clips overlap, multiple tracks might be created in the background, but the user should not need to create tracks manually.</p>
<p>The sketches help me figure this out.</p>
<p>I think that we can have one structure with all the clips and their positions. Then we can split those up into sections. One type of section has no overlaps, and the other do. Overlaps must be handled differently. They both render differently (stacked on top of each other) and they must produce multiple MLT tracks in the background.</p>
<p>I work on this section splitting code and end up with this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; a = Source(&quot;A&quot;).create_cut(0, 20).at(0)</span>
<span class="sd">&gt;&gt;&gt; b = Source(&quot;b&quot;).create_cut(0, 20).at(10)</span>
<span class="sd">&gt;&gt;&gt; cuts = Cuts()</span>
<span class="sd">&gt;&gt;&gt; cuts = cuts.add(a)</span>
<span class="sd">&gt;&gt;&gt; cuts = cuts.add(b)</span>
<span class="sd">&gt;&gt;&gt; cuts.split_into_sections().to_ascii_canvas()</span>
<span class="sd">|&lt;-A0------|--A10----&gt;|--b10----&gt;|</span>
<span class="sd">|          |&lt;-b0------|          |</span>
<span class="sd">&gt;&gt;&gt; cuts.modify(b, lambda cut: cut.move(1)).split_into_sections().to_ascii_canvas()</span>
<span class="sd">|&lt;-A0-------|--A11---&gt;|--b9------&gt;|</span>
<span class="sd">|           |&lt;-b0-----|           |</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The <code>to_ascii_canvas</code> is only used in tests to give me faster feedback on the splitting code. It also documents quite nicely what the timeline would look like in different situations.</p>
<h2 id="putting-it-together">Putting it together</h2>
<p>I spend quite some time getting the splitting of cuts to work. Even before I know if this design will work out. (Not very smart.) We know if it will work out when we put everything together.</p>
<p>I first try to put everything together in a Pygame application, but it gives me all kinds of problems, so I decide to try GTK instead.</p>
<p>The application has two parts: one that shows the timeline, and one that shows the preview window.</p>
<p>The timeline is created something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">timeline_draw</span><span class="p">(</span><span class="n">widget</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="n">sections</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">timeline</span> <span class="o">=</span> <span class="n">Gtk</span><span class="o">.</span><span class="n">DrawingArea</span><span class="p">()</span>
<span class="n">timeline</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;draw&quot;</span><span class="p">,</span> <span class="n">timeline_draw</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>It hooks up the draw event and lets the sections (created by <code>split_into_sections</code>) do all the drawing.</p>
<p>The preview window is created something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">preview</span> <span class="o">=</span> <span class="n">Gtk</span><span class="o">.</span><span class="n">DrawingArea</span><span class="p">()</span>
<span class="n">os</span><span class="o">.</span><span class="n">putenv</span><span class="p">(</span><span class="s2">&quot;SDL_WINDOWID&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">preview</span><span class="o">.</span><span class="n">get_window</span><span class="p">()</span><span class="o">.</span><span class="n">get_xid</span><span class="p">()))</span>
<span class="n">consumer</span> <span class="o">=</span> <span class="n">mlt</span><span class="o">.</span><span class="n">Consumer</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;sdl&quot;</span><span class="p">)</span>
<span class="n">consumer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">consumer</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sections</span><span class="o">.</span><span class="n">to_mlt_producer</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>It connects the SDL consumer to the preview window and the producer (created by <code>to_mlt_producer</code>) to the consumer. I learn how to make the SDL consumer draw its output inside a GTK window by looking at the Flowblade source code.</p>
<p>I get a basic version of <code>Sections.draw</code> and <code>Sections.to_mlt_producer</code> and end up with this on July 3:</p>
<p>
<center>
<img src="current-status.png" title="fig:" alt="Current look of application." />
</center>
</p>
<h2 id="future">Future</h2>
<p>At this point we have a sort of proof of concept of the design. We can now</p>
<ul>
<li>Programmaticlly load clips into a timeline data structure.</li>
<li>This structure can draw itself onto a Cairo context which we can use to render it inside a GTK application.</li>
<li>This structure can also generate an MLT producer which we can use to preview the composition using the SDL consumer and have the output shown in a window in our GTK application via <code>SDL_WINDOWID</code>.</li>
</ul>
<p>One thing that I worry about with this design is performance. Every time we modify the timeline, we have to generate a new sections object and from that generate a new MLT producer. That might take time. My hope and guess is that we can do smart things to get good enough performance. But it is worth looking into to quite soon to ensure that this design will hold even for larger projects.</p>
<p>There for sure are many, many more details to flesh out before we have a functioning video editor. But I’m quite pleased that we have gotten this far in this quite short amount of time.</p>
<p>You can find the source code on <a href="https://github.com/rickardlindberg/rlvideo">GitHub</a>.</p>
]]></description>
    <pubDate>Fri, 28 Jul 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/writing-my-own-video-editor/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>How to get fast feedback on graphical code?</title>
    <link>http://rickardlindberg.me/writing/fast-feedback-on-graphical-code/</link>
    <description><![CDATA[<h1>How to get fast feedback on graphical code?</h1>

<p><em>Published on 28 July 2023.</em></p>

<p>I am working on <a href="/writing/writing-my-own-video-editor/index.html">my own video editor</a>. It currently looks like this:</p>
<p>
<center>
<img src="rlvideo.png" title="fig:" alt="Current state of video editor." />
</center>
</p>
<p>The bottom pane shows the timeline with all the clips. It is a <code>Gtk.DrawingArea</code> where all the drawing is done using Cairo.</p>
<p>When I work on the drawing code, I want fast feedback on it. Does it look good? Does it draw as intended?</p>
<p>Usually I use TDD for this kind of feedback, but graphical output it hard to test.</p>
<p>In the beginning, I used to run the application after every change. This was quite fast because the application is still small and I can start it up with a sample timeline quite quickly. However, it still takes a few seconds and a couple of keystrokes.</p>
<p>Then I came up with a much better workflow.</p>
<p>I added a (doc)test to my test suite that does something like this (some details removed):</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)</span>
<span class="sd">&gt;&gt;&gt; context = cairo.Context(surface)</span>
<span class="sd">&gt;&gt;&gt; project = Project.new()</span>
<span class="sd">&gt;&gt;&gt; with project.new_transaction() as transaction:</span>
<span class="sd">...     _ = transaction.add_text_clip(&quot;hello&quot;, length=30)</span>
<span class="sd">...     x = transaction.add_text_clip(&quot;world&quot;, length=35)</span>
<span class="sd">...     _ = transaction.add_text_clip(&quot;end&quot;, length=20)</span>
<span class="sd">...     _ = transaction.add_text_clip(&quot;end&quot;, length=20)</span>
<span class="sd">...     transaction.modify(x, lambda cut: cut.move(-10))</span>
<span class="sd">&gt;&gt;&gt; timeline = Timeline(project)</span>
<span class="sd">&gt;&gt;&gt; timeline.draw_cairo(</span>
<span class="sd">...     context=context,</span>
<span class="sd">...     playhead_position=40,</span>
<span class="sd">...     width=width,</span>
<span class="sd">...     height=height</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; surface.write_to_png(&quot;timeline.png&quot;)</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The <code>Timeline</code> class is what does the drawing of the timeline. Fortunately, it is separated from the GTK component onto which it is drawn. This allows us to create our own Cairo surface, let the timeline draw itself on that, and in the end, write that surface to a file.</p>
<p>Every time we run the test suite (which I like to do automatically on every save) we get a new <code>timeline.png</code> file where the example clips that we populated in the test are drawn. If we open this file in the GNOME image viewer (<code>eog timeline.png</code>) it will automatically reload the image when it changes.</p>
<p>In this workflow, this is my typical setup:</p>
<p>
<center>
<img src="workflow1.png" title="fig:" alt="Workflow setup." />
</center>
</p>
<p>I have my editor to the right, the automatic test suite runner in the top left, and the timeline image in the bottom left.</p>
<p>In this example I draw two timelines with different zoom levels so that I can quickly see how that looks.</p>
<p>Then I can make a change to some color for example, and within a second or two, my test suite has automatically run and my desktop looks like this:</p>
<p>
<center>
<img src="workflow2.png" title="fig:" alt="Workflow after a change." />
</center>
</p>
<p>I can tweak numbers until I think it looks good and I never have to leave my editor.</p>
]]></description>
    <pubDate>Fri, 28 Jul 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/fast-feedback-on-graphical-code/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>
<item>
    <title>DevLog 001: J-cuts and L-cuts in my video editor?</title>
    <link>http://rickardlindberg.me/writing/devlog-001-jcut-lcut/</link>
    <description><![CDATA[<h1>DevLog 001: J-cuts and L-cuts in my video editor?</h1>

<p><em>Published on 28 July 2023.</em></p>

<h2 id="about-devlogs">About DevLogs</h2>
<p>DevLogs is an experiment to try to document development that I do on various projects. I will try to write what is going on in my head as I do various development tasks.</p>
<h2 id="todays-problem">Today’s problem</h2>
<p>In my video editor, there is a problem with overlapping clips. How they overlap appears to be almost random.</p>
<p>In this edit, the <code>two.mp4</code> clip is rendered below:</p>
<p>
<center>
<img src="edit1.png" title="fig:" alt="Alternative text." />
</center>
</p>
<p>If we edit the <code>one.mp4</code> clip, then the two switch order.</p>
<p>
<center>
<img src="edit2.png" title="fig:" alt="Alternative text." />
</center>
</p>
<p>So the order depends on the modification times of clips.</p>
<p>That is not very good.</p>
<h2 id="plan">Plan</h2>
<p>My idea for how to solve this is that each clip can specify how it should be cut into the previous one.</p>
<p>I imagine a library of cuts such as:</p>
<ul>
<li>over</li>
<li>under</li>
<li>j-cut</li>
<li>l-cut</li>
<li>overlay (with priority)</li>
<li>background (with priority)</li>
</ul>
<p>To make progress on this, we can probably assume a default cut (maybe under) and make sure it works. Then we can extend the library of cuts.</p>
<h2 id="writing-a-test">Writing a test</h2>
<p>The relevant code for this is mostly here:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">extract_mix_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; cuts = Cuts.from_list([</span>
<span class="sd">    ...     Cut.test_instance(name=&quot;A&quot;, start=0, end=8, position=1),</span>
<span class="sd">    ...     Cut.test_instance(name=&quot;B&quot;, start=0, end=8, position=5),</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; cuts.to_ascii_canvas()</span>
<span class="sd">    | &lt;-A0---&gt;    |</span>
<span class="sd">    |     &lt;-B0---&gt;|</span>
<span class="sd">    &gt;&gt;&gt; cuts.extract_mix_section(Region(start=0, end=15)).to_ascii_canvas()</span>
<span class="sd">    %&lt;-A0---&gt;%%%%%%</span>
<span class="sd">    %%%%%&lt;-B0---&gt;%%</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: sort based on cut (j-cut, l-cut, overlay, background).</span>
    <span class="n">playlists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_cut</span><span class="p">(</span><span class="n">region</span><span class="p">)</span><span class="o">.</span><span class="n">cut_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">playlists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Cuts</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span><span class="o">.</span><span class="n">extract_playlist_section</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">MixSection</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">region</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">playlists</span><span class="o">=</span><span class="n">playlists</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Let’s write a test that shows the current behavior first:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; region = Region(start=0, end=15)</span>
<span class="sd">&gt;&gt;&gt; a_cut = Cut.test_instance(name=&quot;A&quot;, start=0, end=8, position=1)</span>
<span class="sd">&gt;&gt;&gt; b_cut = Cut.test_instance(name=&quot;B&quot;, start=0, end=8, position=5)</span>

<span class="sd">&gt;&gt;&gt; Cuts.from_list([</span>
<span class="sd">...     a_cut,</span>
<span class="sd">...     b_cut,</span>
<span class="sd">... ]).extract_mix_section(region).to_ascii_canvas()</span>
<span class="sd">%&lt;-A0---&gt;%%%%%%</span>
<span class="sd">%%%%%&lt;-B0---&gt;%%</span>

<span class="sd">&gt;&gt;&gt; Cuts.from_list([</span>
<span class="sd">...     b_cut,</span>
<span class="sd">...     a_cut,</span>
<span class="sd">... ]).extract_mix_section(region).to_ascii_canvas()</span>
<span class="sd">%%%%%&lt;-B0---&gt;%%</span>
<span class="sd">%&lt;-A0---&gt;%%%%%%</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>So depending on the order in which cuts are added, they mix differently. This is exactly the behavior that we want to change. We want them to mix the same no matter what order they are added in.</p>
<p>Let’s commit this as a baseline:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>$ ./make.py commit -m <span class="s1">&#39;Pinpoint current behavior of mixing cuts.&#39;</span>
</pre>
</div>
</div>
</div>
<p>The <code>./make.py commit</code> script is a wrapper around <code>git commit</code> that also runs the tests and makes sure there are no untracked files. A real handy tool to make sure we don’t commit “bad” code.</p>
<h2 id="cut-the-same">Cut the same</h2>
<p>I modify the test above to assert that the same mix is created even when the cuts are in the reverse order.</p>
<p>I make it pass by sorting the clips by start time, making “later” clips appear below which would be the equivalent of having the cut on the second b clip set to “under”:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">sort_cuts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuts</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cuts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cut</span><span class="p">:</span> <span class="n">cut</span><span class="o">.</span><span class="n">get_source_cut</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That works as intended in the application as well. Let’s commit:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>$ ./make.py commit -m <span class="s1">&#39;Always mix cuts below previous cut.&#39;</span>
</pre>
</div>
</div>
</div>
<h2 id="clips-with-the-same-start">Clips with the same start</h2>
<p>If two cuts have the same start, the sorting will have no effect and we still have the same problem.</p>
<p>First of all, I don’t think this scenario will be that common in a real situation.</p>
<p>I’m thinking we can handle it with a warning. If such situation appears, the user has to resolve the issue by hinting how the mix should be done.</p>
<p>We can also take the end position into account. Then only cuts with the same start and end has the problem. In which case the user must explicitly tell which should be on top somehow.</p>
<h2 id="summary">Summary</h2>
<p>We made progress towards mixing cuts in a better way. Next step in this area I think is to allow the type of cut to be specified per clip and take that into account when sorting cuts. I think it should be quite easy to write tests for this and we should be able to move steady and carefully using TDD.</p>
]]></description>
    <pubDate>Fri, 28 Jul 2023 00:00:00 UT</pubDate>
    <guid>http://rickardlindberg.me/writing/devlog-001-jcut-lcut/</guid>
    <dc:creator>Rickard Lindberg</dc:creator>
</item>

    </channel>
</rss>
