<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      RLMeta poster 2: the poster that wasn't | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>RLMeta poster 2: the poster that wasn't</h1>

<p><em>Published on 12 February 2022.</em></p>

<ul>
<li><a href="#code-walk-through">Code walk through</a>
<ul>
<li><a href="#getting-rlmeta">Getting RLMeta</a></li>
<li><a href="#file-structure">File structure</a></li>
<li><a href="#exploring-rlmeta">Exploring RLMeta</a></li>
<li><a href="#a-tour-of-the-main-function">A tour of the main function</a></li>
<li><a href="#following-a-compilation">Following a compilation</a></li>
<li><a href="#the-purpose-of-the-make-script">The purpose of the make script</a></li>
</ul></li>
<li><a href="#changes-from-the-poster-version">Changes from the poster version</a>
<ul>
<li><a href="#generate-labels-in-semantic-actions">Generate labels in semantic actions</a></li>
<li><a href="#remove-dependency-on-bash">Remove dependency on Bash</a></li>
<li><a href="#extract-assembler">Extract assembler</a></li>
<li><a href="#rewrite-vm-for-clarity">Rewrite VM for clarity</a></li>
<li><a href="#add-ability-to-run-a-rule-in-semantic-action">Add ability to run a rule in semantic action</a></li>
<li><a href="#misc">Misc</a></li>
</ul></li>
<li><a href="#the-future">The future</a></li>
<li><a href="#code-listings-for-rlmeta">Code listings for RLMeta</a>
<ul>
<li><a href="#srcparser.rlmeta">src/parser.rlmeta</a></li>
<li><a href="#srccodegenerator.rlmeta">src/codegenerator.rlmeta</a></li>
<li><a href="#srcassembler.rlmeta">src/assembler.rlmeta</a></li>
<li><a href="#srcsupport.py">src/support.py</a></li>
<li><a href="#srcmain.py">src/main.py</a></li>
<li><a href="#make.py">make.py</a></li>
</ul></li>
</ul>
<p>A while ago I created a <a href="../../writing/creating-rlmeta-poster/">poster</a> to showcase RLMeta. The version of RLMeta on the poster is based on the version from the <a href="../../writing/rlmeta-memoize-failures/">memoizing failures</a> article, but I made it smaller and more beautiful to better fit the poster. To be able to finish the poster, I had to stop making changes and put the source code on the poster. That was difficult because I felt the need for it to be perfect. Eventually I did stop polishing, and left a few items unresolved.</p>
<p>Almost immediately after I finished the poster, I started working on a second version. Initially, my plan was to make a second version of the poster. I started to fix the unresolved items and I was making progress. But somehow imperfections kept creeping in. It felt like a never ending game of chasing perfection. That’s when I decided that a second poster was probably not going to be worth it. But I still liked the new version of RLMeta.</p>
<p>Instead, I decided to attempt to present the new version in the style of a code walk through. In other words, another way to showcase RLMeta that is also a bit more practical. Compared to the poster version, this version could also be more easily improved because rendering the blog post is automatic whereas creating the layout of a poster requires manual work every time the source code changes. I also wanted to experiment with the walk through format because I thought it could be something worth putting into the README of a project.</p>
<p>The rest of this blog post consists of the walk through of the new version of RLMeta and a section on the most important changes from the poster version and motivations for them.</p>
<h2 id="code-walk-through">Code walk through</h2>
<h3 id="getting-rlmeta">Getting RLMeta</h3>
<p>In order to follow along on this walk through, you need to download the version of RLMeta from here: <a href="rlmeta-poster-2.zip">rlmeta-poster-2.zip</a>.</p>
<h3 id="file-structure">File structure</h3>
<p>The zip file consists of the source code for the RLMeta compiler, a make script, and the compiler itself (<code>rlmeta.py</code>):</p>
<pre class="text"><code>$ tree --dirsfirst
.
├── src
│   ├── assembler.rlmeta
│   ├── codegenerator.rlmeta
│   ├── main.py
│   ├── parser.rlmeta
│   └── support.py
├── make.py
└── rlmeta.py

1 directory, 7 files</code></pre>
<p>The size of the source code is quite small:</p>
<pre class="text"><code>$ wc -l src/*
   39 src/assembler.rlmeta
   57 src/codegenerator.rlmeta
   26 src/main.py
   60 src/parser.rlmeta
  240 src/support.py
  422 total</code></pre>
<p>The compiler can be created from this source code only. We will see how later in this walk through.</p>
<h3 id="exploring-rlmeta">Exploring RLMeta</h3>
<p>Before we dive into how the RLMeta compiler is created, let’s explore RLMeta by writing a small, but real, program in it.</p>
<p>What types of programs can we write in RLMeta?</p>
<p>In RLMeta, we write grammars. Grammars have rules that specify how to match objects from an input stream and specify what should happen when objects are matched.</p>
<p>Let’s write a grammar that counts the number of objects in an input stream and produces a report:</p>
<pre class="text"><code>$ cat object_counter.rlmeta
ObjectCounter {
    count = .*:xs -&gt; { &quot;number of objects = &quot; len(xs) }
}</code></pre>
<p>The main function of the RLMeta compiler is to transform grammars into Python code. If invoked without arguments, the compiler reads a grammar from stdin and writes Python code to stdout:</p>
<pre class="text"><code>$ cat object_counter.rlmeta | python rlmeta.py
class ObjectCounter(Grammar):
    rules = {
        'count': 0
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        10,
        MATCH,
        'any',
        lambda x: True,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        ACTION,
        lambda self: join(['number of objects = ', self.lookup('len')(self.lookup('xs'))]),
        POP_SCOPE,
        RETURN
    ]</code></pre>
<p>This is equivalent to using the <code>--compile</code> command with a value of <code>-</code> which stands for stdin:</p>
<pre class="text"><code>$ cat object_counter.rlmeta | python rlmeta.py --compile - | head -n3
class ObjectCounter(Grammar):
    rules = {
        'count': 0</code></pre>
<p>And, the file can also be specified directly like this:</p>
<pre class="text"><code>$ python rlmeta.py --compile object_counter.rlmeta | head -n3
class ObjectCounter(Grammar):
    rules = {
        'count': 0</code></pre>
<p>Don’t worry about understanding the generated code. We will explore it more later. Just note that the generated class inherits from a class called <code>Grammar</code> and that it uses some constants like <code>PUSH_SCOPE</code> and <code>LIST_START</code>. These things are defined in a support library which can be generated by the RLMeta compiler with the <code>--support</code> command:</p>
<pre class="text"><code>$ python rlmeta.py --support | grep '^\(class\|def\)'
class VM:
def PUSH_SCOPE(vm):
def POP_SCOPE(vm):
def BACKTRACK(vm):
def COMMIT(vm):
def CALL(vm):
def CALL_(vm, pc):
def RETURN(vm):
def MATCH(vm):
def MATCH_(vm, fn, message):
def MATCH_CALL_RULE(vm):
def LIST_START(vm):
def LIST_APPEND(vm):
def LIST_END(vm):
def BIND(vm):
def ACTION(vm):
def PUSH_STREAM(vm):
def POP_STREAM(vm):
def FAIL(vm):
def FAIL_(vm, fail_message):
class SemanticAction(object):
class MatchError(Exception):
class Grammar(object):
class Runtime(dict):
class Counter(object):
def splice(depth, item):
def concat(lists):
def join(items, delimiter=&quot;&quot;):
def indent(text, prefix=&quot;    &quot;):
def compile_chain(grammars, source):</code></pre>
<p>To create a complete program, we also have to write a main function that instantiates the <code>ObjectCounter</code> grammar and invokes its <code>count</code> rule.</p>
<p>Here is an example that passes stdin as the input stream to the <code>count</code> rule and prints the result to stdout:</p>
<pre class="text"><code>$ cat object_counter_main.py
if __name__ == &quot;__main__&quot;:
    import sys
    sys.stdout.write(ObjectCounter().run(&quot;count&quot;, sys.stdin.read()))</code></pre>
<p>The <code>--copy</code> command of the RLMeta compiler can be used to copy this main file, as is, to the output.</p>
<p>Combining these pieces into a single compile command, we get this:</p>
<pre class="text"><code>$ python rlmeta.py --support --compile object_counter.rlmeta --copy object_counter_main.py &gt; object_counter.py</code></pre>
<p>It will perform all commands in the given order and write all generated code concatenated into a single file.</p>
<p>Note that the support library comes before the grammar so that <code>Grammar</code> is defined by the time <code>ObjectCounter</code> is evaluated.</p>
<p>The object counter source code has now been compiled into a standalone Python program that can be run like this:</p>
<pre class="text"><code>$ echo 'hello' | python object_counter.py
number of objects = 6```

```text
$ echo 'this is longer' | python object_counter.py
number of objects = 15```

So programs in RLMeta are written mainly in grammar files with some support
functions written in Python. The RLMeta compiler can process all these files to
produce a single Python file which is the compiled program.


### Compiling RLMeta itself

Now that we have an understanding of RLMeta, let's look at the command that
compiles the RLMeta compiler itself from the source code:

```text
$ python rlmeta.py --embed SUPPORT src/support.py --support --compile src/parser.rlmeta --compile src/codegenerator.rlmeta --compile src/assembler.rlmeta --copy src/main.py &gt; rlmeta-raw.py</code></pre>
<p>The first command, <code>--embed SUPPORT src/support.py</code>, tells the compiler to generate a Python variable named <code>SUPPORT</code> containing the contents of the file <code>src/support.py</code>. The <code>--embed</code> command is the last command of the compiler that we have not yet seen. (The RLMeta compiler needs the support library in a variable so that it can generate it later with the <code>--support</code> command.)</p>
<p>Next, the <code>--support</code> command tells the compiler to generate the support library that is embedded in it.</p>
<p>The <code>--compile ...</code> commands tell the compiler to compile the given grammar files.</p>
<p>The last command, <code>--copy src/main.py</code>, tells the compiler to copy the main file verbatim. Similar to what we did to the main file in the object counter.</p>
<p>The make script can be called with the <code>--compile</code> command to perform this exact function:</p>
<pre class="text"><code>$ ./make.py --compile &gt; rlmeta-compile.py
Compiling rlmeta using rlmeta.py
  O-----------------O
  | RLMeta compiled |
~~|     itself!     |
  O-----------------O</code></pre>
<p>And all these files are exactly the same:</p>
<pre class="text"><code>$ md5sum rlmeta.py rlmeta-compile.py rlmeta-raw.py
92396155e85e24fb45cb3e58e160e89e  rlmeta.py
92396155e85e24fb45cb3e58e160e89e  rlmeta-compile.py
92396155e85e24fb45cb3e58e160e89e  rlmeta-raw.py</code></pre>
<p>Thus, the RLMeta compiler reproduced itself exactly from the source code.</p>
<h3 id="a-tour-of-the-main-function">A tour of the main function</h3>
<p>Let’s now look at how all commands of the RLMeta compiler are implemented. Here is the main function:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="kw">def</span> read(path):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>        <span class="cf">if</span> path <span class="op">==</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>            <span class="cf">return</span> sys.stdin.read()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        <span class="cf">with</span> <span class="bu">open</span>(path) <span class="im">as</span> f:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>            <span class="cf">return</span> f.read()</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    args <span class="op">=</span> sys.argv[<span class="dv">1</span>:] <span class="kw">or</span> [<span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;-&quot;</span>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    <span class="cf">while</span> args:</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>        command <span class="op">=</span> args.pop(<span class="dv">0</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>        <span class="cf">if</span> command <span class="op">==</span> <span class="st">&quot;--support&quot;</span>:</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>            sys.stdout.write(SUPPORT)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--copy&quot;</span>:</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>            sys.stdout.write(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--embed&quot;</span>:</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>            sys.stdout.write(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> = </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>                args.pop(<span class="dv">0</span>),</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>                <span class="bu">repr</span>(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>            ))</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--compile&quot;</span>:</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>            sys.stdout.write(compile_chain(</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>                [(Parser, <span class="st">&quot;file&quot;</span>), (CodeGenerator, <span class="st">&quot;asts&quot;</span>), (Assembler, <span class="st">&quot;asts&quot;</span>)],</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>                read(args.pop(<span class="dv">0</span>))</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>            ))</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: Unknown command '</span><span class="sc">{}</span><span class="st">'&quot;</span>.<span class="bu">format</span>(command))</span></code></pre></div>
<p>It contains command line parsing and handles processing of all commands.</p>
<p>The <code>--compile</code> command is the most complex of them all. It calls the <code>compile_chain</code> function which runs the given grammars/rules in order (in this case the input will first be parsed, then passed to the code generator, and finally passed to the assembler) and prints a pretty error message to stderr upon failure:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">def</span> compile_chain(grammars, source):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    <span class="im">import</span> os</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    <span class="im">import</span> pprint</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="cf">for</span> grammar, rule <span class="kw">in</span> grammars:</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>            source <span class="op">=</span> grammar().run(rule, source)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        <span class="cf">except</span> MatchError <span class="im">as</span> e:</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>            marker <span class="op">=</span> <span class="st">&quot;&lt;ERROR POSITION&gt;&quot;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>            <span class="cf">if</span> os.isatty(sys.stderr.fileno()):</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>                marker <span class="op">=</span> <span class="ss">f&quot;</span><span class="ch">\033</span><span class="ss">[0;31m</span><span class="sc">{</span>marker<span class="sc">}</span><span class="ch">\033</span><span class="ss">[0m&quot;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(e.stream, <span class="bu">str</span>):</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>                stream_string <span class="op">=</span> e.stream[:e.pos] <span class="op">+</span> marker <span class="op">+</span> e.stream[e.pos:]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>                stream_string <span class="op">=</span> pprint.pformat(e.stream)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">POSITION: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">STREAM:</span><span class="ch">\n</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>                e.message,</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>                e.pos,</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a>                indent(stream_string)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a>            ))</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>    <span class="cf">return</span> source</span></code></pre></div>
<p>This function might be useful for other RLMeta programs as well. That is why it’s included in the support library and not only in the main file.</p>
<h3 id="following-a-compilation">Following a compilation</h3>
<p>Let’s now follow a compilation of an example grammar to learn more about how a grammar file is turned into Python code. Here it is:</p>
<pre class="text"><code>$ cat example.rlmeta
Example {
    main = .
}</code></pre>
<p>And this is what it compiles to:</p>
<pre class="text"><code>$ python rlmeta.py --compile example.rlmeta
class Example(Grammar):
    rules = {
        'main': 0
    }
    code = [
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        POP_SCOPE,
        RETURN
    ]</code></pre>
<p>The transformations that the grammar goes through are defined in the main function:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>[(Parser, <span class="st">&quot;file&quot;</span>), (CodeGenerator, <span class="st">&quot;asts&quot;</span>), (Assembler, <span class="st">&quot;asts&quot;</span>)],</span></code></pre></div>
<p>So first the grammar file is passed to the <code>file</code> rule of the parser:</p>
<pre class="text"><code>file =
  | (space grammar)*:xs space !.            -&gt; xs</code></pre>
<p>It in turn calls the <code>grammar</code> rule to parse all grammars in the file:</p>
<pre class="text"><code>grammar =
  | name:x space '{' rule*:ys space '}'     -&gt; [&quot;Grammar&quot; x ~ys]</code></pre>
<p>This rule matches the name, the open curly brace, a set of rules, and the closing curly brace. It will then return an AST that looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>[</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    <span class="st">&quot;Grammar&quot;</span>,</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="st">&quot;Example&quot;</span>,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    ...</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>All grammar AST nodes are handed off to the <code>asts</code> rule in the code generator:</p>
<pre class="text"><code>asts          = ast*:xs !.  -&gt; xs</code></pre>
<p>It it turn calls the <code>ast</code> rule to process each AST node:</p>
<pre class="text"><code>ast           = [%:x]       -&gt; x</code></pre>
<p>The <code>ast</code> rule treats the first argument in the AST as a rule name, and calls that rule. In this case <code>Grammar</code>:</p>
<pre class="text"><code>Grammar       = .:x ast*:ys -&gt; [&quot;Grammar&quot; x ~~ys]</code></pre>
<p>The code generator creates a new AST node representing a grammar. But this AST node is slightly different and meant to be processed by the assembler. The result is this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>[</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>    <span class="st">&quot;Grammar&quot;</span>,</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    <span class="st">&quot;Example&quot;</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    ... ast nodes <span class="cf">for</span> consumption by assembler ...</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>This AST node and all the others that the code generator produces are passed to the <code>asts</code> rule in the assembler:</p>
<pre class="text"><code>asts     = ast*:xs !.      -&gt; { xs }</code></pre>
<p>It in turn calls the <code>ast</code> rule:</p>
<pre class="text"><code>ast      = [%:x]           -&gt; x</code></pre>
<p>Which does the same trick again, now invoking the <code>Grammar</code> rule (in the assembler) which looks like this:</p>
<pre class="text"><code>Grammar  = .:x ast*:ys     -&gt; list():rules
                           -&gt; list():code
                           -&gt; dict():labels
                           -&gt; list():patches
                           -&gt; ys
                           -&gt; run(&quot;asts&quot; patches)
                           -&gt; { &quot;class &quot; x &quot;(Grammar):\n&quot; &gt;
                                  &quot;rules = {\n&quot; &gt; join(rules &quot;,\n&quot;) &lt; &quot;\n}\n&quot;
                                  &quot;code = [\n&quot; &gt; join(code  &quot;,\n&quot;) &lt; &quot;\n]\n&quot;
                                &lt; }</code></pre>
<p>This rule can be read as follows:</p>
<ul>
<li>Match the grammar name and all AST nodes</li>
<li>Perform the following action
<ul>
<li>Define a variable called <code>rules</code> which is a list</li>
<li>Define a variable called <code>code</code> which is a list</li>
<li>Define a variable called <code>labels</code> which is a dictionary</li>
<li>Define a variable called <code>patches</code> which is a list</li>
<li>Evaluate the AST nodes (with possible side effects recorded in the above variables)</li>
<li>Treat the value of the <code>patches</code> variable as a list of AST nodes and process them with the <code>asts</code> rule of this grammar</li>
<li>Return a string which is generated Python code</li>
</ul></li>
</ul>
<p>The generated code from our example looks like this:</p>
<pre><code>class Example(Grammar):
    rules = {
        ...
    }
    code = [
        ...
    ]</code></pre>
<p>To understand how the <code>rule</code> and <code>code</code> sections are generated, we just have to follow a few more transformations.</p>
<p>Let’s look at one more and see how the rule in our example grammar is transformed.</p>
<p>First, the rule is parsed by the <code>rule</code> rule in the parser:</p>
<pre class="text"><code>rule =
  | name:x space '=' choice:y               -&gt; [&quot;Rule&quot; x y]</code></pre>
<p>First the name is matched, then the equals sign, and then an expression representing the body of the rule.</p>
<p>It our case, this rule produces this AST node:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>[</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>    <span class="st">&quot;Rule&quot;</span>,</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>    <span class="st">&quot;main&quot;</span>,</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>    ...</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>That node is going to be processed by the <code>Rule</code> rule in the code generator:</p>
<pre class="text"><code>Rule          = .:x ast:y   -&gt; [[&quot;Rule&quot; x]
                                ~y
                                [&quot;OpCode&quot; &quot;RETURN&quot;]]</code></pre>
<p>Generating an AST node that looks like this:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>[</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>    [<span class="st">&quot;Rule&quot;</span>, <span class="st">&quot;main&quot;</span>],</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    ...,</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    [<span class="st">&quot;OpCode&quot;</span>, <span class="st">&quot;RETURN&quot;</span>]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>]</span></code></pre></div>
<p>Here we can see that the AST from the code generator looks a bit more like assembly code than a representation of the syntax in the grammar.</p>
<p>The first child in this AST node is going to be handled the <code>Rule</code> rule in the assembler:</p>
<pre class="text"><code>Rule     = .:x             -&gt; add(rules { repr(x) &quot;: &quot; len(code) })
                           -&gt; set(labels x len(code))</code></pre>
<p>It does two things:</p>
<ol type="1">
<li>Adds a string value to the <code>rules</code> list</li>
<li>Adds an entry to the <code>labels</code> dictionary to map a label to an index in the <code>code</code> list</li>
</ol>
<p>At this point, the variables have the following values.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>rules <span class="op">=</span> [</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="st">&quot;'main': 0&quot;</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>]</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>labels <span class="op">=</span> {</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>    <span class="st">'main'</span>: <span class="dv">0</span>,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>The second child in the AST node is going to be handled by the <code>OpCode</code> rule in the assembler:</p>
<pre class="text"><code>OpCode   = .:x             -&gt; add(code x)</code></pre>
<p>It adds the given op code to the <code>code</code> list, giving it this value:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>code <span class="op">=</span> [</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>    ...,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    <span class="st">&quot;RETURN&quot;</span>,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>]</span></code></pre></div>
<p>When the <code>rules</code> and <code>code</code> variables are expanded, the resulting class looks like this:</p>
<pre><code>class Example(Grammar):
    rules = {
        'main': 0
    }
    code = [
        ...,
        RETURN
    ]</code></pre>
<p>Hopefully you should now be comfortable to follow transformations yourself to understand how a compilation is done.</p>
<h3 id="the-purpose-of-the-make-script">The purpose of the make script</h3>
<p>When the make script is called without arguments, it performs a meta compilation and runs a few tests:</p>
<pre class="text"><code>$ ./make.py
Compiling rlmeta using rlmeta.py
Writing rlmeta1.py
Test: Has its own support library
Test: Disallow semantic action in the middle
ERROR: expected }
POSITION: 22
STREAM:
    Grammar { x = . -&gt; [] &lt;ERROR POSITION&gt;. }
Test: Call unknown rule foo
Moving rlmeta1.py -&gt; rlmeta.py
  O-----------------O
  | RLMeta compiled |
~~|     itself!     |
  O-----------------O</code></pre>
<p>The meaning of a meta compilation is to create a new version of RLMeta that can still reproduce itself from the source code.</p>
<p>In the output above, we can see that it compiled RLMeta and wrote the result to <code>rlmeta1.py</code>. In this case, since it is exactly the same as <code>rlmeta.py</code>, the compilation stopped there and a few more tests were run using this compiler. But if we make changes to the source code, <code>rlmeta1.py</code> will most likely not be exactly the same as <code>rlmeta.py</code>, and a few more compilations might be needed. I’ve written about the details of meta compilation in a <a href="../../writing/modifying-rlmeta/index.html#5f6a1c91143146dbb3b865ac42562135">previous blog post</a>.</p>
<p>So the purpose of the make script is to ease meta compilations and also run a test suit on the newly generated metacompiler before accepting it.</p>
<p>The make script can also be used to perform a single compilation of RLMeta with the <code>--compile</code> argument as we saw earlier.</p>
<h2 id="changes-from-the-poster-version">Changes from the poster version</h2>
<p>This section explains the most important changes in this version of RLMeta compared to the poster version.</p>
<p>First of all, I wanted to work on the unresolved items which were the following:</p>
<ul>
<li>The label counter is incremented at match time, not at semantic action evaluation time.</li>
<li>Compilation depends on Bash.</li>
<li>Assembly code in code generator is hard to read.</li>
</ul>
<p>In the poster article, I also had a few notes about <a href="../../writing/creating-rlmeta-poster/index.html#b070abcd2f134cf894e33e63188a9fee">future versions</a>:</p>
<blockquote>
<p>The smaller it is, the easier it is to understand and therefore extend. The more flexible it is to extend the better. If I make another poster version it would therefore focus on being smaller and more flexible. Since all successive version of RLMeta have been faster than the ones before, performance is also important. But small size, clarity, and flexibility come first.</p>
</blockquote>
<p>I used these guidelines to decide if certain changes should go into the new version or not.</p>
<p>One interesting thing to note is that the guidelines are sometimes contradicting. Writing clear code might mean more lines of code which makes the code base larger. Perhaps that’s also why I got stuck chasing perfection. I thought I made something easier to read, but it ended up costing 10 extra lines of code. Should I include it?</p>
<h3 id="generate-labels-in-semantic-actions">Generate labels in semantic actions</h3>
<p>One thing that I left in the poster version that still annoyed me was that labels were generated at match time, not at semantic action evaluation time. It would not produce incorrect results. At worst, some labels end up not being used because the counter value captured was in a rule that later failed. But dealing with labels at match time does not make sense. It should really happen at semantic action evaluation time.</p>
<p>Here is what the <code>Not</code> rule looks like in the poster version:</p>
<pre class="text"><code>Not = ast:x #:a #:b -&gt; { &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                         x
                         &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                         &quot;LABEL(&quot; a &quot;)\n&quot;
                         &quot;I('FAIL', 'no match expected')\n&quot;
                         &quot;LABEL(&quot; b &quot;)\n&quot;                   }</code></pre>
<p>Here is what the <code>Not</code> rule looks like after the change:</p>
<pre class="text"><code>Not = ast:x -&gt; label():a -&gt; label():b
            -&gt; { &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                 x
                 &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                 &quot;LABEL(&quot; a &quot;)\n&quot;
                 &quot;I('FAIL', 'no match expected')\n&quot;
                 &quot;LABEL(&quot; b &quot;)\n&quot;                   }</code></pre>
<p>This change puts label generation where it belongs, in semantic actions, and thus makes the implementation <strong>more clear</strong>. The VM is no longer concerned with labels. It is only concerned with matching. This change required a bit of rework how semantic actions work. Previously only one expression was allowed:</p>
<pre><code>&lt;match expression&gt; -&gt; &lt;semantic action expression&gt;</code></pre>
<p>Now multiple expressions are allowed:</p>
<pre><code>&lt;match expression&gt; -&gt; &lt;semantic action expression&gt;:x
                   -&gt; &lt;semantic action expression&gt;
                   -&gt; &lt;semantic action expression&gt;</code></pre>
<p>The result of expressions can also be bound to names which subsequent expressions can refer to. <code>label</code> is such a variable that is set internally to a function that generates increasing integers starting at 0.</p>
<p>The implementation of this change also <strong>increases the flexibility</strong> of RLMeta. For example, it is now possible to write a semantic action that generates code in different sections like this:</p>
<pre class="text"><code>ExampleBuffers {
    program  = ast:x  -&gt; []:header
                      -&gt; { &quot;# HEADER\n&quot;
                           header
                           &quot;# BODY\n&quot;
                           x            }
    ast      = [%:x]  -&gt; x
    Program  = ast*
    Function = .:name -&gt; add(header { &quot;def &quot; name &quot;\n&quot; })
                      -&gt; { name &quot;()\n&quot; }
}</code></pre>
<p>The expression <code>[]:header</code> creates a list and assigns it to the variable <code>header</code>. When <code>x</code> is evaluated in the next step, the semantic action for the <code>Function</code> rule will be evaluated which can then access the <code>header</code> variable defined earlier. These variables are not lexically scoped, but dynamically scoped. If at runtime, a variable is defined, it will be accessible. It also means that the <code>Function</code> rule can not be run without <code>program</code> being run first, or the <code>header</code> variable will not be defined.</p>
<p>Here is an example AST representing a program:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>AST <span class="op">=</span> [</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>    [<span class="st">'Program'</span>,</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>        [<span class="st">'Function'</span>, <span class="st">'foo'</span>],</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>        [<span class="st">'Function'</span>, <span class="st">'bar'</span>]</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>    ]</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>]</span></code></pre></div>
<p>When the <code>program</code> rule is run on the example input, the following is output:</p>
<pre class="text"><code>$ python example_buffers.py
# HEADER
def foo
def bar
# BODY
foo()
bar()</code></pre>
<p>In summary, this change is as follows:</p>
<ul>
<li>Label syntax (<code>#</code>) in parser is removed</li>
<li>Actions can have multiple expressions</li>
<li>Expressions can be bound to names</li>
<li>A default <code>label</code> function to generate labels</li>
<li>Names in semantic actions refer to matches or results bound earlier</li>
</ul>
<p>(The complete initial diff for this change can be found on <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/5154583e9d98c123630fb41664aa6906d4801d05">GitHub</a>.)</p>
<p>The increased clarity and flexibility come with a price. The size increases and the performance drops.</p>
<p>The parser and the code generator are mostly the same. The greatest addition is in the support library. Which is expected when semantic action evaluation becomes more complex. The drop in performance is likely due to more function calls when evaluating semantic actions. Even though size and performance got worse, I believe the clarity and flexibility gain is worth it.</p>
<h3 id="remove-dependency-on-bash">Remove dependency on Bash</h3>
<p>To compile the poster version of RLMeta, you ran the following command:</p>
<pre><code>./compile.sh rlmeta.py</code></pre>
<p>In one way, the compiler could not compile itself, but relied on a Bash script for gluing things together. It would call the <code>rlmeta.py</code> compiler for certain tasks and use Bash and Python for other tasks.</p>
<p>As we have already seen, the new version of RLMeta compiles itself like this:</p>
<pre><code>python rlmeta.py \
    --embed SUPPORT src/support.py \
    --support \
    --compile src/parser.rlmeta \
    --compile src/codegenerator.rlmeta \
    --compile src/assembler.rlmeta \
    --copy src/main.py \
    &gt; rlmeta.py</code></pre>
<p>The <code>rlmeta.py</code> compiler now has support (via <code>--embed</code> and <code>--copy</code>) for doing what the Bash script previously did.</p>
<p>This makes the compiler slightly larger, but it feels so much cleaner.</p>
<p>In addition, the extra features are useful when writing programs in RLMeta. Those programs can now also be compiled with a single command, and there is no need to concatenate different pieces together.</p>
<p>(The complete diff for this change can be found on <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/935bb77e1d5b88e09de64112aa2fb2f46dbcb7d9">GitHub</a>.)</p>
<h3 id="extract-assembler">Extract assembler</h3>
<p>The third thing that annoyed me with in the poster version was the readability of the code generator. For example, the <code>Not</code> rule looked like this:</p>
<pre class="text"><code>Not = ast:x -&gt; label():a -&gt; label():b
            -&gt; { &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                 x
                 &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                 &quot;LABEL(&quot; a &quot;)\n&quot;
                 &quot;I('FAIL', 'no match expected')\n&quot;
                 &quot;LABEL(&quot; b &quot;)\n&quot;                   }</code></pre>
<p>It generates a string which contains Python code that calls functions to create “assembly” code. So part of the compilation is actually happening at runtime here. It is mixed and messy.</p>
<p>The new <code>Not</code> rule looks like this:</p>
<pre class="text"><code>Not = ast:x -&gt; label():a -&gt; label():b
            -&gt; [[&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                [&quot;Target&quot; b]
                ~x
                [&quot;OpCode&quot; &quot;COMMIT&quot;]
                [&quot;Target&quot; a]
                [&quot;Label&quot; a]
                [&quot;OpCode&quot; &quot;FAIL&quot;]
                [&quot;Value&quot; &quot;no match&quot;]
                [&quot;Label&quot; b]]</code></pre>
<p>Instead of outputting Python code directly, it now generates abstract assembly code. Then a new third pass, the assembler, turns those instructions into Python code as well as resolves label positions. So no more compilation at runtime.</p>
<p>This reads better because the purpose of the code generator is now a bit narrower. It can focus on one thing and leave the rest to the assembler.</p>
<p>Adding another pass also opens up the possibility to do peep-hole optimizations on the abstract assembly code before the assembler turns the instructions into Python code.</p>
<h3 id="rewrite-vm-for-clarity">Rewrite VM for clarity</h3>
<p>In the poster version, the virtual machine was written as a single function with one loop like this:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="kw">def</span> vm(instructions, labels, start_rule, stream):</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>    ...</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>        name, arg1, arg2 <span class="op">=</span> instructions[pc]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>        <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;PUSH_SCOPE&quot;</span>:</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>            scope_stack.append(scope)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>            scope <span class="op">=</span> {}</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BACKTRACK&quot;</span>:</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>            ...</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>        ...</span></code></pre></div>
<p>It was written like that to be as fast as possible. It avoided function calls. It avoided class variables lookup by avoiding classes. All variables used were defined locally in the <code>vm</code> function. Because function calls could not be used, some code was also duplicated.</p>
<p>I decided that I would not consider performance at all, and instead try to write the VM as clear as I could. I ended up with a <code>VM</code> class to hold some state and instruction functions that operate on an instance of a VM:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="kw">class</span> VM:</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, code, rules):</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>        ...</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>    ...</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a><span class="kw">def</span> PUSH_SCOPE(vm):</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>    vm.scope_rest <span class="op">=</span> (vm.scope, vm.scope_rest)</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true"></a>    vm.scope <span class="op">=</span> {}</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true"></a></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true"></a><span class="kw">def</span> BACKTRACK(vm):</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true"></a>    ...</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true"></a>...</span></code></pre></div>
<p>As I noted earlier, I’m not sure I am happy with this result. I’m not convinced that it reads better. The biggest upside is that since function calls are now allowed, part of the VM can be expressed more clearly without repetition.</p>
<p>Before I ended up with this VM, I experimented with a language for writing virtual machines that compiled to Python code. You could define instructions and the arguments they took and define macros for code re-use. It was basically a small macro language on top of Python. It looked something like this:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="kw">def</span> vm(code, rules, start_rule, stream):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>    action <span class="op">=</span> SemanticAction(<span class="va">None</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>    pc <span class="op">=</span> rules[start_rule]</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>    call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>    stream, stream_rest <span class="op">=</span> (stream, <span class="va">None</span>)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a>    pos, pos_rest <span class="op">=</span> (<span class="dv">0</span>, <span class="bu">tuple</span>())</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>    scope, scope_rest <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>    fail_message <span class="op">=</span> <span class="va">None</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>    latest_fail_message, latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>    memo <span class="op">=</span> {}</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true"></a>definstruction PUSH_SCOPE():</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true"></a>    scope_rest <span class="op">=</span> (scope, scope_rest)</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true"></a>    scope <span class="op">=</span> {}</span></code></pre></div>
<p>And here is how macros were used:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>definstruction FAIL(arg_message):</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (arg_message,)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a>    <span class="co">#FAIL</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>defmacro FAIL:</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>When this was compiled, something similar to the <code>vm</code> function above was generated. A single function that was intended to run as fast as possible. But you could write the VM quite clearly anyway.</p>
<p>I liked the result of that, but it introduced yet another language and made compilation and metacompilation more complicated. For that reason, I decided against it.</p>
<p>Perhaps another approach would be to consider the VM a separate piece, not to be included in compilations and metacompilations. But they are also strongly connected. Say for example that an optimizer decides to output a new VM instruction, then the VM has to change.</p>
<p>I am not entirely clear about the interface here between the VM and the rest of the compiler.</p>
<h3 id="add-ability-to-run-a-rule-in-semantic-action">Add ability to run a rule in semantic action</h3>
<p>Another feature that was added in this version was the ability to run a grammar rule recursively from a semantic action.</p>
<p>This was initially needed to to implement recursive macros in the VM language mentioned in the previous section, but it made its way into RLMeta to support the patching of assembly instructions.</p>
<p>When a <code>Target</code> instruction is encountered, the <code>patches</code> list is populated with a command:</p>
<pre class="text"><code>Target   = .:x             -&gt; add(patches [&quot;Patch&quot; len(code) x])
                           -&gt; add(code &quot;placeholder&quot;)</code></pre>
<p>These commands are then evaluated by running the <code>asts</code> rule on the <code>patches</code> list. This starts another parse on the given stream.</p>
<pre class="text"><code>-&gt; run(&quot;asts&quot; patches)</code></pre>
<p>The new parse has access to all the runtime variables that the semantic action that invokes it has. So that is why a <code>Patch</code> instruction can modify the <code>code</code> array and insert the correct index there instead of the placeholder:</p>
<pre class="text"><code>Patch    = .:x .:y         -&gt; set(code x get(labels y))</code></pre>
<h3 id="misc">Misc</h3>
<p>Many more small changes were made. Here are a few notes about them.</p>
<ul>
<li><p>Various renames to make intention more clear and reformats to improve readability.</p></li>
<li><p>Various clean ups in the parser:</p>
<ul>
<li><p>Only allow semantic actions at the very end of a rule.</p></li>
<li><p>Make sure the whole file is parsed so that junk after a grammar results in an error.</p></li>
</ul></li>
<li><p>Adapt to Python 3.</p></li>
</ul>
<h2 id="the-future">The future</h2>
<p>On the one hand, I’m quite happy with the improvements to RLMeta that I was able to make. The code feels more clear and flexible. Definitely a better version of RLMeta.</p>
<p>On the other hand, this article turned out to have the same problem as the poster. It just kept growing and growing, and at some point I had to stop working on in, leave some issues unresolved, and call the article finished. For example, I am not happy with how the new VM looks. A mix between classes and functions and helpers.</p>
<p>I decided to set up a <a href="https://github.com/rickardlindberg/rlmeta">repo on GitHub</a> for RLMeta where it can continue to be improved.</p>
<p>I plan for it to contain the base version of RLMeta which is the minimal version that is able to compile itself and maintain properties such as flexible, easy to extend, and easy to understand. Then I want to include examples as well to show how RLMeta can be used and how you can extend it in various ways.</p>
<h2 id="code-listings-for-rlmeta">Code listings for RLMeta</h2>
<p>Here is all the source code and also the make script for this version of RLMeta.</p>
<h3 id="srcparser.rlmeta">src/parser.rlmeta</h3>
<pre class="text"><code>Parser {
  file =
    | (space grammar)*:xs space !.            -&gt; xs
  grammar =
    | name:x space '{' rule*:ys space '}'     -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space '=' choice:y               -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space '|')?
      sequence:x (space '|' sequence)*:xs     -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr*:xs maybeAction:ys                 -&gt; [&quot;Scope&quot; [&quot;And&quot; ~xs ~ys]]
  expr =
    | expr1:x space ':' name:y                -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space '*'                       -&gt; [&quot;Star&quot; x]
    | expr2:x space '?'                       -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space '!' expr2:x                       -&gt; [&quot;Not&quot; x]
    | space '%'                               -&gt; [&quot;MatchCallRule&quot;]
    | expr2
  expr2 =
    | name:x !(space '=')                     -&gt; [&quot;MatchRule&quot; x]
    | space char:x '-' char:y                 -&gt; [&quot;MatchObject&quot; [&quot;Range&quot; x y]]
    | space '\'' (!'\'' matchChar)*:xs '\''   -&gt; [&quot;And&quot; ~xs]
    | space '.'                               -&gt; [&quot;MatchObject&quot; [&quot;Any&quot;]]
    | space '(' choice:x space ')'            -&gt; x
    | space '[' expr*:xs space ']'            -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  matchChar =
    | innerChar:x                             -&gt; [&quot;MatchObject&quot; [&quot;Eq&quot; x]]
  maybeAction =
    | actionExpr:x                            -&gt; [[&quot;Action&quot; x]]
    |                                         -&gt; []
  actionExpr =
    | space '-&gt;' hostExpr:x
      (space ':' name | -&gt; &quot;&quot;):y actionExpr:z -&gt; [&quot;Set&quot; y x z]
    | space '-&gt;' hostExpr:x                   -&gt; x
  hostExpr =
    | space string:x                          -&gt; [&quot;String&quot; x]
    | space '[' hostListItem*:xs space ']'    -&gt; [&quot;List&quot; ~xs]
    | space '{' formatExpr*:xs space '}'      -&gt; [&quot;Format&quot; ~xs]
    | var:x space '(' hostExpr*:ys space ')'  -&gt; [&quot;Call&quot; x ~ys]
    | var:x
  hostListItem =
    | space '~'*:ys hostExpr:x                -&gt; [&quot;ListItem&quot; len(ys) x]
  formatExpr =
    | space '&gt;' formatExpr*:xs space '&lt;'      -&gt; [&quot;Indent&quot; [&quot;Format&quot; ~xs]]
    | hostExpr
  var =
    | name:x !(space '=')                     -&gt; [&quot;Lookup&quot; x]
  string    = '&quot;'  (!'&quot;'  innerChar)*:xs '&quot;'  -&gt; { xs }
  char      = '\''  !'\'' innerChar  :x  '\'' -&gt; x
  innerChar = '\\' escape | .
  escape    = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
            | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs  -&gt; { x xs }
  nameStart = 'a'-'z' | 'A'-'Z'
  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'
  space     = (' ' | '\n')*
}</code></pre>
<h3 id="srccodegenerator.rlmeta">src/codegenerator.rlmeta</h3>
<pre class="text"><code>CodeGenerator {
  Grammar       = .:x ast*:ys -&gt; [&quot;Grammar&quot; x ~~ys]
  Rule          = .:x ast:y   -&gt; [[&quot;Rule&quot; x]
                                  ~y
                                  [&quot;OpCode&quot; &quot;RETURN&quot;]]
  Or            =
    | ast:x Or:y              -&gt; label():a -&gt; label():b
                              -&gt; [[&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                                  [&quot;Target&quot; a]
                                  ~x
                                  [&quot;OpCode&quot; &quot;COMMIT&quot;]
                                  [&quot;Target&quot; b]
                                  [&quot;Label&quot; a]
                                  ~y
                                  [&quot;Label&quot; b]]
    | ast
  Scope         = ast:x       -&gt; [[&quot;OpCode&quot; &quot;PUSH_SCOPE&quot;]
                                  ~x
                                  [&quot;OpCode&quot; &quot;POP_SCOPE&quot;]]
  And           = ast*:xs     -&gt; [~~xs]
  Bind          = .:x ast:y   -&gt; [~y
                                  [&quot;OpCode&quot; &quot;BIND&quot;]
                                  [&quot;Value&quot; x]]
  Star          = ast:x       -&gt; label():a -&gt; label():b
                              -&gt; [[&quot;OpCode&quot; &quot;LIST_START&quot;]
                                  [&quot;Label&quot; a]
                                  [&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                                  [&quot;Target&quot; b]
                                  ~x
                                  [&quot;OpCode&quot; &quot;LIST_APPEND&quot;]
                                  [&quot;OpCode&quot; &quot;COMMIT&quot;]
                                  [&quot;Target&quot; a]
                                  [&quot;Label&quot; b]
                                  [&quot;OpCode&quot; &quot;LIST_END&quot;]]
  Not           = ast:x       -&gt; label():a -&gt; label():b
                              -&gt; [[&quot;OpCode&quot; &quot;BACKTRACK&quot;]
                                  [&quot;Target&quot; b]
                                  ~x
                                  [&quot;OpCode&quot; &quot;COMMIT&quot;]
                                  [&quot;Target&quot; a]
                                  [&quot;Label&quot; a]
                                  [&quot;OpCode&quot; &quot;FAIL&quot;]
                                  [&quot;Value&quot; &quot;no match&quot;]
                                  [&quot;Label&quot; b]]
  MatchCallRule =             -&gt; [[&quot;OpCode&quot; &quot;MATCH_CALL_RULE&quot;]]
  MatchRule     = .:x         -&gt; [[&quot;OpCode&quot; &quot;CALL&quot;]
                                  [&quot;Target&quot; x]]
  MatchObject   = .:x         -&gt; [[&quot;OpCode&quot; &quot;MATCH&quot;]
                                  x]
  MatchList     = ast:x       -&gt; [[&quot;OpCode&quot; &quot;PUSH_STREAM&quot;]
                                  ~x
                                  [&quot;OpCode&quot; &quot;POP_STREAM&quot;]]
  Action        = .:x         -&gt; [[&quot;OpCode&quot; &quot;ACTION&quot;]
                                  [&quot;Action&quot; x]]
  asts          = ast*:xs !.  -&gt; xs
  ast           = [%:x]       -&gt; x
}</code></pre>
<h3 id="srcassembler.rlmeta">src/assembler.rlmeta</h3>
<pre class="text"><code>Assembler {
  Grammar  = .:x ast*:ys     -&gt; list():rules
                             -&gt; list():code
                             -&gt; dict():labels
                             -&gt; list():patches
                             -&gt; ys
                             -&gt; run(&quot;asts&quot; patches)
                             -&gt; { &quot;class &quot; x &quot;(Grammar):\n&quot; &gt;
                                    &quot;rules = {\n&quot; &gt; join(rules &quot;,\n&quot;) &lt; &quot;\n}\n&quot;
                                    &quot;code = [\n&quot; &gt; join(code  &quot;,\n&quot;) &lt; &quot;\n]\n&quot;
                                  &lt; }
  Rule     = .:x             -&gt; add(rules { repr(x) &quot;: &quot; len(code) })
                             -&gt; set(labels x len(code))
  Label    = .:x             -&gt; set(labels x len(code))
  Target   = .:x             -&gt; add(patches [&quot;Patch&quot; len(code) x])
                             -&gt; add(code &quot;placeholder&quot;)
  Patch    = .:x .:y         -&gt; set(code x get(labels y))
  OpCode   = .:x             -&gt; add(code x)
  Value    = .:x             -&gt; add(code repr(x))
  Eq       = .:x             -&gt; add(code repr(x))
                             -&gt; add(code { &quot;lambda x: x == &quot; repr(x) })
  Range    = .:x .:y         -&gt; add(code repr({&quot;range &quot; repr(x) &quot;-&quot; repr(y)}))
                             -&gt; add(code { &quot;lambda x: &quot; repr(x) &quot; &lt;= x &lt;= &quot; repr(y) })
  Any      =                 -&gt; add(code repr(&quot;any&quot;))
                             -&gt; add(code &quot;lambda x: True&quot;)
  Action   = ast:x           -&gt; add(code {&quot;lambda self: &quot; x})
  Set      = .:x ast:y ast:z -&gt; { &quot;self.bind(&quot; repr(x) &quot;, &quot; y &quot;, lambda: &quot; z &quot;)&quot; }
  String   = .:x             -&gt; repr(x)
  List     = astList:x       -&gt; { &quot;concat([&quot; x &quot;])&quot; }
  ListItem = .:x ast:y       -&gt; { &quot;splice(&quot; repr(x) &quot;, &quot; y &quot;)&quot; }
  Format   = astList:x       -&gt; { &quot;join([&quot; x &quot;])&quot; }
  Indent   = ast:x           -&gt; { &quot;indent(&quot; x &quot;, &quot;
                                  &quot;self.lookup('indentprefix'))&quot; }
  Call     = ast:x astList:y -&gt; { x &quot;(&quot; y &quot;)&quot; }
  Lookup   = .:x             -&gt; { &quot;self.lookup(&quot; repr(x) &quot;)&quot; }
  asts     = ast*:xs !.      -&gt; { xs }
  astList  = ast*:xs         -&gt; join(xs &quot;, &quot;)
  ast      = [%:x]           -&gt; x
}</code></pre>
<h3 id="srcsupport.py">src/support.py</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="kw">class</span> VM:</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, code, rules):</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>        <span class="va">self</span>.code <span class="op">=</span> code</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a>        <span class="va">self</span>.rules <span class="op">=</span> rules</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, start_rule, stream):</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>        <span class="va">self</span>.action <span class="op">=</span> SemanticAction(<span class="va">None</span>)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a>        <span class="va">self</span>.pc <span class="op">=</span> <span class="va">self</span>.rules[start_rule]</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>        <span class="va">self</span>.call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a>        <span class="va">self</span>.stream, <span class="va">self</span>.stream_rest <span class="op">=</span> (stream, <span class="va">None</span>)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a>        <span class="va">self</span>.pos, <span class="va">self</span>.pos_rest <span class="op">=</span> (<span class="dv">0</span>, <span class="bu">tuple</span>())</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a>        <span class="va">self</span>.scope, <span class="va">self</span>.scope_rest <span class="op">=</span> (<span class="va">None</span>, <span class="va">None</span>)</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true"></a>        <span class="va">self</span>.latest_fail_message, <span class="va">self</span>.latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true"></a>        <span class="va">self</span>.memo <span class="op">=</span> {}</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true"></a>            result <span class="op">=</span> <span class="va">self</span>.pop_arg()(<span class="va">self</span>)</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true"></a>            <span class="cf">if</span> result:</span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true"></a>                <span class="cf">return</span> result</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true"></a></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true"></a>    <span class="kw">def</span> pop_arg(<span class="va">self</span>):</span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true"></a>        code <span class="op">=</span> <span class="va">self</span>.code[<span class="va">self</span>.pc]</span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true"></a>        <span class="va">self</span>.pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true"></a>        <span class="cf">return</span> code</span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true"></a></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true"></a><span class="kw">def</span> PUSH_SCOPE(vm):</span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true"></a>    vm.scope_rest <span class="op">=</span> (vm.scope, vm.scope_rest)</span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true"></a>    vm.scope <span class="op">=</span> {}</span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true"></a></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true"></a><span class="kw">def</span> POP_SCOPE(vm):</span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true"></a>    vm.scope, vm.scope_rest <span class="op">=</span> vm.scope_rest</span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true"></a></span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true"></a><span class="kw">def</span> BACKTRACK(vm):</span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true"></a>    vm.call_backtrack_stack.append((</span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true"></a>        vm.pop_arg(), vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest</span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true"></a>    ))</span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true"></a></span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true"></a><span class="kw">def</span> COMMIT(vm):</span>
<span id="cb60-39"><a href="#cb60-39" aria-hidden="true"></a>    vm.call_backtrack_stack.pop()</span>
<span id="cb60-40"><a href="#cb60-40" aria-hidden="true"></a>    vm.pc <span class="op">=</span> vm.pop_arg()</span>
<span id="cb60-41"><a href="#cb60-41" aria-hidden="true"></a></span>
<span id="cb60-42"><a href="#cb60-42" aria-hidden="true"></a><span class="kw">def</span> CALL(vm):</span>
<span id="cb60-43"><a href="#cb60-43" aria-hidden="true"></a>    CALL_(vm, vm.pop_arg())</span>
<span id="cb60-44"><a href="#cb60-44" aria-hidden="true"></a></span>
<span id="cb60-45"><a href="#cb60-45" aria-hidden="true"></a><span class="kw">def</span> CALL_(vm, pc):</span>
<span id="cb60-46"><a href="#cb60-46" aria-hidden="true"></a>    key <span class="op">=</span> (pc, vm.pos_rest<span class="op">+</span>(vm.pos,))</span>
<span id="cb60-47"><a href="#cb60-47" aria-hidden="true"></a>    <span class="cf">if</span> key <span class="kw">in</span> vm.memo:</span>
<span id="cb60-48"><a href="#cb60-48" aria-hidden="true"></a>        <span class="cf">if</span> vm.memo[key][<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb60-49"><a href="#cb60-49" aria-hidden="true"></a>            FAIL_(vm, vm.memo[key][<span class="dv">1</span>])</span>
<span id="cb60-50"><a href="#cb60-50" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb60-51"><a href="#cb60-51" aria-hidden="true"></a>            vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest <span class="op">=</span> vm.memo[key]</span>
<span id="cb60-52"><a href="#cb60-52" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-53"><a href="#cb60-53" aria-hidden="true"></a>        vm.call_backtrack_stack.append((vm.pc, key))</span>
<span id="cb60-54"><a href="#cb60-54" aria-hidden="true"></a>        vm.pc <span class="op">=</span> pc</span>
<span id="cb60-55"><a href="#cb60-55" aria-hidden="true"></a></span>
<span id="cb60-56"><a href="#cb60-56" aria-hidden="true"></a><span class="kw">def</span> RETURN(vm):</span>
<span id="cb60-57"><a href="#cb60-57" aria-hidden="true"></a>    <span class="cf">if</span> <span class="kw">not</span> vm.call_backtrack_stack:</span>
<span id="cb60-58"><a href="#cb60-58" aria-hidden="true"></a>        <span class="cf">return</span> vm.action</span>
<span id="cb60-59"><a href="#cb60-59" aria-hidden="true"></a>    vm.pc, key <span class="op">=</span> vm.call_backtrack_stack.pop()</span>
<span id="cb60-60"><a href="#cb60-60" aria-hidden="true"></a>    vm.memo[key] <span class="op">=</span> (vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest)</span>
<span id="cb60-61"><a href="#cb60-61" aria-hidden="true"></a></span>
<span id="cb60-62"><a href="#cb60-62" aria-hidden="true"></a><span class="kw">def</span> MATCH(vm):</span>
<span id="cb60-63"><a href="#cb60-63" aria-hidden="true"></a>    object_description <span class="op">=</span> vm.pop_arg()</span>
<span id="cb60-64"><a href="#cb60-64" aria-hidden="true"></a>    fn <span class="op">=</span> vm.pop_arg()</span>
<span id="cb60-65"><a href="#cb60-65" aria-hidden="true"></a>    MATCH_(vm, fn, (<span class="st">&quot;expected </span><span class="sc">{}</span><span class="st">&quot;</span>, object_description))</span>
<span id="cb60-66"><a href="#cb60-66" aria-hidden="true"></a></span>
<span id="cb60-67"><a href="#cb60-67" aria-hidden="true"></a><span class="kw">def</span> MATCH_(vm, fn, message):</span>
<span id="cb60-68"><a href="#cb60-68" aria-hidden="true"></a>    <span class="cf">if</span> vm.pos <span class="op">&gt;=</span> <span class="bu">len</span>(vm.stream) <span class="kw">or</span> <span class="kw">not</span> fn(vm.stream[vm.pos]):</span>
<span id="cb60-69"><a href="#cb60-69" aria-hidden="true"></a>        FAIL_(vm, message)</span>
<span id="cb60-70"><a href="#cb60-70" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-71"><a href="#cb60-71" aria-hidden="true"></a>        vm.action <span class="op">=</span> SemanticAction(vm.stream[vm.pos])</span>
<span id="cb60-72"><a href="#cb60-72" aria-hidden="true"></a>        vm.pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-73"><a href="#cb60-73" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb60-74"><a href="#cb60-74" aria-hidden="true"></a></span>
<span id="cb60-75"><a href="#cb60-75" aria-hidden="true"></a><span class="kw">def</span> MATCH_CALL_RULE(vm):</span>
<span id="cb60-76"><a href="#cb60-76" aria-hidden="true"></a>    <span class="cf">if</span> MATCH_(vm, <span class="kw">lambda</span> x: x <span class="kw">in</span> vm.rules, (<span class="st">&quot;expected rule name&quot;</span>,)):</span>
<span id="cb60-77"><a href="#cb60-77" aria-hidden="true"></a>        CALL_(vm, vm.rules[vm.action.value])</span>
<span id="cb60-78"><a href="#cb60-78" aria-hidden="true"></a></span>
<span id="cb60-79"><a href="#cb60-79" aria-hidden="true"></a><span class="kw">def</span> LIST_START(vm):</span>
<span id="cb60-80"><a href="#cb60-80" aria-hidden="true"></a>    vm.scope_rest <span class="op">=</span> (vm.scope, vm.scope_rest)</span>
<span id="cb60-81"><a href="#cb60-81" aria-hidden="true"></a>    vm.scope <span class="op">=</span> []</span>
<span id="cb60-82"><a href="#cb60-82" aria-hidden="true"></a></span>
<span id="cb60-83"><a href="#cb60-83" aria-hidden="true"></a><span class="kw">def</span> LIST_APPEND(vm):</span>
<span id="cb60-84"><a href="#cb60-84" aria-hidden="true"></a>    vm.scope.append(vm.action)</span>
<span id="cb60-85"><a href="#cb60-85" aria-hidden="true"></a></span>
<span id="cb60-86"><a href="#cb60-86" aria-hidden="true"></a><span class="kw">def</span> LIST_END(vm):</span>
<span id="cb60-87"><a href="#cb60-87" aria-hidden="true"></a>    vm.action <span class="op">=</span> SemanticAction(vm.scope, <span class="kw">lambda</span> <span class="va">self</span>: [x.<span class="bu">eval</span>(<span class="va">self</span>.runtime) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.value])</span>
<span id="cb60-88"><a href="#cb60-88" aria-hidden="true"></a>    vm.scope, vm.scope_rest <span class="op">=</span> vm.scope_rest</span>
<span id="cb60-89"><a href="#cb60-89" aria-hidden="true"></a></span>
<span id="cb60-90"><a href="#cb60-90" aria-hidden="true"></a><span class="kw">def</span> BIND(vm):</span>
<span id="cb60-91"><a href="#cb60-91" aria-hidden="true"></a>    vm.scope[vm.pop_arg()] <span class="op">=</span> vm.action</span>
<span id="cb60-92"><a href="#cb60-92" aria-hidden="true"></a></span>
<span id="cb60-93"><a href="#cb60-93" aria-hidden="true"></a><span class="kw">def</span> ACTION(vm):</span>
<span id="cb60-94"><a href="#cb60-94" aria-hidden="true"></a>    vm.action <span class="op">=</span> SemanticAction(vm.scope, vm.pop_arg())</span>
<span id="cb60-95"><a href="#cb60-95" aria-hidden="true"></a></span>
<span id="cb60-96"><a href="#cb60-96" aria-hidden="true"></a><span class="kw">def</span> PUSH_STREAM(vm):</span>
<span id="cb60-97"><a href="#cb60-97" aria-hidden="true"></a>    <span class="cf">if</span> vm.pos <span class="op">&gt;=</span> <span class="bu">len</span>(vm.stream) <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(vm.stream[vm.pos], <span class="bu">list</span>):</span>
<span id="cb60-98"><a href="#cb60-98" aria-hidden="true"></a>        FAIL_(vm, (<span class="st">&quot;expected list&quot;</span>,))</span>
<span id="cb60-99"><a href="#cb60-99" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-100"><a href="#cb60-100" aria-hidden="true"></a>        vm.stream_rest <span class="op">=</span> (vm.stream, vm.stream_rest)</span>
<span id="cb60-101"><a href="#cb60-101" aria-hidden="true"></a>        vm.pos_rest <span class="op">=</span> vm.pos_rest <span class="op">+</span> (vm.pos,)</span>
<span id="cb60-102"><a href="#cb60-102" aria-hidden="true"></a>        vm.stream <span class="op">=</span> vm.stream[vm.pos]</span>
<span id="cb60-103"><a href="#cb60-103" aria-hidden="true"></a>        vm.pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb60-104"><a href="#cb60-104" aria-hidden="true"></a></span>
<span id="cb60-105"><a href="#cb60-105" aria-hidden="true"></a><span class="kw">def</span> POP_STREAM(vm):</span>
<span id="cb60-106"><a href="#cb60-106" aria-hidden="true"></a>    <span class="cf">if</span> vm.pos <span class="op">&lt;</span> <span class="bu">len</span>(vm.stream):</span>
<span id="cb60-107"><a href="#cb60-107" aria-hidden="true"></a>        FAIL_(vm, (<span class="st">&quot;expected end of list&quot;</span>,))</span>
<span id="cb60-108"><a href="#cb60-108" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-109"><a href="#cb60-109" aria-hidden="true"></a>        vm.stream, vm.stream_rest <span class="op">=</span> vm.stream_rest</span>
<span id="cb60-110"><a href="#cb60-110" aria-hidden="true"></a>        vm.pos, vm.pos_rest <span class="op">=</span> vm.pos_rest[<span class="op">-</span><span class="dv">1</span>], vm.pos_rest[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb60-111"><a href="#cb60-111" aria-hidden="true"></a>        vm.pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-112"><a href="#cb60-112" aria-hidden="true"></a></span>
<span id="cb60-113"><a href="#cb60-113" aria-hidden="true"></a><span class="kw">def</span> FAIL(vm):</span>
<span id="cb60-114"><a href="#cb60-114" aria-hidden="true"></a>    FAIL_(vm, (vm.pop_arg(),))</span>
<span id="cb60-115"><a href="#cb60-115" aria-hidden="true"></a></span>
<span id="cb60-116"><a href="#cb60-116" aria-hidden="true"></a><span class="kw">def</span> FAIL_(vm, fail_message):</span>
<span id="cb60-117"><a href="#cb60-117" aria-hidden="true"></a>    fail_pos <span class="op">=</span> vm.pos_rest<span class="op">+</span>(vm.pos,)</span>
<span id="cb60-118"><a href="#cb60-118" aria-hidden="true"></a>    <span class="cf">if</span> fail_pos <span class="op">&gt;=</span> vm.latest_fail_pos:</span>
<span id="cb60-119"><a href="#cb60-119" aria-hidden="true"></a>        vm.latest_fail_message <span class="op">=</span> fail_message</span>
<span id="cb60-120"><a href="#cb60-120" aria-hidden="true"></a>        vm.latest_fail_pos <span class="op">=</span> fail_pos</span>
<span id="cb60-121"><a href="#cb60-121" aria-hidden="true"></a>    call_backtrack_entry <span class="op">=</span> <span class="bu">tuple</span>()</span>
<span id="cb60-122"><a href="#cb60-122" aria-hidden="true"></a>    <span class="cf">while</span> vm.call_backtrack_stack:</span>
<span id="cb60-123"><a href="#cb60-123" aria-hidden="true"></a>        call_backtrack_entry <span class="op">=</span> vm.call_backtrack_stack.pop()</span>
<span id="cb60-124"><a href="#cb60-124" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">==</span> <span class="dv">7</span>:</span>
<span id="cb60-125"><a href="#cb60-125" aria-hidden="true"></a>            <span class="cf">break</span></span>
<span id="cb60-126"><a href="#cb60-126" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb60-127"><a href="#cb60-127" aria-hidden="true"></a>            vm.memo[call_backtrack_entry[<span class="dv">1</span>]] <span class="op">=</span> (<span class="va">None</span>, fail_message)</span>
<span id="cb60-128"><a href="#cb60-128" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">!=</span> <span class="dv">7</span>:</span>
<span id="cb60-129"><a href="#cb60-129" aria-hidden="true"></a>        <span class="cf">raise</span> MatchError(</span>
<span id="cb60-130"><a href="#cb60-130" aria-hidden="true"></a>            vm.latest_fail_message[<span class="dv">0</span>].<span class="bu">format</span>(<span class="op">*</span>vm.latest_fail_message[<span class="dv">1</span>:]),</span>
<span id="cb60-131"><a href="#cb60-131" aria-hidden="true"></a>            vm.latest_fail_pos[<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb60-132"><a href="#cb60-132" aria-hidden="true"></a>            vm.stream</span>
<span id="cb60-133"><a href="#cb60-133" aria-hidden="true"></a>        )</span>
<span id="cb60-134"><a href="#cb60-134" aria-hidden="true"></a>    (vm.pc, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest) <span class="op">=</span> call_backtrack_entry</span>
<span id="cb60-135"><a href="#cb60-135" aria-hidden="true"></a></span>
<span id="cb60-136"><a href="#cb60-136" aria-hidden="true"></a><span class="kw">class</span> SemanticAction(<span class="bu">object</span>):</span>
<span id="cb60-137"><a href="#cb60-137" aria-hidden="true"></a></span>
<span id="cb60-138"><a href="#cb60-138" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, fn<span class="op">=</span><span class="kw">lambda</span> <span class="va">self</span>: <span class="va">self</span>.value):</span>
<span id="cb60-139"><a href="#cb60-139" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb60-140"><a href="#cb60-140" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb60-141"><a href="#cb60-141" aria-hidden="true"></a></span>
<span id="cb60-142"><a href="#cb60-142" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>, runtime):</span>
<span id="cb60-143"><a href="#cb60-143" aria-hidden="true"></a>        <span class="va">self</span>.runtime <span class="op">=</span> runtime</span>
<span id="cb60-144"><a href="#cb60-144" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn(<span class="va">self</span>)</span>
<span id="cb60-145"><a href="#cb60-145" aria-hidden="true"></a></span>
<span id="cb60-146"><a href="#cb60-146" aria-hidden="true"></a>    <span class="kw">def</span> bind(<span class="va">self</span>, name, value, continuation):</span>
<span id="cb60-147"><a href="#cb60-147" aria-hidden="true"></a>        <span class="va">self</span>.runtime <span class="op">=</span> <span class="va">self</span>.runtime.<span class="bu">set</span>(name, value)</span>
<span id="cb60-148"><a href="#cb60-148" aria-hidden="true"></a>        <span class="cf">return</span> continuation()</span>
<span id="cb60-149"><a href="#cb60-149" aria-hidden="true"></a></span>
<span id="cb60-150"><a href="#cb60-150" aria-hidden="true"></a>    <span class="kw">def</span> lookup(<span class="va">self</span>, name):</span>
<span id="cb60-151"><a href="#cb60-151" aria-hidden="true"></a>        <span class="cf">if</span> name <span class="kw">in</span> <span class="va">self</span>.value:</span>
<span id="cb60-152"><a href="#cb60-152" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">self</span>.value[name].<span class="bu">eval</span>(<span class="va">self</span>.runtime)</span>
<span id="cb60-153"><a href="#cb60-153" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb60-154"><a href="#cb60-154" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">self</span>.runtime[name]</span>
<span id="cb60-155"><a href="#cb60-155" aria-hidden="true"></a></span>
<span id="cb60-156"><a href="#cb60-156" aria-hidden="true"></a><span class="kw">class</span> MatchError(<span class="pp">Exception</span>):</span>
<span id="cb60-157"><a href="#cb60-157" aria-hidden="true"></a></span>
<span id="cb60-158"><a href="#cb60-158" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, message, pos, stream):</span>
<span id="cb60-159"><a href="#cb60-159" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb60-160"><a href="#cb60-160" aria-hidden="true"></a>        <span class="va">self</span>.message <span class="op">=</span> message</span>
<span id="cb60-161"><a href="#cb60-161" aria-hidden="true"></a>        <span class="va">self</span>.pos <span class="op">=</span> pos</span>
<span id="cb60-162"><a href="#cb60-162" aria-hidden="true"></a>        <span class="va">self</span>.stream <span class="op">=</span> stream</span>
<span id="cb60-163"><a href="#cb60-163" aria-hidden="true"></a></span>
<span id="cb60-164"><a href="#cb60-164" aria-hidden="true"></a><span class="kw">class</span> Grammar(<span class="bu">object</span>):</span>
<span id="cb60-165"><a href="#cb60-165" aria-hidden="true"></a></span>
<span id="cb60-166"><a href="#cb60-166" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule, stream, runtime<span class="op">=</span>{}):</span>
<span id="cb60-167"><a href="#cb60-167" aria-hidden="true"></a>        <span class="cf">return</span> Runtime(<span class="va">self</span>, <span class="bu">dict</span>(runtime, <span class="op">**</span>{</span>
<span id="cb60-168"><a href="#cb60-168" aria-hidden="true"></a>            <span class="st">&quot;label&quot;</span>: Counter(),</span>
<span id="cb60-169"><a href="#cb60-169" aria-hidden="true"></a>            <span class="st">&quot;indentprefix&quot;</span>: <span class="st">&quot;    &quot;</span>,</span>
<span id="cb60-170"><a href="#cb60-170" aria-hidden="true"></a>            <span class="st">&quot;list&quot;</span>: <span class="bu">list</span>,</span>
<span id="cb60-171"><a href="#cb60-171" aria-hidden="true"></a>            <span class="st">&quot;dict&quot;</span>: <span class="bu">dict</span>,</span>
<span id="cb60-172"><a href="#cb60-172" aria-hidden="true"></a>            <span class="st">&quot;add&quot;</span>: <span class="kw">lambda</span> x, y: x.append(y),</span>
<span id="cb60-173"><a href="#cb60-173" aria-hidden="true"></a>            <span class="st">&quot;get&quot;</span>: <span class="kw">lambda</span> x, y: x[y],</span>
<span id="cb60-174"><a href="#cb60-174" aria-hidden="true"></a>            <span class="st">&quot;set&quot;</span>: <span class="kw">lambda</span> x, y, z: x.<span class="fu">__setitem__</span>(y, z),</span>
<span id="cb60-175"><a href="#cb60-175" aria-hidden="true"></a>            <span class="st">&quot;len&quot;</span>: <span class="bu">len</span>,</span>
<span id="cb60-176"><a href="#cb60-176" aria-hidden="true"></a>            <span class="st">&quot;repr&quot;</span>: <span class="bu">repr</span>,</span>
<span id="cb60-177"><a href="#cb60-177" aria-hidden="true"></a>            <span class="st">&quot;join&quot;</span>: join,</span>
<span id="cb60-178"><a href="#cb60-178" aria-hidden="true"></a>        })).run(rule, stream)</span>
<span id="cb60-179"><a href="#cb60-179" aria-hidden="true"></a></span>
<span id="cb60-180"><a href="#cb60-180" aria-hidden="true"></a><span class="kw">class</span> Runtime(<span class="bu">dict</span>):</span>
<span id="cb60-181"><a href="#cb60-181" aria-hidden="true"></a></span>
<span id="cb60-182"><a href="#cb60-182" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, grammar, values):</span>
<span id="cb60-183"><a href="#cb60-183" aria-hidden="true"></a>        <span class="bu">dict</span>.<span class="fu">__init__</span>(<span class="va">self</span>, <span class="bu">dict</span>(values, run<span class="op">=</span><span class="va">self</span>.run))</span>
<span id="cb60-184"><a href="#cb60-184" aria-hidden="true"></a>        <span class="va">self</span>.grammar <span class="op">=</span> grammar</span>
<span id="cb60-185"><a href="#cb60-185" aria-hidden="true"></a></span>
<span id="cb60-186"><a href="#cb60-186" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">set</span>(<span class="va">self</span>, key, value):</span>
<span id="cb60-187"><a href="#cb60-187" aria-hidden="true"></a>        <span class="cf">return</span> Runtime(<span class="va">self</span>.grammar, <span class="bu">dict</span>(<span class="va">self</span>, <span class="op">**</span>{key: value}))</span>
<span id="cb60-188"><a href="#cb60-188" aria-hidden="true"></a></span>
<span id="cb60-189"><a href="#cb60-189" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule, stream):</span>
<span id="cb60-190"><a href="#cb60-190" aria-hidden="true"></a>        <span class="cf">return</span> VM(<span class="va">self</span>.grammar.code, <span class="va">self</span>.grammar.rules).run(rule, stream).<span class="bu">eval</span>(<span class="va">self</span>)</span>
<span id="cb60-191"><a href="#cb60-191" aria-hidden="true"></a></span>
<span id="cb60-192"><a href="#cb60-192" aria-hidden="true"></a><span class="kw">class</span> Counter(<span class="bu">object</span>):</span>
<span id="cb60-193"><a href="#cb60-193" aria-hidden="true"></a></span>
<span id="cb60-194"><a href="#cb60-194" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb60-195"><a href="#cb60-195" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb60-196"><a href="#cb60-196" aria-hidden="true"></a></span>
<span id="cb60-197"><a href="#cb60-197" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>):</span>
<span id="cb60-198"><a href="#cb60-198" aria-hidden="true"></a>        result <span class="op">=</span> <span class="va">self</span>.value</span>
<span id="cb60-199"><a href="#cb60-199" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-200"><a href="#cb60-200" aria-hidden="true"></a>        <span class="cf">return</span> result</span>
<span id="cb60-201"><a href="#cb60-201" aria-hidden="true"></a></span>
<span id="cb60-202"><a href="#cb60-202" aria-hidden="true"></a><span class="kw">def</span> splice(depth, item):</span>
<span id="cb60-203"><a href="#cb60-203" aria-hidden="true"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb60-204"><a href="#cb60-204" aria-hidden="true"></a>        <span class="cf">return</span> [item]</span>
<span id="cb60-205"><a href="#cb60-205" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb60-206"><a href="#cb60-206" aria-hidden="true"></a>        <span class="cf">return</span> concat([splice(depth<span class="op">-</span><span class="dv">1</span>, subitem) <span class="cf">for</span> subitem <span class="kw">in</span> item])</span>
<span id="cb60-207"><a href="#cb60-207" aria-hidden="true"></a></span>
<span id="cb60-208"><a href="#cb60-208" aria-hidden="true"></a><span class="kw">def</span> concat(lists):</span>
<span id="cb60-209"><a href="#cb60-209" aria-hidden="true"></a>    <span class="cf">return</span> [x <span class="cf">for</span> xs <span class="kw">in</span> lists <span class="cf">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb60-210"><a href="#cb60-210" aria-hidden="true"></a></span>
<span id="cb60-211"><a href="#cb60-211" aria-hidden="true"></a><span class="kw">def</span> join(items, delimiter<span class="op">=</span><span class="st">&quot;&quot;</span>):</span>
<span id="cb60-212"><a href="#cb60-212" aria-hidden="true"></a>    <span class="cf">return</span> delimiter.join(</span>
<span id="cb60-213"><a href="#cb60-213" aria-hidden="true"></a>        join(item, delimiter) <span class="cf">if</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>) <span class="cf">else</span> <span class="bu">str</span>(item)</span>
<span id="cb60-214"><a href="#cb60-214" aria-hidden="true"></a>        <span class="cf">for</span> item <span class="kw">in</span> items</span>
<span id="cb60-215"><a href="#cb60-215" aria-hidden="true"></a>    )</span>
<span id="cb60-216"><a href="#cb60-216" aria-hidden="true"></a></span>
<span id="cb60-217"><a href="#cb60-217" aria-hidden="true"></a><span class="kw">def</span> indent(text, prefix<span class="op">=</span><span class="st">&quot;    &quot;</span>):</span>
<span id="cb60-218"><a href="#cb60-218" aria-hidden="true"></a>    <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join(prefix<span class="op">+</span>line <span class="cf">for</span> line <span class="kw">in</span> text.splitlines(<span class="va">True</span>))</span>
<span id="cb60-219"><a href="#cb60-219" aria-hidden="true"></a></span>
<span id="cb60-220"><a href="#cb60-220" aria-hidden="true"></a><span class="kw">def</span> compile_chain(grammars, source):</span>
<span id="cb60-221"><a href="#cb60-221" aria-hidden="true"></a>    <span class="im">import</span> os</span>
<span id="cb60-222"><a href="#cb60-222" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb60-223"><a href="#cb60-223" aria-hidden="true"></a>    <span class="im">import</span> pprint</span>
<span id="cb60-224"><a href="#cb60-224" aria-hidden="true"></a>    <span class="cf">for</span> grammar, rule <span class="kw">in</span> grammars:</span>
<span id="cb60-225"><a href="#cb60-225" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb60-226"><a href="#cb60-226" aria-hidden="true"></a>            source <span class="op">=</span> grammar().run(rule, source)</span>
<span id="cb60-227"><a href="#cb60-227" aria-hidden="true"></a>        <span class="cf">except</span> MatchError <span class="im">as</span> e:</span>
<span id="cb60-228"><a href="#cb60-228" aria-hidden="true"></a>            marker <span class="op">=</span> <span class="st">&quot;&lt;ERROR POSITION&gt;&quot;</span></span>
<span id="cb60-229"><a href="#cb60-229" aria-hidden="true"></a>            <span class="cf">if</span> os.isatty(sys.stderr.fileno()):</span>
<span id="cb60-230"><a href="#cb60-230" aria-hidden="true"></a>                marker <span class="op">=</span> <span class="ss">f&quot;</span><span class="ch">\033</span><span class="ss">[0;31m</span><span class="sc">{</span>marker<span class="sc">}</span><span class="ch">\033</span><span class="ss">[0m&quot;</span></span>
<span id="cb60-231"><a href="#cb60-231" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(e.stream, <span class="bu">str</span>):</span>
<span id="cb60-232"><a href="#cb60-232" aria-hidden="true"></a>                stream_string <span class="op">=</span> e.stream[:e.pos] <span class="op">+</span> marker <span class="op">+</span> e.stream[e.pos:]</span>
<span id="cb60-233"><a href="#cb60-233" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb60-234"><a href="#cb60-234" aria-hidden="true"></a>                stream_string <span class="op">=</span> pprint.pformat(e.stream)</span>
<span id="cb60-235"><a href="#cb60-235" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">POSITION: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">STREAM:</span><span class="ch">\n</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb60-236"><a href="#cb60-236" aria-hidden="true"></a>                e.message,</span>
<span id="cb60-237"><a href="#cb60-237" aria-hidden="true"></a>                e.pos,</span>
<span id="cb60-238"><a href="#cb60-238" aria-hidden="true"></a>                indent(stream_string)</span>
<span id="cb60-239"><a href="#cb60-239" aria-hidden="true"></a>            ))</span>
<span id="cb60-240"><a href="#cb60-240" aria-hidden="true"></a>    <span class="cf">return</span> source</span></code></pre></div>
<h3 id="srcmain.py">src/main.py</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>    <span class="im">import</span> sys</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a>    <span class="kw">def</span> read(path):</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>        <span class="cf">if</span> path <span class="op">==</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>            <span class="cf">return</span> sys.stdin.read()</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true"></a>        <span class="cf">with</span> <span class="bu">open</span>(path) <span class="im">as</span> f:</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true"></a>            <span class="cf">return</span> f.read()</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true"></a>    args <span class="op">=</span> sys.argv[<span class="dv">1</span>:] <span class="kw">or</span> [<span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;-&quot;</span>]</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true"></a>    <span class="cf">while</span> args:</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true"></a>        command <span class="op">=</span> args.pop(<span class="dv">0</span>)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true"></a>        <span class="cf">if</span> command <span class="op">==</span> <span class="st">&quot;--support&quot;</span>:</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true"></a>            sys.stdout.write(SUPPORT)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--copy&quot;</span>:</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true"></a>            sys.stdout.write(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--embed&quot;</span>:</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true"></a>            sys.stdout.write(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> = </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true"></a>                args.pop(<span class="dv">0</span>),</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true"></a>                <span class="bu">repr</span>(read(args.pop(<span class="dv">0</span>)))</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true"></a>            ))</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true"></a>        <span class="cf">elif</span> command <span class="op">==</span> <span class="st">&quot;--compile&quot;</span>:</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true"></a>            sys.stdout.write(compile_chain(</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true"></a>                [(Parser, <span class="st">&quot;file&quot;</span>), (CodeGenerator, <span class="st">&quot;asts&quot;</span>), (Assembler, <span class="st">&quot;asts&quot;</span>)],</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true"></a>                read(args.pop(<span class="dv">0</span>))</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true"></a>            ))</span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true"></a>            sys.exit(<span class="st">&quot;ERROR: Unknown command '</span><span class="sc">{}</span><span class="st">'&quot;</span>.<span class="bu">format</span>(command))</span></code></pre></div>
<h3 id="make.py">make.py</h3>
<div class="sourceCode" id="cb62"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a><span class="co">#!/usr/bin/env python</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a><span class="im">import</span> os</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a><span class="im">import</span> subprocess</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a><span class="im">import</span> sys</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true"></a><span class="kw">def</span> make_next_version():</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true"></a>    final_compiler <span class="op">=</span> meta_compile_rlmeta()</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true"></a>    test(final_compiler)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true"></a>    mv(final_compiler, <span class="st">&quot;rlmeta.py&quot;</span>)</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true"></a><span class="kw">def</span> meta_compile_rlmeta():</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true"></a>    compiler <span class="op">=</span> <span class="st">&quot;rlmeta.py&quot;</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true"></a>    content <span class="op">=</span> read(compiler)</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true"></a>        next_compiler <span class="op">=</span> <span class="st">&quot;rlmeta</span><span class="sc">{}</span><span class="st">.py&quot;</span>.<span class="bu">format</span>(i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true"></a>        next_content <span class="op">=</span> compile_rlmeta(compiler)</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true"></a>        log(<span class="st">&quot;Writing </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(next_compiler))</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true"></a>        write(next_compiler, next_content)</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true"></a>        <span class="cf">if</span> next_content <span class="op">==</span> content:</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true"></a>            <span class="cf">return</span> next_compiler</span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true"></a>        compiler <span class="op">=</span> next_compiler</span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true"></a>        content <span class="op">=</span> next_content</span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true"></a>    fail(<span class="st">&quot;Unable to produce metacompiler.&quot;</span>)</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true"></a></span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true"></a><span class="kw">def</span> compile_rlmeta(rlmeta):</span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true"></a>    log(<span class="st">&quot;Compiling rlmeta using </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(rlmeta))</span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true"></a>    <span class="cf">return</span> run_rlmeta(rlmeta, [</span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true"></a>        <span class="st">&quot;--embed&quot;</span>, <span class="st">&quot;SUPPORT&quot;</span>, <span class="st">&quot;src/support.py&quot;</span>,</span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true"></a>        <span class="st">&quot;--support&quot;</span>,</span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true"></a>        <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;src/parser.rlmeta&quot;</span>,</span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true"></a>        <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;src/codegenerator.rlmeta&quot;</span>,</span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true"></a>        <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;src/assembler.rlmeta&quot;</span>,</span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true"></a>        <span class="st">&quot;--copy&quot;</span>, <span class="st">&quot;src/main.py&quot;</span>,</span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true"></a>    ])</span>
<span id="cb62-36"><a href="#cb62-36" aria-hidden="true"></a></span>
<span id="cb62-37"><a href="#cb62-37" aria-hidden="true"></a><span class="kw">def</span> test(rlmeta):</span>
<span id="cb62-38"><a href="#cb62-38" aria-hidden="true"></a>    log(<span class="st">&quot;Test: Has its own support library&quot;</span>)</span>
<span id="cb62-39"><a href="#cb62-39" aria-hidden="true"></a>    <span class="cf">assert</span> run_rlmeta(rlmeta, [<span class="st">&quot;--support&quot;</span>]) <span class="op">==</span> read(<span class="st">&quot;src/support.py&quot;</span>)</span>
<span id="cb62-40"><a href="#cb62-40" aria-hidden="true"></a>    log(<span class="st">&quot;Test: Disallow semantic action in the middle&quot;</span>)</span>
<span id="cb62-41"><a href="#cb62-41" aria-hidden="true"></a>    run_rlmeta(rlmeta, [], b<span class="st">&quot;Grammar { x = . -&gt; [] . }&quot;</span>, expect_failure<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb62-42"><a href="#cb62-42" aria-hidden="true"></a>    log(<span class="st">&quot;Test: Call unknown rule foo&quot;</span>)</span>
<span id="cb62-43"><a href="#cb62-43" aria-hidden="true"></a>    <span class="cf">assert</span> test_grammar(</span>
<span id="cb62-44"><a href="#cb62-44" aria-hidden="true"></a>        rlmeta,</span>
<span id="cb62-45"><a href="#cb62-45" aria-hidden="true"></a>        b<span class="st">&quot;Grammar { x = % | . }&quot;</span>,</span>
<span id="cb62-46"><a href="#cb62-46" aria-hidden="true"></a>        b<span class="st">&quot;print(compile_chain([(Grammar, 'x')], ['foo']))&quot;</span></span>
<span id="cb62-47"><a href="#cb62-47" aria-hidden="true"></a>    ) <span class="op">==</span> b<span class="st">&quot;foo</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb62-48"><a href="#cb62-48" aria-hidden="true"></a></span>
<span id="cb62-49"><a href="#cb62-49" aria-hidden="true"></a><span class="kw">def</span> test_grammar(rlmeta, grammar, main_code):</span>
<span id="cb62-50"><a href="#cb62-50" aria-hidden="true"></a>    compiled <span class="op">=</span> run_rlmeta(rlmeta, [<span class="st">&quot;--support&quot;</span>, <span class="st">&quot;--compile&quot;</span>, <span class="st">&quot;-&quot;</span>], grammar)</span>
<span id="cb62-51"><a href="#cb62-51" aria-hidden="true"></a>    total <span class="op">=</span> compiled <span class="op">+</span> main_code</span>
<span id="cb62-52"><a href="#cb62-52" aria-hidden="true"></a>    process <span class="op">=</span> subprocess.Popen(</span>
<span id="cb62-53"><a href="#cb62-53" aria-hidden="true"></a>        [<span class="st">&quot;python&quot;</span>],</span>
<span id="cb62-54"><a href="#cb62-54" aria-hidden="true"></a>        stdin<span class="op">=</span>subprocess.PIPE,</span>
<span id="cb62-55"><a href="#cb62-55" aria-hidden="true"></a>        stdout<span class="op">=</span>subprocess.PIPE</span>
<span id="cb62-56"><a href="#cb62-56" aria-hidden="true"></a>    )</span>
<span id="cb62-57"><a href="#cb62-57" aria-hidden="true"></a>    stdout, _ <span class="op">=</span> process.communicate(total)</span>
<span id="cb62-58"><a href="#cb62-58" aria-hidden="true"></a>    <span class="cf">return</span> stdout</span>
<span id="cb62-59"><a href="#cb62-59" aria-hidden="true"></a></span>
<span id="cb62-60"><a href="#cb62-60" aria-hidden="true"></a><span class="kw">def</span> run_rlmeta(rlmeta, args, stdin<span class="op">=</span>b<span class="st">&quot;&quot;</span>, expect_failure<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb62-61"><a href="#cb62-61" aria-hidden="true"></a>    process <span class="op">=</span> subprocess.Popen(</span>
<span id="cb62-62"><a href="#cb62-62" aria-hidden="true"></a>        [<span class="st">&quot;python&quot;</span>, rlmeta]<span class="op">+</span>args,</span>
<span id="cb62-63"><a href="#cb62-63" aria-hidden="true"></a>        stdin<span class="op">=</span>subprocess.PIPE,</span>
<span id="cb62-64"><a href="#cb62-64" aria-hidden="true"></a>        stdout<span class="op">=</span>subprocess.PIPE</span>
<span id="cb62-65"><a href="#cb62-65" aria-hidden="true"></a>    )</span>
<span id="cb62-66"><a href="#cb62-66" aria-hidden="true"></a>    stdout, _ <span class="op">=</span> process.communicate(stdin)</span>
<span id="cb62-67"><a href="#cb62-67" aria-hidden="true"></a>    <span class="cf">if</span> expect_failure:</span>
<span id="cb62-68"><a href="#cb62-68" aria-hidden="true"></a>        <span class="cf">if</span> process.returncode <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb62-69"><a href="#cb62-69" aria-hidden="true"></a>            fail(<span class="st">&quot;Expected failure&quot;</span>)</span>
<span id="cb62-70"><a href="#cb62-70" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb62-71"><a href="#cb62-71" aria-hidden="true"></a>        <span class="cf">if</span> process.returncode <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb62-72"><a href="#cb62-72" aria-hidden="true"></a>            fail(<span class="st">&quot;Expected success&quot;</span>)</span>
<span id="cb62-73"><a href="#cb62-73" aria-hidden="true"></a>    <span class="cf">return</span> stdout</span>
<span id="cb62-74"><a href="#cb62-74" aria-hidden="true"></a></span>
<span id="cb62-75"><a href="#cb62-75" aria-hidden="true"></a><span class="kw">def</span> mv(src, dest):</span>
<span id="cb62-76"><a href="#cb62-76" aria-hidden="true"></a>    log(<span class="st">&quot;Moving </span><span class="sc">{}</span><span class="st"> -&gt; </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(src, dest))</span>
<span id="cb62-77"><a href="#cb62-77" aria-hidden="true"></a>    os.remove(dest)</span>
<span id="cb62-78"><a href="#cb62-78" aria-hidden="true"></a>    os.rename(src, dest)</span>
<span id="cb62-79"><a href="#cb62-79" aria-hidden="true"></a></span>
<span id="cb62-80"><a href="#cb62-80" aria-hidden="true"></a><span class="kw">def</span> cleanup():</span>
<span id="cb62-81"><a href="#cb62-81" aria-hidden="true"></a>    <span class="cf">for</span> path <span class="kw">in</span> [</span>
<span id="cb62-82"><a href="#cb62-82" aria-hidden="true"></a>        <span class="st">&quot;rlmeta1.py&quot;</span>,</span>
<span id="cb62-83"><a href="#cb62-83" aria-hidden="true"></a>        <span class="st">&quot;rlmeta2.py&quot;</span>,</span>
<span id="cb62-84"><a href="#cb62-84" aria-hidden="true"></a>        <span class="st">&quot;rlmeta3.py&quot;</span>,</span>
<span id="cb62-85"><a href="#cb62-85" aria-hidden="true"></a>        <span class="st">&quot;rlmeta4.py&quot;</span>,</span>
<span id="cb62-86"><a href="#cb62-86" aria-hidden="true"></a>    ]:</span>
<span id="cb62-87"><a href="#cb62-87" aria-hidden="true"></a>        <span class="cf">if</span> os.path.exists(path):</span>
<span id="cb62-88"><a href="#cb62-88" aria-hidden="true"></a>            log(<span class="st">&quot;Deleting </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(path))</span>
<span id="cb62-89"><a href="#cb62-89" aria-hidden="true"></a>            os.remove(path)</span>
<span id="cb62-90"><a href="#cb62-90" aria-hidden="true"></a></span>
<span id="cb62-91"><a href="#cb62-91" aria-hidden="true"></a><span class="kw">def</span> read(path):</span>
<span id="cb62-92"><a href="#cb62-92" aria-hidden="true"></a>    <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">&quot;rb&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb62-93"><a href="#cb62-93" aria-hidden="true"></a>        <span class="cf">return</span> f.read()</span>
<span id="cb62-94"><a href="#cb62-94" aria-hidden="true"></a></span>
<span id="cb62-95"><a href="#cb62-95" aria-hidden="true"></a><span class="kw">def</span> write(path, content):</span>
<span id="cb62-96"><a href="#cb62-96" aria-hidden="true"></a>    <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">&quot;wb&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb62-97"><a href="#cb62-97" aria-hidden="true"></a>        <span class="cf">return</span> f.write(content)</span>
<span id="cb62-98"><a href="#cb62-98" aria-hidden="true"></a></span>
<span id="cb62-99"><a href="#cb62-99" aria-hidden="true"></a><span class="kw">def</span> log(message):</span>
<span id="cb62-100"><a href="#cb62-100" aria-hidden="true"></a>    sys.stderr.write(color(<span class="ss">f&quot;</span><span class="sc">{</span>message<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>, <span class="st">&quot;33&quot;</span>))</span>
<span id="cb62-101"><a href="#cb62-101" aria-hidden="true"></a></span>
<span id="cb62-102"><a href="#cb62-102" aria-hidden="true"></a><span class="kw">def</span> success(message):</span>
<span id="cb62-103"><a href="#cb62-103" aria-hidden="true"></a>    sys.stderr.write(color(<span class="ss">f&quot;</span><span class="sc">{</span>message<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>, <span class="st">&quot;32&quot;</span>))</span>
<span id="cb62-104"><a href="#cb62-104" aria-hidden="true"></a></span>
<span id="cb62-105"><a href="#cb62-105" aria-hidden="true"></a><span class="kw">def</span> fail(message):</span>
<span id="cb62-106"><a href="#cb62-106" aria-hidden="true"></a>    sys.exit(color(<span class="ss">f&quot;ERROR: </span><span class="sc">{</span>message<span class="sc">}</span><span class="ss">&quot;</span>, <span class="st">&quot;31&quot;</span>))</span>
<span id="cb62-107"><a href="#cb62-107" aria-hidden="true"></a></span>
<span id="cb62-108"><a href="#cb62-108" aria-hidden="true"></a><span class="kw">def</span> color(message, color):</span>
<span id="cb62-109"><a href="#cb62-109" aria-hidden="true"></a>    <span class="cf">if</span> os.isatty(sys.stderr.fileno()):</span>
<span id="cb62-110"><a href="#cb62-110" aria-hidden="true"></a>        <span class="cf">return</span> <span class="ss">f&quot;</span><span class="ch">\033</span><span class="ss">[0;</span><span class="sc">{</span>color<span class="sc">}</span><span class="ss">m</span><span class="sc">{</span>message<span class="sc">}</span><span class="ch">\033</span><span class="ss">[0m&quot;</span></span>
<span id="cb62-111"><a href="#cb62-111" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb62-112"><a href="#cb62-112" aria-hidden="true"></a>        <span class="cf">return</span> message</span>
<span id="cb62-113"><a href="#cb62-113" aria-hidden="true"></a></span>
<span id="cb62-114"><a href="#cb62-114" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb62-115"><a href="#cb62-115" aria-hidden="true"></a>    cleanup()</span>
<span id="cb62-116"><a href="#cb62-116" aria-hidden="true"></a>    <span class="cf">if</span> sys.argv[<span class="dv">1</span>:] <span class="op">==</span> [<span class="st">&quot;--compile&quot;</span>]:</span>
<span id="cb62-117"><a href="#cb62-117" aria-hidden="true"></a>        sys.stdout.<span class="bu">buffer</span>.write(compile_rlmeta(<span class="st">&quot;rlmeta.py&quot;</span>))</span>
<span id="cb62-118"><a href="#cb62-118" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb62-119"><a href="#cb62-119" aria-hidden="true"></a>        make_next_version()</span>
<span id="cb62-120"><a href="#cb62-120" aria-hidden="true"></a>    cleanup()</span>
<span id="cb62-121"><a href="#cb62-121" aria-hidden="true"></a>    success(<span class="st">&quot;  O-----------------O&quot;</span>)</span>
<span id="cb62-122"><a href="#cb62-122" aria-hidden="true"></a>    success(<span class="st">&quot;  | RLMeta compiled |&quot;</span>)</span>
<span id="cb62-123"><a href="#cb62-123" aria-hidden="true"></a>    success(<span class="st">&quot;~~|     itself!     |&quot;</span>)</span>
<span id="cb62-124"><a href="#cb62-124" aria-hidden="true"></a>    success(<span class="st">&quot;  O-----------------O&quot;</span>)</span></code></pre></div>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
