{
"root_page":{
"children":[
{
"children":[],
"id":"a9a4166e943a4d2c974c443cef1da5a9",
"paragraphs":[
{
"chunkpath":[
"match rule"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"def _match_rule(self, rule_name):\n    key = (rule_name, self._stream.position())\n    if key in self._memo:\n        if self._memo[key][0] is None:\n            self._stream.fail(\"\")\n        else:\n            result, _, self._stream = self._memo[key]\n    else:\n        try:\n            start = self._stream\n            result = getattr(self, \"_rule_{}\".format(rule_name))()\n            end = self._stream\n            self._memo[key] = (result, start, end)\n        except _MatchError as e:\n            self._memo[key] = (None, None, None)\n            raise\n    return result\n",
"type":"code"
}
],
"id":"49bd6fdc3d8a40a9ae62454cafe2e330",
"type":"code"
}
],
"title":"Optimized"
},
{
"children":[],
"id":"fe17638693e344ad9e521e55bf0676f3",
"paragraphs":[
{
"chunkpath":[
"RETURN"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"if len(call_backtrack_stack) == 0:\n    return last_action.eval()\npc, key = call_backtrack_stack.pop()\nmemo[key] = (last_action, stream_pos_stack+[(stream, pos)])\ncontinue\n",
"type":"code"
}
],
"id":"20ace23911b1446ab7c8e6cba4a4527a",
"type":"code"
},
{
"chunkpath":[
"pop backtrack entries"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"call_backtrack_entry = tuple()\nwhile call_backtrack_stack:\n    call_backtrack_entry = call_backtrack_stack.pop()\n    if len(call_backtrack_entry) == 4:\n        break\n    else:\n        _, key = call_backtrack_entry\n        memo[key] = (None, fail_message)\n",
"type":"code"
}
],
"id":"09bb7d528d084ca7a31b98ea7659a8a0",
"type":"code"
},
{
"chunkpath":[
"CALL"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))\nif key in memo:\n    if memo[key][0] is None:\n        fail_message = memo[key][1]\n    else:\n        last_action, stream_pos_stack = memo[key]\n        stream_pos_stack = stream_pos_stack[:]\n        stream, pos = stream_pos_stack.pop()\n        pc += 1\n        continue\nelse:\n    call_backtrack_stack.append((pc+1, key))\n    pc = labels[arg1]\n    continue\n",
"type":"code"
}
],
"id":"7f7bb394b7b9434eb91e19118aa52a0a",
"type":"code"
},
{
"chunkpath":[
"MATCH_CALL_RULE"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"if pos >= len(stream):\n    fail_message = (\"expected any\",)\nelse:\n    fn_name = str(stream[pos])\n    key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))\n    if key in memo:\n        if memo[key][0] is None:\n            fail_message = memo[key][1]\n        else:\n            last_action, stream_pos_stack = memo[key]\n            stream_pos_stack = stream_pos_stack[:]\n            stream, pos = stream_pos_stack.pop()\n            pc += 1\n            continue\n    else:\n        call_backtrack_stack.append((pc+1, key))\n        pc = labels[fn_name]\n        pos += 1\n        continue\n",
"type":"code"
}
],
"id":"6ff1e38b876b4f32b4a004a4611c1639",
"type":"code"
}
],
"title":"VM"
},
{
"children":[],
"id":"42ae6babf74d427880f831bd14109002",
"paragraphs":[
{
"fragments":[
{
"text":"Enter image text here...",
"type":"text"
}
],
"id":"866972443e7644629d53b53db0607fb5",
"image_base64":"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",
"type":"image"
}
],
"title":"Results"
},
{
"children":[
{
"children":[],
"id":"9818dacb067848a48d8d593215719064",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"optimized",
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space string:x                           -> [\"MatchString\" x]\n    | space charseq:x                          -> [\"MatchCharseq\" x]\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'        -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x                     -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'                                -> [\"IndentBuilder\"]\n    | space '<'                                -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''  -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"30e8da90e5fa4b988d5938381e91cd26",
"type":"code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"f7faa2ba27d644feb0d879b808214232",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"optimized",
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(_Grammar):\\n\" > ys <                       }\n  Rule           = .:x ast:y       -> { \"\\ndef _rule_\" x \"(self):\\n\" > \"return \" y \"()\\n\" <     }\n  MatchAny       =                 -> { \"self._match_any\"                                       }\n  MatchCallRule  =                 -> { \"self._match_call_rule\"                                 }\n  String         = .:x             -> { repr(x)                                                 }\n  List           = astList:x       -> { x                                                       }\n  Builder        = astItems:x      -> { \"_Builder.create([\" x \"])\"                              }\n  IndentBuilder  =                 -> { \"_IndentBuilder()\"                                      }\n  DedentBuilder  =                 -> { \"_DedentBuilder()\"                                      }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                                             }\n  VarLookup      = .:x             -> { \"_vars.lookup(\" repr(x) \").eval()\"                      }\n  Or             =\n    | ast:x !.                     -> x\n    | astItems:x                   -> { \"(lambda: self._or([\" x \"]))\"                           }\n  Scope          = ast:x           -> { \"(lambda: (lambda _vars:\\n\" > x < \"()\\n)(_Vars()))\"     }\n  And            =\n    | ast:x !.                     -> x\n    | astItems:x                   -> { \"(lambda: self._and([\" x \"]))\"                          }\n  Bind           = .:x ast:y       -> { \"(lambda: _vars.bind(\" repr(x) \", \" y \"()))\"            }\n  Star           = ast:x           -> { \"(lambda: self._star(\" x \"))\"                           }\n  Not            = ast:x           -> { \"(lambda: self._not(\" x \"))\"                            }\n  SemanticAction = ast:x           -> { \"(lambda: _SemanticAction(lambda: \" x \"))\"              }\n  MatchRule      = .:x             -> { \"(lambda: self._match_rule(\" repr(x) \"))\"               }\n  MatchRange     = .:x .:y         -> { \"(lambda: self._match_range(\" repr(x) \", \" repr(y) \"))\" }\n  MatchString    = .:x             -> { \"(lambda: self._match_string(\" repr(x) \"))\"             }\n  MatchCharseq   = .:x             -> { \"(lambda: self._match_charseq(\" repr(x) \"))\"            }\n  MatchList      = ast:x           -> { \"(lambda: self._match_list(\" x \"))\"                     }\n  ast            = [%:x]           -> x\n  astItems       = astItem*:xs     -> { \"\\n\" > xs <                                             }\n  astItem        = ast:x           -> { x \",\\n\"                                                 }\n  astList        = astListItem*:xs -> { \"(\" xs \"[])\"                                            }\n  astListItem    =\n    | [\"ListItemSplice\" ast:x]     -> {     x  \"+\"                                              }\n    | ast:x                        -> { \"[\" x \"]+\"                                              }\n}\n",
"type":"code"
}
],
"id":"2924a3b3a22b43e4808a867ab3bb2e9f",
"type":"code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"a7c587100e7b471398ab18d4ac876d81",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\nclass _Grammar(object):\n\n    def _or(self, matchers):\n        original_stream = self._stream\n        for matcher in matchers[:-1]:\n            try:\n                return matcher()\n            except _MatchError:\n                self._stream = original_stream\n        return matchers[-1]()\n\n    def _and(self, matchers):\n        result = None\n        for matcher in matchers:\n            result = matcher()\n        return result\n\n    def _star(self, matcher):\n        result = []\n        while True:\n            original_stream = self._stream\n            try:\n                result.append(matcher())\n            except _MatchError:\n                self._stream = original_stream\n                return _SemanticAction(lambda: [x.eval() for x in result])\n\n    def _not(self, matcher):\n        original_stream = self._stream\n        try:\n            matcher()\n        except _MatchError:\n            return _SemanticAction(lambda: None)\n        else:\n            original_stream.fail(lambda: \"match found\")\n        finally:\n            self._stream = original_stream\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"match rule"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"\n    def _match_range(self, start, end):\n        next_objext = self._stream.peek()\n        if next_objext >= start and next_objext <= end:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: next_objext)\n        else:\n            self._stream.fail(\n                lambda: \"expected range {!r}-{!r} but found {!r}\".format(start, end, next_objext)\n            )\n\n    def _match_string(self, string):\n        next_object = self._stream.peek()\n        if next_object == string:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: string)\n        else:\n            self._stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(string, next_object)\n            )\n\n    def _match_charseq(self, charseq):\n        for char in charseq:\n            next_object = self._stream.peek()\n            if next_object != char:\n                self._stream.fail(\n                    lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n                )\n            self._stream = self._stream.advance()\n        return _SemanticAction(lambda: charseq)\n\n    def _match_any(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return _SemanticAction(lambda: next_object)\n\n    def _match_call_rule(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return self._match_rule(str(next_object))\n\n    def _match_list(self, matcher):\n        original_stream = self._stream\n        next_object = self._stream.peek()\n        if isinstance(next_object, list):\n            self._stream = self._stream.nested(next_object)\n            matcher()\n            if self._stream.is_at_end():\n                self._stream = original_stream.advance()\n                return _SemanticAction(lambda: next_object)\n        original_stream.fail(lambda: \"list match failed\")\n\n    def run(self, rule_name, input_object):\n        self._memo = _Memo()\n        self._stream = _Stream.from_object(self._memo, input_object)\n        result = self._match_rule(rule_name).eval()\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Vars(dict):\n\n    def bind(self, name, value):\n        self[name] = value\n        return value\n\n    def lookup(self, name):\n        return self[name]\n\nclass _SemanticAction(object):\n\n    def __init__(self, fn):\n        self.fn = fn\n\n    def eval(self):\n        return self.fn()\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _Memo(dict):\n\n    def __init__(self):\n        dict.__init__(self)\n        self._latest_stream = _ObjectStream(self, [], -1)\n        self._latest_lazy_message = lambda: \"\"\n\n    def describe(self):\n        items = []\n        for (rule_name, _), (_, start, end) in self.items():\n            if end > start:\n                items.append((rule_name, start, end))\n        items.sort(key=lambda item: (item[2].position(), item[1].position()))\n        message = []\n        for item in items:\n            message.append(\"matched {: <20} {} -> {}\\n\".format(*item))\n        message.append(\"\\n\")\n        message.append(\"ERROR: {}: {}\\n\".format(\n            self._latest_stream,\n            self._latest_lazy_message()\n        ))\n        return \"\".join(message)\n\n    def fail(self, stream, lazy_message):\n        if stream.position() >= self._latest_stream.position():\n            self._latest_stream = stream\n            self._latest_lazy_message = lazy_message\n        raise _MatchError(self)\n\nclass _MatchError(Exception):\n\n    def __init__(self, memo):\n        Exception.__init__(self)\n        self._memo = memo\n\n    def describe(self):\n        return self._memo.describe()\n\nclass _Stream(object):\n\n    @classmethod\n    def from_object(cls, memo, input_object):\n        if isinstance(input_object, basestring):\n            return _CharStream(memo, input_object, 0)\n        else:\n            return _ObjectStream(memo, [input_object], 0)\n\n    def __init__(self, memo, objects, index):\n        self._memo = memo\n        self._objects = objects\n        self._index = index\n\n    def fail(self, lazy_message):\n        self._memo.fail(self, lazy_message)\n\n    def peek(self):\n        if self.is_at_end():\n            self.fail(lambda: \"not eof\")\n        return self._objects[self._index]\n\n    def is_at_end(self):\n        return self._index >= len(self._objects)\n\nclass _CharStream(_Stream):\n\n    def __init__(self, memo, objects, index, line=1, column=1):\n        _Stream.__init__(self, memo, objects, index)\n        self._line = line\n        self._column = column\n\n    def position(self):\n        return self._index\n\n    def advance(self):\n        if self._objects[self._index] == \"\\n\":\n            line = self._line + 1\n            column = 1\n        else:\n            line = self._line\n            column = self._column + 1\n        return _CharStream(self._memo, self._objects, self._index+1, line, column)\n\n    def __str__(self):\n        return \"L{:03d}:C{:03d}\".format(self._line, self._column)\n\nclass _ObjectStream(_Stream):\n\n    def __init__(self, memo, objects, index, parent=()):\n        _Stream.__init__(self, memo, objects, index)\n        self._parent_position = parent\n        self._position = self._parent_position + (self._index,)\n\n    def position(self):\n        return self._position\n\n    def nested(self, input_object):\n        return _ObjectStream(self._memo, input_object, 0, self._position)\n\n    def advance(self):\n        return _ObjectStream(self._memo, self._objects, self._index+1, self._parent_position)\n\n    def __str__(self):\n        return \"[{}]\".format(\", \".join(str(x) for x in self.position()))\n",
"type":"code"
}
],
"id":"aca14d0f6ac5466b86977fb1f64dbfe7",
"type":"code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"712c4e18d59b4c8ba02c7fa9cf06a8e3",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"optimized",
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"69b9bb22e193400eb1f59ab0e2f697c5",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"c2cfcdaf112241f3b5910c886ad5124e",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"optimized",
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"59ed29030d134c959df5522496629b85",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"fa899c41ee3d43a88b659ad9b0486c2c",
"paragraphs":[],
"title":"Code listings for RLMeta (optimized)"
},
{
"children":[
{
"children":[],
"id":"1b68587ebbb24fde927b6f6f897e07ef",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"vm",
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | space '#'                                -> [\"Label\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space string:x                           -> [\"MatchString\" x]\n    | space charseq:x                          -> [\"MatchCharseq\" x]\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'        -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x                     -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'                                -> [\"IndentBuilder\"]\n    | space '<'                                -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''  -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"c71fce8e74cb440980a3ae2b5533eea0",
"type":"code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"1b486a301405470c833411bb9016fefc",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"vm",
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n  ast            = [%:x]           -> x\n  py             = .:x             -> repr(x)\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(_Grammar):\\n\\n\" >\n                                          \"def __init__(self):\\n\" >\n                                            \"self._instructions = i = []\\n\"\n                                            \"self._labels = l = {}\\n\"\n                                            \"def I(name, x=None, y=None):\\n\" >\n                                              \"i.append((name, x, y))\\n\"\n                                            <\n                                            \"def LABEL(name):\\n\" >\n                                              \"l[name] = len(i)\\n\"\n                                            <\n                                            ys\n                                          <\n                                        <                                    }\n  Rule           = py:x ast:y      -> { \"LABEL(\" x \")\\n\"\n                                        y\n                                        \"I('RETURN')\\n\"                      }\n  Or             =\n    | ast:x Or:y #:a #:b           -> { \"I('BACKTRACK', \" a \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" b \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        y\n                                        \"LABEL(\" b \")\\n\"                     }\n    | ast\n  Scope          = ast:x           -> { \"I('PUSH_SCOPE')\\n\"\n                                        x\n                                        \"I('POP_SCOPE')\\n\"                   }\n  And            = ast*\n  Bind           = py:x ast:y      -> { y\n                                        \"I('BIND', \" x \")\\n\"                 }\n  Star           = ast:x #:a #:b   -> { \"I('LIST_START')\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('LIST_APPEND')\\n\"\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" b \")\\n\"\n                                        \"I('LIST_END')\\n\"                    }\n  Not            = ast:x #:a #:b   -> { \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('FAIL', 'no match expected')\\n\"\n                                        \"LABEL(\" b \")\\n\"                     }\n  MatchCallRule  =                 -> { \"I('MATCH_CALL_RULE')\\n\"             }\n  Label          =                 -> { \"I('LABEL')\\n\"                       }\n  SemanticAction = ast:x           -> { \"I('ACTION', lambda scope: \" x \")\\n\" }\n  String         = py\n  List           = astList\n  Builder        = astItems:x      -> { \"_Builder.create([\" x \"])\"           }\n  IndentBuilder  =                 -> { \"_IndentBuilder()\"                   }\n  DedentBuilder  =                 -> { \"_DedentBuilder()\"                   }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                          }\n  VarLookup      = py:x            -> { \"scope[\" x \"].eval()\"                }\n  astItems       =\n    | ast:x astItem*:xs            -> { x xs                                 }\n    |                              -> {                                      }\n  astItem        = ast:x           -> { \", \" x                               }\n  astList        = astListItem*:xs -> { \"(\" xs \"[])\"                         }\n  astListItem    =\n    | [\"ListItemSplice\" ast:x]     -> {     x  \"+\"                           }\n    | ast:x                        -> { \"[\" x \"]+\"                           }\n  MatchRule      = py:x            -> { \"I('CALL', \" x \")\\n\"                 }\n  MatchRange     = py:x py:y       -> { \"I('MATCH_RANGE', \" x \", \" y \")\\n\"   }\n  MatchString    = py:x            -> { \"I('MATCH_STRING', \" x \")\\n\"         }\n  MatchCharseq   = py:x            -> { \"I('MATCH_CHARSEQ', \" x \")\\n\"        }\n  MatchAny       =                 -> { \"I('MATCH_ANY')\\n\"                   }\n  MatchList      = ast:x           -> { \"I('PUSH_STREAM')\\n\"\n                                        x\n                                        \"I('POP_STREAM')\\n\"                  }\n}\n",
"type":"code"
}
],
"id":"ba1fc285f5874989987cc7bb52ec1a6e",
"type":"code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"2d78cf2770f24b818ffcefa6216cb81c",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\ndef rlmeta_vm(instructions, labels, start_rule, stream):\n    label_counter = 0\n    last_action = _ConstantSemanticAction(None)\n    pc = labels[start_rule]\n    call_backtrack_stack = []\n    stream, pos, stream_pos_stack = (stream, 0, [])\n    scope, scope_stack = (None, [])\n    fail_message = None\n    latest_fail_message, latest_fail_pos = (None, tuple())\n    memo = {}\n    while True:\n        name, arg1, arg2 = instructions[pc]\n        if name == \"PUSH_SCOPE\":\n            scope_stack.append(scope)\n            scope = {}\n            pc += 1\n            continue\n        elif name == \"BACKTRACK\":\n            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))\n            pc += 1\n            continue\n        elif name == \"CALL\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"CALL"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"MATCH_CHARSEQ\":\n            for char in arg1:\n                if pos >= len(stream) or stream[pos] != char:\n                    fail_message = (\"expected {!r}\", char)\n                    break\n                pos += 1\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pc += 1\n                continue\n        elif name == \"COMMIT\":\n            call_backtrack_stack.pop()\n            pc = labels[arg1]\n            continue\n        elif name == \"POP_SCOPE\":\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"RETURN\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"RETURN"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"LIST_APPEND\":\n            scope.append(last_action)\n            pc += 1\n            continue\n        elif name == \"BIND\":\n            scope[arg1] = last_action\n            pc += 1\n            continue\n        elif name == \"ACTION\":\n            last_action = _UserSemanticAction(arg1, scope)\n            pc += 1\n            continue\n        elif name == \"MATCH_RANGE\":\n            if pos >= len(stream) or not (arg1 <= stream[pos] <= arg2):\n                fail_message = (\"expected range {!r}-{!r}\", arg1, arg2)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"LIST_START\":\n            scope_stack.append(scope)\n            scope = []\n            pc += 1\n            continue\n        elif name == \"LIST_END\":\n            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"MATCH_ANY\":\n            if pos >= len(stream):\n                fail_message = (\"expected any\",)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"PUSH_STREAM\":\n            if pos >= len(stream) or not isinstance(stream[pos], list):\n                fail_message = (\"expected list\",)\n            else:\n                stream_pos_stack.append((stream, pos))\n                stream = stream[pos]\n                pos = 0\n                pc += 1\n                continue\n        elif name == \"POP_STREAM\":\n            if pos < len(stream):\n                fail_message = (\"expected end of list\",)\n            else:\n                stream, pos = stream_pos_stack.pop()\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"MATCH_CALL_RULE\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"MATCH_CALL_RULE"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"FAIL\":\n            fail_message = (arg1,)\n        elif name == \"LABEL\":\n            last_action = _ConstantSemanticAction(label_counter)\n            label_counter += 1\n            pc += 1\n            continue\n        elif name == \"MATCH_STRING\":\n            if pos >= len(stream) or stream[pos] != arg1:\n                fail_message = (\"expected {!r}\", arg1)\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pos += 1\n                pc += 1\n                continue\n        else:\n            raise Exception(\"unknown instruction {}\".format(name))\n        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])\n        if fail_pos >= latest_fail_pos:\n            latest_fail_message = fail_message\n            latest_fail_pos = fail_pos\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"pop backtrack entries"
],
"prefix":"        ",
"type":"chunk"
},
{
"text":"        if len(call_backtrack_entry) != 4:\n            fail_pos = list(latest_fail_pos)\n            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream\n            while len(fail_pos) > 1:\n                fail_stream = fail_stream[fail_pos.pop(0)]\n            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)\n        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry\n        if len(stream_pos_stack) > stream_stack_len:\n            stream = stream_pos_stack[stream_stack_len][0]\n        stream_pos_stack = stream_pos_stack[:stream_stack_len]\n        if len(scope_stack) > scope_stack_len:\n            scope = scope_stack[scope_stack_len]\n        scope_stack = scope_stack[:scope_stack_len]\n\nclass _Grammar(object):\n\n    def run(self, rule_name, input_object):\n        if isinstance(input_object, basestring):\n            stream = input_object\n        else:\n            stream = [input_object]\n        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _ConstantSemanticAction(object):\n\n    def __init__(self, value):\n        self.value = value\n\n    def eval(self):\n        return self.value\n\nclass _UserSemanticAction(object):\n\n    def __init__(self, fn, scope):\n        self.fn = fn\n        self.scope = scope\n\n    def eval(self):\n        return self.fn(self.scope)\n\nclass _MatchError(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\n    def describe(self):\n        message = \"\"\n        if isinstance(self.stream, basestring):\n            before = self.stream[:self.pos].splitlines()\n            after = self.stream[self.pos:].splitlines()\n            for context_before in before[-4:-1]:\n                message += self._context(context_before)\n            message += self._context(before[-1], after[0])\n            message += self._arrow(len(before[-1]))\n            for context_after in after[1:4]:\n                message += self._context(context_after)\n        else:\n            message += self._context(\"[\")\n            for context_before in self.stream[:self.pos]:\n                message += self._context(\"  \", repr(context_before), \",\")\n            message += self._context(\"  \", repr(self.stream[self.pos]), \",\")\n            message += self._arrow(2)\n            for context_after in self.stream[self.pos+1:]:\n                message += self._context(\"  \", repr(context_after), \",\")\n            message += self._context(\"]\")\n        message += \"Error: \"\n        message += self.message[0].format(*self.message[1:])\n        message += \"\\n\"\n        return message\n\n    def _context(self, *args):\n        return \"> {}\\n\".format(\"\".join(args))\n\n    def _arrow(self, lenght):\n        return \"--{}^\\n\".format(\"-\"*lenght)\n",
"type":"code"
}
],
"id":"3233095b41404567872d7e190fb1ad66",
"type":"code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"c1f72e8df1ce4b619eeb30edf609e126",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"vm",
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"3ad80b7cb047456a89a9991cec9aa894",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"09b8983ad4194ac6a781880bd70117db",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"vm",
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"8fe0efd92f1b4fe4a24eca91003c68ed",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"5e20b8a3bc1348808c087c091612d9e0",
"paragraphs":[],
"title":"Code listings for RLMeta (VM)"
}
],
"id":"f4591956cea04b03be2859df337f261a",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta has a flaw in its memoization logic: It only memoizes successful matches. I realized it after reading ",
"type":"text"
},
{
"text":"Generating a PEG Parser",
"type":"link",
"url":"https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9"
},
{
"text":" in which Guido writes this:",
"type":"text"
}
],
"id":"3a35c5393d0047a4b172fcce7438ef97",
"type":"text"
},
{
"fragments":[
{
"text":"It is important to cache negative results too - in fact most calls to parsing methods will be negative results.",
"type":"text"
}
],
"id":"8ed0d48428924afe8fa356860cdf59b6",
"type":"quote"
}
],
"title":"Memoizing failiures in RLMeta"
},
"variables":{}
}