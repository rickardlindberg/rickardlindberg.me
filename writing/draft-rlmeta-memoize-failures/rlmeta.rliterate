{
"root_page":{
"children":[
{
"children":[],
"id":"fe17638693e344ad9e521e55bf0676f3",
"paragraphs":[
{
"chunkpath":[
"RETURN"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"if len(call_backtrack_stack) == 0:\n    return last_action.eval()\npc, key = call_backtrack_stack.pop()\nmemo[key] = (last_action, stream_pos_stack+[(stream, pos)])\ncontinue\n",
"type":"code"
}
],
"id":"20ace23911b1446ab7c8e6cba4a4527a",
"type":"code"
},
{
"chunkpath":[
"pop backtrack entries"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"call_backtrack_entry = tuple()\nwhile call_backtrack_stack:\n    call_backtrack_entry = call_backtrack_stack.pop()\n    if len(call_backtrack_entry) == 4:\n        break\n",
"type":"code"
}
],
"id":"09bb7d528d084ca7a31b98ea7659a8a0",
"type":"code"
},
{
"chunkpath":[
"CALL"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))\nif key in memo:\n    last_action, stream_pos_stack = memo[key]\n    stream_pos_stack = stream_pos_stack[:]\n    stream, pos = stream_pos_stack.pop()\n    pc += 1\nelse:\n    call_backtrack_stack.append((pc+1, key))\n    pc = labels[arg1]\ncontinue\n",
"type":"code"
}
],
"id":"7f7bb394b7b9434eb91e19118aa52a0a",
"type":"code"
},
{
"chunkpath":[
"MATCH_CALL_RULE"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"if pos >= len(stream):\n    fail_message = (\"expected any\",)\nelse:\n    fn_name = str(stream[pos])\n    key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))\n    if key in memo:\n        last_action, stream_pos_stack = memo[key]\n        stream_pos_stack = stream_pos_stack[:]\n        stream, pos = stream_pos_stack.pop()\n        pc += 1\n    else:\n        call_backtrack_stack.append((pc+1, key))\n        pc = labels[fn_name]\n        pos += 1\n    continue\n",
"type":"code"
}
],
"id":"6ff1e38b876b4f32b4a004a4611c1639",
"type":"code"
}
],
"title":"VM"
},
{
"children":[
{
"children":[],
"id":"1b68587ebbb24fde927b6f6f897e07ef",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | space '#'                                -> [\"Label\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space string:x                           -> [\"MatchString\" x]\n    | space charseq:x                          -> [\"MatchCharseq\" x]\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'        -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x                     -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'                                -> [\"IndentBuilder\"]\n    | space '<'                                -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''  -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"c71fce8e74cb440980a3ae2b5533eea0",
"type":"code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"1b486a301405470c833411bb9016fefc",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n  ast            = [%:x]           -> x\n  py             = .:x             -> repr(x)\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(_Grammar):\\n\\n\" >\n                                          \"def __init__(self):\\n\" >\n                                            \"self._instructions = i = []\\n\"\n                                            \"self._labels = l = {}\\n\"\n                                            \"def I(name, x=None, y=None):\\n\" >\n                                              \"i.append((name, x, y))\\n\"\n                                            <\n                                            \"def LABEL(name):\\n\" >\n                                              \"l[name] = len(i)\\n\"\n                                            <\n                                            ys\n                                          <\n                                        <                                    }\n  Rule           = py:x ast:y      -> { \"LABEL(\" x \")\\n\"\n                                        y\n                                        \"I('RETURN')\\n\"                      }\n  Or             =\n    | ast:x Or:y #:a #:b           -> { \"I('BACKTRACK', \" a \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" b \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        y\n                                        \"LABEL(\" b \")\\n\"                     }\n    | ast\n  Scope          = ast:x           -> { \"I('PUSH_SCOPE')\\n\"\n                                        x\n                                        \"I('POP_SCOPE')\\n\"                   }\n  And            = ast*\n  Bind           = py:x ast:y      -> { y\n                                        \"I('BIND', \" x \")\\n\"                 }\n  Star           = ast:x #:a #:b   -> { \"I('LIST_START')\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('LIST_APPEND')\\n\"\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" b \")\\n\"\n                                        \"I('LIST_END')\\n\"                    }\n  Not            = ast:x #:a #:b   -> { \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('FAIL', 'no match expected')\\n\"\n                                        \"LABEL(\" b \")\\n\"                     }\n  MatchCallRule  =                 -> { \"I('MATCH_CALL_RULE')\\n\"             }\n  Label          =                 -> { \"I('LABEL')\\n\"                       }\n  SemanticAction = ast:x           -> { \"I('ACTION', lambda scope: \" x \")\\n\" }\n  String         = py\n  List           = astList\n  Builder        = astItems:x      -> { \"_Builder.create([\" x \"])\"           }\n  IndentBuilder  =                 -> { \"_IndentBuilder()\"                   }\n  DedentBuilder  =                 -> { \"_DedentBuilder()\"                   }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                          }\n  VarLookup      = py:x            -> { \"scope[\" x \"].eval()\"                }\n  astItems       =\n    | ast:x astItem*:xs            -> { x xs                                 }\n    |                              -> {                                      }\n  astItem        = ast:x           -> { \", \" x                               }\n  astList        = astListItem*:xs -> { \"(\" xs \"[])\"                         }\n  astListItem    =\n    | [\"ListItemSplice\" ast:x]     -> {     x  \"+\"                           }\n    | ast:x                        -> { \"[\" x \"]+\"                           }\n  MatchRule      = py:x            -> { \"I('CALL', \" x \")\\n\"                 }\n  MatchRange     = py:x py:y       -> { \"I('MATCH_RANGE', \" x \", \" y \")\\n\"   }\n  MatchString    = py:x            -> { \"I('MATCH_STRING', \" x \")\\n\"         }\n  MatchCharseq   = py:x            -> { \"I('MATCH_CHARSEQ', \" x \")\\n\"        }\n  MatchAny       =                 -> { \"I('MATCH_ANY')\\n\"                   }\n  MatchList      = ast:x           -> { \"I('PUSH_STREAM')\\n\"\n                                        x\n                                        \"I('POP_STREAM')\\n\"                  }\n}\n",
"type":"code"
}
],
"id":"ba1fc285f5874989987cc7bb52ec1a6e",
"type":"code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"2d78cf2770f24b818ffcefa6216cb81c",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\ndef rlmeta_vm(instructions, labels, start_rule, stream):\n    label_counter = 0\n    last_action = _ConstantSemanticAction(None)\n    pc = labels[start_rule]\n    call_backtrack_stack = []\n    stream, pos, stream_pos_stack = (stream, 0, [])\n    scope, scope_stack = (None, [])\n    fail_message = None\n    latest_fail_message, latest_fail_pos = (None, tuple())\n    memo = {}\n    while True:\n        name, arg1, arg2 = instructions[pc]\n        if name == \"PUSH_SCOPE\":\n            scope_stack.append(scope)\n            scope = {}\n            pc += 1\n            continue\n        elif name == \"BACKTRACK\":\n            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))\n            pc += 1\n            continue\n        elif name == \"CALL\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"CALL"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"MATCH_CHARSEQ\":\n            for char in arg1:\n                if pos >= len(stream) or stream[pos] != char:\n                    fail_message = (\"expected {!r}\", char)\n                    break\n                pos += 1\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pc += 1\n                continue\n        elif name == \"COMMIT\":\n            call_backtrack_stack.pop()\n            pc = labels[arg1]\n            continue\n        elif name == \"POP_SCOPE\":\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"RETURN\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"RETURN"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"LIST_APPEND\":\n            scope.append(last_action)\n            pc += 1\n            continue\n        elif name == \"BIND\":\n            scope[arg1] = last_action\n            pc += 1\n            continue\n        elif name == \"ACTION\":\n            last_action = _UserSemanticAction(arg1, scope)\n            pc += 1\n            continue\n        elif name == \"MATCH_RANGE\":\n            if pos >= len(stream) or not (arg1 <= stream[pos] <= arg2):\n                fail_message = (\"expected range {!r}-{!r}\", arg1, arg2)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"LIST_START\":\n            scope_stack.append(scope)\n            scope = []\n            pc += 1\n            continue\n        elif name == \"LIST_END\":\n            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"MATCH_ANY\":\n            if pos >= len(stream):\n                fail_message = (\"expected any\",)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"PUSH_STREAM\":\n            if pos >= len(stream) or not isinstance(stream[pos], list):\n                fail_message = (\"expected list\",)\n            else:\n                stream_pos_stack.append((stream, pos))\n                stream = stream[pos]\n                pos = 0\n                pc += 1\n                continue\n        elif name == \"POP_STREAM\":\n            if pos < len(stream):\n                fail_message = (\"expected end of list\",)\n            else:\n                stream, pos = stream_pos_stack.pop()\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"MATCH_CALL_RULE\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"MATCH_CALL_RULE"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"FAIL\":\n            fail_message = (arg1,)\n        elif name == \"LABEL\":\n            last_action = _ConstantSemanticAction(label_counter)\n            label_counter += 1\n            pc += 1\n            continue\n        elif name == \"MATCH_STRING\":\n            if pos >= len(stream) or stream[pos] != arg1:\n                fail_message = (\"expected {!r}\", arg1)\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pos += 1\n                pc += 1\n                continue\n        else:\n            raise Exception(\"unknown instruction {}\".format(name))\n        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])\n        if fail_pos >= latest_fail_pos:\n            latest_fail_message = fail_message\n            latest_fail_pos = fail_pos\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"pop backtrack entries"
],
"prefix":"        ",
"type":"chunk"
},
{
"text":"        if len(call_backtrack_entry) != 4:\n            fail_pos = list(latest_fail_pos)\n            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream\n            while len(fail_pos) > 1:\n                fail_stream = fail_stream[fail_pos.pop(0)]\n            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)\n        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry\n        if len(stream_pos_stack) > stream_stack_len:\n            stream = stream_pos_stack[stream_stack_len][0]\n        stream_pos_stack = stream_pos_stack[:stream_stack_len]\n        if len(scope_stack) > scope_stack_len:\n            scope = scope_stack[scope_stack_len]\n        scope_stack = scope_stack[:scope_stack_len]\n\nclass _Grammar(object):\n\n    def run(self, rule_name, input_object):\n        if isinstance(input_object, basestring):\n            stream = input_object\n        else:\n            stream = [input_object]\n        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _ConstantSemanticAction(object):\n\n    def __init__(self, value):\n        self.value = value\n\n    def eval(self):\n        return self.value\n\nclass _UserSemanticAction(object):\n\n    def __init__(self, fn, scope):\n        self.fn = fn\n        self.scope = scope\n\n    def eval(self):\n        return self.fn(self.scope)\n\nclass _MatchError(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\n    def describe(self):\n        message = \"\"\n        if isinstance(self.stream, basestring):\n            before = self.stream[:self.pos].splitlines()\n            after = self.stream[self.pos:].splitlines()\n            for context_before in before[-4:-1]:\n                message += self._context(context_before)\n            message += self._context(before[-1], after[0])\n            message += self._arrow(len(before[-1]))\n            for context_after in after[1:4]:\n                message += self._context(context_after)\n        else:\n            message += self._context(\"[\")\n            for context_before in self.stream[:self.pos]:\n                message += self._context(\"  \", repr(context_before), \",\")\n            message += self._context(\"  \", repr(self.stream[self.pos]), \",\")\n            message += self._arrow(2)\n            for context_after in self.stream[self.pos+1:]:\n                message += self._context(\"  \", repr(context_after), \",\")\n            message += self._context(\"]\")\n        message += \"Error: \"\n        message += self.message[0].format(*self.message[1:])\n        message += \"\\n\"\n        return message\n\n    def _context(self, *args):\n        return \"> {}\\n\".format(\"\".join(args))\n\n    def _arrow(self, lenght):\n        return \"--{}^\\n\".format(\"-\"*lenght)\n",
"type":"code"
}
],
"id":"3233095b41404567872d7e190fb1ad66",
"type":"code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"c1f72e8df1ce4b619eeb30edf609e126",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"3ad80b7cb047456a89a9991cec9aa894",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"09b8983ad4194ac6a781880bd70117db",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"8fe0efd92f1b4fe4a24eca91003c68ed",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"5e20b8a3bc1348808c087c091612d9e0",
"paragraphs":[],
"title":"Code listings for RLMeta (VM)"
}
],
"id":"f4591956cea04b03be2859df337f261a",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta has a fatal flaw in its memoization logic. It only memoizes successful matches.",
"type":"text"
}
],
"id":"3a35c5393d0047a4b172fcce7438ef97",
"type":"text"
}
],
"title":"Memoizing failiures in RLMeta"
},
"variables":{}
}