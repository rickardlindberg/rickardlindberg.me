{
"root_page":{
"children":[
{
"children":[],
"id":"a83adf407dbd43929bfbb4ab7f7311e5",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  expr  = digit:x (op:y digit:z -> [y z])*:xs -> parseOps(x xs)\n  digit = '0'-'9':x                           -> int(x)\n  op    =\n    | '+' -> Op(makeNode(\"ADD\") 1 \"left\")\n    | '-' -> Op(makeNode(\"SUB\") 1 \"left\")\n    | '*' -> Op(makeNode(\"MUL\") 2 \"left\")\n    | '/' -> Op(makeNode(\"DIV\") 2 \"left\")\n    | '^' -> Op(makeNode(\"POW\") 3 \"right\")\n}\n",
"type":"code"
}
],
"id":"d3a45ae9dc0345bebfbf390d7247c39b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def makeNode(name):\n    def op(left, right):\n        return [name, left, right]\n    return op\n",
"type":"code"
}
],
"id":"d447ef7f73c3449a86562dc994bd14aa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class Op(object):\n\n    def __init__(self, fn, prec, assoc):\n        self.fn = fn\n        self.prec = prec\n        self.assoc = assoc\n",
"type":"code"
}
],
"id":"26892d627896439aa7b3080a02ad7ffa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def parseOps(expr, items, min_level=0):\n    while items and items[0][0].prec >= min_level:\n        op, rhs = items.pop(0)\n        if op.assoc == \"left\":\n            next_level = op.prec + 1\n        else:\n            next_level = op.prec\n        expr = op.fn(expr, parseOps(rhs, items, next_level))\n    return expr\n",
"type":"code"
}
],
"id":"0e3c33cbca0f4cb296429066f8a80146",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n9^5\n",
"type":"code"
}
],
"id":"a28c516d70f34a0395bb9904c5c379d1",
"post_process":[
"bash",
"compile.sh",
"parser"
],
"type":"code"
},
{
"code_id":"a28c516d70f34a0395bb9904c5c379d1",
"id":"137ce8857b5c4a8d8c38b74917c41504",
"type":"expanded_code"
}
],
"title":"Parser"
},
{
"children":[],
"id":"0488143f851349bf876169b04770e6bf",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"stackmachine.rlmeta"
],
"fragments":[
{
"text":"StackMachine {\n  expr =\n    | [.:name expr:left expr:right] -> [~left ~right [name]]\n    | .:leaf                        -> [[\"CONST\" leaf]]\n}\n",
"type":"code"
}
],
"id":"0fa99ac78bf24f558aecc3a4760c95bd",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"4598cfbceed64836b4c4ee934a90eed6",
"post_process":[
"bash",
"compile.sh",
"parser",
"stackmachine"
],
"type":"code"
},
{
"code_id":"4598cfbceed64836b4c4ee934a90eed6",
"id":"c17173be18e643c5889acd3b28796ca7",
"type":"expanded_code"
}
],
"title":"Stack machine"
},
{
"children":[],
"id":"bb76bbbba48d4c23b982e5c90af36d86",
"paragraphs":[
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"rsp",
"type":"code"
},
{
"text":" is the stack pointer",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"rbx",
"type":"code"
},
{
"text":" is a temporary register",
"type":"text"
}
]
}
],
"id":"b92e18b1c525415e9dc01876f3051269",
"type":"list"
},
{
"chunkpath":[],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"Assembly {\n  expr = [pre:x instr*:ys post:z] -> [~x ~~ys ~z]\n  pre = -> [\n    [\"section\" \"text\"]\n    [\"directive\" \"global _start\"]\n    [\"label\" \"_start\"]\n  ]\n  instr = [%:op] -> op\n  post = -> [\n    [\"mov\"      [\"addr\"  \"rsp\"] [\"reg\" \"rdi\"]]\n    [\"mov\"      [\"const\" 60   ] [\"reg\" \"rax\"]]\n    [\"syscall\"                               ]\n  ]\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"instructions"
],
"prefix":"  ",
"type":"chunk"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"82c7f0b301fe414daed3ccf01f1a3004",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"ADD = -> [\n  [\"pop\" [\"reg\"  \"rax\"]]\n  [\"add\" [\"reg\"  \"rax\"] [\"addr\" \"rsp\"]]\n]\n",
"type":"code"
}
],
"id":"3817c30ae29547c7ba43d4a09da383d7",
"language":"",
"post_process":[],
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"RHS is popped to ",
"type":"text"
},
{
"text":"rax",
"type":"code"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"LHS is on stack",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"add",
"type":"code"
},
{
"text":" does ",
"type":"text"
},
{
"text":"SP = SP + RHS",
"type":"code"
}
]
}
],
"id":"a33bf8e247204250a6b0f44ca61d38da",
"type":"list"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"SUB = -> [\n  [\"pop\" [\"reg\"  \"rax\"]               ]\n  [\"sub\" [\"reg\"  \"rax\"] [\"addr\" \"rsp\"]]\n]\n",
"type":"code"
}
],
"id":"617031f2a4cc49da98979cd4e4c323ce",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"MUL = -> [\n  [\"pop\"  [\"reg\"  \"rax\"]               ]\n  [\"imul\" [\"addr\" \"rsp\"] [\"reg\"  \"rax\"]]\n  [\"mov\"  [\"reg\"  \"rax\"] [\"addr\" \"rsp\"]]\n]\n",
"type":"code"
}
],
"id":"ba98b56127bb42d6b60fb57ad9385645",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"DIV = -> [\n  [\"pop\"  [\"reg\"   \"rbx\"]              ]\n  [\"pop\"  [\"reg\"   \"rax\"]              ]\n  [\"mov\"  [\"const\" 0    ] [\"reg\" \"edx\"]]\n  [\"idiv\" [\"reg\"   \"rbx\"]              ]\n  [\"push\" [\"reg\"   \"rax\"]              ]\n]\n",
"type":"code"
}
],
"id":"45560909864b48ebaeae6a9aebbfad2b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"POW = -> [\n  [\"f2xm1\" [\"reg\"  \"eax\"] [\"addr\" \"rsp\"]]\n]\n",
"type":"code"
}
],
"id":"becc0894c3de4a46b700eef621a53fb6",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"assembly.rlmeta"
],
"fragments":[
{
"text":"CONST = .:x -> [\n  [\"push\" [\"const\" x]]\n]\n",
"type":"code"
}
],
"id":"290c168cd42d4e5c943426482c99494a",
"language":"",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"TODO: how much does push push? 32-bit? 64-bit?",
"type":"strong"
},
{
"text":" Check with ",
"type":"text"
},
{
"text":"objdump -d a.out",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"9980269e129d4709a10bb7705fba1ab0",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"6cf60873293d4f8a815f29443ddd954c",
"post_process":[
"bash",
"compile.sh",
"parser",
"stackmachine",
"assembly"
],
"type":"code"
},
{
"code_id":"6cf60873293d4f8a815f29443ddd954c",
"id":"8852d3b4a5464870a71e4fabff92fb75",
"type":"expanded_code"
}
],
"title":"Assembly"
},
{
"children":[],
"id":"12e4e39c6b494b30a425f4570e8b8d53",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"gnu.rlmeta"
],
"fragments":[
{
"text":"GNU {\n  expr = [instr*:xs] -> { xs }\n  instr =\n    | [\"section\" .:x]              -> { \".\" x \"\\n\" }\n    | [\"directive\" .:x]            -> { \".\" x \"\\n\" }\n    | [\"label\" .:x]                -> { x \":\\n\" }\n    | [name:x op:source op:target] -> { x \"  \" source \",\" target \"\\n\" }\n    | [name:x op:arg]              -> { x \"  \" arg \"\\n\" }\n    | [name:x]                     -> { x \"\\n\" }\n  op =\n    | [\"reg\" .:name]    -> { \"%\" name     }\n    | [\"addr\" .:name]   -> { \"(%\" name \")\" }\n    | [\"const\" .:value] -> { \"$\" value    }\n  name = .:x -> pad(x)\n}\n",
"type":"code"
}
],
"id":"a3c752a8e4fc42cfbd6cfdf5bb8c2674",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def pad(text):\n    return text.ljust(7)\n",
"type":"code"
}
],
"id":"42da3457d2a9450bbb21aaccdf8398aa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1\n1+2*3\n",
"type":"code"
}
],
"id":"04e14524f1b34b6f940d0922a6bfc6f4",
"post_process":[
"bash",
"compile.sh",
"parser",
"stackmachine",
"assembly",
"gnu"
],
"type":"code"
},
{
"code_id":"04e14524f1b34b6f940d0922a6bfc6f4",
"id":"7857b19690284563bbdaff9437c5c454",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"Compile with ",
"type":"text"
},
{
"text":"gcc -nostdlib file.s",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"679dddb6aac04f20bdd82e14bab671ec",
"type":"text"
}
],
"title":"GNU"
},
{
"children":[],
"id":"d3ece5a4ba484033ac47d9190e513acd",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"assembler.rlmeta"
],
"fragments":[
{
"text":"Assembler {\n  expr = [instr*:xs]     -> [~~xs]\n  instr =\n    | [\"section\" .:x]    -> []\n    | [\"directive\" .:x]  -> []\n    | [\"label\" .:x]      -> []\n    | [%:x]              -> x\n  syscall =              -> [5]\n  push = const:x         -> [0x6a ensureByte(x)]\n  pop  = reg:r           -> [add(88 r)]\n  imul = addr:m reg:r    -> [m r]\n  add  = reg:r  addr:m   -> [r m]\n  mov  =\n    | addr:m  reg:r      -> [50 m r]\n    | reg:r   addr:m     -> [50 r m]\n    | const:i reg:r      -> [50 i]\n  const = [\"const\" .:i]  -> i\n  addr  = [\"addr\"  .:m]  -> m\n  reg   = [\"reg\" regn:r] -> r\n  regn =\n    | \"rax\" -> 0\n    | \"rdi\" -> 3\n}\n",
"type":"code"
}
],
"id":"e2ea2040aa4f453482e9d850f5205d2f",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def ensureByte(number):\n    if number > 0xFF:\n        raise ValueError(\"{} is larger than a byte\".format(number))\n    return number\n",
"type":"code"
}
],
"id":"4e6f7298b5f14801b348a78fb83ccbac",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def add(x, y):\n    return x + y\n",
"type":"code"
}
],
"id":"a30abe807d3f445c9d0d442000144030",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1\n1+2*3\n",
"type":"code"
}
],
"id":"1e52e522c9f34e49a3027204d14e43a7",
"post_process":[
"bash",
"compile.sh",
"parser",
"stackmachine",
"assembly",
"assembler"
],
"type":"code"
},
{
"code_id":"1e52e522c9f34e49a3027204d14e43a7",
"id":"984c9169bbe74c63b57cadbe6ff58061",
"type":"expanded_code"
}
],
"title":"Assembler"
},
{
"children":[],
"id":"ff74bacb76bf40f082f88738ebc5d8b0",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I use a version of RLMeta that builds upon the VM based version from ",
"type":"text"
},
{
"text":"memoizing failures",
"type":"link",
"url":"/writing/rlmeta-memoizing-failures/index.html"
},
{
"text":". I've made the following changes:",
"type":"text"
}
],
"id":"2908143610b545ef892af4cec6305282",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Added support for integers in semantic actions.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Support arbitrary many ",
"type":"text"
},
{
"text":"~",
"type":"code"
},
{
"text":".",
"type":"text"
}
]
}
],
"id":"81259246ed89412e90d42629b6c1017a",
"type":"list"
},
{
"fragments":[
{
"text":"I will not explain how I made those changes. The full source code is available on [github]().",
"type":"text"
}
],
"id":"c0afc230562e44a687569508fdc6449d",
"type":"text"
}
],
"title":"Appendix: RLMeta"
},
{
"children":[],
"id":"7790eca23f484ea7b7430ef607b491c2",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def main():\n    grammars = {\n        \"parser\": Parser(),\n        \"stackmachine\": StackMachine(),\n        \"assembly\": Assembly(),\n        \"gnu\": GNU(),\n        \"assembler\": Assembler(),\n    }\n    try:\n        for index, expr in enumerate(sys.stdin.read().splitlines()):\n            if index > 0:\n                print(\"\")\n                print(\"-\"*30)\n                print(\"\")\n            for grammar_name in sys.argv[1:]:\n                if grammar_name.startswith(\"@\"):\n                    with open(grammar_name[1:], \"w\") as f:\n                        f.write(str(expr))\n                    continue\n                grammar = grammars[grammar_name]\n                print_expr(expr)\n                print_box(grammar.__class__.__name__)\n                expr = grammar.run(\"expr\", expr)\n            print_expr(expr)\n    except _MatchError as e:\n        sys.stderr.write(e.describe())\n\ndef print_expr(expr):\n    if isinstance(expr, str):\n        print(expr.strip())\n    else:\n        pprint.pprint(expr, width=20)\n\ndef print_box(name):\n    HALF = 10\n    WIDTH = HALF*2+1\n    print(\"\")\n    print(\"{}V{}\".format(\"=\"*HALF, \"=\"*HALF))\n    print(name.center(WIDTH))\n    print(\"{}V{}\".format(\"=\"*HALF, \"=\"*HALF))\n    print(\"\")\n",
"type":"code"
}
],
"id":"f1d6ba61587e43a5878aff3bbdbf8cac",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"set -e\n\ncompile() {\n    echo \"import sys\"\n    echo \"import pprint\"\n    python rlmeta/rlmeta.py --support\n    cat \"support.py\"\n    python rlmeta/rlmeta.py < parser.rlmeta\n    python rlmeta/rlmeta.py < stackmachine.rlmeta\n    python rlmeta/rlmeta.py < assembly.rlmeta\n    python rlmeta/rlmeta.py < gnu.rlmeta\n    python rlmeta/rlmeta.py < assembler.rlmeta\n    echo \"main()\"\n}\n\npython <(compile) \"$@\"\n",
"type":"code"
}
],
"id":"3d82622d2bab436ebb7f6d53eefb985f",
"type":"code"
}
],
"title":"Appendix: Test script"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[],
"title":"Calculator to assembly"
},
"variables":{}
}