<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      High-level or micro-tests? A discussion with Ron. | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>High-level or micro-tests? A discussion with Ron.</h1>

<p><em>Published on 18 June 2023.</em></p>

<p>Ron and I have been discussing on Mastodon high-level vs micro-tests. Ron has summarized the discussion <a href="https://ronjeffries.com/articles/-y023/python/-m130/139/">here</a> and also expanded his thoughts on it. In this blog post, I want to expand my thoughts as well.</p>
<h1 id="how-it-started">How it started</h1>
<p>In <a href="https://ronjeffries.com/articles/-y023/python/-m130/136/">Python 136</a>, Ron discusses a possible drawback with the decentralized design:</p>
<blockquote>
<p>Now, many of my objects interact with missiles, the ship and saucer and asteroids at least, perhaps others. And so when I implemented the SaucerMissile, saucer missiles stopped interacting via <code>interact_with_missile</code> and started calling <code>interact_with_saucermissile</code>.</p>
<p>And that method is explicitly ignored unless the object implements it, i.e. unless the programmer, i.e. yours truly, remembers to implement the new method where it’s needed.</p>
<p>And I didn’t remember them all. I spent most of my article yesterday discovering another case that I had forgotten, and I was relying too much on my tests. They did help me at first but after a while, things were broken but no tests existed to show the problem.</p>
</blockquote>
<p>I interpret that (hopefully correctly) to mean something like this:</p>
<ol type="1">
<li><p>There are tests that call <code>asteroid.interact_with_missile</code> to verify behavior for asteroids colliding with missiles.</p></li>
<li><p>When the new missile subclass was added <code>interact_with_missile</code> was actually never called for real, but <code>interact_with_saucermissile</code> was called instead.</p></li>
<li><p>The tests that called <code>asteroids.interact_with_missile</code> continued to pass, but they tested something that never happened in reality.</p></li>
<li><p>All tests passed. The game was broken.</p></li>
</ol>
<p>To this, I <a href="https://hachyderm.io/@rickardlindberg/110549123416204580">replied</a>:</p>
<blockquote>
<p>What about writing domain/“game rule” tests at a higher level? That is, you put a bunch of flyers in the collection, call update (or whatever it was called), have the collection do all the interact_with_, and assert something on the collection.</p>
<p>Then you could more easily trust your tests and you are free to implement it however you want (implementation inheritance, events, etc).</p>
<p>I think such tests might even read quite well as descriptions of the game rules.</p>
</blockquote>
<p>Ron <a href="https://mastodon.social/@RonJeffries/110549805294230736">replied</a>:</p>
<blockquote>
<p>a good idea … with a centralized test there’s at least a place to look. Unfortunately such tests have to involve a lot of time stuff due to all the timers.</p>
</blockquote>
<p>And so the discussion about high-level tests vs micro-tests began.</p>
<h1 id="rons-arguments-for-micro-tests">Ron’s arguments for micro-tests</h1>
<p>Ron seems in favour of writing more micro-tests and fewer high-level tests. He argues that</p>
<blockquote>
<p>Certainly it must be true that if every object does the right thing at the right time, the program must work. This is the root reason why micro-testing works.</p>
</blockquote>
<p>I agree with this, and at the same time, I sometimes find it difficult to convince myself that every object does the right thing at the right time. Let me try to explain why.</p>
<h1 id="mocking">Mocking</h1>
<p>Mocking and micro-testing have something in common. (At least if you squint.) And that is that they are solitary-ish tests that focus on a very specific, isolated part of the code.</p>
<p>I will illustrate what I think is problematic with that with a calculator example that show the total on a display:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">class</span> Calculator:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, display):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span class="va">self</span>.display <span class="op">=</span> display</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>        <span class="va">self</span>.total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="kw">def</span> add(<span class="va">self</span>, amount):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="va">self</span>.total <span class="op">+=</span> amount</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>        <span class="va">self</span>.display.show(<span class="ss">f&quot;Total = </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>total<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="kw">class</span> Display:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    <span class="kw">def</span> show(<span class="va">self</span>, text):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>        <span class="co"># gui stuff to show something on the screen</span></span></code></pre></div>
<p>To test this, we might write one solitary test per class:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">def</span> test_calculator():</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    mock_display <span class="op">=</span> Mock(Display)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    calculator <span class="op">=</span> Calculator(mock_display)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    calculator.add(<span class="dv">3</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    calculator.add(<span class="dv">2</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="cf">assert</span> mock_display.show.calls <span class="op">=</span> [</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="st">&quot;Total = 3&quot;</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>        <span class="st">&quot;Total = 5&quot;</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    ]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="kw">def</span> test_display():</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    display <span class="op">=</span> Display()</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>    display.show(<span class="st">&quot;hello&quot;</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>    <span class="co"># assert that gui shows with text 'hello'</span></span></code></pre></div>
<p>These two tests prove that the whole works. But I find them a bit fragile. Especially in a dynamically typed language like Python.</p>
<p>What if we changed the signature of <code>show</code> to something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">def</span> show(<span class="va">self</span>, text, color):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    ...</span></code></pre></div>
<p><code>test_display</code> would break, but what about <code>test_calculator</code>? At least in Python, I don’t think the type checking is able to catch that the signature has changed. So <code>test_calculator</code> will continue to pass. But the application will not work.</p>
<p>The same thing is true for micro-testing. Your micro-tests can continue to pass, but the methods they are calling are actually not called for real.</p>
<p>This aspect of mocking and micro-testing makes me less confident that my code actually works.</p>
<h1 id="move-example">Move example</h1>
<p>Ron continues to discuss asteroid movement:</p>
<blockquote>
<p>… but I would argue that we don’t need a larger scale test to verify how they move.</p>
</blockquote>
<p>I don’t think so either. Movement is completely contained within an asteroid. It does not depend on interactions with other flyers. We could test it by instantiating an asteroid, calling its update method, and assert that it moved.</p>
<h1 id="missile-vs-asteroid-example">Missile vs asteroid example</h1>
<p>Ron continues to discuss another example where asteroids collide with missiles. He wish he had a test for scoring in that situation and writes this test:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">def</span> test_missile_vs_asteroid_scoring(<span class="va">self</span>):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    fleets <span class="op">=</span> Fleets()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    fi <span class="op">=</span> FI(fleets)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    pos <span class="op">=</span> Vector2(<span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    vel <span class="op">=</span> Vector2(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    asteroid <span class="op">=</span> Asteroid(<span class="dv">2</span>, pos)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    missile <span class="op">=</span> Missile.from_ship(pos, vel)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    asteroid.interact_with_missile(missile, fleets)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    scores <span class="op">=</span> fi.scores</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="cf">assert</span> scores[<span class="dv">0</span>].score <span class="op">==</span> u.MISSILE_SCORE_LIST[asteroid.size]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    asteroid.size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    asteroid.interact_with_missile(missile, fleets)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    scores <span class="op">=</span> fi.scores</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    <span class="cf">assert</span> scores[<span class="dv">1</span>].score <span class="op">==</span> u.MISSILE_SCORE_LIST[asteroid.size]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    asteroid.size <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    asteroid.interact_with_missile(missile, fleets)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    scores <span class="op">=</span> fi.scores</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    <span class="cf">assert</span> scores[<span class="dv">2</span>].score <span class="op">==</span> u.MISSILE_SCORE_LIST[asteroid.size]</span></code></pre></div>
<p>And notes that</p>
<blockquote>
<p>Now, since Rickard specifically mentions using interact_with in the tests he’s talking about, perhaps this is an example of just what he means. If that’s the case, we probably don’t have any real disagreement at all. That would be nice.</p>
</blockquote>
<p>I’m not sure I explained myself clearly enough on Mastodon. I will do another attempt here.</p>
<p>I would not call <code>interact_with_*</code> in tests. I would write the test above like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">def</span> test_missile_vs_asteroid_scoring_rickard(<span class="va">self</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="cf">for</span> asteroid_size <span class="kw">in</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        position <span class="op">=</span> Vector2(<span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        fleets <span class="op">=</span> Fleets()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        fleets.append(Asteroid(</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>            size<span class="op">=</span>asteroid_size,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>            position<span class="op">=</span>position</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>        ))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>        fleets.append(Missile.from_ship(</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>            position<span class="op">=</span>position,</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>            velocity<span class="op">=</span>Vector2(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>        ))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        fleets.perform_interactions()</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>        (score,) <span class="op">=</span> FI(fleets).scores</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>        <span class="cf">assert</span> score.score <span class="op">==</span> u.MISSILE_SCORE_LIST[asteroid_size]</span></code></pre></div>
<p>To be able to test scoring, we have to include both an asteroid and a missile in the test. To also make sure that they interact correctly, I would write the test by putting them in <code>Fleets</code> and have fleets <code>perform_interactions</code>.</p>
<blockquote>
<p>At this moment, I would ask Rickard whether he agrees that we can be sure that ship missile vs asteroid collisions score correctly. And if he said we cannot be sure, I’d try to devise another low-level test to help him be sure.</p>
</blockquote>
<p>With my version of the test above, I would be certain that scoring works. With Ron’s version, I would worry about the test calling the wrong <code>interact_with_*</code>. I would not worry that much, just a little. But I don’t think my version of the test has any drawbacks compared to Ron’s version. And it has the upside of verifying that interactions work properly.</p>
<p>I believe that the weakness of this implementation of a decentralized design is that it is difficult to know if you implemented the correct <code>interact_with_*</code> methods.</p>
<p>In Ron’s test, <code>interact_with_missile</code> is called explicitly. So it will not catch errors if the method should have been <code>interact_with_saucermissile</code> for example.</p>
<p>My version of the test is at a higher level. It puts an asteroid and a missile in the fleets and have them interact and assert that scoring happens correctly. Had we implemented the wrong <code>interact_with_*</code>, this test would have failed.</p>
<p>If I were to take a more micro-test approach to this, I would write multiple tests. First this one:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">def</span> test_missile_vs_asteroid_scoring_rickard_micro_high(<span class="va">self</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    position <span class="op">=</span> Vector2(<span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    fleets <span class="op">=</span> Fleets()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    fleets.append(Asteroid(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>        size<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        position<span class="op">=</span>position</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    ))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    fleets.append(Missile.from_ship(</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>        position<span class="op">=</span>position,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        velocity<span class="op">=</span>Vector2(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    ))</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    fleets.perform_interactions()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    (score,) <span class="op">=</span> FI(fleets).scores</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    <span class="cf">assert</span> score.score <span class="op">==</span> u.MISSILE_SCORE_LIST[<span class="dv">2</span>]</span></code></pre></div>
<p>This test ensures that the interactions work with regards to scoring. But it is only testing one score.</p>
<p>With that test in place, I feel pretty certain that <code>score_for_hitting</code> is called. I can read the code and see that the only way the score would be correct in the first test is if <code>score_for_hitting</code> is called.</p>
<p>To test that we get correct scores back, I therefore don’t think we need to test that via interactions, we can test it with a more lower-level, micro-test:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">def</span> test_missile_vs_asteroid_scoring_rickard_micro_low(<span class="va">self</span>):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="cf">for</span> asteroid_size <span class="kw">in</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>        position <span class="op">=</span> Vector2(<span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        <span class="cf">assert</span> Asteroid(</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>            size<span class="op">=</span>asteroid_size,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>            position<span class="op">=</span>position</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>        ).score_for_hitting(</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>            Missile.from_ship(</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>                position<span class="op">=</span>position,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>                velocity<span class="op">=</span>Vector2(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>            )</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>        ) <span class="op">==</span> u.MISSILE_SCORE_LIST[asteroid_size]</span></code></pre></div>
<p>This test has lots of irrelevant details though. The positions and velocity don’t matter, so it’s annoying to have to specify them. It makes the test harder to read. I would think about how I could refactor the code so that the test could read something like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">def</span> test_missile_vs_asteroid_scoring_rickard_micro_low(<span class="va">self</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">for</span> asteroid_size <span class="kw">in</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>        <span class="cf">assert</span> Asteroid(size<span class="op">=</span>asteroid_size).score_for_hitting(Missile.from_ship()) <span class="op">\</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>            <span class="op">==</span> u.MISSILE_SCORE_LIST[asteroid_size]</span></code></pre></div>
<p>This is overlapping, sociable testing. An approach I’ve started appreciating more and more over the last year or so.</p>
<p>The score for size 2 is tested in both tests. This might feel wrong to some people. It certainly did to me in the beginning. But what it gives me (and perhaps you as well) is greater confidence that stuff actually works. And that trade-off is something that I’ve started to appreciate.</p>
<h1 id="did-this-bring-clarity">Did this bring clarity?</h1>
<p>Ron writes:</p>
<blockquote>
<p>I should say right off the bat that you’ve seen everything that Rickard and I have shared on the subject, so there’s no reason to be certain that we’re even talking about the same kind of tests. I’m thinking that he means a big story test with all the objects in it and a long series of time ticks and checks on the game state throughout. He might be thinking of tests like the one I just wrote, or even simpler ones, with just a few objects and a few interactions, but more than one test. We may not disagree at all on that.</p>
</blockquote>
<p>I was thinking of a test like <code>test_missile_vs_asteroid_scoring_rickard</code>. You only put the objects that are needed for a particular interaction into fleets and have them interact.</p>
<p>I hope I managed to explain my thinking a bit more in this blog post. If it sounds like I say “you should do this because it is better” I apologize. My intention was to explain my current thinking and what I would do if I did it now. And as Ron pointed out, if we actually did this together, the end result would probably be something different.</p>
<h1 id="so-high-level-or-micro">So high-level or micro?</h1>
<blockquote>
<p>And if we got the code expressing each micro rule very clearly … would we still wonder about the bigger picture?</p>
</blockquote>
<p>I think the game rules will be quite clear with micro-tests only.</p>
<p>My concern with this implementation is mainly that it is difficult to write those correctly. (You have to implement and call the correct <code>interact_with_*</code>.) I think that my suggestion to write a higher-lever tests for interactions partly solves that problem.</p>
<p>If we can come up with a better scheme for this mechanism in Python, I might be less inclined to write high-level test.</p>
<p>But currently, I think I still like higher-level tests. At least some. I like overlapping, sociable tests. That means tests at many different levels. And if testing at a higher level is not inconvenient (it quickly becomes), I <em>think</em> I prefer that. First of all because it gives me greater confidence that the code works, and second because it allows refactoring without changing tests.</p>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
