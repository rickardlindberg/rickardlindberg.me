{
"root_page":{
"children":[
{
"children":[
{
"children":[],
"id":"9ce22f137e4a4bf3b4080f4803f3205d",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | space '#'                                -> [\"Label\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space charseq\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' formatExpr*:xs space '}'       -> [\"Format\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~'*:ys hostExpr:x                 -> [\"ListItem\" len(ys) x]\n  formatExpr =\n    | space '>' formatExpr*:xs space '<'       -> [\"Indent\" [\"Format\" ~xs]]\n    | hostExpr\n  charseq   = '\\'' (!'\\'' matchChar)*:xs '\\''  -> [\"And\" ~xs]\n  matchChar = innerChar:x                      -> [\"MatchObject\" x]\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> { xs }\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> { x xs }\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"5ad42c6a022f445daba3287b53c22701",
"language":"",
"type":"code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"af73e151e4a847e98832b2460fd43cc1",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n  ast            = [%:x]           -> x\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(Grammar):\\n\\n\" >\n                                          \"def assemble(self, I, LABEL):\\n\" >\n                                            ys\n                                          <\n                                        <                                    }\n  Rule           = py:x ast:y      -> { \"LABEL(\" x \")\\n\"\n                                        y\n                                        \"I('RETURN')\\n\"                      }\n  Or             =\n    | ast:x Or:y #:a #:b           -> { \"I('BACKTRACK', \" a \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" b \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        y\n                                        \"LABEL(\" b \")\\n\"                     }\n    | ast\n  Scope          = ast:x           -> { \"I('PUSH_SCOPE')\\n\"\n                                        x\n                                        \"I('POP_SCOPE')\\n\"                   }\n  And            = ast*\n  Bind           = py:x ast:y      -> { y\n                                        \"I('BIND', \" x \")\\n\"                 }\n  Star           = ast:x #:a #:b   -> { \"I('LIST_START')\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('LIST_APPEND')\\n\"\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" b \")\\n\"\n                                        \"I('LIST_END')\\n\"                    }\n  Not            = ast:x #:a #:b   -> { \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('FAIL', 'no match expected')\\n\"\n                                        \"LABEL(\" b \")\\n\"                     }\n  MatchCallRule  =                 -> { \"I('MATCH_CALL_RULE')\\n\"             }\n  Label          =                 -> { \"I('LABEL')\\n\"                       }\n  SemanticAction = ast:x           -> { \"I('ACTION', lambda scope: \" x \")\\n\" }\n  MatchRule      = py:x            -> { \"I('CALL', \" x \")\\n\"                 }\n  MatchRange     = py:x py:y       -> { \"I('MATCH_RANGE', \" x \", \" y \")\\n\"   }\n  MatchObject    = py:x            -> { \"I('MATCH_OBJECT', \" x \")\\n\"         }\n  MatchAny       =                 -> { \"I('MATCH_ANY')\\n\"                   }\n  MatchList      = ast:x           -> { \"I('PUSH_STREAM')\\n\"\n                                        x\n                                        \"I('POP_STREAM')\\n\"                  }\n  String         = py\n  List           = astItems:x      -> { \"concat([\" x \"])\"                    }\n  ListItem       = py:x ast:y      -> { \"splice(\" x \", \" y \")\"               }\n  Format         = astItems:x      -> { \"join([\" x \"])\"                      }\n  Indent         = ast:x           -> { \"indent(\" x \")\"                      }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                          }\n  VarLookup      = py:x            -> { \"scope[\" x \"].eval()\"                }\n  astItems       =\n    | ast:x astItem*:xs            -> { x xs                                 }\n    |                              -> {                                      }\n  astItem        = ast:x           -> { \", \" x                               }\n  py             = .:x             -> repr(x)\n}\n",
"type":"code"
}
],
"id":"98018c8fb01845719724306201926c0a",
"language":"",
"type":"code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"79d15a72ff31485ea0204c8f79d3a641",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def vm(instructions, labels, start_rule, stream):\n    label_counter = 0\n    action = SemanticAction(None)\n    pc = labels[start_rule]\n    call_backtrack_stack = []\n    stream, pos, stream_pos_stack = (stream, 0, [])\n    scope, scope_stack = (None, [])\n    fail_message = None\n    latest_fail_message, latest_fail_pos = (None, tuple())\n    memo = {}\n    while True:\n        name, arg1, arg2 = instructions[pc]\n        if name == \"PUSH_SCOPE\":\n            scope_stack.append(scope)\n            scope = {}\n            pc += 1\n            continue\n        elif name == \"BACKTRACK\":\n            call_backtrack_stack.append((\n                labels[arg1], pos, len(stream_pos_stack), len(scope_stack)\n            ))\n            pc += 1\n            continue\n        elif name == \"CALL\":\n            key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))\n            if key in memo:\n                if memo[key][0] is None:\n                    fail_message = memo[key][1]\n                else:\n                    action, stream_pos_stack = memo[key]\n                    stream_pos_stack = stream_pos_stack[:]\n                    stream, pos = stream_pos_stack.pop()\n                    pc += 1\n                    continue\n            else:\n                call_backtrack_stack.append((pc+1, key))\n                pc = labels[arg1]\n                continue\n        elif name == \"POP_SCOPE\":\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"MATCH_OBJECT\":\n            if pos >= len(stream) or stream[pos] != arg1:\n                fail_message = (\"expected {!r}\", arg1)\n            else:\n                action = SemanticAction(arg1)\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"COMMIT\":\n            call_backtrack_stack.pop()\n            pc = labels[arg1]\n            continue\n        elif name == \"RETURN\":\n            if len(call_backtrack_stack) == 0:\n                return action.eval()\n            pc, key = call_backtrack_stack.pop()\n            memo[key] = (action, stream_pos_stack+[(stream, pos)])\n            continue\n        elif name == \"LIST_APPEND\":\n            scope.append(action)\n            pc += 1\n            continue\n        elif name == \"BIND\":\n            scope[arg1] = action\n            pc += 1\n            continue\n        elif name == \"ACTION\":\n            action = SemanticAction(scope, arg1)\n            pc += 1\n            continue\n        elif name == \"MATCH_RANGE\":\n            if pos >= len(stream) or not (arg1 <= stream[pos] <= arg2):\n                fail_message = (\"expected range {!r}-{!r}\", arg1, arg2)\n            else:\n                action = SemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"LIST_START\":\n            scope_stack.append(scope)\n            scope = []\n            pc += 1\n            continue\n        elif name == \"LIST_END\":\n            action = SemanticAction(scope, lambda xs: [x.eval() for x in xs])\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"MATCH_ANY\":\n            if pos >= len(stream):\n                fail_message = (\"expected any\",)\n            else:\n                action = SemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"PUSH_STREAM\":\n            if pos >= len(stream) or not isinstance(stream[pos], list):\n                fail_message = (\"expected list\",)\n            else:\n                stream_pos_stack.append((stream, pos))\n                stream = stream[pos]\n                pos = 0\n                pc += 1\n                continue\n        elif name == \"POP_STREAM\":\n            if pos < len(stream):\n                fail_message = (\"expected end of list\",)\n            else:\n                stream, pos = stream_pos_stack.pop()\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"MATCH_CALL_RULE\":\n            if pos >= len(stream):\n                fail_message = (\"expected any\",)\n            else:\n                fn_name = str(stream[pos])\n                key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))\n                if key in memo:\n                    if memo[key][0] is None:\n                        fail_message = memo[key][1]\n                    else:\n                        action, stream_pos_stack = memo[key]\n                        stream_pos_stack = stream_pos_stack[:]\n                        stream, pos = stream_pos_stack.pop()\n                        pc += 1\n                        continue\n                else:\n                    call_backtrack_stack.append((pc+1, key))\n                    pc = labels[fn_name]\n                    pos += 1\n                    continue\n        elif name == \"FAIL\":\n            fail_message = (arg1,)\n        elif name == \"LABEL\":\n            action = SemanticAction(label_counter)\n            label_counter += 1\n            pc += 1\n            continue\n        else:\n            raise Exception(\"unknown instruction {}\".format(name))\n        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])\n        if fail_pos >= latest_fail_pos:\n            latest_fail_message = fail_message\n            latest_fail_pos = fail_pos\n        call_backtrack_entry = tuple()\n        while call_backtrack_stack:\n            call_backtrack_entry = call_backtrack_stack.pop()\n            if len(call_backtrack_entry) == 4:\n                break\n            else:\n                _, key = call_backtrack_entry\n                memo[key] = (None, fail_message)\n        if len(call_backtrack_entry) != 4:\n            raise MatchError(\n                latest_fail_message[0].format(*latest_fail_message[1:]),\n                latest_fail_pos,\n                stream_pos_stack[0][0] if stream_pos_stack else stream\n            )\n        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry\n        if len(stream_pos_stack) > stream_stack_len:\n            stream = stream_pos_stack[stream_stack_len][0]\n        stream_pos_stack = stream_pos_stack[:stream_stack_len]\n        if len(scope_stack) > scope_stack_len:\n            scope = scope_stack[scope_stack_len]\n        scope_stack = scope_stack[:scope_stack_len]\n\nclass SemanticAction(object):\n\n    def __init__(self, value, fn=lambda value: value):\n        self.value = value\n        self.fn = fn\n\n    def eval(self):\n        return self.fn(self.value)\n\nclass MatchError(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\nclass Grammar(object):\n\n    def run(self, rule_name, stream):\n        instructions = []\n        labels = {}\n        def I(name, arg1=None, arg2=None):\n            instructions.append((name, arg1, arg2))\n        def LABEL(name):\n            labels[name] = len(instructions)\n        self.assemble(I, LABEL)\n        return vm(instructions, labels, rule_name, stream)\n\ndef splice(depth, item):\n    if depth == 0:\n        return [item]\n    else:\n        return concat([splice(depth-1, subitem) for subitem in item])\n\ndef concat(lists):\n    return [x for xs in lists for x in xs]\n\ndef join(items):\n    return \"\".join(\n        join(item) if isinstance(item, list) else str(item)\n        for item in items\n    )\n\ndef indent(text):\n    return join(join([\"    \", line]) for line in text.splitlines(True))\n",
"type":"code"
}
],
"id":"d2549d686eb344199b32987ab1f45eff",
"language":"",
"type":"code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"7142a9c9c93e4aa2aaf35c7962eb3c88",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$1\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\nimport pprint\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(\n                CodeGenerator().run(\n                    \"ast\",\n                    [Parser().run(\"grammar\", sys.stdin.read())]\n                )\n            )\n        except MatchError as e:\n            stream = e.stream\n            for pos in e.pos[:-1]:\n                stream = stream[pos]\n            pos = e.pos[-1]\n            MARKER = \"\\\\033[0;31m<ERROR POSITION>\\\\033[0m\"\n            if isinstance(stream, basestring):\n                stream_string = stream[:pos] + MARKER + stream[pos:]\n            else:\n                stream_string = pprint.pformat(stream)\n            sys.exit(\"ERROR: {}\\\\nPOSITION: {}\\\\nSTREAM:\\\\n{}\".format(\n              e.message,\n              pos,\n              indent(stream_string)\n            ))\nEOF\n",
"type":"code"
}
],
"id":"76749a4bf2c446069218a8573568dc2b",
"language":"",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"8c47ff964a3f43a29a4413bbf5b0132d",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\necho \"Test: Reproduces itself\"\ndiff rlmeta2.py rlmeta3.py\n\necho \"Test: Has its own support library embedded\"\ndiff support.py <(python rlmeta3.py --support)\n\necho \"Test: Error reporting string input\"\necho \"Grammar { foo = . \" | python rlmeta3.py && false\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho \"OK\"\n",
"type":"code"
}
],
"id":"93ea6d553d104afdb03637cee08213f9",
"language":"",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"730eea3f33b24e07b3714ef4c1981fd1",
"paragraphs":[
{
"fragments":[
{
"text":"The code here is exactly the same as in the poster. The ",
"type":"text"
},
{
"text":"meta_compile.sh",
"type":"code"
},
{
"text":" script is not shown in the poster since it is not strictly part of the implementation. It is more of a developer tool.",
"type":"text"
}
],
"id":"de3f4b2b8eec4e45a64ac2d13bde7f4a",
"type":"text"
}
],
"title":"Code listings for RLMeta"
}
],
"id":"41705a9531784b16b88f363b083897d9",
"paragraphs":[
{
"fragments":[
{
"text":"The poster was made from the VM based version from ",
"type":"text"
},
{
"text":"memoizing failures article",
"type":"link",
"url":"/writing/rlmeta-memoize-failures/index.html"
},
{
"text":". The following changes were made to it:",
"type":"text"
}
],
"id":"bf332aae28be4825bc7dd3ed7e85f4f6",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Assemble function in support",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Replace builder with join/indent",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Let compile.sh do error reporting (support only gives information)",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Compact and modify formatting to better suit poster",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Only one semantic action class",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"charseq -> and + match object",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Remove string matching",
"type":"text"
}
]
}
],
"id":"027f957efe60470ca9e594bdd72a80b3",
"type":"list"
},
{
"fragments":[
{
"text":"Things that still annoy me with the poster version that I left:",
"type":"text"
}
],
"id":"60f0a5b3e966470ebbd6bed796f2e6ea",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Assembly hard to read (not sure how to improve it)",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Counter is incremented at match time, not at eval time (leave it for now)",
"type":"text"
}
]
}
],
"id":"43e751fe8b954b33a6ee5c96dc9dc523",
"type":"list"
},
{
"fragments":[
{
"text":"Things that would make the code even smaller to fit better on a poster:",
"type":"text"
}
],
"id":"beda93e0d1f2428ab449261e3fff0c58",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Macro language for creating VMs in Python",
"type":"text"
}
]
}
],
"id":"ce5b2afa6f2948aeb4c2fb00a29cbdfb",
"type":"list"
}
],
"title":"RLMeta poster"
},
"variables":{}
}