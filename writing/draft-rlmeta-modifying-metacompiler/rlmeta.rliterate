{
"root_page":{
"children":[
{
"children":[],
"id":"39efe623ff374daba9830984300fcde2",
"paragraphs":[
{
"fragments":[
{
"text":"I was unable to find a clear definition, so the following is my best attempt at one.",
"type":"emphasis"
}
],
"id":"61b6156f27d942da86ba13c23813eb55",
"type":"text"
},
{
"fragments":[
{
"text":"A metacompiler is a compiler that can reproduce itself from a description written in a metalanguage. A metalanguage is a domain specific language for describing the syntax and semantics of languages.",
"type":"text"
}
],
"id":"528a58686ce442d79e1b367408fe944c",
"type":"text"
},
{
"fragments":[
{
"text":"A regular compiler transforms source code into an executable:",
"type":"text"
}
],
"id":"e192774e5eeb495589a7021b6f8f4d88",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> compiler -> executable\n",
"type":"code"
}
],
"id":"84b2d2ffe1b641c388d7f834af5e427b",
"type":"code"
},
{
"fragments":[
{
"text":"A metacompiler transforms source code into itself (given that the source code is the source code for the metacompiler):",
"type":"text"
}
],
"id":"05285271f1cc494ca90f7d3d9a1dcd91",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> metacompiler -----\n               ^           |\n               |           |\n               -------------\n",
"type":"code"
}
],
"id":"af656248fc3845cfab5327911291fb11",
"type":"code"
},
{
"fragments":[
{
"text":"A C compiler written in C is not a metacompiler because C is not a metalanguage. It is a general purpose programming language not designed specifically to describe other languages. Such compiler is merely a self-hosting compiler.",
"type":"text"
}
],
"id":"68a70728549c41478d8110b0248c678c",
"type":"text"
}
],
"title":"What is a metacompiler?"
},
{
"children":[],
"id":"bf2e6a99e41f478f884dd15ea243c111",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta is compiled with the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. It takes one argument which is the path to the RLMeta compiler. The script uses that compiler to compile the source files and then assemble the final Python file which looks liek this:",
"type":"text"
}
],
"id":"22f617b9696f41d68c4ddeb7889d94c5",
"type":"text"
},
{
"chunkpath":[
"rlmeta template"
],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"import sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\n",
"type":"code"
}
],
"id":"cab1f5d6d3c0412696419fd2f8c0ab88",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The variables ",
"type":"text"
},
{
"text":"$support_py",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"$parser_py",
"type":"code"
},
{
"text":", and ",
"type":"text"
},
{
"text":"$codegenerator_py",
"type":"code"
},
{
"text":" are produced by the RLMeta compiler passed in as argument to the script. ",
"type":"text"
},
{
"text":"$support_py_string",
"type":"code"
},
{
"text":" is produced by converting the support library to a Python string. Here is the full compile.sh script:",
"type":"text"
}
],
"id":"ac4e4f2a863f48e4a82eddbc322b4d54",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"rlmeta template"
],
"prefix":"",
"type":"chunk"
},
{
"text":"EOF\n",
"type":"code"
}
],
"id":"ef234944361c48eeb16387d8014a4c9b",
"type":"code"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"is_metacompiler.sh",
"type":"code"
},
{
"text":" script checks if a given file is an RLMeta metacompiler. It does it by comparing the file to the file generated by the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. If they are equal the file is an RLMeta metacompiler because it reproduced itself exactly. Otherwise the two files differ.",
"type":"text"
}
],
"id":"734c020ee59a4446a84baeeab3e5c655",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"is_metacompiler.sh"
],
"fragments":[
{
"text":"if diff $1 <(./compile.sh $1); then\n    echo \"$1 is a metacompiler!\"\nelse\n    echo \"$1 is not a metacompiler. See diff above.\"\nfi\n",
"type":"code"
}
],
"id":"51c75af0347d416181ffec8cab1f0c51",
"type":"code"
},
{
"fragments":[
{
"text":"RLMeta is a metacompiler because its source code is written in a metalanguage and it is able to reproduce itself.",
"type":"text"
}
],
"id":"d86dd49a17e94d2694bedd68c178a028",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\nrlmeta.py is a metacompiler!\n",
"type":"code"
}
],
"id":"8e96b580ce5c4ed2bc67997925bc1117",
"type":"code"
}
],
"title":"Compiling RLMeta"
},
{
"children":[],
"id":"93d9030e0e4849c5a8d8ca0fffdf7592",
"paragraphs":[
{
"fragments":[
{
"text":"In general, to modify a program written in a compiled language, its source code and a compiler is needed. The compiler transforms the source code into an executable. Modifying the executable is a matter of modifying the source code and compiling it.",
"type":"text"
}
],
"id":"e0a64299fcfa4b19ab466704dee628e3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> compiler -> executable\n",
"type":"code"
}
],
"id":"70809fbb4dbe4f6f8cdff0d0d498525c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> compiler -> modified executable\n",
"type":"code"
}
],
"id":"71dcb5f5a51742f5b5e3e05c2d14919c",
"type":"code"
},
{
"fragments":[
{
"text":"In the case of a metacompiler, the compiler and the executable is exactly the same. However, if the source code is changed, the executable might no longer be the metacompiler itself.",
"type":"text"
}
],
"id":"5e43207a89814de58fe844c511df67f9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> metacompiler -> metacompiler\n",
"type":"code"
}
],
"id":"97d5e02aa4cc445188c5b5ab1a065def",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> metacompiler -> ???\n",
"type":"code"
}
],
"id":"3c6356572e66461995dbbc5d6ed0c38d",
"type":"code"
},
{
"fragments":[
{
"text":"At this point, the source code for the metacompiler is \"lost\" because there is no way to reproduce the metacompiler from the modified source code.",
"type":"text"
}
],
"id":"9aca2d8b77714269915348220a80b2f3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> ??? -> metacompiler\n",
"type":"code"
}
],
"id":"eab099f879994d5b95b8a19b8fb103c6",
"type":"code"
},
{
"fragments":[
{
"text":"When making changes to a metacompiler, care has to be taken to ensure that, in the end, the executable is still a metacompiler. This is a key difference from modifying a regular program. (When modifying a self-hosting compiler similar care has to be taken.)",
"type":"text"
}
],
"id":"c363ade479ef4a0cb62a455a36b802c5",
"type":"text"
},
{
"fragments":[
{
"text":"The following sections explain how to make changes to RLMeta that ensure that the modified version is still a metacompiler.",
"type":"text"
}
],
"id":"d21afc4f5e604e78b978a9ff65b73c3f",
"type":"text"
}
],
"title":"Modifying a metacompiler"
},
{
"children":[],
"id":"5f6a1c91143146dbb3b865ac42562135",
"paragraphs":[
{
"fragments":[
{
"text":"The code generator in RLMeta generates lambda expressions with newlines and indentation:",
"type":"text"
}
],
"id":"c5cf0946f71647f687176d66e5e4fb2f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    ...\n)\n",
"type":"code"
}
],
"id":"cc11caffc9884033bff44020b3fa3632",
"type":"code"
},
{
"fragments":[
{
"text":"The additional punctuation might not make the generated code more readable and it takes longer to generate. It might therefore be desirable to generate equivalents lambda expressions without the additional punctuation:",
"type":"text"
}
],
"id":"72a9d99eed5349d587fd9d5d49145541",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda: ...)\n",
"type":"code"
}
],
"id":"b7c19d3dc91340c5aa0de1cb3ccd3c86",
"type":"code"
},
{
"fragments":[
{
"text":"This is achieved by changing the following line in the code generator",
"type":"text"
}
],
"id":"c73514c15f9749a29e5d070423aee716",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| astFnBody:x -> { \"(lambda:\\n\" > x < \"\\n)\" }\n",
"type":"code"
}
],
"id":"75962a34bc124422840c608c5ce11574",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"to",
"type":"text"
}
],
"id":"971eabd00f6143428fe06553074e4cb8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| astFnBody:x -> { \"(lambda: \" x \")\" }\n",
"type":"code"
}
],
"id":"00aa8eafb77042e58c86e630149b9d27",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"With this change, ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" is no longer a metacompiler because the resulting file, ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":", differs from ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"c16df5bc53fc422796deaf081c25ae8b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"7a6b856affa54cc4bdb62fd5a0b4f137",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"9fd7d26ae6d54fcaa6d64a5739f6cf36",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\n1685,1686c1685\n<                                         '(lambda:\\n',\n<                                         _IndentBuilder(),\n---\n>                                         '(lambda:',\n1688,1689c1687\n<                                         _DedentBuilder(),\n<                                         '\\n)',\n---\n>                                         ')',\nrlmeta.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"90cf5d9eca604cd8becd3e9feca345dc",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"The difference is that the code for generating lambda expressions is different. The generated file should still be a compiler that recognizes the same source language so it can be checked if it is a metacompiler.",
"type":"text"
}
],
"id":"fde362e72d364e7a8698cca2495fadfe",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"d9e1b2a1b8484b6ba4122794a3df0e20",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta1.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"3e4fe4aad7c94c40a8dfb0c6476e32b5",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\n287,325c287,299\n<         return (lambda:\n<             self._or([\n<                 (lambda:\n<                     (lambda _vars:\n<                         (lambda:\n<                             self._and([\n<                                 (lambda:\n<                                     _vars.bind('x', (lambda:\n<                                         self._match_rule('name')\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('{')\n<                                 ),\n<                                 (lambda:\n<                                     _vars.bind('ys', (lambda:\n<                                         self._star((lambda:\n<                                             self._match_rule('rule')\n<                                         ))\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('}')\n<                                 ),\n<                                 (lambda:\n<                                     _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))\n<                                 ),\n<                             ])\n<                         )()\n<                     )(_Vars())\n<                 ),\n<             ])\n<         )()\n---\n>         return (lambda: self._or([\n>             (lambda: (lambda _vars:\n>                 (lambda: self._and([\n>                     (lambda: _vars.bind('x', (lambda: self._match_rule('name'))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('{')),\n>                     (lambda: _vars.bind('ys', (lambda: self._star((lambda: self._match_rule('rule'))))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('}')),\n>                     (lambda: _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))),\n>                 ]))()\n>             )(_Vars())),\n>         ]))()\n...\nrlmeta1.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"27880ff33fae4aafa40bd977cc4cd0c4",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"Enter text here...",
"type":"text"
}
],
"id":"8719ed6b7ab14ef59c9f71e6dc80059a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta2.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"220782c1b04d44718525cae19adfc70b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta2.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"3c22d9fe73f4464db6905289eb5cd0e6",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta2.py\nrlmeta2.py is a metacompiler!\n",
"type":"code"
}
],
"id":"02c659d8ee7e4f9797fb9ca93a1fa1a4",
"type":"code"
},
{
"fragments":[
{
"text":"This means that ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" is a metacompiler. The compiler that rlmeta2.py produces is exactly the same as itself. ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" can be discarded and ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" becomes the new ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"6b890adad1964ae9b928a7531d2c1793",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta2.py -> rlmeta2.py\n                 |\n                 V\n   source -> rlmeta.py -> rlmeta.py\n\n",
"type":"code"
}
],
"id":"342281e2e7b1449d98a0453c8ccd2076",
"type":"code"
},
{
"fragments":[
{
"text":"We now have a new metacompiler that generates code slightly different, but the metacompiler property still holds.",
"type":"text"
}
],
"id":"13f5b9ccbb0844468d99fbb40212672d",
"type":"text"
}
],
"title":"Changing code generator"
},
{
"children":[],
"id":"0130b76cb3d24f458bb47debb6fc2780",
"paragraphs":[
{
"fragments":[
{
"text":"Explain how bug was fixed.",
"type":"text"
}
],
"id":"a7b2bbcc13a9431da6c2fbb3c4c9ec41",
"type":"text"
},
{
"fragments":[
{
"text":"Generate support.py from compiler instead of from source.",
"type":"text"
}
],
"id":"0b7839572c9940dabc0e4afe5343ab9b",
"type":"text"
}
],
"title":"Changing support library"
},
{
"children":[],
"id":"22e574102e394218b874f03bb879c92f",
"paragraphs":[
{
"fragments":[
{
"text":"Changing syntax in steps: 1) modify grammar to accept new syntax 2) feed updated grammar to new compiler.",
"type":"text"
}
],
"id":"73adf0902f014946b6a0b1812588ef8c",
"type":"text"
}
],
"title":"Changing grammar syntax"
},
{
"children":[],
"id":"d54bbeda3d9846bca027f2c2995775a5",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"bd7e31bf3ea7456f975830d5bf2ef05c",
"type":"code"
},
{
"fragments":[
{
"text":"Only changes from original RLMeta is the compile.sh script. Full sources on github.",
"type":"text"
}
],
"id":"969153820b334d91838f46bfd52388ad",
"type":"text"
}
],
"title":"Code listings for RLMeta"
}
],
"id":"7b987f7cd685486da72bf77dcd0b3f29",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I explain how to modify the RLMeta metacompiler and how modifying a metacompiler is different from modifying a regular program.",
"type":"text"
}
],
"id":"4d967f1bcd054206b4731c141ff9822a",
"type":"text"
}
],
"title":"Modifying RLMeta"
},
"variables":{}
}