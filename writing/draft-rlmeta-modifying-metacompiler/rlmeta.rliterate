{
"root_page":{
"children":[
{
"children":[],
"id":"39efe623ff374daba9830984300fcde2",
"paragraphs":[
{
"fragments":[
{
"text":"A general compiler translates source code into an executable:",
"type":"text"
}
],
"id":"e192774e5eeb495589a7021b6f8f4d88",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> compiler -> executable\n",
"type":"code"
}
],
"id":"84b2d2ffe1b641c388d7f834af5e427b",
"type":"code"
},
{
"fragments":[
{
"text":"A C compiler translates source code written in C code into an executable:",
"type":"text"
}
],
"id":"247442defad9486dbbc00a80a7ba5853",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"C source -> C compiler -> executable\n",
"type":"code"
}
],
"id":"9637925d22dd4794906e11a82c0979e0",
"type":"code"
},
{
"fragments":[
{
"text":"A metacompiler translates source code written in a metalanguage into an executable:",
"type":"text"
}
],
"id":"dda8f4fc2f004d3fb52fe16672790891",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"metalanguage source -> metacompiler -> executable\n",
"type":"code"
}
],
"id":"37c8ccef5d884282b288faeed4eb687b",
"type":"code"
},
{
"fragments":[
{
"text":"A metalanguage is a domain specific language for describing other languages. It can be used to describe what languages look like (their syntax) and how to translate them into executables (their semantics). In essence, it can be used to describe compilers.",
"type":"text"
}
],
"id":"2ae1792b33f04c3cb643d28db004a5f9",
"type":"text"
},
{
"fragments":[
{
"text":"Because a metalanguage can be used to describe any compiler, it can also be used describe the metacompiler itself. The metacompiler translates such a description into itself:",
"type":"text"
}
],
"id":"05285271f1cc494ca90f7d3d9a1dcd91",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> metacompiler -----\n               ^           |\n               |           |\n               -------------\n",
"type":"code"
}
],
"id":"406f320e489544f0adac76714322286b",
"type":"code"
},
{
"fragments":[
{
"text":"A C compiler written in C is not a metacompiler because C is not a metalanguage. It is a general purpose programming language not designed specifically to describe other languages. Such compiler is merely a self-hosting compiler.",
"type":"text"
}
],
"id":"68a70728549c41478d8110b0248c678c",
"type":"text"
},
{
"fragments":[
{
"text":"A metacompiler does not necessarily have to be implemented in the metalanguage itself, but I suspect that it is common that they are. RLMeta is. META II is. For the rest of this article, I will assume that a metacompiler is also self-hosting.",
"type":"text"
}
],
"id":"bc611e48de17497caa0a20eaa7664dba",
"type":"text"
}
],
"title":"What is a metacompiler?"
},
{
"children":[],
"id":"93d9030e0e4849c5a8d8ca0fffdf7592",
"paragraphs":[
{
"fragments":[
{
"text":"In general, to modify a program written in a compiled language, its source code and a compiler is needed. Modifying the program is a matter of modifying the source code and compiling it.",
"type":"text"
}
],
"id":"e0a64299fcfa4b19ab466704dee628e3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> compiler -> executable\n",
"type":"code"
}
],
"id":"70809fbb4dbe4f6f8cdff0d0d498525c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> compiler -> modified executable\n",
"type":"code"
}
],
"id":"71dcb5f5a51742f5b5e3e05c2d14919c",
"type":"code"
},
{
"fragments":[
{
"text":"In the case of a metacompiler, the compiler and the executable is exactly the same. However, if the source code is changed, the executable might not be the metacompiler itself.",
"type":"text"
}
],
"id":"5e43207a89814de58fe844c511df67f9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> metacompiler -----\n               ^           |\n               |           |\n               -------------\n",
"type":"code"
}
],
"id":"95da99c68a514e7f998882cb40da5e9f",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> metacompiler -> ???\n",
"type":"code"
}
],
"id":"3c6356572e66461995dbbc5d6ed0c38d",
"type":"code"
},
{
"fragments":[
{
"text":"At this point, the metacompiler is needed to keep maintaining the new executable. Also, the source code for the metacompiler is \"lost\" because the metacompiler can not be reproduced from the modified source code.",
"type":"text"
}
],
"id":"9aca2d8b77714269915348220a80b2f3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> ??? -> metacompiler\n",
"type":"code"
}
],
"id":"eab099f879994d5b95b8a19b8fb103c6",
"type":"code"
},
{
"fragments":[
{
"text":"Because there is no source code, the original metacompiler can not be modified either. A binary must be kept around.",
"type":"text"
}
],
"id":"52e85832ecd94b3cac6f44a322e61e51",
"type":"text"
},
{
"fragments":[
{
"text":"When making changes to a metacompiler, care has to be taken to ensure that, in the end, the executable is still a metacompiler. This is a key difference from modifying a regular program. (Similar care has to be taken when modifying a self-hosting compiler.)",
"type":"text"
}
],
"id":"c363ade479ef4a0cb62a455a36b802c5",
"type":"text"
}
],
"title":"Modifying a metacompiler"
},
{
"children":[],
"id":"bf2e6a99e41f478f884dd15ea243c111",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta is compiled with the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. It takes one argument which is the path to the RLMeta compiler. The script uses that compiler to compile the source files and then assemble the output to a Python file which looks like this:",
"type":"text"
}
],
"id":"22f617b9696f41d68c4ddeb7889d94c5",
"type":"text"
},
{
"chunkpath":[
"rlmeta template"
],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"import sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\n",
"type":"code"
}
],
"id":"cab1f5d6d3c0412696419fd2f8c0ab88",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The variables ",
"type":"text"
},
{
"text":"$support_py",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"$parser_py",
"type":"code"
},
{
"text":", and ",
"type":"text"
},
{
"text":"$codegenerator_py",
"type":"code"
},
{
"text":" are produced by the RLMeta compiler. The variable ",
"type":"text"
},
{
"text":"$support_py_string",
"type":"code"
},
{
"text":" is produced by converting the support library to a Python string. Here is the rest of the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script:",
"type":"text"
}
],
"id":"ac4e4f2a863f48e4a82eddbc322b4d54",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"rlmeta template"
],
"prefix":"",
"type":"chunk"
},
{
"text":"EOF\n",
"type":"code"
}
],
"id":"ef234944361c48eeb16387d8014a4c9b",
"type":"code"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"is_metacompiler.sh",
"type":"code"
},
{
"text":" script checks if a given file is a metacompiler. It does so by comparing the file to the file generated by the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. If they are equal the file is a metacompiler because it reproduced itself exactly. Otherwise the two files differ.",
"type":"text"
}
],
"id":"734c020ee59a4446a84baeeab3e5c655",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"is_metacompiler.sh"
],
"fragments":[
{
"text":"if diff $1 <(./compile.sh $1); then\n    echo \"$1 is a metacompiler!\"\nelse\n    echo \"$1 is not a metacompiler. See diff above.\"\nfi\n",
"type":"code"
}
],
"id":"51c75af0347d416181ffec8cab1f0c51",
"type":"code"
},
{
"fragments":[
{
"text":"RLMeta is a metacompiler because its source code is written in a metalanguage and it is able to reproduce itself.",
"type":"text"
}
],
"id":"d86dd49a17e94d2694bedd68c178a028",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\nrlmeta.py is a metacompiler!\n",
"type":"code"
}
],
"id":"8e96b580ce5c4ed2bc67997925bc1117",
"type":"code"
},
{
"fragments":[
{
"text":"The following sections explain how to make changes to RLMeta that ensure that the modified version is still a metacompiler.",
"type":"text"
}
],
"id":"d21afc4f5e604e78b978a9ff65b73c3f",
"type":"text"
}
],
"title":"Compiling RLMeta"
},
{
"children":[],
"id":"5f6a1c91143146dbb3b865ac42562135",
"paragraphs":[
{
"fragments":[
{
"text":"The code generator in RLMeta generates lambda expressions with newlines and indentation:",
"type":"text"
}
],
"id":"c5cf0946f71647f687176d66e5e4fb2f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    ...\n)\n",
"type":"code"
}
],
"id":"cc11caffc9884033bff44020b3fa3632",
"type":"code"
},
{
"fragments":[
{
"text":"It might be desirable to instead generate equivalent lambda expressions without the additional punctuation because it is faster and does not make the code less readable:",
"type":"text"
}
],
"id":"72a9d99eed5349d587fd9d5d49145541",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda: ...)\n",
"type":"code"
}
],
"id":"b7c19d3dc91340c5aa0de1cb3ccd3c86",
"type":"code"
},
{
"fragments":[
{
"text":"This is achieved by changing the following line in the code generator",
"type":"text"
}
],
"id":"c73514c15f9749a29e5d070423aee716",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| astFnBody:x -> { \"(lambda:\\n\" > x < \"\\n)\" }\n",
"type":"code"
}
],
"id":"75962a34bc124422840c608c5ce11574",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"to",
"type":"text"
}
],
"id":"971eabd00f6143428fe06553074e4cb8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| astFnBody:x -> { \"(lambda: \" x \")\" }\n",
"type":"code"
}
],
"id":"00aa8eafb77042e58c86e630149b9d27",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"Compile the modified source:",
"type":"text"
}
],
"id":"0be1c52082a54085a0e9f0e94702a4e7",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"7a6b856affa54cc4bdb62fd5a0b4f137",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"9fd7d26ae6d54fcaa6d64a5739f6cf36",
"type":"code"
},
{
"fragments":[
{
"text":"With this change, ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" is no longer a metacompiler because the modified executable ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" differs from ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"c16df5bc53fc422796deaf081c25ae8b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\n1685,1686c1685\n<                                         '(lambda:\\n',\n<                                         _IndentBuilder(),\n---\n>                                         '(lambda:',\n1688,1689c1687\n<                                         _DedentBuilder(),\n<                                         '\\n)',\n---\n>                                         ')',\nrlmeta.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"90cf5d9eca604cd8becd3e9feca345dc",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"The difference is that the code for generating lambda expressions is different. ",
"type":"text"
},
{
"text":"rlemta1.py",
"type":"code"
},
{
"text":" should still be a compiler that recognizes the same source language so it can be used to compile once more:",
"type":"text"
}
],
"id":"fde362e72d364e7a8698cca2495fadfe",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"d9e1b2a1b8484b6ba4122794a3df0e20",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta1.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"3e4fe4aad7c94c40a8dfb0c6476e32b5",
"type":"code"
},
{
"fragments":[
{
"text":"With this compilation, ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" is not either a metacomiler:",
"type":"text"
}
],
"id":"0a7938f4e6424d3d89bcc7191eb9986e",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\n287,325c287,299\n<         return (lambda:\n<             self._or([\n<                 (lambda:\n<                     (lambda _vars:\n<                         (lambda:\n<                             self._and([\n<                                 (lambda:\n<                                     _vars.bind('x', (lambda:\n<                                         self._match_rule('name')\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('{')\n<                                 ),\n<                                 (lambda:\n<                                     _vars.bind('ys', (lambda:\n<                                         self._star((lambda:\n<                                             self._match_rule('rule')\n<                                         ))\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('}')\n<                                 ),\n<                                 (lambda:\n<                                     _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))\n<                                 ),\n<                             ])\n<                         )()\n<                     )(_Vars())\n<                 ),\n<             ])\n<         )()\n---\n>         return (lambda: self._or([\n>             (lambda: (lambda _vars:\n>                 (lambda: self._and([\n>                     (lambda: _vars.bind('x', (lambda: self._match_rule('name'))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('{')),\n>                     (lambda: _vars.bind('ys', (lambda: self._star((lambda: self._match_rule('rule'))))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('}')),\n>                     (lambda: _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))),\n>                 ]))()\n>             )(_Vars())),\n>         ]))()\n...\nrlmeta1.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"27880ff33fae4aafa40bd977cc4cd0c4",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"This time the difference is only in formatting. The original change set out to remove additional punctuation in lambda expressions, and this change can now be seen. Compile once again:",
"type":"text"
}
],
"id":"8719ed6b7ab14ef59c9f71e6dc80059a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta2.py > rlmeta3.py\n",
"type":"code"
}
],
"id":"220782c1b04d44718525cae19adfc70b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta2.py -> rlmeta3.py\n",
"type":"code"
}
],
"id":"3c22d9fe73f4464db6905289eb5cd0e6",
"type":"code"
},
{
"fragments":[
{
"text":"Now, ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" is a metacompiler:",
"type":"text"
}
],
"id":"a1d45d6b69964c9ea979858cad95ae98",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta2.py\nrlmeta2.py is a metacompiler!\n",
"type":"code"
}
],
"id":"02c659d8ee7e4f9797fb9ca93a1fa1a4",
"type":"code"
},
{
"fragments":[
{
"text":"The compiler that rlmeta2.py produces (",
"type":"text"
},
{
"text":"rlmeta3.py",
"type":"code"
},
{
"text":") is exactly the same as itself. ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":", and ",
"type":"text"
},
{
"text":"rlmeta3.py",
"type":"code"
},
{
"text":" can be discarded and ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" becomes the new ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"6b890adad1964ae9b928a7531d2c1793",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta2.py -> rlmeta2.py\n                 |\n                 V\n   source -> rlmeta.py -> rlmeta.py\n\n",
"type":"code"
}
],
"id":"342281e2e7b1449d98a0453c8ccd2076",
"type":"code"
},
{
"fragments":[
{
"text":"A new version of RLMeta was created that generates code slightly different and is still a metacompiler.",
"type":"text"
}
],
"id":"13f5b9ccbb0844468d99fbb40212672d",
"type":"text"
}
],
"title":"Modifying code generator"
},
{
"children":[],
"id":"0130b76cb3d24f458bb47debb6fc2780",
"paragraphs":[
{
"fragments":[
{
"text":"Explain how bug was fixed.",
"type":"text"
}
],
"id":"a7b2bbcc13a9431da6c2fbb3c4c9ec41",
"type":"text"
},
{
"fragments":[
{
"text":"Generate support.py from compiler instead of from source.",
"type":"text"
}
],
"id":"0b7839572c9940dabc0e4afe5343ab9b",
"type":"text"
}
],
"title":"Modifying support library"
},
{
"children":[],
"id":"22e574102e394218b874f03bb879c92f",
"paragraphs":[
{
"fragments":[
{
"text":"Changing syntax in steps: 1) modify grammar to accept new syntax 2) feed updated grammar to new compiler.",
"type":"text"
}
],
"id":"73adf0902f014946b6a0b1812588ef8c",
"type":"text"
}
],
"title":"Modifying grammar syntax"
},
{
"children":[],
"id":"6bfdc073cd4041238b169caa671c9652",
"paragraphs":[
{
"fragments":[
{
"text":"Not possible to create a metacompiler from a breaking change.",
"type":"text"
}
],
"id":"cd4b606dcb364ea6bc1d6055e7853ef6",
"type":"text"
}
],
"title":"Making a breaking change"
},
{
"children":[],
"id":"d54bbeda3d9846bca027f2c2995775a5",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"bd7e31bf3ea7456f975830d5bf2ef05c",
"type":"code"
},
{
"fragments":[
{
"text":"Only changes from original RLMeta is the compile.sh script. Full sources on github.",
"type":"text"
}
],
"id":"969153820b334d91838f46bfd52388ad",
"type":"text"
}
],
"title":"Code listings for RLMeta"
}
],
"id":"7b987f7cd685486da72bf77dcd0b3f29",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I explain how to modify the RLMeta metacompiler and how modifying it is different from modifying a regular program.",
"type":"text"
}
],
"id":"4d967f1bcd054206b4731c141ff9822a",
"type":"text"
}
],
"title":"Modifying RLMeta"
},
"variables":{}
}