{
"root_page":{
"children":[
{
"children":[],
"id":"39efe623ff374daba9830984300fcde2",
"paragraphs":[
{
"fragments":[
{
"text":"I was unable to find a clear definition, so the following are my best attempts.",
"type":"emphasis"
}
],
"id":"61b6156f27d942da86ba13c23813eb55",
"type":"text"
},
{
"fragments":[
{
"text":"A metacompiler is a compiler that can reproduce itself from a description written in a metalanguage. A metalanguage is domain specific language for reasoning about statements in another language.",
"type":"text"
}
],
"id":"528a58686ce442d79e1b367408fe944c",
"type":"text"
},
{
"fragments":[
{
"text":"A generic compiler takes source code as input and outputs executable code:",
"type":"text"
}
],
"id":"e192774e5eeb495589a7021b6f8f4d88",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> compiler -> executable\n",
"type":"code"
}
],
"id":"84b2d2ffe1b641c388d7f834af5e427b",
"type":"code"
},
{
"fragments":[
{
"text":"A metacompiler takes source code as input and outputs itself (given that the source is the source for the metacompiler):",
"type":"text"
}
],
"id":"05285271f1cc494ca90f7d3d9a1dcd91",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> metacompiler -----\n               ^           |\n               |           |\n               -------------\n",
"type":"code"
}
],
"id":"af656248fc3845cfab5327911291fb11",
"type":"code"
},
{
"fragments":[
{
"text":"A C compiler written in C is not a metacompiler because C is not a metalanguage. It is a general purpose programming language. Such compiler is merely a self-hosting compiler.",
"type":"text"
}
],
"id":"68a70728549c41478d8110b0248c678c",
"type":"text"
}
],
"title":"What is a metacompiler?"
},
{
"children":[],
"id":"bf2e6a99e41f478f884dd15ea243c111",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta is a metacompiler because its source is written in a metalanguage and it is able to reproduce itself.",
"type":"text"
}
],
"id":"d86dd49a17e94d2694bedd68c178a028",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" scripts compiles the RLMeta compiler. It runs the source files (",
"type":"text"
},
{
"text":"parser.rlmeta",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"codegenerator.rlmeta",
"type":"code"
},
{
"text":") through the RLMeta compiler and combines the output with the support library (",
"type":"text"
},
{
"text":"support.py",
"type":"code"
},
{
"text":") and code to invoke it. The ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script takes one argument which is the path to the RLMeta compiler.",
"type":"text"
}
],
"id":"ac4e4f2a863f48e4a82eddbc322b4d54",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"rlmeta template"
],
"prefix":"",
"type":"chunk"
},
{
"text":"EOF\n",
"type":"code"
}
],
"id":"ef234944361c48eeb16387d8014a4c9b",
"type":"code"
},
{
"chunkpath":[
"rlmeta template"
],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"import sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\n",
"type":"code"
}
],
"id":"cab1f5d6d3c0412696419fd2f8c0ab88",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"How can it be verified that RLMeta is a metacompiler? The following script does it by comparing the RLMeta compiler to the compiler generated by the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. If they are equal the RLMeta compiler reproduced itself exactly, and is thus a metacompiler. Otherwise the two compilers differ.",
"type":"text"
}
],
"id":"734c020ee59a4446a84baeeab3e5c655",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":" compile.sh rlmeta.py\n|-----------------------|\n| source -> rlmeta.py --|---\n|                ^      |  |\n|                |      |  |\n|                -------|---\n|-----------------------|\n",
"type":"code"
}
],
"id":"6bba4e434dc44f8181caf4c5ccfee01e",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"is_metacompiler.sh"
],
"fragments":[
{
"text":"if diff $1 <(./compile.sh $1); then\n    echo \"$1 is a metacompiler!\"\nelse\n    echo \"$1 is not a metacompiler. See diff above.\"\nfi\n",
"type":"code"
}
],
"id":"51c75af0347d416181ffec8cab1f0c51",
"type":"code"
},
{
"fragments":[
{
"text":"To prove:",
"type":"text"
}
],
"id":"52191a29ca4d4462860c0a2552160441",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\nrlmeta.py is a metacompiler!\n",
"type":"code"
}
],
"id":"8e96b580ce5c4ed2bc67997925bc1117",
"type":"code"
}
],
"title":"Is RLMeta a metacompiler?"
},
{
"children":[],
"id":"93d9030e0e4849c5a8d8ca0fffdf7592",
"paragraphs":[
{
"fragments":[
{
"text":"When making a change in the source code for RLMeta, it must be ensured that the metacompiler property still holds. This is a key difference when modifying a metacompiler.",
"type":"text"
}
],
"id":"c363ade479ef4a0cb62a455a36b802c5",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source -> rlmeta.py -> rlmeta.py\n\nmodified source -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"3c6356572e66461995dbbc5d6ed0c38d",
"type":"code"
},
{
"fragments":[
{
"text":"In order to maintain ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" both the modified source and the original ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" is needed. This is no good place to be. At this point the source for rlmeta.py is lost. So we can't really modify it.",
"type":"text"
}
],
"id":"9aca2d8b77714269915348220a80b2f3",
"type":"text"
},
{
"fragments":[
{
"text":"In order to modify rlmeta.py we need the source code and a compiler. If there is no way we can reproduce it, we can't modify it.",
"type":"text"
}
],
"id":"c7f676bd1b8e4759bb676cb020172a36",
"type":"text"
}
],
"title":"Maintaining metacompiler property"
},
{
"children":[],
"id":"5f6a1c91143146dbb3b865ac42562135",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    | astFnBody:x               -> { \"(lambda:\\n\" > x < \"\\n)\" }\n",
"type":"code"
}
],
"id":"75962a34bc124422840c608c5ce11574",
"language":"rlmeta",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    | astFnBody:x               -> { \"(lambda: \" x \")\" }\n",
"type":"code"
}
],
"id":"00aa8eafb77042e58c86e630149b9d27",
"language":"rlmeta",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ git diff codegenerator.rlmeta\ndiff --git a/writing/draft-rlmeta-modifying-metacompiler/codegenerator.rlmeta b/writing/draft-rlmeta-modifying-metacompiler/codegenerator.rlmeta\nindex 293e013..657f59a 100644\n--- a/writing/draft-rlmeta-modifying-metacompiler/codegenerator.rlmeta\n+++ b/writing/draft-rlmeta-modifying-metacompiler/codegenerator.rlmeta\n@@ -10,7 +10,7 @@ CodeGenerator {\n     | [\"DedentBuilder\"]         -> { \"_DedentBuilder()\"                                  }\n     | [\"FnCall\" .:x astItems:y] -> { x \"(\" y \")\"                                         }\n     | [\"VarLookup\" .:x]         -> { \"_vars.lookup(\" repr(x) \").eval()\"                  }\n-    | astFnBody:x               -> { \"(lambda:\\n\" > x < \"\\n)\" }\n+    | astFnBody:x               -> { \"(lambda: \" x \")\" }\n   astFnBody =\n     | [\"Or\" astItems:x]         -> { \"self._or([\" x \"])\"                                 }\n     | [\"Scope\" ast:x]           -> { \"(lambda _vars:\\n\" > x < \"()\\n)(_Vars())\"           }\n",
"type":"code"
}
],
"id":"0bc5ae207dbd4ea3b41a00651d0d1873",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"Is rlmeta.py a metacompiler? Le'ts check:",
"type":"text"
}
],
"id":"c16df5bc53fc422796deaf081c25ae8b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ diff rlmeta.py <(./compile.sh rlmeta.py)\n1685,1686c1685\n<                                         '(lambda:\\n',\n<                                         _IndentBuilder(),\n---\n>                                         '(lambda: ',\n1688,1689c1687\n<                                         _DedentBuilder(),\n<                                         '\\n)',\n---\n> \n",
"type":"code"
}
],
"id":"90cf5d9eca604cd8becd3e9feca345dc",
"language":"diff",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"7a6b856affa54cc4bdb62fd5a0b4f137",
"type":"code"
},
{
"fragments":[
{
"text":"Is rlmeta1.py a metacompiler? Le'ts check:",
"type":"text"
}
],
"id":"4818c579d5da41caa796d973b28d6752",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\n287,325c287,299\n<         return (lambda:\n<             self._or([\n<                 (lambda:\n<                     (lambda _vars:\n<                         (lambda:\n<                             self._and([\n<                                 (lambda:\n<                                     _vars.bind('x', (lambda:\n<                                         self._match_rule('name')\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('{')\n<                                 ),\n<                                 (lambda:\n<                                     _vars.bind('ys', (lambda:\n<                                         self._star((lambda:\n<                                             self._match_rule('rule')\n<                                         ))\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('}')\n<                                 ),\n<                                 (lambda:\n<                                     _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))\n<                                 ),\n<                             ])\n<                         )()\n<                     )(_Vars())\n<                 ),\n<             ])\n<         )()\n---\n>         return (lambda: self._or([\n>             (lambda: (lambda _vars:\n>                 (lambda: self._and([\n>                     (lambda: _vars.bind('x', (lambda: self._match_rule('name'))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('{')),\n>                     (lambda: _vars.bind('ys', (lambda: self._star((lambda: self._match_rule('rule'))))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('}')),\n>                     (lambda: _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))),\n>                 ]))()\n>             )(_Vars())),\n>         ]))()\n...\nrlmeta1.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"27880ff33fae4aafa40bd977cc4cd0c4",
"language":"diff",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"220782c1b04d44718525cae19adfc70b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta2.py\nrlmeta2.py is a metacompiler!\n",
"type":"code"
}
],
"id":"02c659d8ee7e4f9797fb9ca93a1fa1a4",
"type":"code"
},
{
"fragments":[
{
"text":"This means that rlmeta2.py is a metacompiler. The compiler that rlmeta2.py produces is exactly the same as itself.",
"type":"text"
}
],
"id":"6b890adad1964ae9b928a7531d2c1793",
"type":"text"
}
],
"title":"Making a change"
},
{
"children":[],
"id":"0130b76cb3d24f458bb47debb6fc2780",
"paragraphs":[
{
"fragments":[
{
"text":"Explain how bug was fixed.",
"type":"text"
}
],
"id":"a7b2bbcc13a9431da6c2fbb3c4c9ec41",
"type":"text"
},
{
"fragments":[
{
"text":"Generate support.py from compiler instead of from source.",
"type":"text"
}
],
"id":"0b7839572c9940dabc0e4afe5343ab9b",
"type":"text"
}
],
"title":"Changing support"
},
{
"children":[],
"id":"22e574102e394218b874f03bb879c92f",
"paragraphs":[
{
"fragments":[
{
"text":"Changing syntax in steps: 1) modify grammar to accept new syntax 2) feed updated grammar to new compiler.",
"type":"text"
}
],
"id":"73adf0902f014946b6a0b1812588ef8c",
"type":"text"
}
],
"title":"Grammar syntax change"
},
{
"children":[],
"id":"d54bbeda3d9846bca027f2c2995775a5",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"bd7e31bf3ea7456f975830d5bf2ef05c",
"type":"code"
},
{
"fragments":[
{
"text":"Only changes from original RLMeta is the compile.sh script. Full sources on github.",
"type":"text"
}
],
"id":"969153820b334d91838f46bfd52388ad",
"type":"text"
}
],
"title":"Code listings for RLMeta"
}
],
"id":"7b987f7cd685486da72bf77dcd0b3f29",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I explain how to modify the RLMeta metacompiler and how modifying a metacompiler is different from modifying non metacompiler (or program).",
"type":"text"
}
],
"id":"4d967f1bcd054206b4731c141ff9822a",
"type":"text"
}
],
"title":"Modifying RLMeta"
},
"variables":{}
}