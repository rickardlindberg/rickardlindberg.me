{
"root_page":{
"children":[
{
"children":[],
"id":"39efe623ff374daba9830984300fcde2",
"paragraphs":[
{
"fragments":[
{
"text":"A compiler translates source code into an executable:",
"type":"text"
}
],
"id":"e192774e5eeb495589a7021b6f8f4d88",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source code -> compiler -> executable\n",
"type":"code"
}
],
"id":"84b2d2ffe1b641c388d7f834af5e427b",
"type":"code"
},
{
"fragments":[
{
"text":"A C compiler translates source code written in C into an executable:",
"type":"text"
}
],
"id":"247442defad9486dbbc00a80a7ba5853",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"C source code -> C compiler -> executable\n",
"type":"code"
}
],
"id":"9637925d22dd4794906e11a82c0979e0",
"type":"code"
},
{
"fragments":[
{
"text":"A metacompiler translates source code written in a metalanguage into an executable:",
"type":"text"
}
],
"id":"dda8f4fc2f004d3fb52fe16672790891",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"metalanguage source code -> metacompiler -> executable\n",
"type":"code"
}
],
"id":"37c8ccef5d884282b288faeed4eb687b",
"type":"code"
},
{
"fragments":[
{
"text":"A metalanguage is a domain specific language for describing other languages. It can be used to describe what languages look like (their syntax) and how to translate them into executables (their semantics). In essence, it can be used to describe compilers.",
"type":"text"
}
],
"id":"2ae1792b33f04c3cb643d28db004a5f9",
"type":"text"
},
{
"fragments":[
{
"text":"Because a metalanguage can be used to describe any compiler, it can also be used describe the metacompiler itself. The metacompiler translates such a description into itself:",
"type":"text"
}
],
"id":"05285271f1cc494ca90f7d3d9a1dcd91",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source code -> metacompiler -----\n                    ^           |\n                    |           |\n                    -------------\n",
"type":"code"
}
],
"id":"406f320e489544f0adac76714322286b",
"type":"code"
},
{
"fragments":[
{
"text":"A metacompiler does not necessarily have to be implemented in the metalanguage itself, but I suspect that it is common that it is. RLMeta is indeed implemented in its own language. This is also known as self-hosting. For the rest of this article, I will assume that a metacompiler is also self-hosting.",
"type":"text"
}
],
"id":"bc611e48de17497caa0a20eaa7664dba",
"type":"text"
},
{
"fragments":[
{
"text":"A C compiler written in C is not a metacompiler because C is not a metalanguage. It is a general purpose programming language not designed specifically to describe other languages. Such compiler is merely a self-hosting compiler.",
"type":"text"
}
],
"id":"68a70728549c41478d8110b0248c678c",
"type":"text"
}
],
"title":"What is a metacompiler?"
},
{
"children":[],
"id":"93d9030e0e4849c5a8d8ca0fffdf7592",
"paragraphs":[
{
"fragments":[
{
"text":"In general, to modify a program written in a compiled language, its source code and a compiler is needed. Modifying the program is a matter of modifying the source code and compiling it:",
"type":"text"
}
],
"id":"e0a64299fcfa4b19ab466704dee628e3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source code -> compiler -> executable\n",
"type":"code"
}
],
"id":"70809fbb4dbe4f6f8cdff0d0d498525c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> compiler -> modified executable\n",
"type":"code"
}
],
"id":"71dcb5f5a51742f5b5e3e05c2d14919c",
"type":"code"
},
{
"fragments":[
{
"text":"In the case of a metacompiler, the compiler and the executable is the same. However, if the source code is changed, the executable might not be the metacompiler itself.",
"type":"text"
}
],
"id":"5e43207a89814de58fe844c511df67f9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"source code -> metacompiler -----\n                    ^           |\n                    |           |\n                    -------------\n",
"type":"code"
}
],
"id":"95da99c68a514e7f998882cb40da5e9f",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> metacompiler -> modified executable\n",
"type":"code"
}
],
"id":"3c6356572e66461995dbbc5d6ed0c38d",
"type":"code"
},
{
"fragments":[
{
"text":"At this point, the metacompiler is needed to keep maintaining the modified executable. But the source code for the metacompiler itself is \"lost\" because the metacompiler can not be reproduced from the modified source code.",
"type":"text"
}
],
"id":"9aca2d8b77714269915348220a80b2f3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> ??? -> metacompiler\n",
"type":"code"
}
],
"id":"eab099f879994d5b95b8a19b8fb103c6",
"type":"code"
},
{
"fragments":[
{
"text":"Because there is no source code, the original metacompiler can not be modified either.",
"type":"text"
}
],
"id":"52e85832ecd94b3cac6f44a322e61e51",
"type":"text"
},
{
"fragments":[
{
"text":"When making changes to a metacompiler, care has to be taken to ensure that, in the end, the executable is still a metacompiler. Otherwise the metacompiler can not be modified further. This is a key difference from modifying a regular program. (Similar care has to be taken when modifying a self-hosting compiler.)",
"type":"text"
}
],
"id":"c363ade479ef4a0cb62a455a36b802c5",
"type":"text"
}
],
"title":"Modifying a metacompiler"
},
{
"children":[],
"id":"bf2e6a99e41f478f884dd15ea243c111",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta is compiled with the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. It takes one argument which is the path to the RLMeta compiler. The script uses that compiler to compile the source code and then assemble the output to a Python file that looks like this:",
"type":"text"
}
],
"id":"22f617b9696f41d68c4ddeb7889d94c5",
"type":"text"
},
{
"chunkpath":[
"rlmeta template"
],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"import sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\n",
"type":"code"
}
],
"id":"cab1f5d6d3c0412696419fd2f8c0ab88",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The variables ",
"type":"text"
},
{
"text":"$support_py",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"$parser_py",
"type":"code"
},
{
"text":", and ",
"type":"text"
},
{
"text":"$codegenerator_py",
"type":"code"
},
{
"text":" are produced by the RLMeta compiler. The variable ",
"type":"text"
},
{
"text":"$support_py_string",
"type":"code"
},
{
"text":" is produced by converting the support library to a Python string. Here is the rest of the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script:",
"type":"text"
}
],
"id":"ac4e4f2a863f48e4a82eddbc322b4d54",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"rlmeta template"
],
"prefix":"",
"type":"chunk"
},
{
"text":"EOF\n",
"type":"code"
}
],
"id":"ef234944361c48eeb16387d8014a4c9b",
"type":"code"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"is_metacompiler.sh",
"type":"code"
},
{
"text":" script checks if a given file is a metacompiler. It does so by comparing the file to the file generated by the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script. If they are equal, the file is a metacompiler because it reproduced itself exactly. Otherwise the two files differ.",
"type":"text"
}
],
"id":"734c020ee59a4446a84baeeab3e5c655",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"is_metacompiler.sh"
],
"fragments":[
{
"text":"if diff $1 <(./compile.sh $1); then\n    echo \"$1 is a metacompiler!\"\nelse\n    echo \"$1 is not a metacompiler. See diff above.\"\nfi\n",
"type":"code"
}
],
"id":"51c75af0347d416181ffec8cab1f0c51",
"type":"code"
},
{
"fragments":[
{
"text":"RLMeta is a metacompiler because its source code is written in a metalanguage and it is able to reproduce itself:",
"type":"text"
}
],
"id":"d86dd49a17e94d2694bedd68c178a028",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\nrlmeta.py is a metacompiler!\n",
"type":"code"
}
],
"id":"8e96b580ce5c4ed2bc67997925bc1117",
"type":"code"
},
{
"fragments":[
{
"text":"The following sections show examples of how to make changes to RLMeta that ensure that the modified version is still a metacompiler.",
"type":"text"
}
],
"id":"d21afc4f5e604e78b978a9ff65b73c3f",
"type":"text"
}
],
"title":"Compiling RLMeta"
},
{
"children":[],
"id":"5f6a1c91143146dbb3b865ac42562135",
"paragraphs":[
{
"fragments":[
{
"text":"The code generator in RLMeta generates lambda expressions with newlines and indentation:",
"type":"text"
}
],
"id":"c5cf0946f71647f687176d66e5e4fb2f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    ...\n)\n",
"type":"code"
}
],
"id":"cc11caffc9884033bff44020b3fa3632",
"type":"code"
},
{
"fragments":[
{
"text":"It might be desirable to instead generate lambda expressions without the additional punctuation because it is faster and does not make the generated code less readable:",
"type":"text"
}
],
"id":"72a9d99eed5349d587fd9d5d49145541",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda: ...)\n",
"type":"code"
}
],
"id":"b7c19d3dc91340c5aa0de1cb3ccd3c86",
"type":"code"
},
{
"fragments":[
{
"text":"This is achieved by changing the following line in the code generator",
"type":"text"
}
],
"id":"c73514c15f9749a29e5d070423aee716",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| astFnBody:x -> { \"(lambda:\\n\" > x < \"\\n)\" }\n",
"type":"code"
}
],
"id":"75962a34bc124422840c608c5ce11574",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"to",
"type":"text"
}
],
"id":"971eabd00f6143428fe06553074e4cb8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| astFnBody:x -> { \"(lambda: \" x \")\" }\n",
"type":"code"
}
],
"id":"00aa8eafb77042e58c86e630149b9d27",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"The modified source code describes a metacompiler whose code generator generates lambda expressions without additional punctuation.",
"type":"text"
}
],
"id":"aef5814858194975a5121743ad87519b",
"type":"text"
},
{
"fragments":[
{
"text":"Compiling the modified source code gives a new executable:",
"type":"text"
}
],
"id":"0be1c52082a54085a0e9f0e94702a4e7",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"7a6b856affa54cc4bdb62fd5a0b4f137",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"9fd7d26ae6d54fcaa6d64a5739f6cf36",
"type":"code"
},
{
"fragments":[
{
"text":"With this modification, ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" is no longer a metacompiler because it differs from ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"c16df5bc53fc422796deaf081c25ae8b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\n1685,1686c1685\n<                                         '(lambda:\\n',\n<                                         _IndentBuilder(),\n---\n>                                         '(lambda:',\n1688,1689c1687\n<                                         _DedentBuilder(),\n<                                         '\\n)',\n---\n>                                         ')',\nrlmeta.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"90cf5d9eca604cd8becd3e9feca345dc",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"The difference is that the code for generating lambda expressions is different. ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" should still be a compiler that recognizes the same source language so it can be used to compile the modified source code again, giving yet another executable:",
"type":"text"
}
],
"id":"fde362e72d364e7a8698cca2495fadfe",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"d9e1b2a1b8484b6ba4122794a3df0e20",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta1.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"3e4fe4aad7c94c40a8dfb0c6476e32b5",
"type":"code"
},
{
"fragments":[
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" is not a metacompiler either because it differs from ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"b65b2d835c0448d7a63e36fef48de55a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\n287,325c287,299\n<         return (lambda:\n<             self._or([\n<                 (lambda:\n<                     (lambda _vars:\n<                         (lambda:\n<                             self._and([\n<                                 (lambda:\n<                                     _vars.bind('x', (lambda:\n<                                         self._match_rule('name')\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('{')\n<                                 ),\n<                                 (lambda:\n<                                     _vars.bind('ys', (lambda:\n<                                         self._star((lambda:\n<                                             self._match_rule('rule')\n<                                         ))\n<                                     )())\n<                                 ),\n<                                 (lambda:\n<                                     self._match_rule('space')\n<                                 ),\n<                                 (lambda:\n<                                     self._match_charseq('}')\n<                                 ),\n<                                 (lambda:\n<                                     _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))\n<                                 ),\n<                             ])\n<                         )()\n<                     )(_Vars())\n<                 ),\n<             ])\n<         )()\n---\n>         return (lambda: self._or([\n>             (lambda: (lambda _vars:\n>                 (lambda: self._and([\n>                     (lambda: _vars.bind('x', (lambda: self._match_rule('name'))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('{')),\n>                     (lambda: _vars.bind('ys', (lambda: self._star((lambda: self._match_rule('rule'))))())),\n>                     (lambda: self._match_rule('space')),\n>                     (lambda: self._match_charseq('}')),\n>                     (lambda: _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))),\n>                 ]))()\n>             )(_Vars())),\n>         ]))()\n...\nrlmeta1.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"27880ff33fae4aafa40bd977cc4cd0c4",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"This time the difference is only in formatting. The two programs should be semantically equivalent. The original change set out to remove additional punctuation in lambda expressions, and this change can now be seen in the generated code. ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" can be used to compile the modified source code again, giving yet another executable:",
"type":"text"
}
],
"id":"8719ed6b7ab14ef59c9f71e6dc80059a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta2.py > rlmeta3.py\n",
"type":"code"
}
],
"id":"220782c1b04d44718525cae19adfc70b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta2.py -> rlmeta3.py\n",
"type":"code"
}
],
"id":"3c22d9fe73f4464db6905289eb5cd0e6",
"type":"code"
},
{
"fragments":[
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" is now a metacompiler because it is the same as ",
"type":"text"
},
{
"text":"rlmeta3.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"a1d45d6b69964c9ea979858cad95ae98",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta2.py\nrlmeta2.py is a metacompiler!\n",
"type":"code"
}
],
"id":"02c659d8ee7e4f9797fb9ca93a1fa1a4",
"type":"code"
},
{
"fragments":[
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" together with the modified source becomes the next version of the metacompiler. All other intermediate versions can be discarded.",
"type":"text"
}
],
"id":"6b890adad1964ae9b928a7531d2c1793",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"   source code -> rlmeta.py -> rlmeta.py\n                     |\n                     V\nmodified source code -> rlmeta.py  -> rlmeta1.py\nmodified source code -> rlmeta1.py -> rlmeta2.py\nmodified source code -> rlmeta2.py ---|\n                            ^         |\n                            |---------|\n",
"type":"code"
}
],
"id":"342281e2e7b1449d98a0453c8ccd2076",
"type":"code"
},
{
"fragments":[
{
"text":"A new version of RLMeta has been created that generates code slightly different. Intermediate compilers had to be created to produce the new metacompiler.",
"type":"text"
}
],
"id":"13f5b9ccbb0844468d99fbb40212672d",
"type":"text"
}
],
"title":"Modifying formatting of generated code"
},
{
"children":[],
"id":"6bfdc073cd4041238b169caa671c9652",
"paragraphs":[
{
"fragments":[
{
"text":"What happens if the source code is modified so that it no longer correctly describes a metacompiler?",
"type":"text"
}
],
"id":"2d9fa3e9ffe34f7cbaa940362be99669",
"type":"text"
},
{
"fragments":[
{
"text":"Changing the source code that generates code for rules from",
"type":"text"
}
],
"id":"24958db22ee14ffdb45c2ec86165dd6e",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| [\"Rule\" .:x ast:y] -> { \"\\ndef _rule_\" x \"(self):\\n\" > \"return \" y \"()\\n\" < }\n",
"type":"code"
}
],
"id":"7f71cf97492c4e44a86fdf80802f2ccd",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"to",
"type":"text"
}
],
"id":"09c0ad337870423ab7a8cbabcef78427",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| [\"Rule\" .:x ast:y] -> { \"\\ndef _rule_\" x \"(self):\\n\" > \"pass\\n\" < }\n",
"type":"code"
}
],
"id":"55cec80cf6cc4328b9d09901ae162c3c",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"is a dummy change that should break things.",
"type":"text"
}
],
"id":"a515f10cf88d4a61904a5480f52b3063",
"type":"text"
},
{
"fragments":[
{
"text":"Compiling the modified source code gives a new executable:",
"type":"text"
}
],
"id":"9260da643b3a4d5799dc6bb3bcf003c6",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"f3665d39883144618b9fd91d2e8d885b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"bb50c144771b4a49b331353daddd315d",
"type":"code"
},
{
"fragments":[
{
"text":"With this modification, ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" is no longer a metacompiler because it differs from ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"2f540e07b4c749229f627b63238d1ba0",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\n1453,1455c1453\n<                                         'return ',\n<                                         _vars.lookup('y').eval(),\n<                                         '()\\n',\n---\n>                                         'pass\\n',\nrlmeta.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"5ec997969feb4b21835e3eb784f0cce4",
"type":"code"
},
{
"fragments":[
{
"text":"The difference is that the code for generating code for rules is different. Instead of generating actual code, only a ",
"type":"text"
},
{
"text":"pass",
"type":"code"
},
{
"text":" is generated. ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" should still be a compiler that recognizes the same source language so it can be used to compile the modified source code again, giving yet another executable:",
"type":"text"
}
],
"id":"a75dd09d6bf845d1afaaf499352b66ef",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"8119eed6eccb4c9a8ec2b4d0feb12bb9",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta1.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"11fb37043b5e49418b2a49b9bc9a0e83",
"type":"code"
},
{
"fragments":[
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" is not a metacompiler either because it differs from ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"ad5aa41a2c9f482bb0a239d6baa89d7b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\n287,325c287\n<         return (lambda:\n<             self._or([\n<                 (lambda:\n...\n<                 ),\n<             ])\n<         )()\n---\n>         pass\n...\nrlmeta1.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"c1a8e52615f94520bf9cf6451a1a42e0",
"type":"code"
},
{
"fragments":[
{
"text":"This time the difference is that all rules return ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" instead of actually doing matching and returning results. What happens if the modified source code is compiled with ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":"?",
"type":"text"
}
],
"id":"3b77b267e9da41cc840b80df19085462",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta2.py > rlmeta3.py\n",
"type":"code"
}
],
"id":"2b5b939f818f49cc8ff3ad311756314c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta2.py -> rlmeta3.py\n",
"type":"code"
}
],
"id":"5b034cc6ecae4d8d904fad5997e03a0c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta2.py > rlmeta3.py\nTraceback (most recent call last):\n  File \"rlmeta2.py\", line 375, in <module>\n    sys.stdout.write(compile_grammar(sys.stdin.read()))\n  File \"rlmeta2.py\", line 368, in compile_grammar\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n  File \"rlmeta2.py\", line 102, in run\n    result = self._match_rule(rule_name).eval()\nAttributeError: 'NoneType' object has no attribute 'eval'\n",
"type":"code"
}
],
"id":"c27fa5bb8f6e417eb59cf2a5fa135971",
"type":"code"
},
{
"fragments":[
{
"text":"Because the modified source code does not correctly describe how code for rules should be generated, it does not describe a metacompiler, and it can never be used to create a metacompiler. The ",
"type":"text"
},
{
"text":"rlmeta3.py",
"type":"code"
},
{
"text":" is an empty file because ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" could not generate anything.",
"type":"text"
}
],
"id":"df2c1bcf67b44373894a46e7f61a2a6b",
"type":"text"
}
],
"title":"Making a breaking change"
},
{
"children":[],
"id":"0130b76cb3d24f458bb47debb6fc2780",
"paragraphs":[
{
"fragments":[
{
"text":"Say an API change is required in the support library. Say ",
"type":"text"
},
{
"text":"bind",
"type":"code"
},
{
"text":" needs to swap arguments. This is achieved by changing the code generator and the support library:",
"type":"text"
}
],
"id":"81e2b3bcfa5d48ceb09498acbdb94e5d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"-    | [\"Bind\" .:x ast:y] -> { \"_vars.bind(\" repr(x) \", \" y \"())\" }\n+    | [\"Bind\" .:x ast:y] -> { \"_vars.bind(\" y \"(), \" repr(x) \")\" }\n\n",
"type":"code"
}
],
"id":"201252047e654a31a94adfd76b1c969a",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"-    def bind(self, name, value):\n+    def bind(self, value, name):\n",
"type":"code"
}
],
"id":"bafc978d667e49dd95683e06e4d46d47",
"type":"code"
},
{
"fragments":[
{
"text":"Compiling the modified source code gives a new executable:",
"type":"text"
}
],
"id":"f02b96b6acbc4c339c2621e69750a592",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"ba676362bfc8421889fda9d7aec948a3",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"8b652c95263e462794910ec79a0251d6",
"type":"code"
},
{
"fragments":[
{
"text":"With this modification, ",
"type":"text"
},
{
"text":"rlmeta.py",
"type":"code"
},
{
"text":" is no longer a metacompiler because it differs from ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"a21e9297b77648b9b22780a9d468999d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\n3c3\n< SUPPORT = ...\n---\n> SUPPORT = ...\n1814a1815,1816\n>                                         _vars.lookup('y').eval(),\n>                                         '(), ',\n1818,1820c1820\n<                                         ', ',\n<                                         _vars.lookup('y').eval(),\n<                                         '())',\n---\n>                                         ')',\nrlmeta.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"d2e1489ce3de4c368f53e00150fa9863",
"type":"code"
},
{
"fragments":[
{
"text":"The difference is that the support library string (used to generate the support library) is different, and code for generating ",
"type":"text"
},
{
"text":"bind",
"type":"code"
},
{
"text":" calls is different. ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" can be used to compile the modified source code again, giving yet another executable:",
"type":"text"
}
],
"id":"cf2206774f7243689e21019522776104",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\n",
"type":"code"
}
],
"id":"1ddf4353d5684b0da67ad4f48a2fd286",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source code -> rlmeta1.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"dd5343b5babd4f4c9d23e2b565d61b31",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\n110c110\n<     def bind(self, name, value):\n---\n>     def bind(self, value, name):\n294c294\n<                                     _vars.bind('x', (lambda:\n---\n>                                     _vars.bind((lambda:\n...\nrlmeta1.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"a7108e40b0b7482fab25719f3117fb12",
"type":"code"
},
{
"fragments":[
{
"text":"This time the difference is that the generated support library has swapped arguments for ",
"type":"text"
},
{
"text":"bind",
"type":"code"
},
{
"text":" and the generated code for ",
"type":"text"
},
{
"text":"bind",
"type":"code"
},
{
"text":" calls also have swapped arguments. ",
"type":"text"
},
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" can be used to compile the modified source code again, giving yet another executable:",
"type":"text"
}
],
"id":"f48b6c98b95d4ab1a0df8eeef49a3e5b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta2.py > rlmeta3.py\n",
"type":"code"
}
],
"id":"37f1142df88d4f919cbaa235799cc98c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta2.py -> rlmeta3.py\n",
"type":"code"
}
],
"id":"70f1fc9501b64ea5bf246d1b42429915",
"type":"code"
},
{
"fragments":[
{
"text":"rlmeta2.py",
"type":"code"
},
{
"text":" is now a metacompiler because it is the same as ",
"type":"text"
},
{
"text":"rlmeta3.py",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"b058648ee05c4e6196484f247227c1dc",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta2.py\nrlmeta2.py is a metacompiler!\n",
"type":"code"
}
],
"id":"110f536658634b6798e0b192b0288bd6",
"type":"code"
},
{
"fragments":[
{
"text":"These compilation steps were not possible in the first version of RLMeta because the ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script generated the support library incorrectly. All RLMeta compilers have two versions of the support library: the one that it generates (stored in the ",
"type":"text"
},
{
"text":"SUPPORT",
"type":"code"
},
{
"text":" variable), and the one it uses itself. If the compiler is a metacompiler, the two versions are the same, but in intermediate compilers they might differ.",
"type":"text"
}
],
"id":"f159ab372dfa4963933f83b562dbeaaa",
"type":"text"
},
{
"fragments":[
{
"text":"The first version of RLMeta generated the support library like this:",
"type":"text"
}
],
"id":"fc12edcf75974eb1bb5e0b7431e0b4b8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"support_py=$(cat support.py)\n",
"type":"code"
}
],
"id":"f8b7a99762b94e3d9eb6514380294f79",
"language":"bash",
"type":"code"
},
{
"fragments":[
{
"text":"It meant that the intermediate compilers always had the latest support library, and the two versions of the support library were always the same.",
"type":"text"
}
],
"id":"4bd2d41f68e34d9ead322984c6f73b85",
"type":"text"
},
{
"fragments":[
{
"text":"In this example, it would lead to ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" having swapped arguments in the support library, but the generated code would still expect not swapped arguments:",
"type":"text"
}
],
"id":"44b91f05b5dd439e97b33a542f968957",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta.py\n3c3\n< SUPPORT = ...\n---\n> SUPPORT = ...\n110c110\n<     def bind(self, name, value):\n---\n>     def bind(self, value, name):\n1814a1815,1816\n>                                         _vars.lookup('y').eval(),\n>                                         '(), ',\n1818,1820c1820\n<                                         ', ',\n<                                         _vars.lookup('y').eval(),\n<                                         '())',\n---\n>                                         ')',\nrlmeta.py is not a metacompiler. See diff above.\n",
"type":"code"
}
],
"id":"59957f0f204246cda36163580870ef35",
"type":"code"
},
{
"fragments":[
{
"text":"This in turn would lead to ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" not functioning because its ",
"type":"text"
},
{
"text":"bind",
"type":"code"
},
{
"text":" calls have not stored the name as key, but the value:",
"type":"text"
}
],
"id":"bb42b23bb0c040f19816c8c95a375d61",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > rlmeta2.py\nTraceback (most recent call last):\n  File \"rlmeta1.py\", line 2217, in <module>\n    sys.stdout.write(compile_grammar(sys.stdin.read()))\n  File \"rlmeta1.py\", line 2210, in compile_grammar\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n  File \"rlmeta1.py\", line 102, in run\n    result = self._match_rule(rule_name).eval()\n  File \"rlmeta1.py\", line 123, in eval\n    return self.fn()\n  File \"rlmeta1.py\", line 318, in <lambda>\n    _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))\n  File \"rlmeta1.py\", line 115, in lookup\n    return self[name]\nKeyError: 'x'\n",
"type":"code"
}
],
"id":"36da070b1d2040db93af5dbd91577b3b",
"type":"code"
},
{
"fragments":[
{
"text":"The version of RLMeta in this article fixes the generation of the ",
"type":"text"
},
{
"text":"$support_py",
"type":"code"
},
{
"text":" variable like this:",
"type":"text"
}
],
"id":"7dae87609400493c87a72721cf297424",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"support_py=$(python \"$rlmeta_compiler\" --support)\n",
"type":"code"
}
],
"id":"e0f589f3b4534c1db7e683e1ce3f895e",
"language":"bash",
"type":"code"
},
{
"fragments":[
{
"text":"This ensures that the code that the code generator generates is always in sync with the support library.",
"type":"text"
}
],
"id":"a87cb57a477a4bda9aa234c18f099c01",
"type":"text"
}
],
"title":"Modifying API of support library"
},
{
"children":[],
"id":"d54bbeda3d9846bca027f2c2995775a5",
"paragraphs":[
{
"fragments":[
{
"text":"The example modifications I've shown so far can be compiled with the following script:",
"type":"text"
}
],
"id":"4e9ba6518d91445b8c170031e52bbe42",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"bd7e31bf3ea7456f975830d5bf2ef05c",
"type":"code"
},
{
"fragments":[
{
"text":"How many times is compilation needed? Max 2? But VM required 4?",
"type":"text"
}
],
"id":"af0923fee8f34769a93128bbda5645e6",
"type":"text"
},
{
"fragments":[
{
"text":"Prints 'OK' if a new metacompiler was successfully created.",
"type":"text"
}
],
"id":"3ad9f3cc37c3413ea55ac3e6758faa59",
"type":"text"
},
{
"fragments":[
{
"text":"Also checks that the two support libraries are same.",
"type":"text"
}
],
"id":"691212683b6f406d87d57bb29cb52de1",
"type":"text"
}
],
"title":"Meta compile script"
},
{
"children":[],
"id":"1a090bb868154140a167968d8b4b15dc",
"paragraphs":[
{
"fragments":[
{
"text":"The escape codes possible in strings are the following:",
"type":"text"
}
],
"id":"3752ee44334c4b9ca7c1e832a365f0cd",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"escape = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n       | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n",
"type":"code"
}
],
"id":"0eace03d4c884263974ce5f845ba40b0",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"Say it's desirable to add ",
"type":"text"
},
{
"text":"\\t",
"type":"code"
},
{
"text":" as well? How can it be done?",
"type":"text"
}
],
"id":"a83410c86d4e46fe921a76839ca1a893",
"type":"text"
},
{
"fragments":[
{
"text":"First attempt might look like this:",
"type":"text"
}
],
"id":"ed6d78514ecc475aa4832a05757e2bda",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"escape = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n       | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n       | 't'  -> \"\\t\"\n",
"type":"code"
}
],
"id":"2be56ecfeac141b9a7b384a93c14da43",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"This will not work as intended.",
"type":"text"
}
],
"id":"37b617ec3777458191709d45ecea7d4f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./meta_compile.sh\nOK\n",
"type":"code"
}
],
"id":"a6c7487784b14357b6e364747d148d77",
"type":"code"
},
{
"fragments":[
{
"text":"The code generated for the tab case looks like this:",
"type":"text"
}
],
"id":"bda6c32d41814781b1d752a48f9e9c9c",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    (lambda _vars:\n        (lambda:\n            self._and([\n                (lambda:\n                    self._match_charseq('t')\n                ),\n                (lambda:\n                    _SemanticAction(lambda: '\\\\t')\n                ),\n            ])\n        )()\n    )(_Vars())\n),\n",
"type":"code"
}
],
"id":"f7ebd9cde05041dd83e33bacd3bf2d0e",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The semantic action does not return a tab character but rather two characters: '",
"type":"text"
},
{
"text":"\\",
"type":"code"
},
{
"text":"' and '",
"type":"text"
},
{
"text":"t",
"type":"code"
},
{
"text":"'.",
"type":"text"
}
],
"id":"82a056abf1f845d598e345933ec326bc",
"type":"text"
},
{
"fragments":[
{
"text":"Why is it still a metacompiler? Because tab is not used.",
"type":"text"
}
],
"id":"357049865f34435c8cd6a0f77ff600f4",
"type":"text"
},
{
"fragments":[
{
"text":"How can semantic action be made to return a tab character?",
"type":"text"
}
],
"id":"dcee60e01ed44ef09ae428ddc4cf4bab",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"escape = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n       | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n       | 't'  -> tab()\n",
"type":"code"
}
],
"id":"0b15794e6edb40e2ab156155efcfb688",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"Add following to Python template to give generated code access to ",
"type":"text"
},
{
"text":"tab",
"type":"code"
},
{
"text":" function:",
"type":"text"
}
],
"id":"cd062d599a9a4ccba2a125313deeeb7d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"tab = lambda: \"\\t\"\n",
"type":"code"
}
],
"id":"1a43c1ff6fb84e989507f0368235a00d",
"language":"python",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./meta_compile.sh\nOK\n",
"type":"code"
}
],
"id":"a074bca6bd3441aeb22b187f2c1939dd",
"type":"code"
},
{
"fragments":[
{
"text":"The code generated for the tab case:",
"type":"text"
}
],
"id":"e7ca3979a4a740f09f614d1846d9537b",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    (lambda _vars:\n        (lambda:\n            self._and([\n                (lambda:\n                    self._match_charseq('t')\n                ),\n                (lambda:\n                    _SemanticAction(lambda: tab(\n                    ))\n                ),\n            ])\n        )()\n    )(_Vars())\n),\n",
"type":"code"
}
],
"id":"883aa54c39e94bbaad439939e0f5b926",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"Semantic action now generates tab characters correctly. And ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" becomes the next version of the metacompiler:",
"type":"text"
}
],
"id":"82b9d4a3e9304a40ae632a7de85d6554",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./is_metacompiler.sh rlmeta1.py\nrlmeta1.py is a metacompiler!\n",
"type":"code"
}
],
"id":"90c40374b1cc46109c8ce8886ca331db",
"type":"code"
},
{
"fragments":[
{
"text":"Now the new escape can be used and the ",
"type":"text"
},
{
"text":"tab",
"type":"code"
},
{
"text":" function discarded.",
"type":"text"
}
],
"id":"288a7dca0e0a441c86e15445126d3870",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"escape = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n       | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n       | 't'  -> \"\\t\"\n",
"type":"code"
}
],
"id":"920ef986ed9541cc8ac8fa3f42df4199",
"language":"rlmeta",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./meta_compile.sh\nOK\n",
"type":"code"
}
],
"id":"565991516f3244979d33aa4e1103053d",
"type":"code"
},
{
"fragments":[
{
"text":"The code generated for the tab case:",
"type":"text"
}
],
"id":"a2895180d45846458539aeaaf37837fe",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    (lambda _vars:\n        (lambda:\n            self._and([\n                (lambda:\n                    self._match_charseq('t')\n                ),\n                (lambda:\n                    _SemanticAction(lambda: '\\t')\n                ),\n            ])\n        )()\n    )(_Vars())\n),\n",
"type":"code"
}
],
"id":"1d5d027c53e04af8953e529629cdaf8e",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"Adding the tab escaped required two passes: one to recognize it and one to actually use it.",
"type":"text"
}
],
"id":"3eebfda49d064c088d05b8fe29d1a17b",
"type":"text"
}
],
"title":"Adding a new escape character"
},
{
"children":[],
"id":"22e574102e394218b874f03bb879c92f",
"paragraphs":[
{
"fragments":[
{
"text":"Changing syntax in steps: 1) modify grammar to accept new syntax 2) feed updated grammar to new compiler.",
"type":"text"
}
],
"id":"73adf0902f014946b6a0b1812588ef8c",
"type":"text"
},
{
"fragments":[
{
"text":"Change ",
"type":"text"
},
{
"text":"->",
"type":"code"
},
{
"text":" to ",
"type":"text"
},
{
"text":"=>",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"0e6aee95f12d497a9b442328f1625d1a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta.py > rlmeta1.py\n",
"type":"code"
}
],
"id":"3dd5db4ace854e82931dfd6171c212be",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta.py -> rlmeta1.py\n",
"type":"code"
}
],
"id":"6e5380ea659241caa4ed3887cc42f673",
"type":"code"
},
{
"fragments":[
{
"text":"Compile again:",
"type":"text"
}
],
"id":"19fe90ba72334446940c87e686283e51",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > crash\n",
"type":"code"
}
],
"id":"faad43f0a420409f945c54adeef57ff9",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source -> rlmeta1.py -> crash\n",
"type":"code"
}
],
"id":"fe1af25f326b4996a0cc48c63a086c25",
"type":"code"
},
{
"fragments":[
{
"text":"What happened? ",
"type":"text"
},
{
"text":"rlmeta1.py",
"type":"code"
},
{
"text":" expects the syntax to be ",
"type":"text"
},
{
"text":"=>",
"type":"code"
},
{
"text":", but the modified source is still using ",
"type":"text"
},
{
"text":"->",
"type":"code"
},
{
"text":". Modify again.",
"type":"text"
}
],
"id":"f769c4e316fa441d8880b645f239757d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ ./compile.sh rlmeta1.py > crash\n",
"type":"code"
}
],
"id":"9f7f9aacfac645f2a67084c7ff963612",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"modified source 2 -> rlmeta1.py -> rlmeta2.py\n",
"type":"code"
}
],
"id":"0e3a7c1754644293a95ad0deaca3b680",
"type":"code"
},
{
"fragments":[
{
"text":"Metacompile script will not work here :(",
"type":"text"
}
],
"id":"98d47194afe6453fb7ea05fb612a8dca",
"type":"text"
}
],
"title":"Modifying grammar syntax"
},
{
"children":[
{
"children":[],
"id":"df676d8cca604142bd1049c5e86c68a2",
"paragraphs":[
{
"code_id":"ef234944361c48eeb16387d8014a4c9b",
"id":"8f508048c2074e7694a93b1182126307",
"type":"expanded_code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"38ee00b5ef7c40f79d24fa61f052368f",
"paragraphs":[
{
"code_id":"bd7e31bf3ea7456f975830d5bf2ef05c",
"id":"7c615378b9b64ca3b811bc614095b4ed",
"type":"expanded_code"
}
],
"title":"meta_compile.sh"
}
],
"id":"60cb5d0ff4ca4d94920bfe635ffd2142",
"paragraphs":[
{
"fragments":[
{
"text":"Only changes from original RLMeta is the compile.sh script and the additional meta compile script. Full sources on github.",
"type":"text"
}
],
"id":"969153820b334d91838f46bfd52388ad",
"type":"text"
}
],
"title":"Code listings for RLMeta"
},
{
"children":[],
"id":"cce4fba25b5d4b8489e0f311619bdf11",
"paragraphs":[
{
"fragments":[
{
"text":"Better format for intro of changes?",
"type":"text"
}
],
"id":"7750e99bcb064e368a2164c551800494",
"type":"text"
},
{
"fragments":[
{
"text":"Introduce meta compile script earlier?",
"type":"text"
}
],
"id":"f6d1de44e7a74d7aa99182e6af72c883",
"type":"text"
}
],
"title":"TODO"
}
],
"id":"7b987f7cd685486da72bf77dcd0b3f29",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I explain how to modify the RLMeta metacompiler and how modifying it is different from modifying a regular program.",
"type":"text"
}
],
"id":"4d967f1bcd054206b4731c141ff9822a",
"type":"text"
}
],
"title":"Modifying RLMeta"
},
"variables":{}
}