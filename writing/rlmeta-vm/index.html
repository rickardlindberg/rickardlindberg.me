<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      RLMeta: a VM based approach | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>RLMeta: a VM based approach</h1>

<p><em>Published on  6 August 2019.</em></p>

<p>In this article I present an alternative implementation of <a href="../../writing/rlmeta/">RLMeta</a> in which grammars are compiled into instructions for a virtual machine (VM).</p>
<p>The VM based version builds upon the <a href="../../writing/optimizing-rlmeta/">optimized version</a> and the implementation is inspired by <a href="https://swtch.com/~rsc/regexp/regexp2.html">Regular Expression Matching: the Virtual Machine Approach</a> and <a href="http://www.inf.puc-rio.br/%7Eroberto/docs/peg.pdf">A Text Pattern-Matching Tool based on Parsing Expression Grammars</a>.</p>
<ul>
<li><a href="#3df386e2afb1452b87a29185c2de0673">Big picture difference</a></li>
<li><a href="#d1a2d050fcc444cfa4991b968a02a315">Parser</a></li>
<li><a href="#24aa83d59704475dba2a010f1b5d3eb0">Code generator</a>
<ul>
<li><a href="#8fc432da8cb94c91baeba2ee6b69f40b">Grammar</a></li>
<li><a href="#72b77f7c8a594757a67ef61f9502f8e9">Rule</a></li>
<li><a href="#613d04f41a3e4521ad022a3d4e0237ea">Or</a></li>
<li><a href="#e0d721aa4fae40af8de5a54253243cb0">Scope</a></li>
<li><a href="#34ee0862096d4fd4aa3342c4b3b6c294">And</a></li>
<li><a href="#8275c4d4e16c483f84be55f550e3d39c">Bind</a></li>
<li><a href="#963d53648b304544be75045e59c6e183">Star</a></li>
<li><a href="#0efe424b680f477a9bb8c1b9f679ff84">Not</a></li>
<li><a href="#24675b6707284a99ba3d3cb17b60e3f2">MatchCallRule</a></li>
<li><a href="#629b7ffad2d54725ad0af4e73bf434d8">Label</a></li>
<li><a href="#4ddebcb41511403c8b3fa5c96f14c8f4">SemanticAction</a></li>
<li><a href="#fc62b5be27fd4e40978d415ba4070a05">MatchRule</a></li>
<li><a href="#ce3171f9336a4f1a961f4d6fd6665361">MatchRange</a></li>
<li><a href="#40fcdbbabfe44b009d3f405060a2055f">MatchString</a></li>
<li><a href="#c6e2326b6b774601b761538455918bbe">MatchCharseq</a></li>
<li><a href="#de0847d410c6495d9a8ee4e75a0423cc">MatchAny</a></li>
<li><a href="#1dc829aba4484ed399eb025d01ed843e">MatchList</a></li>
<li><a href="#6cc83570ba674d71bccd12660fddefcc">Example revisited</a></li>
</ul></li>
<li><a href="#e66f8cec6206420abe4736ae32849c53">VM</a>
<ul>
<li><a href="#8f0fffeab7084a1d9b01d928be4878a8">MATCH_ANY</a></li>
<li><a href="#a8160d30b886418882ada3a2a884e580">MATCH_STRING</a></li>
<li><a href="#d8dcb57d5da141908f28f8c52983d1a6">MATCH_RANGE</a></li>
<li><a href="#df5dc1b5e5054e548d5c3606daba0d55">MATCH_CHARSEQ</a></li>
<li><a href="#49ca0a2fa665466cb90c8c128d5cc835">PUSH_SCOPE</a></li>
<li><a href="#b2510846e20d4cd08f9b0cd2dfb5c01d">POP_SCOPE</a></li>
<li><a href="#1315305641224e4aa99dd00ec5b524b1">BIND</a></li>
<li><a href="#738356fde86e4c7290b0f99850917ba8">ACTION</a></li>
<li><a href="#d7d285d9586b437ca7d7f51b5deb6193">LABEL</a></li>
<li><a href="#b3562467300348028f04ae5034db0f34">LIST_START</a></li>
<li><a href="#b4aacd38dec8406c9db784e0823c3554">LIST_APPEND</a></li>
<li><a href="#9940cd44d7fe4777b1c12e335bac33ae">LIST_END</a></li>
<li><a href="#fee2dcf573f04ac3a9e7cfd92adbe0c8">PUSH_STREAM</a></li>
<li><a href="#87a1eee2cfb94e1a9463a6561c226012">POP_STREAM</a></li>
<li><a href="#34915cae29994179abbe19f2f7e4c267">FAIL</a></li>
<li><a href="#8e19cbb2e71c412f95c7e241a69f0901">CALL</a></li>
<li><a href="#d42df29209bf475280ac510d9ae31182">MATCH_CALL_RULE</a></li>
<li><a href="#d104aa6d6b8e43818f662498f6566e38">RETURN</a></li>
<li><a href="#542906286e124874b2975d0ae23f034f">BACKTRACK</a></li>
<li><a href="#5b99ed36fbde45989829fde6e17d4821">COMMIT</a></li>
<li><a href="#77edfc243204447ba84468c78f05d8e5">Handling failure</a></li>
<li><a href="#95ffb1abf59546e1972c78ee7159b758">Optimizations</a></li>
</ul></li>
<li><a href="#2e3ad1de345642658be2e5910ab5be4e">Note on size</a></li>
<li><a href="#c490369b053247c0b7761f324658aa15">Note on performance</a></li>
<li><a href="#7e7b4c5318ff4c849c6e98e9ddeaacf0">Code listings for RLMeta</a>
<ul>
<li><a href="#53f0708b231b468d844291df3fe17cf2">parser.rlmeta</a></li>
<li><a href="#74bf51f7e8d94bcba1747edb477137ef">codegenerator.rlmeta</a></li>
<li><a href="#60ff77cb85fa455589e3e45cdeac8160">support.py</a></li>
<li><a href="#338ad257e61e4025b8859d610a475c6a">compile.sh</a></li>
<li><a href="#272d17f2d55749b59d7e5ec7b9b8e0ec">meta_compile.sh</a></li>
</ul></li>
</ul>
<h2 id="df386e2afb1452b87a29185c2de0673big-picture-difference">[]{#3df386e2afb1452b87a29185c2de0673}Big picture difference</h2>
<p>The optimized version compiles grammars into Python classes which can be used like this:</p>
<pre class="text"><code>g = Grammar()
result = g.run(&quot;foo&quot;, &quot;input string&quot;)</code></pre>
<p>The VM based version also compiles grammars into Python classes with the same interface. The difference is how the <code>run</code> method is implemented. In the optimized version, it calls methods that represent rules in the grammar. The above call would result in <code>_rule_foo</code> being called. That in turn would make calls to other methods representing other rules in the grammar. The VM based version instead has a sequence of instructions and a program counter that keeps track of which instruction to execute. The VM is invoked from the <code>run</code> method.</p>
<p>To make the difference more clear, let's look at the <code>Scream</code> grammar that turns its input into a screaming equivalent (<code>hello</code> to <code>HELLO!!</code> for example):</p>
<pre class="text"><code>Scream {
  scream = char*:xs -&gt; { xs &quot;!!&quot; }
  char   = .:x      -&gt; upper(x)
}</code></pre>
<p>The optimized version compiles it into the following class with one method per rule in the grammar:</p>
<pre class="text"><code>class Scream(_Grammar):

    def _rule_scream(self):
        return (lambda: (lambda _vars:
            (lambda: self._and([
                (lambda: _vars.bind('xs', (lambda: self._star((lambda: self._match_rule('char'))))())),
                (lambda: _SemanticAction(lambda: _Builder.create([
                    _vars.lookup('xs').eval(),
                    '!!',
                ]))),
            ]))()
        )(_Vars()))()

    def _rule_char(self):
        return (lambda: (lambda _vars:
            (lambda: self._and([
                (lambda: _vars.bind('x', self._match_any())),
                (lambda: _SemanticAction(lambda: upper(
                    _vars.lookup('x').eval(),
                ))),
            ]))()
        )(_Vars()))()</code></pre>
<p>The VM based version compiles it into the following class with a sequence of instructions (don't worry about understanding them now, it will be clear later what the instructions mean):</p>
<pre class="text"><code>class Scream(_Grammar):

    def __init__(self):
        self._instructions = i = []
        self._labels = l = {}
        def I(name, x=None, y=None):
            i.append((name, x, y))
        def LABEL(name):
            l[name] = len(i)
        LABEL('scream')
        I('PUSH_SCOPE')
        I('LIST_START')
        LABEL(0)
        I('BACKTRACK', 1)
        I('CALL', 'char')
        I('LIST_APPEND')
        I('COMMIT', 0)
        LABEL(1)
        I('LIST_END')
        I('BIND', 'xs')
        I('ACTION', lambda scope: _Builder.create([scope['xs'].eval(), '!!']))
        I('POP_SCOPE')
        I('RETURN')
        LABEL('char')
        I('PUSH_SCOPE')
        I('MATCH_ANY')
        I('BIND', 'x')
        I('ACTION', lambda scope: upper(scope['x'].eval()))
        I('POP_SCOPE')
        I('RETURN')</code></pre>
<p>The external interface of the classes is exactly the same, but internally they look rather different. The <code>run</code> method in the optimized version looks like this:</p>
<pre class="text"><code>def run(self, rule_name, input_object):
    self._memo = _Memo()
    self._stream = _Stream.from_object(self._memo, input_object)
    result = self._match_rule(rule_name).eval()
    if isinstance(result, _Builder):
        return result.build_string()
    else:
        return result</code></pre>
<p>It does some setup and then calls <code>_match_rule</code> to start matching.</p>
<p>The <code>run</code> method in the VM based version looks like this:</p>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> _Grammar(<span class="bu">object</span>):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule_name, input_object):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(input_object, <span class="bu">basestring</span>):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>            stream <span class="op">=</span> input_object</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>            stream <span class="op">=</span> [input_object]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>        result <span class="op">=</span> rlmeta_vm(<span class="va">self</span>._instructions, <span class="va">self</span>._labels, rule_name, stream)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(result, _Builder):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>            <span class="cf">return</span> result.build_string()</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>            <span class="cf">return</span> result</span></code></pre></div>
<p>It also does some setup, but then it hands over the instructions (that are created in the <code>__init__</code> method) to the VM that then executes them.</p>
<p>In the rest of this article I explain how grammars are compiled into VM instructions and how the VM is implemented.</p>
<h2 id="parser"><span id="d1a2d050fcc444cfa4991b968a02a315"></span>Parser</h2>
<p>The parser in the VM based version has one additional rule for labels:</p>
<pre><code>1.  parser.rlmeta
2.  [expr1]{.cp}</code></pre>
<pre class="rlmeta"><code>| space '#' -&gt; [&quot;Label&quot;]</code></pre>
<p>A label returns a semantic action that evaluates to a unique number. You will see later (in <a href="#613d04f41a3e4521ad022a3d4e0237ea"><em>Or</em></a>, <a href="#963d53648b304544be75045e59c6e183"><em>Star</em></a>, and <a href="#0efe424b680f477a9bb8c1b9f679ff84"><em>Not</em></a>) how it is used in the code generator.</p>
<p>The label feature first had to be added to the optimized version before it could be used to compile the VM based version. That implementation is not shown in this article, but the implementation of labels in the VM based version is similar.</p>
<p>The rest of the parser is exactly the same as in the optimized version:</p>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  grammar =
    | name:x space '{' rule*:ys space '}'      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space '=' choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space '|')?
      sequence:x (space '|' sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space ':' name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space '*'                        -&gt; [&quot;Star&quot; x]
    | expr2:x space '?'                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space '!' expr2:x                        -&gt; [&quot;Not&quot; x]
    | space '%'                                -&gt; [&quot;MatchCallRule&quot;]
    &lt;&lt;expr1&gt;&gt;
    | expr2
  expr2 =
    | space '-&gt;' hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space '=')                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x '-' char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space '.'                                -&gt; [&quot;MatchAny&quot;]
    | space '(' choice:x space ')'             -&gt; x
    | space '[' expr*:xs space ']'             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space '[' hostExprListItem*:xs space ']' -&gt; [&quot;List&quot; ~xs]
    | space '{' buildExpr*:xs space '}'        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space '(' hostExpr*:ys space ')'  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space '~' hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space '&gt;'                                -&gt; [&quot;IndentBuilder&quot;]
    | space '&lt;'                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = '&quot;'  (!'&quot;'  innerChar)*:xs '&quot;'   -&gt; join(xs)
  charseq   = '\'' (!'\'' innerChar)*:xs '\''  -&gt; join(xs)
  char      = '\''  !'\'' innerChar  :x  '\''  -&gt; x
  innerChar = '\\' escape | .
  escape    = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
            | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = 'a'-'z' | 'A'-'Z'
  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'
  space     = (' ' | '\n')*
}</code></pre>
<h2 id="aa83d59704475dba2a010f1b5d3eb0code-generator">[]{#24aa83d59704475dba2a010f1b5d3eb0}Code generator</h2>
<p>The code generator in the VM based version is similarly structured to the code generator in the optimized version with a grammar and a support library:</p>
<pre><code>1.  codegenerator.rlmeta</code></pre>
<pre class="rlmeta"><code>CodeGenerator {
  &lt;&lt;rules&gt;&gt;
}</code></pre>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="op">&lt;&lt;</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="op">&lt;&lt;</span>vm<span class="op">&gt;&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="op">&lt;&lt;</span>classes<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>The <code>ast</code> rule is exactly the same as in the optimized version:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>ast = [%:x] -&gt; x</code></pre>
<p>Then there is an additional rule for when a Python representation of a value is needed:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>py = .:x -&gt; repr(x)</code></pre>
<p>Let's move on and look at how VM instructions are generated.</p>
<h3 id="fc432da8cb94c91baeba2ee6b69f40bgrammar">[]{#8fc432da8cb94c91baeba2ee6b69f40b}Grammar</h3>
<p>When a <code>Grammar</code> AST node is matched, a Python class inheriting <code>_Grammar</code> is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Grammar = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(_Grammar):\n\n&quot; &gt;
                             &quot;def __init__(self):\n&quot; &gt;
                               &quot;self._instructions = i = []\n&quot;
                               &quot;self._labels = l = {}\n&quot;
                               &quot;def I(name, x=None, y=None):\n&quot; &gt;
                                 &quot;i.append((name, x, y))\n&quot;
                               &lt;
                               &quot;def LABEL(name):\n&quot; &gt;
                                 &quot;l[name] = len(i)\n&quot;
                               &lt;
                               ys
                             &lt;
                           &lt; }</code></pre>
<p>The name of the class is the same as the name of the grammar.</p>
<p>The <code>__init__</code> method has functionality for creating instructions. An instruction is represented as a tuple with three elements: the name, the first argument, and the second argument. Arguments can be <code>None</code>. Instructions are stored in a list. Labels map names to positions in the instruction list and are stored in a dictionary.</p>
<p>Shorthand names <code>i</code> and <code>l</code> are used instead of <code>self._instructions</code> and <code>self._labels</code> because they are faster. Not using <code>self</code> reduces one dictionary lookup.</p>
<p>The child AST nodes of <code>Grammar</code> are assumed to use the <code>I</code> and <code>LABEL</code> functions to create instructions.</p>
<h3 id="b77f7c8a594757a67ef61f9502f8e9rule">[]{#72b77f7c8a594757a67ef61f9502f8e9}Rule</h3>
<p>When a <code>Rule</code> AST node is matched, instructions representing a function are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Rule = py:x ast:y -&gt; { &quot;LABEL(&quot; x &quot;)\n&quot;
                       y
                       &quot;I('RETURN')\n&quot; }</code></pre>
<p>In assembly-like notation (where labels are in the first column and instructions are in the second column) it looks like this:</p>
<pre class="text"><code>&lt;x&gt;:
    &lt;y instructions&gt;
    RETURN</code></pre>
<p>The label name is the name of the rule. <a href="#d104aa6d6b8e43818f662498f6566e38"><em>RETURN</em></a> instructs the VM to continue execution at wherever it was before calling this rule.</p>
<h3 id="d04f41a3e4521ad022a3d4e0237eaor">[]{#613d04f41a3e4521ad022a3d4e0237ea}Or</h3>
<p>When an <code>Or</code> AST node is matched, instructions representing a choice are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Or =
  | ast:x Or:y #:a #:b -&gt; { &quot;I('BACKTRACK', &quot; a &quot;)\n&quot;
                            x
                            &quot;I('COMMIT', &quot; b &quot;)\n&quot;
                            &quot;LABEL(&quot; a &quot;)\n&quot;
                            y
                            &quot;LABEL(&quot; b &quot;)\n&quot; }
  | ast</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>    BACKTRACK a
    &lt;x instructions&gt;
    COMMIT b
a:
    &lt;y instructions&gt;
b:</code></pre>
<p><a href="#542906286e124874b2975d0ae23f034f"><em>BACKTRACK</em></a> instructs the VM to push a backtrack entry onto the stack so that it can try matching again at label <code>a</code> if the <code>x</code> instructions fail. <a href="#5b99ed36fbde45989829fde6e17d4821"><em>COMMIT</em></a> instructs the VM to pop this backtrack entry off the stack and continue execution at label <code>b</code>. If <code>x</code> instructions fail, the second choice at label <code>a</code> is tried, otherwise, execution continues at label <code>b</code>. The <code>y</code> instructions might represent another choice or the last choice. If there is only once choice, only instructions for that choice are generated. In that case, no <code>BACKTRACK</code> and <code>COMMIT</code> are needed.</p>
<h3 id="scope"><span id="e0d721aa4fae40af8de5a54253243cb0"></span>Scope</h3>
<p>When a <code>Scope</code> AST node is matched, instructions creating a new scope are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Scope = ast:x -&gt; { &quot;I('PUSH_SCOPE')\n&quot;
                   x
                   &quot;I('POP_SCOPE')\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>PUSH_SCOPE
&lt;x instructions&gt;
POP_SCOPE</code></pre>
<p><a href="#49ca0a2fa665466cb90c8c128d5cc835"><em>PUSH_SCOPE</em></a> instructs the VM to push a new scope onto the stack so that all bindings that are done by <code>x</code> instructions happen in this new scope. <a href="#b2510846e20d4cd08f9b0cd2dfb5c01d"><em>POP_SCOPE</em></a> instructs the VM to pop this scope off the stack.</p>
<h3 id="ee0862096d4fd4aa3342c4b3b6c294and">[]{#34ee0862096d4fd4aa3342c4b3b6c294}And</h3>
<p>When an <code>And</code> AST node is matched, instructions for all items in the sequence are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>And = ast*</code></pre>
<h3 id="c4d4e16c483f84be55f550e3d39cbind">[]{#8275c4d4e16c483f84be55f550e3d39c}Bind</h3>
<p>When a <code>Bind</code> AST node is matched, instructions binding the last result to a name are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Bind = py:x ast:y -&gt; { y
                       &quot;I('BIND', &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>&lt;y instructions&gt;
BIND &lt;x&gt;</code></pre>
<p><a href="#1315305641224e4aa99dd00ec5b524b1"><em>BIND</em></a> instructs the VM to bind the last result from <code>y</code> instructions to the name <code>x</code> in the current scope.</p>
<h3 id="d53648b304544be75045e59c6e183star">[]{#963d53648b304544be75045e59c6e183}Star</h3>
<p>When a <code>Star</code> AST node is matched, instructions representing a repetition are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Star = ast:x #:a #:b -&gt; { &quot;I('LIST_START')\n&quot;
                          &quot;LABEL(&quot; a &quot;)\n&quot;
                          &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                          x
                          &quot;I('LIST_APPEND')\n&quot;
                          &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                          &quot;LABEL(&quot; b &quot;)\n&quot;
                          &quot;I('LIST_END')\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>    LIST_START
a:
    BACKTRACK b
    &lt;x instructions&gt;
    LIST_APPEND
    COMMIT a
b:
    LIST_END</code></pre>
<p><a href="#b3562467300348028f04ae5034db0f34"><em>LIST_START</em></a> instructs the VM to create a new list for accumulating results. <a href="#b4aacd38dec8406c9db784e0823c3554"><em>LIST_APPEND</em></a> instructs the VM to append the last result to this list. <a href="#9940cd44d7fe4777b1c12e335bac33ae"><em>LIST_END</em></a> instructs the VM to make this list itself the last result. The <code>BACKTRACK</code> and <code>COMMIT</code> instructions are used to create control flow for a loop. As long as <code>x</code> instructions succeed, the program loops between label <code>a</code> and the <code>COMMIT</code> instruction. As soon as <code>x</code> instructions fail, the program continues execution at label <code>b</code>.</p>
<h3 id="efe424b680f477a9bb8c1b9f679ff84not">[]{#0efe424b680f477a9bb8c1b9f679ff84}Not</h3>
<p>When a <code>Not</code> AST node is matched, instructions representing negative lookahead are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Not = ast:x #:a #:b -&gt; { &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                         x
                         &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                         &quot;LABEL(&quot; a &quot;)\n&quot;
                         &quot;I('FAIL', 'no match expected')\n&quot;
                         &quot;LABEL(&quot; b &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>    BACKTRACK b
    &lt;x instructions&gt;
    COMMIT a
a:
    FAIL 'no match expected'
b:</code></pre>
<p><a href="#34915cae29994179abbe19f2f7e4c267"><em>FAIL</em></a> instructs the VM to fail with the given message. The <code>BACKTRACK</code> and <code>COMMIT</code> instructions are used to create control flow for negative lookahead. If <code>x</code> instructions succeed, the <code>COMMIT</code> instruction makes the program continue at label <code>a</code>. That immediately fails because the negative lookahead does not expect a match. If <code>x</code> instructions fail, the program continues execution at label <code>b</code>, and the <code>FAIL</code> instruction is skipped.</p>
<h3 id="b6707284a99ba3d3cb17b60e3f2matchcallrule">[]{#24675b6707284a99ba3d3cb17b60e3f2}MatchCallRule</h3>
<p>When a <code>MatchCallRule</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchCallRule = -&gt; { &quot;I('MATCH_CALL_RULE')\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_CALL_RULE</code></pre>
<p><a href="#d42df29209bf475280ac510d9ae31182"><em>MATCH_CALL_RULE</em></a> instructs the VM to call the rule denoted by the current input object.</p>
<h3 id="b7ffad2d54725ad0af4e73bf434d8label">[]{#629b7ffad2d54725ad0af4e73bf434d8}Label</h3>
<p>When a <code>Label</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>Label = -&gt; { &quot;I('LABEL')\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>LABEL</code></pre>
<p><a href="#d7d285d9586b437ca7d7f51b5deb6193"><em>LABEL</em></a> instructs the VM to create a semantic action that evaluates to a unique number.</p>
<h3 id="ddebcb41511403c8b3fa5c96f14c8f4semanticaction">[]{#4ddebcb41511403c8b3fa5c96f14c8f4}SemanticAction</h3>
<p>When a <code>SemanticAction</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>SemanticAction = ast:x -&gt; { &quot;I('ACTION', lambda scope: &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>ACTION &lt;python lambda&gt;</code></pre>
<p><a href="#738356fde86e4c7290b0f99850917ba8"><em>ACTION</em></a> instructs the VM to create a user defined a semantic action. If there is a match, it will be called with the scope that was active when the action was defined.</p>
<p>Semantic actions are not evaluated by the VM, but rather by Python. The VM is only responsible for matching and creating semantic actions as results.</p>
<p>The lambda expression that is the first argument is generated by the following rules similarly to how it was done in the optimized version:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>String        = py
List          = astList
Builder       = astItems:x      -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot; }
IndentBuilder =                 -&gt; { &quot;_IndentBuilder()&quot;         }
DedentBuilder =                 -&gt; { &quot;_DedentBuilder()&quot;         }
FnCall        = .:x astItems:y  -&gt; { x &quot;(&quot; y &quot;)&quot;                }
VarLookup     = py:x            -&gt; { &quot;scope[&quot; x &quot;].eval()&quot;      }
astItems      =
  | ast:x astItem*:xs           -&gt; { x xs                       }
  |                             -&gt; {                            }
astItem       = ast:x           -&gt; { &quot;, &quot; x                     }
astList       = astListItem*:xs -&gt; { &quot;(&quot; xs &quot;[])&quot;               }
astListItem   =
  | [&quot;ListItemSplice&quot; ast:x]    -&gt; {     x  &quot;+&quot;                 }
  | ast:x                       -&gt; { &quot;[&quot; x &quot;]+&quot;                 }</code></pre>
<p>The related pieces in the support library are exactly the same as in the optimized version:</p>
<pre><code>1.  support.py
2.  [imports]{.cp}</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="cf">try</span>:</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a>    <span class="im">from</span> cStringIO <span class="im">import</span> StringIO</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a><span class="cf">except</span>:</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>    <span class="im">from</span> StringIO <span class="im">import</span> StringIO</span></code></pre></div>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a><span class="kw">class</span> _Builder(<span class="bu">object</span>):</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true"></a>    <span class="kw">def</span> build_string(<span class="va">self</span>):</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true"></a>        output <span class="op">=</span> _Output()</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true"></a>        <span class="va">self</span>.write(output)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true"></a>        <span class="cf">return</span> output.value</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true"></a>    <span class="at">@classmethod</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true"></a>    <span class="kw">def</span> create(<span class="va">self</span>, item):</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(item, _Builder):</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true"></a>            <span class="cf">return</span> item</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>):</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true"></a>            <span class="cf">return</span> _ListBuilder([_Builder.create(x) <span class="cf">for</span> x <span class="kw">in</span> item])</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true"></a>            <span class="cf">return</span> _AtomBuilder(item)</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true"></a></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true"></a><span class="kw">class</span> _Output(<span class="bu">object</span>):</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true"></a></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true"></a>        <span class="va">self</span>.<span class="bu">buffer</span> <span class="op">=</span> StringIO()</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true"></a>        <span class="va">self</span>.indentation <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true"></a>        <span class="va">self</span>.on_newline <span class="op">=</span> <span class="va">True</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true"></a></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true"></a>    <span class="at">@property</span></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true"></a>    <span class="kw">def</span> value(<span class="va">self</span>):</span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">buffer</span>.getvalue()</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true"></a></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, value):</span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true"></a>        <span class="cf">for</span> ch <span class="kw">in</span> value:</span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true"></a>            is_linebreak <span class="op">=</span> ch <span class="op">==</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>.indentation <span class="kw">and</span> <span class="va">self</span>.on_newline <span class="kw">and</span> <span class="kw">not</span> is_linebreak:</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true"></a>                <span class="va">self</span>.<span class="bu">buffer</span>.write(<span class="st">&quot;    &quot;</span><span class="op">*</span><span class="va">self</span>.indentation)</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true"></a>            <span class="va">self</span>.<span class="bu">buffer</span>.write(ch)</span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true"></a>            <span class="va">self</span>.on_newline <span class="op">=</span> is_linebreak</span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true"></a></span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true"></a><span class="kw">class</span> _ListBuilder(_Builder):</span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true"></a></span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, builders):</span>
<span id="cb56-39"><a href="#cb56-39" aria-hidden="true"></a>        <span class="va">self</span>.builders <span class="op">=</span> builders</span>
<span id="cb56-40"><a href="#cb56-40" aria-hidden="true"></a></span>
<span id="cb56-41"><a href="#cb56-41" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-42"><a href="#cb56-42" aria-hidden="true"></a>        <span class="cf">for</span> builder <span class="kw">in</span> <span class="va">self</span>.builders:</span>
<span id="cb56-43"><a href="#cb56-43" aria-hidden="true"></a>            builder.write(output)</span>
<span id="cb56-44"><a href="#cb56-44" aria-hidden="true"></a></span>
<span id="cb56-45"><a href="#cb56-45" aria-hidden="true"></a><span class="kw">class</span> _AtomBuilder(_Builder):</span>
<span id="cb56-46"><a href="#cb56-46" aria-hidden="true"></a></span>
<span id="cb56-47"><a href="#cb56-47" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, atom):</span>
<span id="cb56-48"><a href="#cb56-48" aria-hidden="true"></a>        <span class="va">self</span>.atom <span class="op">=</span> atom</span>
<span id="cb56-49"><a href="#cb56-49" aria-hidden="true"></a></span>
<span id="cb56-50"><a href="#cb56-50" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-51"><a href="#cb56-51" aria-hidden="true"></a>        output.write(<span class="bu">str</span>(<span class="va">self</span>.atom))</span>
<span id="cb56-52"><a href="#cb56-52" aria-hidden="true"></a></span>
<span id="cb56-53"><a href="#cb56-53" aria-hidden="true"></a><span class="kw">class</span> _IndentBuilder(_Builder):</span>
<span id="cb56-54"><a href="#cb56-54" aria-hidden="true"></a></span>
<span id="cb56-55"><a href="#cb56-55" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-56"><a href="#cb56-56" aria-hidden="true"></a>        output.indentation <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb56-57"><a href="#cb56-57" aria-hidden="true"></a></span>
<span id="cb56-58"><a href="#cb56-58" aria-hidden="true"></a><span class="kw">class</span> _DedentBuilder(_Builder):</span>
<span id="cb56-59"><a href="#cb56-59" aria-hidden="true"></a></span>
<span id="cb56-60"><a href="#cb56-60" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb56-61"><a href="#cb56-61" aria-hidden="true"></a>        output.indentation <span class="op">-=</span> <span class="dv">1</span></span></code></pre></div>
<h3 id="matchrule"><span id="fc62b5be27fd4e40978d415ba4070a05"></span>MatchRule</h3>
<p>When a <code>MatchRule</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchRule = py:x -&gt; { &quot;I('CALL', &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>CALL &lt;x&gt;</code></pre>
<p><a href="#8e19cbb2e71c412f95c7e241a69f0901"><em>CALL</em></a> instructs the VM to call the given rule.</p>
<h3 id="matchrange"><span id="ce3171f9336a4f1a961f4d6fd6665361"></span>MatchRange</h3>
<p>When a <code>MatchRange</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchRange = py:x py:y -&gt; { &quot;I('MATCH_RANGE', &quot; x &quot;, &quot; y &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_RANGE &lt;x&gt; &lt;y&gt;</code></pre>
<p><a href="#d8dcb57d5da141908f28f8c52983d1a6"><em>MATCH_RANGE</em></a> instructs the VM to match an object in the given range.</p>
<h3 id="fcdbbabfe44b009d3f405060a2055fmatchstring">[]{#40fcdbbabfe44b009d3f405060a2055f}MatchString</h3>
<p>When a <code>MatchString</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchString = py:x -&gt; { &quot;I('MATCH_STRING', &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_STRING &lt;x&gt;</code></pre>
<p><a href="#a8160d30b886418882ada3a2a884e580"><em>MATCH_STRING</em></a> instructs the VM to match the given string.</p>
<h3 id="matchcharseq"><span id="c6e2326b6b774601b761538455918bbe"></span>MatchCharseq</h3>
<p>When a <code>MatchCharseq</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchCharseq = py:x -&gt; { &quot;I('MATCH_CHARSEQ', &quot; x &quot;)\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_CHARSEQ &lt;x&gt;</code></pre>
<p><a href="#df5dc1b5e5054e548d5c3606daba0d55"><em>MATCH_CHARSEQ</em></a> instructs the VM to match the given sequence of characters.</p>
<h3 id="matchany"><span id="de0847d410c6495d9a8ee4e75a0423cc"></span>MatchAny</h3>
<p>When a <code>MatchAny</code> AST node is matched, an instruction representing that operation is generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchAny = -&gt; { &quot;I('MATCH_ANY')\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>MATCH_ANY</code></pre>
<p><a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> instructs the VM to match any object.</p>
<h3 id="dc829aba4484ed399eb025d01ed843ematchlist">[]{#1dc829aba4484ed399eb025d01ed843e}MatchList</h3>
<p>When a <code>MatchList</code> AST node is matched, instructions changing the input stream are generated:</p>
<pre><code>1.  codegenerator.rlmeta
2.  [rules]{.cp}</code></pre>
<pre class="rlmeta"><code>MatchList = ast:x -&gt; { &quot;I('PUSH_STREAM')\n&quot;
                       x
                       &quot;I('POP_STREAM')\n&quot; }</code></pre>
<p>In assembly-like notation it looks like this:</p>
<pre class="text"><code>PUSH_STREAM
&lt;x instructions&gt;
POP_STREAM</code></pre>
<p><a href="#fee2dcf573f04ac3a9e7cfd92adbe0c8"><em>PUSH_STREAM</em></a> instructs the VM to push the current input object onto the stack so that <code>x</code> instructions see it as the current input stream. <a href="#87a1eee2cfb94e1a9463a6561c226012"><em>POP_STREAM</em></a> instructs the VM to pop this input stream off the stack.</p>
<h3 id="cc83570ba674d71bccd12660fddefccexample-revisited">[]{#6cc83570ba674d71bccd12660fddefcc}Example revisited</h3>
<p>The generated instructions for the <code>Scream</code> grammar from the beginning of the article should now make more sense:</p>
<pre class="text"><code>Scream {
  scream = char*:xs -&gt; { xs &quot;!!&quot; }
  char   = .:x      -&gt; upper(x)
}</code></pre>
<pre class="text"><code>class Scream(_Grammar):

    def __init__(self):
        self._instructions = i = []
        self._labels = l = {}
        def I(name, x=None, y=None):
            i.append((name, x, y))
        def LABEL(name):
            l[name] = len(i)
        LABEL('scream')
        I('PUSH_SCOPE')
        I('LIST_START')
        LABEL(0)
        I('BACKTRACK', 1)
        I('CALL', 'char')
        I('LIST_APPEND')
        I('COMMIT', 0)
        LABEL(1)
        I('LIST_END')
        I('BIND', 'xs')
        I('ACTION', lambda scope: _Builder.create([scope['xs'].eval(), '!!']))
        I('POP_SCOPE')
        I('RETURN')
        LABEL('char')
        I('PUSH_SCOPE')
        I('MATCH_ANY')
        I('BIND', 'x')
        I('ACTION', lambda scope: upper(scope['x'].eval()))
        I('POP_SCOPE')
        I('RETURN')</code></pre>
<p>There are two labels for the two rules in the grammar. Both blocks of instructions end with a <code>RETURN</code> instruction so that those functions can be called and returned from. The blocks are are also wrapped in <code>PUSH_SCOPE</code>/<code>POP_SCOPE</code> instructions so that variable bindings for the different calls happen in different scopes. Otherwise they would overwrite each other. The <code>scream</code> rule has a repetition and therefore also the <code>LIST_*</code> instructions. It also has generated label names (<code>0</code> and <code>1</code>) to create the loop. The <code>BIND</code> instructions bind the last result to a name in the current scope. The <code>ACTION</code> instructions have Python lambdas as first argument that are evaluated when there is a match. They get one argument which is the scope that was active when the action was defined.</p>
<p>Now let's move on to the implementation of the VM to understand how the execution of these instructions work.</p>
<h2 id="vm"><span id="e66f8cec6206420abe4736ae32849c53"></span>VM</h2>
<p>The VM is implemented as a single Python function with the following definition:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}</code></pre>
<div class="sourceCode" id="cb78"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a><span class="kw">def</span> rlmeta_vm(instructions, labels, start_rule, stream):</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a>    <span class="op">&lt;&lt;</span>init<span class="op">&gt;&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a>    <span class="op">&lt;&lt;</span>loop<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>It takes a list of instructions to execute, a dictionary of labels, the name of the start rule, and the input stream. The init section sets up the VM state:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [init]{.cp}</code></pre>
<div class="sourceCode" id="cb80"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>label_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a>last_action <span class="op">=</span> _ConstantSemanticAction(<span class="va">None</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a>pc <span class="op">=</span> labels[start_rule]</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a>call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a>stream, pos, stream_pos_stack <span class="op">=</span> (stream, <span class="dv">0</span>, [])</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a>scope, scope_stack <span class="op">=</span> (<span class="va">None</span>, [])</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a>fail_message <span class="op">=</span> <span class="va">None</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a>latest_fail_message, latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true"></a>memo <span class="op">=</span> {}</span></code></pre></div>
<ul>
<li><code>label_counter</code> is used to generate unique <a href="#d7d285d9586b437ca7d7f51b5deb6193"><em>labels</em></a>.</li>
<li><code>last_action</code> stores the result of the last expression (which is always a semantic action).</li>
<li><code>pc</code> is the program counter that determines what instruction to execute. It is initialized to the position of the start rule.</li>
<li><code>call_backtrack_stack</code> keeps track of what <a href="#8e19cbb2e71c412f95c7e241a69f0901"><em>call</em></a> and <a href="#542906286e124874b2975d0ae23f034f"><em>backtrack</em></a> entries have been made.</li>
<li><code>stream</code> and <code>pos</code> is the topmost item in <code>stream_pos_stack</code> which keeps track of the current input stream and the position in it. (Input streams can be nested.) The topmost item is not stored in the list because it would make it slightly less convenient to modify.</li>
<li><code>scope</code> is the topmost item in <code>scope_stack</code> which keeps track of the current scope. The topmost item is not stored in the list because it would make it slightly less convenient to modify.</li>
<li><code>fail_message</code> stores the current fail message as a tuple representing arguments to string formatting. The fail message is not formatted immediately to avoid the extra speed cost of formatting if the message is not used. (Most fail messages are never used.)</li>
<li><code>latest_fail_message</code> and <code>latest_fail_pos</code> store the latest failure message and its position that will be presented to the user if all choices fail.</li>
<li><code>memo</code> is the memoization table that stores results of rule matches.</li>
</ul>
<p>In a picture it looks something like this:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
Overview of VM.
</center>
<p>After the init section comes the VM loop:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}</code></pre>
<div class="sourceCode" id="cb82"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a>    name, arg1, arg2 <span class="op">=</span> instructions[pc]</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true"></a>    <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;PUSH_SCOPE&quot;</span>:</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>PUSH_SCOPE<span class="op">&gt;&gt;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BACKTRACK&quot;</span>:</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>BACKTRACK<span class="op">&gt;&gt;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;CALL&quot;</span>:</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>CALL<span class="op">&gt;&gt;</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_CHARSEQ&quot;</span>:</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_CHARSEQ<span class="op">&gt;&gt;</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;COMMIT&quot;</span>:</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>COMMIT<span class="op">&gt;&gt;</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_SCOPE&quot;</span>:</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>POP_SCOPE<span class="op">&gt;&gt;</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;RETURN&quot;</span>:</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>RETURN<span class="op">&gt;&gt;</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_APPEND&quot;</span>:</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LIST_APPEND<span class="op">&gt;&gt;</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BIND&quot;</span>:</span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>BIND<span class="op">&gt;&gt;</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;ACTION&quot;</span>:</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>ACTION<span class="op">&gt;&gt;</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_RANGE&quot;</span>:</span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_RANGE<span class="op">&gt;&gt;</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_START&quot;</span>:</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LIST_START<span class="op">&gt;&gt;</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_END&quot;</span>:</span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LIST_END<span class="op">&gt;&gt;</span></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_ANY&quot;</span>:</span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_ANY<span class="op">&gt;&gt;</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;PUSH_STREAM&quot;</span>:</span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>PUSH_STREAM<span class="op">&gt;&gt;</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_STREAM&quot;</span>:</span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>POP_STREAM<span class="op">&gt;&gt;</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_CALL_RULE&quot;</span>:</span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_CALL_RULE<span class="op">&gt;&gt;</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;FAIL&quot;</span>:</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>FAIL<span class="op">&gt;&gt;</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LABEL&quot;</span>:</span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>LABEL<span class="op">&gt;&gt;</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_STRING&quot;</span>:</span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true"></a>        <span class="op">&lt;&lt;</span>MATCH_STRING<span class="op">&gt;&gt;</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&quot;unknown instruction </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(name))</span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true"></a>    <span class="op">&lt;&lt;</span>handle failure<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>First it fetches the instruction pointed to by the program counter. Then it has an if-chain with cases that handle the different instructions. If an instruction is not recognized, an exception is raised. Finally, it has code to handle a failure. Many instructions can fail and therefore this common code is at the end of the loop. If an instruction succeeds, it ends with a <code>continue</code> statement to ensure that the loop is started over immediately without executing the code to handle a failure.</p>
<p>The order in which the cases appear in the if-chain is important from a performance perspective. To get to the last case, all previous cases need to be tested, which takes time. So it is important that more common cases appear earlier in the if-chain. I did an instruction frequency analysis when RLMeta compiled itself to determine the most common instructions.</p>
<p>The VM makes use of two semantic actions that represent results from expressions: one for constant values and one for user defined functions:</p>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="kw">class</span> _ConstantSemanticAction(<span class="bu">object</span>):</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value):</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.value</span></code></pre></div>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="kw">class</span> _UserSemanticAction(<span class="bu">object</span>):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn, scope):</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true"></a>        <span class="va">self</span>.scope <span class="op">=</span> scope</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn(<span class="va">self</span>.scope)</span></code></pre></div>
<p>Let's move on to the implementation of each instruction.</p>
<h3 id="f0fffeab7084a1d9b01d928be4878a8match_any">[]{#8f0fffeab7084a1d9b01d928be4878a8}MATCH_ANY</h3>
<p>This instruction matches any object from the input stream:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_ANY]{.cp}</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(stream[pos])</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<p>The only time it fails is when the end of stream has been reached. In that case <code>fail_message</code> is set and no <code>continue</code> statement is executed to ensure that the code to <a href="#77edfc243204447ba84468c78f05d8e5"><em>handle this failure</em></a> is executed.</p>
<p>Otherwise, the last result is set to a semantic action that evaluates to the current input object. <code>pos</code> is incremented because one object has been consumed from the input stream. <code>pc</code> is incremented so that the next instruction is executed in the next loop iteration.</p>
<h3 id="match_string"><span id="a8160d30b886418882ada3a2a884e580"></span>MATCH_STRING</h3>
<p>This instruction works like <a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> but also fails if the current input object is not the string that is given as the first argument:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_STRING]{.cp}</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> stream[pos] <span class="op">!=</span> arg1:</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(arg1)</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="match_range"><span id="d8dcb57d5da141908f28f8c52983d1a6"></span>MATCH_RANGE</h3>
<p>This instruction works like <a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> but also fails if the current input object is not in the range given as arguments:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_RANGE]{.cp}</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> (arg1 <span class="op">&lt;=</span> stream[pos] <span class="op">&lt;=</span> arg2):</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected range </span><span class="sc">{!r}</span><span class="st">-</span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1, arg2)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(stream[pos])</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="match_charseq"><span id="df5dc1b5e5054e548d5c3606daba0d55"></span>MATCH_CHARSEQ</h3>
<p>This instruction works as <a href="#8f0fffeab7084a1d9b01d928be4878a8"><em>MATCH_ANY</em></a> but also fails if the next input objects are not the characters in the string given as the first argument:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_CHARSEQ]{.cp}</code></pre>
<div class="sourceCode" id="cb94"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="cf">for</span> char <span class="kw">in</span> arg1:</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>    <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> stream[pos] <span class="op">!=</span> char:</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a>        fail_message <span class="op">=</span> (<span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st">&quot;</span>, char)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>        <span class="cf">break</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true"></a>    last_action <span class="op">=</span> _ConstantSemanticAction(arg1)</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="ca0a2fa665466cb90c8c128d5cc835push_scope">[]{#49ca0a2fa665466cb90c8c128d5cc835}PUSH_SCOPE</h3>
<p>This instruction pushes a new scope onto the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [PUSH\_SCOPE]{.cp}</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a>scope_stack.append(scope)</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a>scope <span class="op">=</span> {}</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>Pushing a new scope onto the stack means moving the current scope to the list and assigning a new scope to the current scope. A scope is a dictionary mapping names to values.</p>
<h3 id="pop_scope"><span id="b2510846e20d4cd08f9b0cd2dfb5c01d"></span>POP_SCOPE</h3>
<p>This instruction pops a scope off the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [POP\_SCOPE]{.cp}</code></pre>
<div class="sourceCode" id="cb98"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a>scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<h3 id="e4aa99dd00ec5b524b1bind">[]{#1315305641224e4aa99dd00ec5b524b1}BIND</h3>
<p>This instruction binds the last result to the given name in the current scope:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [BIND]{.cp}</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a>scope[arg1] <span class="op">=</span> last_action</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<h3 id="fde86e4c7290b0f99850917ba8action">[]{#738356fde86e4c7290b0f99850917ba8}ACTION</h3>
<p>This instruction creates a user defined semantic action:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [ACTION]{.cp}</code></pre>
<div class="sourceCode" id="cb102"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a>last_action <span class="op">=</span> _UserSemanticAction(arg1, scope)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The first argument is a Python lambda that expects a scope as argument.</p>
<h3 id="label"><span id="d7d285d9586b437ca7d7f51b5deb6193"></span>LABEL</h3>
<p>This instruction creates a semantic action that evaluates to a unique number:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LABEL]{.cp}</code></pre>
<div class="sourceCode" id="cb104"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a>last_action <span class="op">=</span> _ConstantSemanticAction(label_counter)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a>label_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The label counter is incremented to make all labels unique.</p>
<h3 id="list_start"><span id="b3562467300348028f04ae5034db0f34"></span>LIST_START</h3>
<p>This instruction creates a list for accumulating results:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LIST\_START]{.cp}</code></pre>
<div class="sourceCode" id="cb106"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true"></a>scope_stack.append(scope)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true"></a>scope <span class="op">=</span> []</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The list is actually stored on the scope stack, but it could as well have been stored in the current scope under a special name.</p>
<h3 id="list_append"><span id="b4aacd38dec8406c9db784e0823c3554"></span>LIST_APPEND</h3>
<p>This instruction appends the last result to the accumulation list:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LIST\_APPEND]{.cp}</code></pre>
<div class="sourceCode" id="cb108"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true"></a>scope.append(last_action)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The current scope is assumed to be an accumulation list.</p>
<h3 id="cd44d7fe4777b1c12e335bac33aelist_end">[]{#9940cd44d7fe4777b1c12e335bac33ae}LIST_END</h3>
<p>This instruction makes the accumulation list the last result:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [LIST\_END]{.cp}</code></pre>
<div class="sourceCode" id="cb110"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true"></a>last_action <span class="op">=</span> _UserSemanticAction(<span class="kw">lambda</span> xs: [x.<span class="bu">eval</span>() <span class="cf">for</span> x <span class="kw">in</span> xs], scope)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true"></a>scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The current scope is assumed to be an accumulation list.</p>
<p>The accumulation list is turned into a semantic action that evaluates to a list where each semantic action in the accumulation list is also evaluated.</p>
<h3 id="push_stream"><span id="fee2dcf573f04ac3a9e7cfd92adbe0c8"></span>PUSH_STREAM</h3>
<p>This instruction pushes the current input object onto the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [PUSH\_STREAM]{.cp}</code></pre>
<div class="sourceCode" id="cb112"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(stream[pos], <span class="bu">list</span>):</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected list&quot;</span>,)</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true"></a>    stream_pos_stack.append((stream, pos))</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true"></a>    stream <span class="op">=</span> stream[pos]</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true"></a>    pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<p>It fails if the current input object is not a list. Only lists can become input streams.</p>
<p>Otherwise the current input object becomes the current input stream and the position is set to 0.</p>
<h3 id="a1eee2cfb94e1a9463a6561c226012pop_stream">[]{#87a1eee2cfb94e1a9463a6561c226012}POP_STREAM</h3>
<p>This instruction pops an input stream off the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [POP\_STREAM]{.cp}</code></pre>
<div class="sourceCode" id="cb114"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&lt;</span> <span class="bu">len</span>(stream):</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected end of list&quot;</span>,)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true"></a>    stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true"></a>    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<p>It fails if not all items in the input stream have been consumed.</p>
<p>The position that is stored on the stack refers to the position where the input stream was found. This input stream has now been consumed so the position is therefore incremented.</p>
<h3 id="cae29994179abbe19f2f7e4c267fail">[]{#34915cae29994179abbe19f2f7e4c267}FAIL</h3>
<p>This instruction causes an explicit failure with the given message:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [FAIL]{.cp}</code></pre>
<div class="sourceCode" id="cb116"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true"></a>fail_message <span class="op">=</span> (arg1,)</span></code></pre></div>
<h3 id="e19cbb2e71c412f95c7e241a69f0901call">[]{#8e19cbb2e71c412f95c7e241a69f0901}CALL</h3>
<p>This instruction calls the given rule:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [CALL]{.cp}</code></pre>
<div class="sourceCode" id="cb118"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true"></a>key <span class="op">=</span> (arg1, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true"></a><span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true"></a>    last_action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true"></a>    stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true"></a>    stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true"></a>    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true"></a>    call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true"></a>    pc <span class="op">=</span> labels[arg1]</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>It fist generates a key which consists of the name of the rule and the current position in the input stream. Example key: <code>('Label', (0, 1, 3))</code>. If this rule has matched at this position before, the memoized result is used. Otherwise a call is made.</p>
<p>The memoized result consists of the result from calling the rule and the state of the input stream. The memoized state is assigned to the VM state. The state of the input stream stored in the memoization table can not be modified, hence the <code>stream_pos_stack[:]</code>.</p>
<p>To make a call, the next program counter and the key is appended to the stack. The next program counter stores the position where to continue execution, and the key is used to store the result in the memoization table. See <a href="#d104aa6d6b8e43818f662498f6566e38"><em>RETURN</em></a> for how its done.</p>
<h3 id="match_call_rule"><span id="d42df29209bf475280ac510d9ae31182"></span>MATCH_CALL_RULE</h3>
<p>This instruction works like <a href="#8e19cbb2e71c412f95c7e241a69f0901"><em>CALL</em></a> but instead of getting the rule name from the instruction argument, it gets it from the input stream.</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [MATCH\_CALL\_RULE]{.cp}</code></pre>
<div class="sourceCode" id="cb120"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true"></a><span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true"></a>    fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true"></a>    fn_name <span class="op">=</span> <span class="bu">str</span>(stream[pos])</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true"></a>    key <span class="op">=</span> (fn_name, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true"></a>    <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true"></a>        last_action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true"></a>        stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true"></a>        stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true"></a>        pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true"></a>        call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true"></a>        pc <span class="op">=</span> labels[fn_name]</span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true"></a>        pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true"></a>    <span class="cf">continue</span></span></code></pre></div>
<h3 id="return"><span id="d104aa6d6b8e43818f662498f6566e38"></span>RETURN</h3>
<p>This instruction makes execution continue at wherever it was before the current rule was called:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [RETURN]{.cp}</code></pre>
<div class="sourceCode" id="cb122"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(call_backtrack_stack) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true"></a>    <span class="cf">return</span> last_action.<span class="bu">eval</span>()</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true"></a>pc, key <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true"></a>memo[key] <span class="op">=</span> (last_action, stream_pos_stack<span class="op">+</span>[(stream, pos)])</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>If the stack is empty, it means that the end of the <code>start_rule</code> has been reached. In that case, the result is returned from the VM. Otherwise the <code>pc</code> is set to the position that was pushed onto the stack. The memoization table is also filled in.</p>
<h3 id="e124874b2975d0ae23f034fbacktrack">[]{#542906286e124874b2975d0ae23f034f}BACKTRACK</h3>
<p>This instruction pushes a backtrack entry onto the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [BACKTRACK]{.cp}</code></pre>
<div class="sourceCode" id="cb124"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true"></a>call_backtrack_stack.append((labels[arg1], pos, <span class="bu">len</span>(stream_pos_stack), <span class="bu">len</span>(scope_stack)))</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true"></a>pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>A backtrack entry consists of the following:</p>
<ul>
<li>The position where to continue execution. The label is given as the fist argument to, so its position is looked up in the labels dictionary.</li>
<li>The position in the input stream where to try matching again.</li>
<li>The length of the stream stack.</li>
<li>The length of the scope stack.</li>
</ul>
<p>This information is enough to reset the state and try matching the next choice at the current position. Actual backtracking is done in <a href="#77edfc243204447ba84468c78f05d8e5"><em>Handling failure</em></a>.</p>
<h3 id="b99ed36fbde45989829fde6e17d4821commit">[]{#5b99ed36fbde45989829fde6e17d4821}COMMIT</h3>
<p>This instruction pops a backtrack entry off the stack:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [COMMIT]{.cp}</code></pre>
<div class="sourceCode" id="cb126"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true"></a>call_backtrack_stack.pop()</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true"></a>pc <span class="op">=</span> labels[arg1]</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true"></a><span class="cf">continue</span></span></code></pre></div>
<p>The popped item is assumed to be a backtrack entry, and not a call entry.</p>
<p>The entry is ignored since the choice succeeded and no backtracking is needed.</p>
<h3 id="edfc243204447ba84468c78f05d8e5handling-failure">[]{#77edfc243204447ba84468c78f05d8e5}Handling failure</h3>
<p>The first step in handling a failure is to figure out if this failure should be presented to the user. It is done based on the position where the failure occurred. Failures occurring at later positions are assumed to be more relevant. The latest fail message is saved like this:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb128"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true"></a>fail_pos <span class="op">=</span> <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos])</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true"></a><span class="cf">if</span> fail_pos <span class="op">&gt;=</span> latest_fail_pos:</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true"></a>    latest_fail_message <span class="op">=</span> fail_message</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true"></a>    latest_fail_pos <span class="op">=</span> fail_pos</span></code></pre></div>
<p>Next actual backtracking is done. Items are popped off the stack until a backtrack entry is found. Backtrack entries are tuples with 4 arguments.</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb130"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true"></a>call_backtrack_entry <span class="op">=</span> <span class="bu">tuple</span>()</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true"></a><span class="cf">while</span> call_backtrack_stack:</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true"></a>    call_backtrack_entry <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true"></a>        <span class="cf">break</span></span></code></pre></div>
<p>If no backtrack entry is found, matching failed completely and the user is notified with an exception. The latest fail message is passed to the exception along with the position and input stream where the failure occurred.</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb132"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true"></a>    fail_pos <span class="op">=</span> <span class="bu">list</span>(latest_fail_pos)</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true"></a>    fail_stream <span class="op">=</span> stream_pos_stack[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> stream_pos_stack <span class="cf">else</span> stream</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true"></a>    <span class="cf">while</span> <span class="bu">len</span>(fail_pos) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true"></a>        fail_stream <span class="op">=</span> fail_stream[fail_pos.pop(<span class="dv">0</span>)]</span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true"></a>    <span class="cf">raise</span> _MatchError(latest_fail_message, fail_pos[<span class="dv">0</span>], fail_stream)</span></code></pre></div>
<p>The exception has a <code>describe</code> method that formats the error nicely for the user:</p>
<pre><code>1.  support.py
2.  [classes]{.cp}</code></pre>
<div class="sourceCode" id="cb134"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true"></a><span class="kw">class</span> _MatchError(<span class="pp">Exception</span>):</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true"></a></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, message, pos, stream):</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true"></a>        <span class="va">self</span>.message <span class="op">=</span> message</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true"></a>        <span class="va">self</span>.pos <span class="op">=</span> pos</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true"></a>        <span class="va">self</span>.stream <span class="op">=</span> stream</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true"></a></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true"></a>    <span class="kw">def</span> describe(<span class="va">self</span>):</span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true"></a>        message <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(<span class="va">self</span>.stream, <span class="bu">basestring</span>):</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true"></a>            before <span class="op">=</span> <span class="va">self</span>.stream[:<span class="va">self</span>.pos].splitlines()</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true"></a>            after <span class="op">=</span> <span class="va">self</span>.stream[<span class="va">self</span>.pos:].splitlines()</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true"></a>            <span class="cf">for</span> context_before <span class="kw">in</span> before[<span class="op">-</span><span class="dv">4</span>:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(context_before)</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(before[<span class="op">-</span><span class="dv">1</span>], after[<span class="dv">0</span>])</span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._arrow(<span class="bu">len</span>(before[<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true"></a>            <span class="cf">for</span> context_after <span class="kw">in</span> after[<span class="dv">1</span>:<span class="dv">4</span>]:</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(context_after)</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;[&quot;</span>)</span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true"></a>            <span class="cf">for</span> context_before <span class="kw">in</span> <span class="va">self</span>.stream[:<span class="va">self</span>.pos]:</span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;  &quot;</span>, <span class="bu">repr</span>(context_before), <span class="st">&quot;,&quot;</span>)</span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;  &quot;</span>, <span class="bu">repr</span>(<span class="va">self</span>.stream[<span class="va">self</span>.pos]), <span class="st">&quot;,&quot;</span>)</span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._arrow(<span class="dv">2</span>)</span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true"></a>            <span class="cf">for</span> context_after <span class="kw">in</span> <span class="va">self</span>.stream[<span class="va">self</span>.pos<span class="op">+</span><span class="dv">1</span>:]:</span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true"></a>                message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;  &quot;</span>, <span class="bu">repr</span>(context_after), <span class="st">&quot;,&quot;</span>)</span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true"></a>            message <span class="op">+=</span> <span class="va">self</span>._context(<span class="st">&quot;]&quot;</span>)</span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true"></a>        message <span class="op">+=</span> <span class="st">&quot;Error: &quot;</span></span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true"></a>        message <span class="op">+=</span> <span class="va">self</span>.message[<span class="dv">0</span>].<span class="bu">format</span>(<span class="op">*</span><span class="va">self</span>.message[<span class="dv">1</span>:])</span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true"></a>        message <span class="op">+=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true"></a>        <span class="cf">return</span> message</span>
<span id="cb134-33"><a href="#cb134-33" aria-hidden="true"></a></span>
<span id="cb134-34"><a href="#cb134-34" aria-hidden="true"></a>    <span class="kw">def</span> _context(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb134-35"><a href="#cb134-35" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;&gt; </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;&quot;</span>.join(args))</span>
<span id="cb134-36"><a href="#cb134-36" aria-hidden="true"></a></span>
<span id="cb134-37"><a href="#cb134-37" aria-hidden="true"></a>    <span class="kw">def</span> _arrow(<span class="va">self</span>, lenght):</span>
<span id="cb134-38"><a href="#cb134-38" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;--</span><span class="sc">{}</span><span class="st">^</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;-&quot;</span><span class="op">*</span>lenght)</span></code></pre></div>
<p>If the input stream is a string, the character where the failure occurred is highlighted with a few context lines around it like this:</p>
<pre class="text"><code>&gt;     | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
&gt;   expr =
&gt;     | expr1:x space ':' name:y                 -&gt; [&quot;Bind&quot; y x
&gt;     | expr1
------^
&gt;   expr1 =
&gt;     | expr2:x space '*'                        -&gt; [&quot;Star&quot; x]
&gt;     | expr2:x space '?'                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
Error: expected ']'</code></pre>
<p>If the input stream is a list, the whole list is printed as context, and the item where the failure occurred is highlighted like this:</p>
<pre class="text"><code>&gt; [
&gt;   'Bind',
&gt;   'x',
&gt;   ['MatchRule', 'name'],
&gt;   'foo',
----^
&gt; ]
Error: expected end of list</code></pre>
<p>Finally the state of the VM is restored:</p>
<pre><code>1.  support.py
2.  [vm]{.cp}
3.  [loop]{.cp}
4.  [handle failure]{.cp}</code></pre>
<div class="sourceCode" id="cb138"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true"></a>(pc, pos, stream_stack_len, scope_stack_len) <span class="op">=</span> call_backtrack_entry</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(stream_pos_stack) <span class="op">&gt;</span> stream_stack_len:</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true"></a>    stream <span class="op">=</span> stream_pos_stack[stream_stack_len][<span class="dv">0</span>]</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true"></a>stream_pos_stack <span class="op">=</span> stream_pos_stack[:stream_stack_len]</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true"></a><span class="cf">if</span> <span class="bu">len</span>(scope_stack) <span class="op">&gt;</span> scope_stack_len:</span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true"></a>    scope <span class="op">=</span> scope_stack[scope_stack_len]</span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true"></a>scope_stack <span class="op">=</span> scope_stack[:scope_stack_len]</span></code></pre></div>
<p>The program counter and the position is restored from the backtrack entry. The stack lengths are used to restore the stacks. A failure might have occurred deeper in the input stream than when the backtrack entry was created. Similarly for the scope. Those stacks are therefore restored so they have the same length as in the backtrack entry.</p>
<h3 id="ffb1abf59546e1972c78ee7159b758optimizations">[]{#95ffb1abf59546e1972c78ee7159b758}Optimizations</h3>
<p>The <code>rlmeta_vm</code> function is heavily optimized for speed. Here are a few choices made:</p>
<ul>
<li>It is implemented as a single function to avoid function calls.</li>
<li>It handles instructions in a specific order based on how often they are used.</li>
<li>It duplicates code to avoid some Python instructions.
<ul>
<li>Most instructions increments the program counter. That could be done always, and then only instructions that need to do something other than incrementing could do that. But in those cases, some extra Python instructions would be executed.</li>
<li>The code for the two call instructions have some similar code.</li>
<li>All instructions use <code>continue</code> statements instead of the failure handling checking if a fail message was actually set.</li>
</ul></li>
</ul>
<p>These optimizations makes the VM faster and also a little harder to maintain. But it's a trade off.</p>
<h2 id="e3ad1de345642658be2e5910ab5be4enote-on-size">[]{#2e3ad1de345642658be2e5910ab5be4e}Note on size</h2>
<p>Compared to the optimized version, the VM based version is a little bigger:</p>
<pre class="text"><code> 53 parser.rlmeta
 74 codegenerator.rlmeta
302 support.py
 45 compile.sh
474 total</code></pre>
<p>That is 474 lines of code compared to 429 in the optimized version. The <code>rlmeta_vm</code> function is quite optimized and therefore is slightly longer than it could have been. But 474 lines is still small.</p>
<h2 id="note-on-performance"><span id="c490369b053247c0b7761f324658aa15"></span>Note on performance</h2>
<p>The VM based version also turns out to be faster than the <a href="../../writing/optimizing-rlmeta/index.html#3616eda03f5c40458ac9439def097739">optimized version</a>:</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
</center>
<p>Being faster was not a goal with the VM based version, but it's and interesting side effect. Perhaps more programming problems would benefit from a VM based approach? There are probably also more optimizations that can be made to the instructions to make the VM even faster.</p>
<h2 id="e7b4c5318ff4c849c6e98e9ddeaacf0code-listings-for-rlmeta">[]{#7e7b4c5318ff4c849c6e98e9ddeaacf0}Code listings for RLMeta</h2>
<h3 id="f0708b231b468d844291df3fe17cf2parser.rlmeta">[]{#53f0708b231b468d844291df3fe17cf2}parser.rlmeta</h3>
<pre class="text"><code>Parser {
  grammar =
    | name:x space '{' rule*:ys space '}'      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space '=' choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space '|')?
      sequence:x (space '|' sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space ':' name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space '*'                        -&gt; [&quot;Star&quot; x]
    | expr2:x space '?'                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space '!' expr2:x                        -&gt; [&quot;Not&quot; x]
    | space '%'                                -&gt; [&quot;MatchCallRule&quot;]
    | space '#'                                -&gt; [&quot;Label&quot;]
    | expr2
  expr2 =
    | space '-&gt;' hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space '=')                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x '-' char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space '.'                                -&gt; [&quot;MatchAny&quot;]
    | space '(' choice:x space ')'             -&gt; x
    | space '[' expr*:xs space ']'             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space '[' hostExprListItem*:xs space ']' -&gt; [&quot;List&quot; ~xs]
    | space '{' buildExpr*:xs space '}'        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space '(' hostExpr*:ys space ')'  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space '~' hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space '&gt;'                                -&gt; [&quot;IndentBuilder&quot;]
    | space '&lt;'                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = '&quot;'  (!'&quot;'  innerChar)*:xs '&quot;'   -&gt; join(xs)
  charseq   = '\'' (!'\'' innerChar)*:xs '\''  -&gt; join(xs)
  char      = '\''  !'\'' innerChar  :x  '\''  -&gt; x
  innerChar = '\\' escape | .
  escape    = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
            | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = 'a'-'z' | 'A'-'Z'
  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'
  space     = (' ' | '\n')*
}</code></pre>
<h3 id="bf51f7e8d94bcba1747edb477137efcodegenerator.rlmeta">[]{#74bf51f7e8d94bcba1747edb477137ef}codegenerator.rlmeta</h3>
<pre class="text"><code>CodeGenerator {
  ast            = [%:x]           -&gt; x
  py             = .:x             -&gt; repr(x)
  Grammar        = .:x ast*:ys     -&gt; { &quot;class &quot; x &quot;(_Grammar):\n\n&quot; &gt;
                                          &quot;def __init__(self):\n&quot; &gt;
                                            &quot;self._instructions = i = []\n&quot;
                                            &quot;self._labels = l = {}\n&quot;
                                            &quot;def I(name, x=None, y=None):\n&quot; &gt;
                                              &quot;i.append((name, x, y))\n&quot;
                                            &lt;
                                            &quot;def LABEL(name):\n&quot; &gt;
                                              &quot;l[name] = len(i)\n&quot;
                                            &lt;
                                            ys
                                          &lt;
                                        &lt;                                    }
  Rule           = py:x ast:y      -&gt; { &quot;LABEL(&quot; x &quot;)\n&quot;
                                        y
                                        &quot;I('RETURN')\n&quot;                      }
  Or             =
    | ast:x Or:y #:a #:b           -&gt; { &quot;I('BACKTRACK', &quot; a &quot;)\n&quot;
                                        x
                                        &quot;I('COMMIT', &quot; b &quot;)\n&quot;
                                        &quot;LABEL(&quot; a &quot;)\n&quot;
                                        y
                                        &quot;LABEL(&quot; b &quot;)\n&quot;                     }
    | ast
  Scope          = ast:x           -&gt; { &quot;I('PUSH_SCOPE')\n&quot;
                                        x
                                        &quot;I('POP_SCOPE')\n&quot;                   }
  And            = ast*
  Bind           = py:x ast:y      -&gt; { y
                                        &quot;I('BIND', &quot; x &quot;)\n&quot;                 }
  Star           = ast:x #:a #:b   -&gt; { &quot;I('LIST_START')\n&quot;
                                        &quot;LABEL(&quot; a &quot;)\n&quot;
                                        &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                                        x
                                        &quot;I('LIST_APPEND')\n&quot;
                                        &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                                        &quot;LABEL(&quot; b &quot;)\n&quot;
                                        &quot;I('LIST_END')\n&quot;                    }
  Not            = ast:x #:a #:b   -&gt; { &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                                        x
                                        &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                                        &quot;LABEL(&quot; a &quot;)\n&quot;
                                        &quot;I('FAIL', 'no match expected')\n&quot;
                                        &quot;LABEL(&quot; b &quot;)\n&quot;                     }
  MatchCallRule  =                 -&gt; { &quot;I('MATCH_CALL_RULE')\n&quot;             }
  Label          =                 -&gt; { &quot;I('LABEL')\n&quot;                       }
  SemanticAction = ast:x           -&gt; { &quot;I('ACTION', lambda scope: &quot; x &quot;)\n&quot; }
  String         = py
  List           = astList
  Builder        = astItems:x      -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot;           }
  IndentBuilder  =                 -&gt; { &quot;_IndentBuilder()&quot;                   }
  DedentBuilder  =                 -&gt; { &quot;_DedentBuilder()&quot;                   }
  FnCall         = .:x astItems:y  -&gt; { x &quot;(&quot; y &quot;)&quot;                          }
  VarLookup      = py:x            -&gt; { &quot;scope[&quot; x &quot;].eval()&quot;                }
  astItems       =
    | ast:x astItem*:xs            -&gt; { x xs                                 }
    |                              -&gt; {                                      }
  astItem        = ast:x           -&gt; { &quot;, &quot; x                               }
  astList        = astListItem*:xs -&gt; { &quot;(&quot; xs &quot;[])&quot;                         }
  astListItem    =
    | [&quot;ListItemSplice&quot; ast:x]     -&gt; {     x  &quot;+&quot;                           }
    | ast:x                        -&gt; { &quot;[&quot; x &quot;]+&quot;                           }
  MatchRule      = py:x            -&gt; { &quot;I('CALL', &quot; x &quot;)\n&quot;                 }
  MatchRange     = py:x py:y       -&gt; { &quot;I('MATCH_RANGE', &quot; x &quot;, &quot; y &quot;)\n&quot;   }
  MatchString    = py:x            -&gt; { &quot;I('MATCH_STRING', &quot; x &quot;)\n&quot;         }
  MatchCharseq   = py:x            -&gt; { &quot;I('MATCH_CHARSEQ', &quot; x &quot;)\n&quot;        }
  MatchAny       =                 -&gt; { &quot;I('MATCH_ANY')\n&quot;                   }
  MatchList      = ast:x           -&gt; { &quot;I('PUSH_STREAM')\n&quot;
                                        x
                                        &quot;I('POP_STREAM')\n&quot;                  }
}</code></pre>
<h3 id="ff77cb85fa455589e3e45cdeac8160support.py">[]{#60ff77cb85fa455589e3e45cdeac8160}support.py</h3>
<pre class="text"><code>try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

def rlmeta_vm(instructions, labels, start_rule, stream):
    label_counter = 0
    last_action = _ConstantSemanticAction(None)
    pc = labels[start_rule]
    call_backtrack_stack = []
    stream, pos, stream_pos_stack = (stream, 0, [])
    scope, scope_stack = (None, [])
    fail_message = None
    latest_fail_message, latest_fail_pos = (None, tuple())
    memo = {}
    while True:
        name, arg1, arg2 = instructions[pc]
        if name == &quot;PUSH_SCOPE&quot;:
            scope_stack.append(scope)
            scope = {}
            pc += 1
            continue
        elif name == &quot;BACKTRACK&quot;:
            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))
            pc += 1
            continue
        elif name == &quot;CALL&quot;:
            key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))
            if key in memo:
                last_action, stream_pos_stack = memo[key]
                stream_pos_stack = stream_pos_stack[:]
                stream, pos = stream_pos_stack.pop()
                pc += 1
            else:
                call_backtrack_stack.append((pc+1, key))
                pc = labels[arg1]
            continue
        elif name == &quot;MATCH_CHARSEQ&quot;:
            for char in arg1:
                if pos &gt;= len(stream) or stream[pos] != char:
                    fail_message = (&quot;expected {!r}&quot;, char)
                    break
                pos += 1
            else:
                last_action = _ConstantSemanticAction(arg1)
                pc += 1
                continue
        elif name == &quot;COMMIT&quot;:
            call_backtrack_stack.pop()
            pc = labels[arg1]
            continue
        elif name == &quot;POP_SCOPE&quot;:
            scope = scope_stack.pop()
            pc += 1
            continue
        elif name == &quot;RETURN&quot;:
            if len(call_backtrack_stack) == 0:
                return last_action.eval()
            pc, key = call_backtrack_stack.pop()
            memo[key] = (last_action, stream_pos_stack+[(stream, pos)])
            continue
        elif name == &quot;LIST_APPEND&quot;:
            scope.append(last_action)
            pc += 1
            continue
        elif name == &quot;BIND&quot;:
            scope[arg1] = last_action
            pc += 1
            continue
        elif name == &quot;ACTION&quot;:
            last_action = _UserSemanticAction(arg1, scope)
            pc += 1
            continue
        elif name == &quot;MATCH_RANGE&quot;:
            if pos &gt;= len(stream) or not (arg1 &lt;= stream[pos] &lt;= arg2):
                fail_message = (&quot;expected range {!r}-{!r}&quot;, arg1, arg2)
            else:
                last_action = _ConstantSemanticAction(stream[pos])
                pos += 1
                pc += 1
                continue
        elif name == &quot;LIST_START&quot;:
            scope_stack.append(scope)
            scope = []
            pc += 1
            continue
        elif name == &quot;LIST_END&quot;:
            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)
            scope = scope_stack.pop()
            pc += 1
            continue
        elif name == &quot;MATCH_ANY&quot;:
            if pos &gt;= len(stream):
                fail_message = (&quot;expected any&quot;,)
            else:
                last_action = _ConstantSemanticAction(stream[pos])
                pos += 1
                pc += 1
                continue
        elif name == &quot;PUSH_STREAM&quot;:
            if pos &gt;= len(stream) or not isinstance(stream[pos], list):
                fail_message = (&quot;expected list&quot;,)
            else:
                stream_pos_stack.append((stream, pos))
                stream = stream[pos]
                pos = 0
                pc += 1
                continue
        elif name == &quot;POP_STREAM&quot;:
            if pos &lt; len(stream):
                fail_message = (&quot;expected end of list&quot;,)
            else:
                stream, pos = stream_pos_stack.pop()
                pos += 1
                pc += 1
                continue
        elif name == &quot;MATCH_CALL_RULE&quot;:
            if pos &gt;= len(stream):
                fail_message = (&quot;expected any&quot;,)
            else:
                fn_name = str(stream[pos])
                key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))
                if key in memo:
                    last_action, stream_pos_stack = memo[key]
                    stream_pos_stack = stream_pos_stack[:]
                    stream, pos = stream_pos_stack.pop()
                    pc += 1
                else:
                    call_backtrack_stack.append((pc+1, key))
                    pc = labels[fn_name]
                    pos += 1
                continue
        elif name == &quot;FAIL&quot;:
            fail_message = (arg1,)
        elif name == &quot;LABEL&quot;:
            last_action = _ConstantSemanticAction(label_counter)
            label_counter += 1
            pc += 1
            continue
        elif name == &quot;MATCH_STRING&quot;:
            if pos &gt;= len(stream) or stream[pos] != arg1:
                fail_message = (&quot;expected {!r}&quot;, arg1)
            else:
                last_action = _ConstantSemanticAction(arg1)
                pos += 1
                pc += 1
                continue
        else:
            raise Exception(&quot;unknown instruction {}&quot;.format(name))
        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])
        if fail_pos &gt;= latest_fail_pos:
            latest_fail_message = fail_message
            latest_fail_pos = fail_pos
        call_backtrack_entry = tuple()
        while call_backtrack_stack:
            call_backtrack_entry = call_backtrack_stack.pop()
            if len(call_backtrack_entry) == 4:
                break
        if len(call_backtrack_entry) != 4:
            fail_pos = list(latest_fail_pos)
            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream
            while len(fail_pos) &gt; 1:
                fail_stream = fail_stream[fail_pos.pop(0)]
            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)
        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry
        if len(stream_pos_stack) &gt; stream_stack_len:
            stream = stream_pos_stack[stream_stack_len][0]
        stream_pos_stack = stream_pos_stack[:stream_stack_len]
        if len(scope_stack) &gt; scope_stack_len:
            scope = scope_stack[scope_stack_len]
        scope_stack = scope_stack[:scope_stack_len]

class _Grammar(object):

    def run(self, rule_name, input_object):
        if isinstance(input_object, basestring):
            stream = input_object
        else:
            stream = [input_object]
        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)
        if isinstance(result, _Builder):
            return result.build_string()
        else:
            return result

class _Builder(object):

    def build_string(self):
        output = _Output()
        self.write(output)
        return output.value

    @classmethod
    def create(self, item):
        if isinstance(item, _Builder):
            return item
        elif isinstance(item, list):
            return _ListBuilder([_Builder.create(x) for x in item])
        else:
            return _AtomBuilder(item)

class _Output(object):

    def __init__(self):
        self.buffer = StringIO()
        self.indentation = 0
        self.on_newline = True

    @property
    def value(self):
        return self.buffer.getvalue()

    def write(self, value):
        for ch in value:
            is_linebreak = ch == &quot;\n&quot;
            if self.indentation and self.on_newline and not is_linebreak:
                self.buffer.write(&quot;    &quot;*self.indentation)
            self.buffer.write(ch)
            self.on_newline = is_linebreak

class _ListBuilder(_Builder):

    def __init__(self, builders):
        self.builders = builders

    def write(self, output):
        for builder in self.builders:
            builder.write(output)

class _AtomBuilder(_Builder):

    def __init__(self, atom):
        self.atom = atom

    def write(self, output):
        output.write(str(self.atom))

class _IndentBuilder(_Builder):

    def write(self, output):
        output.indentation += 1

class _DedentBuilder(_Builder):

    def write(self, output):
        output.indentation -= 1

class _ConstantSemanticAction(object):

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

class _UserSemanticAction(object):

    def __init__(self, fn, scope):
        self.fn = fn
        self.scope = scope

    def eval(self):
        return self.fn(self.scope)

class _MatchError(Exception):

    def __init__(self, message, pos, stream):
        Exception.__init__(self)
        self.message = message
        self.pos = pos
        self.stream = stream

    def describe(self):
        message = &quot;&quot;
        if isinstance(self.stream, basestring):
            before = self.stream[:self.pos].splitlines()
            after = self.stream[self.pos:].splitlines()
            for context_before in before[-4:-1]:
                message += self._context(context_before)
            message += self._context(before[-1], after[0])
            message += self._arrow(len(before[-1]))
            for context_after in after[1:4]:
                message += self._context(context_after)
        else:
            message += self._context(&quot;[&quot;)
            for context_before in self.stream[:self.pos]:
                message += self._context(&quot;  &quot;, repr(context_before), &quot;,&quot;)
            message += self._context(&quot;  &quot;, repr(self.stream[self.pos]), &quot;,&quot;)
            message += self._arrow(2)
            for context_after in self.stream[self.pos+1:]:
                message += self._context(&quot;  &quot;, repr(context_after), &quot;,&quot;)
            message += self._context(&quot;]&quot;)
        message += &quot;Error: &quot;
        message += self.message[0].format(*self.message[1:])
        message += &quot;\n&quot;
        return message

    def _context(self, *args):
        return &quot;&gt; {}\n&quot;.format(&quot;&quot;.join(args))

    def _arrow(self, lenght):
        return &quot;--{}^\n&quot;.format(&quot;-&quot;*lenght)</code></pre>
<h3 id="ad257e61e4025b8859d610a475c6acompile.sh">[]{#338ad257e61e4025b8859d610a475c6a}compile.sh</h3>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb144"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true"></a></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true"></a></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true"></a></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true"></a></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">'import sys; sys.stdout.write(repr(sys.stdin.read()))'</span></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true"></a></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true"></a></span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true"></a>import sys</span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true"></a></span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true"></a>SUPPORT = <span class="va">$support_py_string</span></span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true"></a></span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true"></a></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true"></a></span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true"></a></span>
<span id="cb144-29"><a href="#cb144-29" aria-hidden="true"></a>join = &quot;&quot;.join</span>
<span id="cb144-30"><a href="#cb144-30" aria-hidden="true"></a></span>
<span id="cb144-31"><a href="#cb144-31" aria-hidden="true"></a>def compile_grammar(grammar):</span>
<span id="cb144-32"><a href="#cb144-32" aria-hidden="true"></a>    parser = Parser()</span>
<span id="cb144-33"><a href="#cb144-33" aria-hidden="true"></a>    code_generator = CodeGenerator()</span>
<span id="cb144-34"><a href="#cb144-34" aria-hidden="true"></a>    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))</span>
<span id="cb144-35"><a href="#cb144-35" aria-hidden="true"></a></span>
<span id="cb144-36"><a href="#cb144-36" aria-hidden="true"></a>if __name__ == &quot;__main__&quot;:</span>
<span id="cb144-37"><a href="#cb144-37" aria-hidden="true"></a>    if &quot;--support&quot; in sys.argv:</span>
<span id="cb144-38"><a href="#cb144-38" aria-hidden="true"></a>        sys.stdout.write(SUPPORT)</span>
<span id="cb144-39"><a href="#cb144-39" aria-hidden="true"></a>    else:</span>
<span id="cb144-40"><a href="#cb144-40" aria-hidden="true"></a>        try:</span>
<span id="cb144-41"><a href="#cb144-41" aria-hidden="true"></a>            sys.stdout.write(compile_grammar(sys.stdin.read()))</span>
<span id="cb144-42"><a href="#cb144-42" aria-hidden="true"></a>        except _MatchError as e:</span>
<span id="cb144-43"><a href="#cb144-43" aria-hidden="true"></a>            sys.stderr.write(e.describe())</span>
<span id="cb144-44"><a href="#cb144-44" aria-hidden="true"></a>            sys.exit(1)</span>
<span id="cb144-45"><a href="#cb144-45" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<h3 id="d17f2d55749b59d7e5ec7b9b8e0ecmeta_compile.sh">[]{#272d17f2d55749b59d7e5ec7b9b8e0ec}meta_compile.sh</h3>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb146"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true"></a></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true"></a></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true"></a></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true"></a></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true"></a></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true"></a></span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true"></a></span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true"></a></span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb146-20"><a href="#cb146-20" aria-hidden="true"></a></span>
<span id="cb146-21"><a href="#cb146-21" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb146-22"><a href="#cb146-22" aria-hidden="true"></a></span>
<span id="cb146-23"><a href="#cb146-23" aria-hidden="true"></a><span class="bu">echo</span> OK</span></code></pre></div>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
