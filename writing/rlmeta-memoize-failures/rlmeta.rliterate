{
"root_page":{
"children":[
{
"children":[],
"id":"a9a4166e943a4d2c974c443cef1da5a9",
"paragraphs":[
{
"fragments":[
{
"text":"In the optimized version, the memoization table currently stores tuples with result, start position, and end position. If a rule fails, a new kind of value that indicates a failure must be stored. We will reuse the same tuple, but have the result be ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" in case of a failure and have the start position be the lazy fail message.",
"type":"text"
}
],
"id":"ad62ef2e2f4341a09001b937f4fec507",
"type":"text"
},
{
"fragments":[
{
"text":"The memoization table is both queried and populated in the support library method ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":". The fixed version looks like this:",
"type":"text"
}
],
"id":"a3456947282b4b8c81e5f3bd41e12371",
"type":"text"
},
{
"chunkpath":[
"match rule"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"def _match_rule(self, rule_name):\n    key = (rule_name, self._stream.position())\n    if key in self._memo:\n        if self._memo[key][0] is None:\n            self._stream.fail(self._memo[key][1])\n        else:\n            result, _, self._stream = self._memo[key]\n    else:\n        try:\n            start = self._stream\n            result = getattr(self, \"_rule_{}\".format(rule_name))()\n            end = self._stream\n            self._memo[key] = (result, start, end)\n        except _MatchError as e:\n            self._memo[key] = (None, e.lazy_message, None)\n            raise\n    return result\n",
"type":"code"
}
],
"id":"49bd6fdc3d8a40a9ae62454cafe2e330",
"type":"code"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"_MatchError",
"type":"code"
},
{
"text":" class is also modified to save the lazy message:",
"type":"text"
}
],
"id":"a717601e63bf43539cddcfd009cafbba",
"type":"text"
},
{
"chunkpath":[
"memo fail"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"def fail(self, stream, lazy_message):\n    if stream.position() >= self._latest_stream.position():\n        self._latest_stream = stream\n        self._latest_lazy_message = lazy_message\n    raise _MatchError(self, lazy_message)\n",
"type":"code"
}
],
"id":"9a08cc0615d1433b8da4c5cd550a5892",
"type":"code"
},
{
"chunkpath":[
"match error"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"class _MatchError(Exception):\n\n    def __init__(self, memo, lazy_message):\n        Exception.__init__(self)\n        self._memo = memo\n        self.lazy_message = lazy_message\n\n    def describe(self):\n        return self._memo.describe()\n",
"type":"code"
}
],
"id":"666a02fdacd2475488156dfb764a70e1",
"type":"code"
}
],
"title":"Optimized"
},
{
"children":[],
"id":"fe17638693e344ad9e521e55bf0676f3",
"paragraphs":[
{
"fragments":[
{
"text":"In the VM based version, the memoization table currently stores tuples with last action, and stream position stack. If a rule fails, a new kind of value that indicates a failure must be stored. We will reuse the same tuple, but have the last action be ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" in case of a failure and have the stream position stack be the failure message.",
"type":"text"
}
],
"id":"dd1699bbf01245788615d6a9ca30b7b7",
"type":"text"
},
{
"fragments":[
{
"text":"The memoization table is queried and populated in different places. The first place it's populated is in the ",
"type":"text"
},
{
"text":"RETURN",
"type":"code"
},
{
"text":" instruction:",
"type":"text"
}
],
"id":"c8ea8426236643b2a30aeb675e9a666f",
"type":"text"
},
{
"chunkpath":[
"RETURN"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"if len(call_backtrack_stack) == 0:\n    return last_action.eval()\npc, key = call_backtrack_stack.pop()\nmemo[key] = (last_action, stream_pos_stack+[(stream, pos)])\ncontinue\n",
"type":"code"
}
],
"id":"20ace23911b1446ab7c8e6cba4a4527a",
"type":"code"
},
{
"fragments":[
{
"text":"This code is unchanged and I include it here only for context. It populates the memoization table when a rule has matched. To populate the memoization table with a failure, the code that pops a backtrack entry must be modified like this:",
"type":"text"
}
],
"id":"a452d66363dd4541832da39c36b13cc5",
"type":"text"
},
{
"chunkpath":[
"pop backtrack entry"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"call_backtrack_entry = tuple()\nwhile call_backtrack_stack:\n    call_backtrack_entry = call_backtrack_stack.pop()\n    if len(call_backtrack_entry) == 4:\n        break\n    else:\n        _, key = call_backtrack_entry\n        memo[key] = (None, fail_message)\n",
"type":"code"
}
],
"id":"09bb7d528d084ca7a31b98ea7659a8a0",
"type":"code"
},
{
"fragments":[
{
"text":"If the popped item is not a backtrack entry, it must be a call entry. It means that the given rule has been called, and it has failed. In that case, ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" is stored in the memoization table to indicate a failure, along wit the fail message as second argument.",
"type":"text"
}
],
"id":"69862c2f6c474a7cb3323400e77399b2",
"type":"text"
},
{
"fragments":[
{
"text":"Next code that queries the memoization table need to be updated. It happens in the two call instructions ",
"type":"text"
},
{
"text":"CALL",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"MATCH_CALL_RULE",
"type":"code"
},
{
"text":". They are changed to look at the first argument in the memoized entry. If it is ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":", it indicates a failure. The ",
"type":"text"
},
{
"text":"fail_message",
"type":"code"
},
{
"text":" is then set and the ",
"type":"text"
},
{
"text":"continue",
"type":"code"
},
{
"text":" statement is skipped:",
"type":"text"
}
],
"id":"5cb1fcd1ceca47298a591a34dd960a48",
"type":"text"
},
{
"chunkpath":[
"CALL"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))\nif key in memo:\n    if memo[key][0] is None:\n        fail_message = memo[key][1]\n    else:\n        last_action, stream_pos_stack = memo[key]\n        stream_pos_stack = stream_pos_stack[:]\n        stream, pos = stream_pos_stack.pop()\n        pc += 1\n        continue\nelse:\n    call_backtrack_stack.append((pc+1, key))\n    pc = labels[arg1]\n    continue\n",
"type":"code"
}
],
"id":"7f7bb394b7b9434eb91e19118aa52a0a",
"type":"code"
},
{
"chunkpath":[
"MATCH_CALL_RULE"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"if pos >= len(stream):\n    fail_message = (\"expected any\",)\nelse:\n    fn_name = str(stream[pos])\n    key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))\n    if key in memo:\n        if memo[key][0] is None:\n            fail_message = memo[key][1]\n        else:\n            last_action, stream_pos_stack = memo[key]\n            stream_pos_stack = stream_pos_stack[:]\n            stream, pos = stream_pos_stack.pop()\n            pc += 1\n            continue\n    else:\n        call_backtrack_stack.append((pc+1, key))\n        pc = labels[fn_name]\n        pos += 1\n        continue\n",
"type":"code"
}
],
"id":"6ff1e38b876b4f32b4a004a4611c1639",
"type":"code"
}
],
"title":"VM"
},
{
"children":[],
"id":"42ae6babf74d427880f831bd14109002",
"paragraphs":[
{
"fragments":[
{
"text":"Performance measurements.",
"type":"text"
}
],
"id":"866972443e7644629d53b53db0607fb5",
"image_base64":"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sReZ5IMPPhgyZIj0uri4+Pz580OHDrW1tb1586YmK9WeCqwTfVRSUiKK4u3bt4ODg9u2bdujRw9XV1cnJ6fXXnttxowZW7ZsKS4uLj9VQUFBt27dli5dWrrx+vXrbdu2jY+P11Lp2qVUKiMiIpo1a3b69GlVY15enqWl5ZEjR3RYmLqKiormzZs3fPjwMu35+flXr17VSUl6QY+2eQKyakh/HJOTk1u3bj1+/Pg///xToVAkJSWJorh79+7c3NxnTNurV6/58+eXbsnMzGzfvv2mTZs0WrOmVWad6KMnT56IotirV68JEyZcv35dFMVbt259//33TZo0adCgwfvvv/+0CT///HNLS8sDBw7k5+dLLSkpKUZGRjk5OdqpXPvS09O9vb19fHx++eWX06dP//HHHx9//HHLli11XZd6pKOpZmZmkyZNOn/+vK7L0Sf6ss1ziLVqSAfWAwICDA0Nf/75519//fXrr79OS0srKCgYPXq0vb393LlzZScURTEqKmrVqlU7duxwdnaWGvPz8+3t7bdv3+7j46PFhahiFV4n+quwsPCVV1757bffunXrpjqxumTJku3bt3/++ec9evSQvZrlwYMHo0aNyszM9PX1tbe3v379+oEDB+rVq7d161ZdLITGSWvm1KlTUVFRf/75p7GxsZWVVYsWLSZPntynTx9dV6eG77//Pi8v79SpU4cPHzY0NGzduvXAgQP9/f0bNGig69KqO33Z5vV+ZEQ1If3VS09P79mzpyAI8+fPf/fddwVBqFu3rqGhofQrRHaspkKh+PDDDxs1ajRixIhff/31zJkzf/755+TJk62trfU6HYVKrBP9VbGrWSwtLaOiory9vf/444/Fixf//PPP3t7eixYt0nb12lJUVFRYWNi2bdsNGzYUFBRs2LBh5cqVO3bs0K90vHv37urVq1u1arVixYoNGzaMHj3axMRk4cKFLi4uhw4d0nV11Z3ebPM63X+tab744ov//Oc/d+/eNTc3z8rKEkXx/v37VlZWR48eFf895FiG1Hjy5Ml33nnHxMTEwsLCwcHhtdde2717t5aL15AKrBO9tnr1altb29DQ0IyMDFEUT58+/d///rdVq1bi/7uw0jV/oihevXpVOjYrimJRUdHJkyeLioq0XrX2rFmzJiAgoHPnzoMGDdq8ebOuy6m4e/fujR07tnbt2sHBwffv3xdF8fLly7///ntUVFTN/hesMH3c5gnIqhQfH9++fXs3N7d27drdvXv32rVro0ePdnNze8Ykjx49evz4sfS6pKRk9+7dCQkJ1XZzqYAKrBN999NPP7Vq1apWrVpt2rRp0aKFi4vLb7/9Jv57krK0L774ok2bNtKV5gsXLqwxw7KeJiMjw9LS8q233po2bZo0bqtRo0ajRo06ePCgrkuroG3btvn4+IwbN071v1gVA5ClX9s8AVnFNm7c2KdPn7Zt27q7uxsbG/v7++/du1cURdkRjDXm1/SzqbVO9JpqxMGtW7cOHDgwb9687777TtpvLk3alfz9998tLCy++uqrrVu3fvjhh5aWlqampoMGDYqLi6t5a0Yyf/78N998UxTF4uLimzdvHjhwYPbs2T4+Pubm5g8fPtR1deopLCwURbG4uHjz5s3Nmzd3dnb+448/SMen0dNtnkE6lSXdiXvVqlXffffdqlWr2rRpc/PmzZ07d+bn57dq1apTp05PO2N//fp1V1fX7t27u7m5HT9+/OjRo4aGhv7+/oGBgd26ddPyUlStCq8TvbZ79+5FixYdPXq0RYsW3377bceOHZ/df8KECbVq1ZKuMRcEIS8vb+fOnYsXL7558+b58+c1X68OpKSk/PzzzzNmzDA3N5daioqKMjIy7t+/7+XlpdvaKiA/P1+6BWtGRsZXX31148aNyZMnd+rUSdd1VV/6t83rOqH1nvTLqFOnTgqFYtKkSS8+YU36NV1GhdeJPqrw1SwnT56MjIxU7XSq5OXlabRgXSkpKTl58qSLi4u+X78kimLPnj39/f2DgoK6des2ePDgMWPGtGnTRqFQjBgxQtelVWt6t80zirVSRFE0MDBIT09PS0tbt27d2rVrT506JQhCUVGRIAhz5sy5efPm06bt2bNnixYtcnNzDQ0NGzdu3L1799DQ0F9++SU+Pl6v71BVmXWij0RRFARh/vz53t7esbGx9+/fd3Nz69ChQ0FBwcqVK2fPnl2mvzS09f79+4mJiUuWLFm0aNGlS5dK371T2impeb788suAgID8/Px33nnH3d19wYIFd+/e1XVRFZGZmenm5mZra2tiYtK9e3djY+OSkpLhw4cHBQV9/vnnuq6uOtLjbV7HAa3npGEXEydO7N27tyiKgwYN6tGjh/TRuXPnFApFQUGB7IQ16dd0GRVeJ3rN29v7p59+EkXRw8MjOjpaavzggw+kHejS41el14MGDWrXrl2rVq0UCoWDg8Nnn30WHx9/48aN6nkmRpbqfNsLnnizsrKaO3fu0aNH9+3b9/HHHzdp0qROnTqenp7S3jZqMP3d5gnIilP9XTAyMtq4caMoiqdPn7axsfnuu+9EUQwNDX311VfFpwxFiY6Odnd3b9q0qUKhcHNzi42NvXPnjhZr15TKrBO9ptbVLDdu3KhTp440Uik7O3vWrFmOjo5GRkZ2dnapqak6qb9iSv87Pjsmz5w50717d9Xw7CdPnly/fn3jxo2+vr76tcjlSQuuVCoZofMMerrNE5CVdf369Q4dOhQWFkp/BOfPn+/m5padnd2sWbO4uDjxKWFQs39NV2yd6LUXvJpF+hu6f//+gIAAaRikyokTJ8aOHasXu9cFBQUrVqwYO3ZsVFTUihUrTp48+dxs2Ldv35AhQ3755Zcy7aqrI1BT6fU2T0BW0IoVK/Lz80vvGUj/9jdv3vT29u7bt6+5ufnTpq2pv6Yrs05qgBe/mmXhwoUeHh7Lly/XRZlVYObMma1atXJ3d+/YsWP79u39/Pw+//zz9evXX7lyRbb/kydPGjRooFAonJyc4uLiasbBEqhFT7d5ArIisrKyvLy8pJFXa9euLTMEa/ny5QqFIigoSJS7Nlysob+mK7lO9JG0ICtXrvT29j579qwoijdu3Pjpp58WLFiwffv2p8XAzZs37ezspAd/RkVF7d2798aNG1qtu9KcnJxWr14timJJScmff/45bty4bt26NW/efN68eU+b5MGDB1u3bvXz8zMyMmrUqNHHH3988ODB8qMZUSPp7zZPQFZEXl5eSkqKKIpJSUm2trbt27cfO3astLsg2b17t7QFlL+VWk39NV2ZdaKnKnM1S0JCwkcffeTo6Cg9H3vBggX68iCwR48eBQcHb926tXTj7du3ly5dmpaW9tzJb968GRsb6+XlpVAohg0bprEyUe3o4zbPjQIqJTs7e9++fadOnfr777+l22j16dNn4MCBnp6ez5gqJyfnwIEDS5Ys2b9/f/369QcNGvTee+95enpKjxTWdxVbJ3pHFEWFQpGenu7i4vLrr7/+97//3bFjR9u2bYuKioyMjObMmfPRRx81adLk2TN59OjRpk2b1q9fv3PnzvDw8PDwcO0UX0lr167du3fvt99++yJbrCiKV69e/euvv86cOePr6/vaa69J7WlpacXFxfp4fwBUhn5t8wRkRUh/HFVvHz9+fP78+bS0tH/++ed///vf8ePHv//++2HDhj13PpmZmevXr//111+Tk5OHDh2q148gr6p1oi+kuwWFhIQcP348Pj5+8ODBd+/eTUhIEATh/PnzTk5O+fn5pqamqv7SM57y8vKOHj36008/FRQUBAYGDhkyRPr02rVrxsbGtra2OlkWtYwePXr9+vX5+fkdOnTo1auXr69vt27dTExMntZ/48aNMTExxcXFDx8+LCwslC6KffDggY2NjRarhg7UhG1el7uveks1CiFoVAAAGnRJREFUZu/atWulBybcv3//8OHD33zzjXR3//JD+5RK5eXLl1etWjVlypTShx9TU1P/+ecfzReuQRVeJ/qoAlezSK8nT57s4uIyefJkKyur119/XRTFrKys27dva38RKiYuLs7GxmbZsmXLli0bPXp0r169vL29BwwYEBER8bTbPzk6On7zzTeiKPr6+v73v/8VRTE5OXnKlCkXL17UaumoIi9+/WsN2OYJyIqQTj7NnDlTujNcs2bNJk2adOHChedOuGHDBh8fn44dO7Zt27Zly5aFhYWFhYW3bt3SfMkaV+F1or/UvZrl0aNH9erVk55c0bZtW2lE38aNG9977z19eR79zJkzp0yZIr0uKSlJSUn59ttvBw0a9LSziampqdbW1g8fPiwqKjI3N5d+BZ48edLb27tmXNH0cnrx61/1fZsnINUmbRCXLl0yNTUNDw/funXrtGnTpDsxdujQYfbs2UVFRU/baGrqr+nKrBO9U4GrWaRlX7NmjYuLiyiK//zzT/369bOzs0VRTE1NbdeuXfknflRDRUVF8+bNGz58eJn2/Pz8q1evyk7y119/eXt75+bm/vjjj+3atZPWQ3x8vK2trcbLRVVT6/rXmrHNE5AV9MMPPwwcOFB6XVxcnJ2dvWfPnhEjRjRq1OhpV2vU+F/TFVgneqcyV7McOnSoS5cuSqVy/PjxQ4YMkRpjY2P15emYCQkJjRs3NjMzmzRp0gv+/C8oKOjdu/eiRYu8vb3nzJkjiqJ0L9Z3331Xw8Wi6ql7/auo/9s8AVlBt2/fDg4OvnTpUunGoqIi6bIN2SsZavyv6QqsE71TmatZHjx44OXl9emnn1paWv7666+i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ggRQzJYtW168eMFisQoKCpqamqiDmpqaHA5nx44dXC53y5YtSm0gwABT25rHLFYABTQ2Nurp6Xl5edXV1S1evLi4uLimpoYgCAMDA4IgNDU1J02a5OjoaGlpqeyWAgwMda55BCSAAsLDw+fOnWtmZkYQRHt7+6NHj3Jzc4VC4b179xoaGoYNG+bi4sLIOwWoLXWuefwNEqC32tra9PT0njx5YmFh8f333+/atYvFYuXk5Fy4cOHWrVtdXV2amppffPFFSEiIslsKMDDUvOYRkAC9dfv27eDg4NjY2LFjx3p4eHSfttfa2vrXX38dO3Zs+/btbm5uSmwkwABS85pHQAIoYNu2bampqTKZbNy4cQKBgMfjKbtFAINLnWseAQmggNbW1pycHH9/f1tb25aWFktLy6CgoJCQkE8++UTZTQMYFOpc85ikA6AALS0tmUxWW1sbHx8/ceLEtra2jIyM/fv3C4VCiUQyefJkZTcQYICpc83jEySAwiQSCfW05Pr6+sePHxcUFGRlZXV2dmZnZyu7aQCDQj1rHgEJ0F8kSVZVVZEkST1CFoDx1KTmEZAAAAA0sNUcAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAADQQkAAAAjf8Bl6aUY26UKaMAAAAASUVORK5CYII=",
"type":"image"
},
{
"fragments":[
{
"text":"Memoizing failures seems to be much less important than memoizing matches. But it still improves performance.",
"type":"text"
}
],
"id":"c6b15c91fe72429898a7835f4f0f7f8d",
"type":"text"
},
{
"fragments":[
{
"text":"todo: verify these numbers before publishing final version",
"type":"strong"
}
],
"id":"9b79c99721e2469e86538ccc5fb711c2",
"type":"text"
}
],
"title":"Results"
},
{
"children":[
{
"children":[],
"id":"ea9e60e51c034b99b32520af593fa2c0",
"paragraphs":[
{
"fragments":[
{
"text":"The rest of the support library:",
"type":"text"
}
],
"id":"8ae1d7735cc3406f82742fdba335cda6",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\nclass _Grammar(object):\n\n    def _or(self, matchers):\n        original_stream = self._stream\n        for matcher in matchers[:-1]:\n            try:\n                return matcher()\n            except _MatchError:\n                self._stream = original_stream\n        return matchers[-1]()\n\n    def _and(self, matchers):\n        result = None\n        for matcher in matchers:\n            result = matcher()\n        return result\n\n    def _star(self, matcher):\n        result = []\n        while True:\n            original_stream = self._stream\n            try:\n                result.append(matcher())\n            except _MatchError:\n                self._stream = original_stream\n                return _SemanticAction(lambda: [x.eval() for x in result])\n\n    def _not(self, matcher):\n        original_stream = self._stream\n        try:\n            matcher()\n        except _MatchError:\n            return _SemanticAction(lambda: None)\n        else:\n            original_stream.fail(lambda: \"match found\")\n        finally:\n            self._stream = original_stream\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"match rule"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"\n    def _match_range(self, start, end):\n        next_objext = self._stream.peek()\n        if next_objext >= start and next_objext <= end:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: next_objext)\n        else:\n            self._stream.fail(\n                lambda: \"expected range {!r}-{!r} but found {!r}\".format(start, end, next_objext)\n            )\n\n    def _match_string(self, string):\n        next_object = self._stream.peek()\n        if next_object == string:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: string)\n        else:\n            self._stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(string, next_object)\n            )\n\n    def _match_charseq(self, charseq):\n        for char in charseq:\n            next_object = self._stream.peek()\n            if next_object != char:\n                self._stream.fail(\n                    lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n                )\n            self._stream = self._stream.advance()\n        return _SemanticAction(lambda: charseq)\n\n    def _match_any(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return _SemanticAction(lambda: next_object)\n\n    def _match_call_rule(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return self._match_rule(str(next_object))\n\n    def _match_list(self, matcher):\n        original_stream = self._stream\n        next_object = self._stream.peek()\n        if isinstance(next_object, list):\n            self._stream = self._stream.nested(next_object)\n            matcher()\n            if self._stream.is_at_end():\n                self._stream = original_stream.advance()\n                return _SemanticAction(lambda: next_object)\n        original_stream.fail(lambda: \"list match failed\")\n\n    def run(self, rule_name, input_object):\n        self._memo = _Memo()\n        self._stream = _Stream.from_object(self._memo, input_object)\n        result = self._match_rule(rule_name).eval()\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Vars(dict):\n\n    def bind(self, name, value):\n        self[name] = value\n        return value\n\n    def lookup(self, name):\n        return self[name]\n\nclass _SemanticAction(object):\n\n    def __init__(self, fn):\n        self.fn = fn\n\n    def eval(self):\n        return self.fn()\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _Memo(dict):\n\n    def __init__(self):\n        dict.__init__(self)\n        self._latest_stream = _ObjectStream(self, [], -1)\n        self._latest_lazy_message = lambda: \"\"\n\n    def describe(self):\n        items = []\n        for (rule_name, _), (_, start, end) in self.items():\n            if end > start:\n                items.append((rule_name, start, end))\n        items.sort(key=lambda item: (item[2].position(), item[1].position()))\n        message = []\n        for item in items:\n            message.append(\"matched {: <20} {} -> {}\\n\".format(*item))\n        message.append(\"\\n\")\n        message.append(\"ERROR: {}: {}\\n\".format(\n            self._latest_stream,\n            self._latest_lazy_message()\n        ))\n        return \"\".join(message)\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"memo fail"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"match error"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\nclass _Stream(object):\n\n    @classmethod\n    def from_object(cls, memo, input_object):\n        if isinstance(input_object, basestring):\n            return _CharStream(memo, input_object, 0)\n        else:\n            return _ObjectStream(memo, [input_object], 0)\n\n    def __init__(self, memo, objects, index):\n        self._memo = memo\n        self._objects = objects\n        self._index = index\n\n    def fail(self, lazy_message):\n        self._memo.fail(self, lazy_message)\n\n    def peek(self):\n        if self.is_at_end():\n            self.fail(lambda: \"not eof\")\n        return self._objects[self._index]\n\n    def is_at_end(self):\n        return self._index >= len(self._objects)\n\nclass _CharStream(_Stream):\n\n    def __init__(self, memo, objects, index, line=1, column=1):\n        _Stream.__init__(self, memo, objects, index)\n        self._line = line\n        self._column = column\n\n    def position(self):\n        return self._index\n\n    def advance(self):\n        if self._objects[self._index] == \"\\n\":\n            line = self._line + 1\n            column = 1\n        else:\n            line = self._line\n            column = self._column + 1\n        return _CharStream(self._memo, self._objects, self._index+1, line, column)\n\n    def __str__(self):\n        return \"L{:03d}:C{:03d}\".format(self._line, self._column)\n\nclass _ObjectStream(_Stream):\n\n    def __init__(self, memo, objects, index, parent=()):\n        _Stream.__init__(self, memo, objects, index)\n        self._parent_position = parent\n        self._position = self._parent_position + (self._index,)\n\n    def position(self):\n        return self._position\n\n    def nested(self, input_object):\n        return _ObjectStream(self._memo, input_object, 0, self._position)\n\n    def advance(self):\n        return _ObjectStream(self._memo, self._objects, self._index+1, self._parent_position)\n\n    def __str__(self):\n        return \"[{}]\".format(\", \".join(str(x) for x in self.position()))\n",
"type":"code"
}
],
"id":"aca14d0f6ac5466b86977fb1f64dbfe7",
"type":"code"
}
],
"title":"Support library (optimzied)"
},
{
"children":[],
"id":"46ac5a5f243c4bd69cec58758e92eadd",
"paragraphs":[
{
"fragments":[
{
"text":"The rest of the support library:",
"type":"text"
}
],
"id":"849f4e79807e468f972e2611ad0f9788",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\ndef rlmeta_vm(instructions, labels, start_rule, stream):\n    label_counter = 0\n    last_action = _ConstantSemanticAction(None)\n    pc = labels[start_rule]\n    call_backtrack_stack = []\n    stream, pos, stream_pos_stack = (stream, 0, [])\n    scope, scope_stack = (None, [])\n    fail_message = None\n    latest_fail_message, latest_fail_pos = (None, tuple())\n    memo = {}\n    while True:\n        name, arg1, arg2 = instructions[pc]\n        if name == \"PUSH_SCOPE\":\n            scope_stack.append(scope)\n            scope = {}\n            pc += 1\n            continue\n        elif name == \"BACKTRACK\":\n            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))\n            pc += 1\n            continue\n        elif name == \"CALL\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"CALL"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"MATCH_CHARSEQ\":\n            for char in arg1:\n                if pos >= len(stream) or stream[pos] != char:\n                    fail_message = (\"expected {!r}\", char)\n                    break\n                pos += 1\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pc += 1\n                continue\n        elif name == \"COMMIT\":\n            call_backtrack_stack.pop()\n            pc = labels[arg1]\n            continue\n        elif name == \"POP_SCOPE\":\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"RETURN\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"RETURN"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"LIST_APPEND\":\n            scope.append(last_action)\n            pc += 1\n            continue\n        elif name == \"BIND\":\n            scope[arg1] = last_action\n            pc += 1\n            continue\n        elif name == \"ACTION\":\n            last_action = _UserSemanticAction(arg1, scope)\n            pc += 1\n            continue\n        elif name == \"MATCH_RANGE\":\n            if pos >= len(stream) or not (arg1 <= stream[pos] <= arg2):\n                fail_message = (\"expected range {!r}-{!r}\", arg1, arg2)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"LIST_START\":\n            scope_stack.append(scope)\n            scope = []\n            pc += 1\n            continue\n        elif name == \"LIST_END\":\n            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"MATCH_ANY\":\n            if pos >= len(stream):\n                fail_message = (\"expected any\",)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"PUSH_STREAM\":\n            if pos >= len(stream) or not isinstance(stream[pos], list):\n                fail_message = (\"expected list\",)\n            else:\n                stream_pos_stack.append((stream, pos))\n                stream = stream[pos]\n                pos = 0\n                pc += 1\n                continue\n        elif name == \"POP_STREAM\":\n            if pos < len(stream):\n                fail_message = (\"expected end of list\",)\n            else:\n                stream, pos = stream_pos_stack.pop()\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"MATCH_CALL_RULE\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"MATCH_CALL_RULE"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"FAIL\":\n            fail_message = (arg1,)\n        elif name == \"LABEL\":\n            last_action = _ConstantSemanticAction(label_counter)\n            label_counter += 1\n            pc += 1\n            continue\n        elif name == \"MATCH_STRING\":\n            if pos >= len(stream) or stream[pos] != arg1:\n                fail_message = (\"expected {!r}\", arg1)\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pos += 1\n                pc += 1\n                continue\n        else:\n            raise Exception(\"unknown instruction {}\".format(name))\n        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])\n        if fail_pos >= latest_fail_pos:\n            latest_fail_message = fail_message\n            latest_fail_pos = fail_pos\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"pop backtrack entry"
],
"prefix":"        ",
"type":"chunk"
},
{
"text":"        if len(call_backtrack_entry) != 4:\n            fail_pos = list(latest_fail_pos)\n            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream\n            while len(fail_pos) > 1:\n                fail_stream = fail_stream[fail_pos.pop(0)]\n            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)\n        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry\n        if len(stream_pos_stack) > stream_stack_len:\n            stream = stream_pos_stack[stream_stack_len][0]\n        stream_pos_stack = stream_pos_stack[:stream_stack_len]\n        if len(scope_stack) > scope_stack_len:\n            scope = scope_stack[scope_stack_len]\n        scope_stack = scope_stack[:scope_stack_len]\n\nclass _Grammar(object):\n\n    def run(self, rule_name, input_object):\n        if isinstance(input_object, basestring):\n            stream = input_object\n        else:\n            stream = [input_object]\n        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _ConstantSemanticAction(object):\n\n    def __init__(self, value):\n        self.value = value\n\n    def eval(self):\n        return self.value\n\nclass _UserSemanticAction(object):\n\n    def __init__(self, fn, scope):\n        self.fn = fn\n        self.scope = scope\n\n    def eval(self):\n        return self.fn(self.scope)\n\nclass _MatchError(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\n    def describe(self):\n        message = \"\"\n        if isinstance(self.stream, basestring):\n            before = self.stream[:self.pos].splitlines()\n            after = self.stream[self.pos:].splitlines()\n            for context_before in before[-4:-1]:\n                message += self._context(context_before)\n            message += self._context(before[-1], after[0])\n            message += self._arrow(len(before[-1]))\n            for context_after in after[1:4]:\n                message += self._context(context_after)\n        else:\n            message += self._context(\"[\")\n            for context_before in self.stream[:self.pos]:\n                message += self._context(\"  \", repr(context_before), \",\")\n            message += self._context(\"  \", repr(self.stream[self.pos]), \",\")\n            message += self._arrow(2)\n            for context_after in self.stream[self.pos+1:]:\n                message += self._context(\"  \", repr(context_after), \",\")\n            message += self._context(\"]\")\n        message += \"Error: \"\n        message += self.message[0].format(*self.message[1:])\n        message += \"\\n\"\n        return message\n\n    def _context(self, *args):\n        return \"> {}\\n\".format(\"\".join(args))\n\n    def _arrow(self, lenght):\n        return \"--{}^\\n\".format(\"-\"*lenght)\n",
"type":"code"
}
],
"id":"3233095b41404567872d7e190fb1ad66",
"type":"code"
}
],
"title":"Support library (VM)"
}
],
"id":"042d4832e92c48349da9e4fe0a73f955",
"paragraphs":[],
"title":"Appendix"
}
],
"id":"f4591956cea04b03be2859df337f261a",
"paragraphs":[
{
"fragments":[
{
"text":"After reading ",
"type":"text"
},
{
"text":"Generating a PEG Parser",
"type":"link",
"url":"https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9"
},
{
"text":" I realized that RLMeta has a flaw in its its memoization logic: It only memoizes results when a rule matches. If a rule fails, it is not recorded in the memoization table. Therefore, if that rule is tried again at the same position, it has to try matching again, even though it will fail. In the article, Guido writes",
"type":"text"
}
],
"id":"3a35c5393d0047a4b172fcce7438ef97",
"type":"text"
},
{
"fragments":[
{
"text":"It is important to cache negative results too - in fact most calls to parsing methods will be negative results.",
"type":"text"
}
],
"id":"8ed0d48428924afe8fa356860cdf59b6",
"type":"quote"
},
{
"fragments":[
{
"text":"Besides fixing the flaw in the memoization logic, I am also interested in seeing how it affects performance.",
"type":"text"
}
],
"id":"b5a617dbf9dc4745a60e8a7e5fc6ec01",
"type":"text"
},
{
"fragments":[
{
"text":"In this article I show how I fix the memoization logic in both the ",
"type":"text"
},
{
"text":"optimized version",
"type":"link",
"url":"/writing/optimizing-rlmeta/index.html"
},
{
"text":" and the ",
"type":"text"
},
{
"text":"vm based version",
"type":"link",
"url":"/writing/rlmeta-vm/index.html"
},
{
"text":" and show how performance is affected.",
"type":"text"
}
],
"id":"eb08d8940b994db29d7af67aa6eb3323",
"type":"text"
}
],
"title":"Memoizing failiures in RLMeta"
},
"variables":{}
}