{
"root_page":{
"children":[
{
"children":[],
"id":"a9a4166e943a4d2c974c443cef1da5a9",
"paragraphs":[
{
"fragments":[
{
"text":"In the optimized version, the memoization table stores tuples with result, start position, and end position. If a rule fails, a new kind of value that indicates a failure must be stored. We reuse the same tuple, but have the result be ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" in case of a failure and have the start position be the lazy fail message.",
"type":"text"
}
],
"id":"ad62ef2e2f4341a09001b937f4fec507",
"type":"text"
},
{
"fragments":[
{
"text":"The memoization table is both queried and populated in the support library method ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":". The fixed version looks like this:",
"type":"text"
}
],
"id":"a3456947282b4b8c81e5f3bd41e12371",
"type":"text"
},
{
"chunkpath":[
"match rule"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"def _match_rule(self, rule_name):\n    key = (rule_name, self._stream.position())\n    if key in self._memo:\n        if self._memo[key][0] is None:\n            self._stream.fail(self._memo[key][1])\n        else:\n            result, _, self._stream = self._memo[key]\n    else:\n        try:\n            start = self._stream\n            result = getattr(self, \"_rule_{}\".format(rule_name))()\n            end = self._stream\n            self._memo[key] = (result, start, end)\n        except _MatchError as e:\n            self._memo[key] = (None, e.lazy_message, None)\n            raise\n    return result\n",
"type":"code"
}
],
"id":"49bd6fdc3d8a40a9ae62454cafe2e330",
"type":"code"
},
{
"fragments":[
{
"text":"If a memoization entry exists and the result part is ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":", the match fails immediately with the fail message stored in the entry. If the result part is not ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" the result is used as before.",
"type":"text"
}
],
"id":"ff60c761ff454d47887254469463e226",
"type":"text"
},
{
"fragments":[
{
"text":"If a memoization entry does not exist and the match fails, the failure is recorded in the memoization table before propagating the exception. If the match succeeds the result is recorded as before.",
"type":"text"
}
],
"id":"cdac85b2dab54385921a4e7a02d14c96",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"_MatchError",
"type":"code"
},
{
"text":" class is also modified to save the lazy message so that it can be accessed for storage in the memoization table:",
"type":"text"
}
],
"id":"a717601e63bf43539cddcfd009cafbba",
"type":"text"
},
{
"chunkpath":[
"memo fail"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"def fail(self, stream, lazy_message):\n    if stream.position() >= self._latest_stream.position():\n        self._latest_stream = stream\n        self._latest_lazy_message = lazy_message\n    raise _MatchError(self, lazy_message)\n",
"type":"code"
}
],
"id":"9a08cc0615d1433b8da4c5cd550a5892",
"type":"code"
},
{
"chunkpath":[
"match error"
],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"class _MatchError(Exception):\n\n    def __init__(self, memo, lazy_message):\n        Exception.__init__(self)\n        self._memo = memo\n        self.lazy_message = lazy_message\n\n    def describe(self):\n        return self._memo.describe()\n",
"type":"code"
}
],
"id":"666a02fdacd2475488156dfb764a70e1",
"type":"code"
}
],
"title":"Optimized version"
},
{
"children":[],
"id":"fe17638693e344ad9e521e55bf0676f3",
"paragraphs":[
{
"fragments":[
{
"text":"In the VM based version, the memoization table stores tuples with last action, and stream position stack. If a rule fails, a new kind of value that indicates a failure must be stored. We reuse the same tuple, but have the last action be ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" in case of a failure and have the stream position stack be the failure message.",
"type":"text"
}
],
"id":"dd1699bbf01245788615d6a9ca30b7b7",
"type":"text"
},
{
"fragments":[
{
"text":"The memoization table is queried and populated in different places. The first place it's populated is in the ",
"type":"text"
},
{
"text":"RETURN",
"type":"code"
},
{
"text":" instruction:",
"type":"text"
}
],
"id":"c8ea8426236643b2a30aeb675e9a666f",
"type":"text"
},
{
"chunkpath":[
"RETURN"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"if len(call_backtrack_stack) == 0:\n    return last_action.eval()\npc, key = call_backtrack_stack.pop()\nmemo[key] = (last_action, stream_pos_stack+[(stream, pos)])\ncontinue\n",
"type":"code"
}
],
"id":"20ace23911b1446ab7c8e6cba4a4527a",
"type":"code"
},
{
"fragments":[
{
"text":"This code is unchanged and I include it here only for context. It populates the memoization table when a rule has matched. To populate the memoization table with a failure, the code that pops a backtrack entry must be modified like this:",
"type":"text"
}
],
"id":"a452d66363dd4541832da39c36b13cc5",
"type":"text"
},
{
"chunkpath":[
"pop backtrack entry"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"call_backtrack_entry = tuple()\nwhile call_backtrack_stack:\n    call_backtrack_entry = call_backtrack_stack.pop()\n    if len(call_backtrack_entry) == 4:\n        break\n    else:\n        _, key = call_backtrack_entry\n        memo[key] = (None, fail_message)\n",
"type":"code"
}
],
"id":"09bb7d528d084ca7a31b98ea7659a8a0",
"type":"code"
},
{
"fragments":[
{
"text":"If the popped item is not a backtrack entry (length of tuple is 4), it must be a call entry. It means that the given rule has been called, and it has failed. In that case, ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":" is stored in the memoization table to indicate a failure, along with the fail message as second element.",
"type":"text"
}
],
"id":"69862c2f6c474a7cb3323400e77399b2",
"type":"text"
},
{
"fragments":[
{
"text":"Next code that queries the memoization table need to be updated. It happens in the two call instructions ",
"type":"text"
},
{
"text":"CALL",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"MATCH_CALL_RULE",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"5cb1fcd1ceca47298a591a34dd960a48",
"type":"text"
},
{
"chunkpath":[
"CALL"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"key = (arg1, tuple([x[1] for x in stream_pos_stack]+[pos]))\nif key in memo:\n    if memo[key][0] is None:\n        fail_message = memo[key][1]\n    else:\n        last_action, stream_pos_stack = memo[key]\n        stream_pos_stack = stream_pos_stack[:]\n        stream, pos = stream_pos_stack.pop()\n        pc += 1\n        continue\nelse:\n    call_backtrack_stack.append((pc+1, key))\n    pc = labels[arg1]\n    continue\n",
"type":"code"
}
],
"id":"7f7bb394b7b9434eb91e19118aa52a0a",
"type":"code"
},
{
"chunkpath":[
"MATCH_CALL_RULE"
],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"if pos >= len(stream):\n    fail_message = (\"expected any\",)\nelse:\n    fn_name = str(stream[pos])\n    key = (fn_name, tuple([x[1] for x in stream_pos_stack]+[pos]))\n    if key in memo:\n        if memo[key][0] is None:\n            fail_message = memo[key][1]\n        else:\n            last_action, stream_pos_stack = memo[key]\n            stream_pos_stack = stream_pos_stack[:]\n            stream, pos = stream_pos_stack.pop()\n            pc += 1\n            continue\n    else:\n        call_backtrack_stack.append((pc+1, key))\n        pc = labels[fn_name]\n        pos += 1\n        continue\n",
"type":"code"
}
],
"id":"6ff1e38b876b4f32b4a004a4611c1639",
"type":"code"
},
{
"fragments":[
{
"text":"They are changed to look at the first argument in the memoized entry. If it is ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":", it indicates a failure. The ",
"type":"text"
},
{
"text":"fail_message",
"type":"code"
},
{
"text":" is then set and the ",
"type":"text"
},
{
"text":"continue",
"type":"code"
},
{
"text":" statement is skipped:",
"type":"text"
}
],
"id":"c84e68688df6401391511bf4508c0f78",
"type":"text"
}
],
"title":"VM based version"
},
{
"children":[],
"id":"42ae6babf74d427880f831bd14109002",
"paragraphs":[
{
"fragments":[
{
"text":"Are the versions that also memoize failures faster? Here are the performance measurements:",
"type":"text"
}
],
"id":"b4c7dc1608e343cc9cbefb2acd3e6844",
"type":"text"
},
{
"fragments":[
{
"text":"Performance measurements.",
"type":"text"
}
],
"id":"866972443e7644629d53b53db0607fb5",
"image_base64":"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",
"type":"image"
},
{
"fragments":[
{
"text":"To measure the performance without memoization I commented out the code that populates the memoization table.",
"type":"text"
}
],
"id":"fd07d441d08d4920a7d4ef0dd5c890f5",
"type":"text"
},
{
"fragments":[
{
"text":"Memoizing failures seems to be much less important than memoizing matches. But it still improves performance.",
"type":"text"
}
],
"id":"c6b15c91fe72429898a7835f4f0f7f8d",
"type":"text"
}
],
"title":"Performance measurements"
},
{
"children":[
{
"children":[],
"id":"ea9e60e51c034b99b32520af593fa2c0",
"paragraphs":[
{
"fragments":[
{
"text":"The rest of the support library for the optimized version:",
"type":"text"
}
],
"id":"8ae1d7735cc3406f82742fdba335cda6",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"optimized",
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\nclass _Grammar(object):\n\n    def _or(self, matchers):\n        original_stream = self._stream\n        for matcher in matchers[:-1]:\n            try:\n                return matcher()\n            except _MatchError:\n                self._stream = original_stream\n        return matchers[-1]()\n\n    def _and(self, matchers):\n        result = None\n        for matcher in matchers:\n            result = matcher()\n        return result\n\n    def _star(self, matcher):\n        result = []\n        while True:\n            original_stream = self._stream\n            try:\n                result.append(matcher())\n            except _MatchError:\n                self._stream = original_stream\n                return _SemanticAction(lambda: [x.eval() for x in result])\n\n    def _not(self, matcher):\n        original_stream = self._stream\n        try:\n            matcher()\n        except _MatchError:\n            return _SemanticAction(lambda: None)\n        else:\n            original_stream.fail(lambda: \"match found\")\n        finally:\n            self._stream = original_stream\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"match rule"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"\n    def _match_range(self, start, end):\n        next_objext = self._stream.peek()\n        if next_objext >= start and next_objext <= end:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: next_objext)\n        else:\n            self._stream.fail(\n                lambda: \"expected range {!r}-{!r} but found {!r}\".format(start, end, next_objext)\n            )\n\n    def _match_string(self, string):\n        next_object = self._stream.peek()\n        if next_object == string:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: string)\n        else:\n            self._stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(string, next_object)\n            )\n\n    def _match_charseq(self, charseq):\n        for char in charseq:\n            next_object = self._stream.peek()\n            if next_object != char:\n                self._stream.fail(\n                    lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n                )\n            self._stream = self._stream.advance()\n        return _SemanticAction(lambda: charseq)\n\n    def _match_any(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return _SemanticAction(lambda: next_object)\n\n    def _match_call_rule(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return self._match_rule(str(next_object))\n\n    def _match_list(self, matcher):\n        original_stream = self._stream\n        next_object = self._stream.peek()\n        if isinstance(next_object, list):\n            self._stream = self._stream.nested(next_object)\n            matcher()\n            if self._stream.is_at_end():\n                self._stream = original_stream.advance()\n                return _SemanticAction(lambda: next_object)\n        original_stream.fail(lambda: \"list match failed\")\n\n    def run(self, rule_name, input_object):\n        self._memo = _Memo()\n        self._stream = _Stream.from_object(self._memo, input_object)\n        result = self._match_rule(rule_name).eval()\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Vars(dict):\n\n    def bind(self, name, value):\n        self[name] = value\n        return value\n\n    def lookup(self, name):\n        return self[name]\n\nclass _SemanticAction(object):\n\n    def __init__(self, fn):\n        self.fn = fn\n\n    def eval(self):\n        return self.fn()\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _Memo(dict):\n\n    def __init__(self):\n        dict.__init__(self)\n        self._latest_stream = _ObjectStream(self, [], -1)\n        self._latest_lazy_message = lambda: \"\"\n\n    def describe(self):\n        items = []\n        for (rule_name, _), (_, start, end) in self.items():\n            if end > start:\n                items.append((rule_name, start, end))\n        items.sort(key=lambda item: (item[2].position(), item[1].position()))\n        message = []\n        for item in items:\n            message.append(\"matched {: <20} {} -> {}\\n\".format(*item))\n        message.append(\"\\n\")\n        message.append(\"ERROR: {}: {}\\n\".format(\n            self._latest_stream,\n            self._latest_lazy_message()\n        ))\n        return \"\".join(message)\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"memo fail"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"match error"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\nclass _Stream(object):\n\n    @classmethod\n    def from_object(cls, memo, input_object):\n        if isinstance(input_object, basestring):\n            return _CharStream(memo, input_object, 0)\n        else:\n            return _ObjectStream(memo, [input_object], 0)\n\n    def __init__(self, memo, objects, index):\n        self._memo = memo\n        self._objects = objects\n        self._index = index\n\n    def fail(self, lazy_message):\n        self._memo.fail(self, lazy_message)\n\n    def peek(self):\n        if self.is_at_end():\n            self.fail(lambda: \"not eof\")\n        return self._objects[self._index]\n\n    def is_at_end(self):\n        return self._index >= len(self._objects)\n\nclass _CharStream(_Stream):\n\n    def __init__(self, memo, objects, index, line=1, column=1):\n        _Stream.__init__(self, memo, objects, index)\n        self._line = line\n        self._column = column\n\n    def position(self):\n        return self._index\n\n    def advance(self):\n        if self._objects[self._index] == \"\\n\":\n            line = self._line + 1\n            column = 1\n        else:\n            line = self._line\n            column = self._column + 1\n        return _CharStream(self._memo, self._objects, self._index+1, line, column)\n\n    def __str__(self):\n        return \"L{:03d}:C{:03d}\".format(self._line, self._column)\n\nclass _ObjectStream(_Stream):\n\n    def __init__(self, memo, objects, index, parent=()):\n        _Stream.__init__(self, memo, objects, index)\n        self._parent_position = parent\n        self._position = self._parent_position + (self._index,)\n\n    def position(self):\n        return self._position\n\n    def nested(self, input_object):\n        return _ObjectStream(self._memo, input_object, 0, self._position)\n\n    def advance(self):\n        return _ObjectStream(self._memo, self._objects, self._index+1, self._parent_position)\n\n    def __str__(self):\n        return \"[{}]\".format(\", \".join(str(x) for x in self.position()))\n",
"type":"code"
}
],
"id":"aca14d0f6ac5466b86977fb1f64dbfe7",
"type":"code"
}
],
"title":"Support library (optimzied)"
},
{
"children":[],
"id":"46ac5a5f243c4bd69cec58758e92eadd",
"paragraphs":[
{
"fragments":[
{
"text":"The rest of the support library for the VM based version:",
"type":"text"
}
],
"id":"849f4e79807e468f972e2611ad0f9788",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"vm",
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\ndef rlmeta_vm(instructions, labels, start_rule, stream):\n    label_counter = 0\n    last_action = _ConstantSemanticAction(None)\n    pc = labels[start_rule]\n    call_backtrack_stack = []\n    stream, pos, stream_pos_stack = (stream, 0, [])\n    scope, scope_stack = (None, [])\n    fail_message = None\n    latest_fail_message, latest_fail_pos = (None, tuple())\n    memo = {}\n    while True:\n        name, arg1, arg2 = instructions[pc]\n        if name == \"PUSH_SCOPE\":\n            scope_stack.append(scope)\n            scope = {}\n            pc += 1\n            continue\n        elif name == \"BACKTRACK\":\n            call_backtrack_stack.append((labels[arg1], pos, len(stream_pos_stack), len(scope_stack)))\n            pc += 1\n            continue\n        elif name == \"CALL\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"CALL"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"MATCH_CHARSEQ\":\n            for char in arg1:\n                if pos >= len(stream) or stream[pos] != char:\n                    fail_message = (\"expected {!r}\", char)\n                    break\n                pos += 1\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pc += 1\n                continue\n        elif name == \"COMMIT\":\n            call_backtrack_stack.pop()\n            pc = labels[arg1]\n            continue\n        elif name == \"POP_SCOPE\":\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"RETURN\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"RETURN"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"LIST_APPEND\":\n            scope.append(last_action)\n            pc += 1\n            continue\n        elif name == \"BIND\":\n            scope[arg1] = last_action\n            pc += 1\n            continue\n        elif name == \"ACTION\":\n            last_action = _UserSemanticAction(arg1, scope)\n            pc += 1\n            continue\n        elif name == \"MATCH_RANGE\":\n            if pos >= len(stream) or not (arg1 <= stream[pos] <= arg2):\n                fail_message = (\"expected range {!r}-{!r}\", arg1, arg2)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"LIST_START\":\n            scope_stack.append(scope)\n            scope = []\n            pc += 1\n            continue\n        elif name == \"LIST_END\":\n            last_action = _UserSemanticAction(lambda xs: [x.eval() for x in xs], scope)\n            scope = scope_stack.pop()\n            pc += 1\n            continue\n        elif name == \"MATCH_ANY\":\n            if pos >= len(stream):\n                fail_message = (\"expected any\",)\n            else:\n                last_action = _ConstantSemanticAction(stream[pos])\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"PUSH_STREAM\":\n            if pos >= len(stream) or not isinstance(stream[pos], list):\n                fail_message = (\"expected list\",)\n            else:\n                stream_pos_stack.append((stream, pos))\n                stream = stream[pos]\n                pos = 0\n                pc += 1\n                continue\n        elif name == \"POP_STREAM\":\n            if pos < len(stream):\n                fail_message = (\"expected end of list\",)\n            else:\n                stream, pos = stream_pos_stack.pop()\n                pos += 1\n                pc += 1\n                continue\n        elif name == \"MATCH_CALL_RULE\":\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"MATCH_CALL_RULE"
],
"prefix":"            ",
"type":"chunk"
},
{
"text":"        elif name == \"FAIL\":\n            fail_message = (arg1,)\n        elif name == \"LABEL\":\n            last_action = _ConstantSemanticAction(label_counter)\n            label_counter += 1\n            pc += 1\n            continue\n        elif name == \"MATCH_STRING\":\n            if pos >= len(stream) or stream[pos] != arg1:\n                fail_message = (\"expected {!r}\", arg1)\n            else:\n                last_action = _ConstantSemanticAction(arg1)\n                pos += 1\n                pc += 1\n                continue\n        else:\n            raise Exception(\"unknown instruction {}\".format(name))\n        fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])\n        if fail_pos >= latest_fail_pos:\n            latest_fail_message = fail_message\n            latest_fail_pos = fail_pos\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"pop backtrack entry"
],
"prefix":"        ",
"type":"chunk"
},
{
"text":"        if len(call_backtrack_entry) != 4:\n            fail_pos = list(latest_fail_pos)\n            fail_stream = stream_pos_stack[0][0] if stream_pos_stack else stream\n            while len(fail_pos) > 1:\n                fail_stream = fail_stream[fail_pos.pop(0)]\n            raise _MatchError(latest_fail_message, fail_pos[0], fail_stream)\n        (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry\n        if len(stream_pos_stack) > stream_stack_len:\n            stream = stream_pos_stack[stream_stack_len][0]\n        stream_pos_stack = stream_pos_stack[:stream_stack_len]\n        if len(scope_stack) > scope_stack_len:\n            scope = scope_stack[scope_stack_len]\n        scope_stack = scope_stack[:scope_stack_len]\n\nclass _Grammar(object):\n\n    def run(self, rule_name, input_object):\n        if isinstance(input_object, basestring):\n            stream = input_object\n        else:\n            stream = [input_object]\n        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _ConstantSemanticAction(object):\n\n    def __init__(self, value):\n        self.value = value\n\n    def eval(self):\n        return self.value\n\nclass _UserSemanticAction(object):\n\n    def __init__(self, fn, scope):\n        self.fn = fn\n        self.scope = scope\n\n    def eval(self):\n        return self.fn(self.scope)\n\nclass _MatchError(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\n    def describe(self):\n        message = \"\"\n        if isinstance(self.stream, basestring):\n            before = self.stream[:self.pos].splitlines()\n            after = self.stream[self.pos:].splitlines()\n            for context_before in before[-4:-1]:\n                message += self._context(context_before)\n            message += self._context(before[-1], after[0])\n            message += self._arrow(len(before[-1]))\n            for context_after in after[1:4]:\n                message += self._context(context_after)\n        else:\n            message += self._context(\"[\")\n            for context_before in self.stream[:self.pos]:\n                message += self._context(\"  \", repr(context_before), \",\")\n            message += self._context(\"  \", repr(self.stream[self.pos]), \",\")\n            message += self._arrow(2)\n            for context_after in self.stream[self.pos+1:]:\n                message += self._context(\"  \", repr(context_after), \",\")\n            message += self._context(\"]\")\n        message += \"Error: \"\n        message += self.message[0].format(*self.message[1:])\n        message += \"\\n\"\n        return message\n\n    def _context(self, *args):\n        return \"> {}\\n\".format(\"\".join(args))\n\n    def _arrow(self, lenght):\n        return \"--{}^\\n\".format(\"-\"*lenght)\n",
"type":"code"
}
],
"id":"3233095b41404567872d7e190fb1ad66",
"type":"code"
}
],
"title":"Support library (VM)"
}
],
"id":"042d4832e92c48349da9e4fe0a73f955",
"paragraphs":[],
"title":"Appendix"
}
],
"id":"f4591956cea04b03be2859df337f261a",
"paragraphs":[
{
"fragments":[
{
"text":"After reading ",
"type":"text"
},
{
"text":"Generating a PEG Parser",
"type":"link",
"url":"https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9"
},
{
"text":" I realized that RLMeta has a flaw in its its memoization logic: It only memoizes results when a rule matches. If a rule fails, it is not recorded in the memoization table. Therefore, if that rule is tried again at the same position, matching has to be tried again, even though it will fail. In the article, Guido writes",
"type":"text"
}
],
"id":"3a35c5393d0047a4b172fcce7438ef97",
"type":"text"
},
{
"fragments":[
{
"text":"It is important to cache negative results too - in fact most calls to parsing methods will be negative results.",
"type":"text"
}
],
"id":"8ed0d48428924afe8fa356860cdf59b6",
"type":"quote"
},
{
"fragments":[
{
"text":"Besides fixing the flaw in the memoization logic, I am also interested in seeing how it affects performance.",
"type":"text"
}
],
"id":"b5a617dbf9dc4745a60e8a7e5fc6ec01",
"type":"text"
},
{
"fragments":[
{
"text":"In this article I show how to fix the memoization logic in both the ",
"type":"text"
},
{
"text":"optimized version",
"type":"link",
"url":"/writing/optimizing-rlmeta/index.html"
},
{
"text":" and the ",
"type":"text"
},
{
"text":"vm based version",
"type":"link",
"url":"/writing/rlmeta-vm/index.html"
},
{
"text":" and show how performance is affected.",
"type":"text"
}
],
"id":"eb08d8940b994db29d7af67aa6eb3323",
"type":"text"
}
],
"title":"Memoizing failures in RLMeta"
},
"variables":{}
}