Assembler {
  Grammar       = .:x ast*:ys      -> list():rules
                                   -> list():code
                                   -> dict():labels
                                   -> list():patches
                                   -> ys
                                   -> run("asts" patches)
                                   -> { "class " x "(Grammar):\n" >
                                          "rules = {\n" > join(rules ",\n") < "\n}\n"
                                          "code = [\n" > join(code  ",\n") < "\n]\n"
                                        < }
  Rule          = .:x              -> append(rules { repr(x) ": " len(code) })
                                   -> set(labels x len(code))
  Label         = .:x              -> set(labels x len(code))
  Target        = .:x              -> append(patches ["Patch" len(code) x])
                                   -> append(code "placeholder")
  Patch         = .:x .:y          -> set(code x get(labels y))
  OpCode        = .:x              -> append(code x)
  Value         = py:x             -> append(code x)
  Action        = ast:x            -> append(code {"lambda self: " x})
  Set           = py:x ast:y ast:z -> { "self.bind("
                                        x ", " y ", lambda: " z ")" }
  String        = py
  List          = astList:x        -> { "concat([" x "])" }
  ListItem      = py:x ast:y       -> { "splice(" x ", " y ")" }
  Format        = astList:x        -> { "join([" x "])" }
  Indent        = ast:x            -> { "indent(" x ", "
                                        "self.lookup('indentprefix'))" }
  Call          = ast:x astList:y  -> { x "(" y ")" }
  Lookup        = py:x             -> { "self.lookup(" x ")" }
  asts          = ast*:xs !.       -> { xs }
  astList       = ast*:xs          -> join(xs ", ")
  ast           = [%:x]            -> x
  py            = .:x              -> repr(x)
}
