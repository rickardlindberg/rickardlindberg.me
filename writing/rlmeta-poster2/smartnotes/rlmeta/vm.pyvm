def vm(instructions, labels, start_rule, stream):
    action = SemanticAction(None)
    pc = labels[start_rule]
    call_backtrack_stack = []
    stream, pos, stream_pos_stack = (stream, 0, [])
    scope, scope_stack = (None, [])
    fail_message = None
    latest_fail_message, latest_fail_pos = (None, tuple())
    memo = {}

definstruction PUSH_SCOPE():
    scope_stack.append(scope)
    scope = {}

definstruction BACKTRACK(argLabel):
    call_backtrack_stack.append((
        labels[argLabel], pos, len(stream_pos_stack), len(scope_stack)
    ))

definstruction CALL(argFnName):
    #CALL

definstruction POP_SCOPE():
    scope = scope_stack.pop()

definstruction MATCH_OBJECT(argObject):
    if pos >= len(stream) or stream[pos] != argObject:
        fail_message = ("expected {!r}", argObject)
        #FAIL
    else:
        action = SemanticAction(argObject)
        pos += 1

definstruction COMMIT(argLabel):
    call_backtrack_stack.pop()
    pc = labels[argLabel]

definstruction RETURN():
    if len(call_backtrack_stack) == 0:
        return action
    pc, key = call_backtrack_stack.pop()
    memo[key] = (action, stream_pos_stack+[(stream, pos)])

definstruction LIST_APPEND():
    scope.append(action)

definstruction BIND(argName):
    scope[argName] = action

definstruction ACTION(argFn):
    action = SemanticAction(scope, argFn)

definstruction MATCH_RANGE(argStart, argEnd):
    if pos >= len(stream) or not (argStart <= stream[pos] <= argEnd):
        fail_message = ("expected range {!r}-{!r}", argStart, argEnd)
        #FAIL
    else:
        action = SemanticAction(stream[pos])
        pos += 1

definstruction LIST_START():
    scope_stack.append(scope)
    scope = []

definstruction LIST_END():
    action = SemanticAction(scope, lambda self: [x.eval(self.runtime) for x in self.value])
    scope = scope_stack.pop()

definstruction MATCH_ANY():
    if pos >= len(stream):
        fail_message = ("expected any",)
        #FAIL
    else:
        action = SemanticAction(stream[pos])
        pos += 1

definstruction PUSH_STREAM():
    if pos >= len(stream) or not isinstance(stream[pos], list):
        fail_message = ("expected list",)
        #FAIL
    else:
        stream_pos_stack.append((stream, pos))
        stream = stream[pos]
        pos = 0

definstruction POP_STREAM():
    if pos < len(stream):
        fail_message = ("expected end of list",)
        #FAIL
    else:
        stream, pos = stream_pos_stack.pop()
        pos += 1

definstruction MATCH_CALL_RULE():
    if pos >= len(stream):
        fail_message = ("expected any",)
        #FAIL
    else:
        argFnName = str(stream[pos])
        pos += 1
        #CALL

definstruction FAIL(argMessage):
    fail_message = (argMessage,)
    #FAIL

defmacro CALL:
    key = (argFnName, tuple([x[1] for x in stream_pos_stack]+[pos]))
    if key in memo:
        if memo[key][0] is None:
            fail_message = memo[key][1]
            #FAIL
        else:
            action, stream_pos_stack = memo[key]
            stream_pos_stack = stream_pos_stack[:]
            stream, pos = stream_pos_stack.pop()
    else:
        call_backtrack_stack.append((pc, key))
        pc = labels[argFnName]

defmacro FAIL:
    fail_pos = tuple([x[1] for x in stream_pos_stack]+[pos])
    if fail_pos >= latest_fail_pos:
        latest_fail_message = fail_message
        latest_fail_pos = fail_pos
    call_backtrack_entry = tuple()
    while call_backtrack_stack:
        call_backtrack_entry = call_backtrack_stack.pop()
        if len(call_backtrack_entry) == 4:
            break
        else:
            _, key = call_backtrack_entry
            memo[key] = (None, fail_message)
    if len(call_backtrack_entry) != 4:
        raise MatchError(
            latest_fail_message[0].format(*latest_fail_message[1:]),
            latest_fail_pos,
            stream_pos_stack[0][0] if stream_pos_stack else stream
        )
    (pc, pos, stream_stack_len, scope_stack_len) = call_backtrack_entry
    if len(stream_pos_stack) > stream_stack_len:
        stream = stream_pos_stack[stream_stack_len][0]
    stream_pos_stack = stream_pos_stack[:stream_stack_len]
    if len(scope_stack) > scope_stack_len:
        scope = scope_stack[scope_stack_len]
    scope_stack = scope_stack[:scope_stack_len]
