def vm(code, rules, start_rule, stream):
    action = SemanticAction(None)
    pc = rules[start_rule]
    call_backtrack_stack = []
    stream, stream_rest = (stream, tuple())
    pos, pos_rest = (0, tuple())
    scope, scope_rest = (None, None)
    fail_message = None
    latest_fail_message, latest_fail_pos = (None, tuple())
    memo = {}

definstruction PUSH_SCOPE():
    scope_rest = (scope, scope_rest)
    scope = {}

definstruction BACKTRACK(arg_pc):
    call_backtrack_stack.append((
        arg_pc, stream, stream_rest, pos, pos_rest, scope, scope_rest
    ))

definstruction CALL(arg_fn_pc):
    #CALL

definstruction POP_SCOPE():
    scope, scope_rest = scope_rest

definstruction MATCH_OBJECT(arg_object):
    if pos >= len(stream) or stream[pos] != arg_object:
        fail_message = ("expected {!r}", arg_object)
        #FAIL
    else:
        action = SemanticAction(arg_object)
        pos += 1

definstruction COMMIT(arg_pc):
    call_backtrack_stack.pop()
    pc = arg_pc

definstruction RETURN():
    if not call_backtrack_stack:
        return action
    pc, key = call_backtrack_stack.pop()
    memo[key] = (action, stream, stream_rest, pos, pos_rest)

definstruction LIST_APPEND():
    scope.append(action)

definstruction BIND(arg_name):
    scope[arg_name] = action

definstruction ACTION(arg_fn):
    action = SemanticAction(scope, arg_fn)

definstruction MATCH_RANGE(arg_start, arg_end):
    if pos >= len(stream) or not (arg_start <= stream[pos] <= arg_end):
        fail_message = ("expected range {!r}-{!r}", arg_start, arg_end)
        #FAIL
    else:
        action = SemanticAction(stream[pos])
        pos += 1

definstruction LIST_START():
    scope_rest = (scope, scope_rest)
    scope = []

definstruction LIST_END():
    action = SemanticAction(scope, lambda self: [x.eval(self.runtime) for x in self.value])
    scope, scope_rest = scope_rest

definstruction MATCH_ANY():
    if pos >= len(stream):
        fail_message = ("expected any",)
        #FAIL
    else:
        action = SemanticAction(stream[pos])
        pos += 1

definstruction PUSH_STREAM():
    if pos >= len(stream) or not isinstance(stream[pos], list):
        fail_message = ("expected list",)
        #FAIL
    else:
        stream_rest = stream_rest + (stream,)
        pos_rest = pos_rest + (pos,)
        stream = stream[pos]
        pos = 0

definstruction POP_STREAM():
    if pos < len(stream):
        fail_message = ("expected end of list",)
        #FAIL
    else:
        stream, stream_rest = stream_rest[-1], stream_rest[:-1]
        pos, pos_rest = pos_rest[-1], pos_rest[:-1]
        pos += 1

definstruction MATCH_CALL_RULE():
    if pos >= len(stream):
        fail_message = ("expected any",)
        #FAIL
    else:
        arg_fn_pc = rules[str(stream[pos])]
        pos += 1
        #CALL

definstruction FAIL(arg_message):
    fail_message = (arg_message,)
    #FAIL

defmacro CALL:
    key = (arg_fn_pc, pos_rest+(pos,))
    if key in memo:
        if memo[key][0] is None:
            fail_message = memo[key][1]
            #FAIL
        else:
            action, stream, stream_rest, pos, pos_rest = memo[key]
    else:
        call_backtrack_stack.append((pc, key))
        pc = arg_fn_pc

defmacro FAIL:
    fail_pos = pos_rest+(pos,)
    if fail_pos >= latest_fail_pos:
        latest_fail_message = fail_message
        latest_fail_pos = fail_pos
    call_backtrack_entry = tuple()
    while call_backtrack_stack:
        call_backtrack_entry = call_backtrack_stack.pop()
        if len(call_backtrack_entry) == 7:
            break
        else:
            _, key = call_backtrack_entry
            memo[key] = (None, fail_message)
    if len(call_backtrack_entry) != 7:
        raise MatchError(
            latest_fail_message[0].format(*latest_fail_message[1:]),
            latest_fail_pos,
            stream_rest[0] if stream_rest else stream
        )
    (pc, stream, stream_rest, pos, pos_rest, scope, scope_rest) = call_backtrack_entry
