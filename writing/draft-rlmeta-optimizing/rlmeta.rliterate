{
"root_page":{
"children":[
{
"children":[],
"id":"8e04b7445714473192bd0ae2c07cb020",
"paragraphs":[
{
"fragments":[
{
"text":"RLMeta compiles itself in the following steps:",
"type":"text"
}
],
"id":"985edf70d12a484ca84294b8c14ba294",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Compile parser",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Compile code generator",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Put it together with the support library",
"type":"text"
}
]
}
],
"id":"a34186a39a1b4fc5bff2e511fe90e5b5",
"type":"list"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py=$(cat support.py)\nsupport_py_string=$(to_python_string < support.py)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"276aa20f5f8040a885bee19ce9b74495",
"language":"bash",
"type":"code"
}
],
"title":"Compilation"
},
{
"children":[],
"id":"31e3c712b4ce4f16bb8e5d352e76fb0e",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.756s\nuser\t0m0.701s\nsys\t0m0.054s\n",
"type":"code"
}
],
"id":"7353abcf68334f5cb322813d3cc21d15",
"type":"code"
},
{
"fragments":[
{
"text":"What takes time?",
"type":"text"
}
],
"id":"56a345b93d2d48b89c310eb50d21dc0f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time python rlmeta.py < parser.rlmeta > /dev/null\n\nreal\t0m0.380s\nuser\t0m0.363s\nsys\t0m0.015s\n",
"type":"code"
}
],
"id":"3e4ed2e3741a4adcaf053218c7aff51c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time python rlmeta.py < codegenerator.rlmeta > /dev/null\n\nreal\t0m0.351s\nuser\t0m0.331s\nsys\t0m0.019s\n",
"type":"code"
}
],
"id":"4fa0e0e48b4844c496c1a8ad71f6b1ee",
"type":"code"
},
{
"fragments":[
{
"text":"Both grammars take roughly the same time to compile (0.380s and 0.351s). The compilation of the grammars take up most of the time. The rest (outputting the support library and assembling the pieces) takes only about 0.025s (0.756-0.380-0.351).",
"type":"text"
}
],
"id":"5bace825a3ee46348cd0c8422ea89d8c",
"type":"text"
},
{
"fragments":[
{
"text":"More specifically, what functions in rlmeta.py takes time?",
"type":"text"
}
],
"id":"40b668292c97425c9fe0473a1499dca8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n             513780 function calls (430760 primitive calls) in 0.476 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8182/2    0.053    0.000    0.427    0.213 rlmeta.py:7(_or)\n    22758    0.040    0.000    0.106    0.000 rlmeta.py:234(next)\n    17411    0.027    0.000    0.046    0.000 rlmeta.py:203(fail)\n  26658/2    0.023    0.000    0.427    0.213 rlmeta.py:16(_and)\n  10730/2    0.020    0.000    0.427    0.213 rlmeta.py:43(_match_rule)\n     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)\n        1    0.013    0.013    0.013    0.013 {method 'write' of 'file' objects}\n...\n",
"type":"code"
}
],
"id":"020968a024554716aa6db67d511fd04e",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < codegenerator.rlmeta\n...\n         450885 function calls (377441 primitive calls) in 0.433 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8152/2    0.052    0.000    0.396    0.198 rlmeta.py:7(_or)\n    19754    0.046    0.000    0.097    0.000 rlmeta.py:234(next)\n    15838    0.026    0.000    0.049    0.000 rlmeta.py:203(fail)\n  23478/2    0.020    0.000    0.396    0.198 rlmeta.py:16(_and)\n   9883/2    0.018    0.000    0.396    0.198 rlmeta.py:43(_match_rule)\n    15838    0.016    0.000    0.016    0.000 rlmeta.py:211(__init__)\n        1    0.012    0.012    0.012    0.012 {method 'write' of 'file' objects}\n...\n",
"type":"code"
}
],
"id":"77424da4068d4cba8d77373149853250",
"type":"code"
},
{
"fragments":[
{
"text":"Again, both grammars take roughly the same time to compile (0.476s and 0.433s). Not sure why this number is higher. Perhaps because profiling. Moreover, roughly the same functions take up the most time (_or, _next, fail, _and, _match_rule, write). Both grammars have similar performance characteristics.",
"type":"text"
}
],
"id":"55354fb22db94925a6774620ca225a57",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"The two different grammars have similar performance characteristics",
"type":"text"
}
]
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"_or: reduce number of ors",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"next: avoid slicing",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"fail: not sure what to do except avoid fails (with less _ors)",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"_and: not sure what to do except avoid _ands",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"_match_rule: use better lookup of function name",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"write: faster string concatenation",
"type":"text"
}
]
}
],
"fragments":[
{
"text":"Areas where performance can be improved",
"type":"text"
}
]
}
],
"id":"0de2da97ab584af68ac4fe82b792d4e0",
"type":"list"
},
{
"fragments":[
{
"text":"Overall compilation time to beat is 0.756s and compilation of a single grammar is 0.476 (I will use the parser only in the following measurements).",
"type":"text"
}
],
"id":"b76d1f7a4547425fac266eea40215d45",
"type":"text"
}
],
"title":"Base measurements"
},
{
"children":[],
"id":"2ac127d411b749919b45ae11c1e47975",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"diff --git a/writing/draft-rlmeta-optimizing/codegenerator.rlmeta b/writing/draft-rlmeta-optimizing/codegenerator.rlmeta\nindex 293e013..2177693 100644\n--- a/writing/draft-rlmeta-optimizing/codegenerator.rlmeta\n+++ b/writing/draft-rlmeta-optimizing/codegenerator.rlmeta\n@@ -10,6 +10,8 @@ CodeGenerator {\n     | [\"DedentBuilder\"]         -> { \"_DedentBuilder()\"                                  }\n     | [\"FnCall\" .:x astItems:y] -> { x \"(\" y \")\"                                         }\n     | [\"VarLookup\" .:x]         -> { \"_vars.lookup(\" repr(x) \").eval()\"                  }\n+    | [\"Or\" ast:x]              -> x\n+    | [\"And\" ast:x]             -> x\n     | astFnBody:x               -> { \"(lambda:\\n\" > x < \"\\n)\" }\n   astFnBody =\n     | [\"Or\" astItems:x]         -> { \"self._or([\" x \"])\"                                 }\n",
"type":"code"
}
],
"id":"273e39ffd9ef4e7999674677fed06fdc",
"language":"diff",
"type":"code"
},
{
"fragments":[
{
"text":"Did not seem to have any effect. Why? Codegenerator becomes bigger which makes it slower.",
"type":"text"
}
],
"id":"df0b7ed6167e4139a369016bb38d789e",
"type":"text"
}
],
"title":"And/Or optimization"
},
{
"children":[],
"id":"f4741ec692124b31af139231151e3a29",
"paragraphs":[
{
"id":"431199a71a704d759438687a0d02dbc8",
"type":"factory"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.608s\nuser\t0m0.585s\nsys\t0m0.022s\n",
"type":"code"
}
],
"id":"2622660f128446a2b8a9fdd37f09e92c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         513780 function calls (430760 primitive calls) in 0.415 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8182/2    0.042    0.000    0.366    0.183 rlmeta.py:7(_or)\n    17411    0.026    0.000    0.044    0.000 rlmeta.py:203(fail)\n  26658/2    0.021    0.000    0.366    0.183 rlmeta.py:16(_and)\n  10730/2    0.019    0.000    0.366    0.183 rlmeta.py:43(_match_rule)\n     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)\n    22758    0.017    0.000    0.077    0.000 rlmeta.py:235(next)\n        1    0.014    0.014    0.014    0.014 {method 'write' of 'file' objects}\n...\n",
"type":"code"
}
],
"id":"6a334e88422c479fb696729a3a7f1ed2",
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Overall compilation time went from 0.7.. to 0.608s.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Single grammar went from x to y",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"next",
"type":"code"
},
{
"text":" has moved down the list ~0.40 -> ~0.17.",
"type":"text"
}
]
}
],
"id":"2c26f455497447b8b1f1b356347cc1b2",
"type":"list"
}
],
"title":"Avoid slicing input"
},
{
"children":[],
"id":"8deb8e7f493a474d8555eb7db34a89dc",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.603s\nuser\t0m0.564s\nsys\t0m0.038s\n",
"type":"code"
}
],
"id":"6d47ef329bf24092879aac74e86e34b9",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         527910 function calls (444890 primitive calls) in 0.397 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8182/2    0.042    0.000    0.370    0.185 rlmeta.py:12(_or)\n    17411    0.026    0.000    0.045    0.000 rlmeta.py:215(fail)\n  26658/2    0.021    0.000    0.370    0.185 rlmeta.py:21(_and)\n  10730/2    0.019    0.000    0.370    0.185 rlmeta.py:48(_match_rule)\n    22758    0.017    0.000    0.078    0.000 rlmeta.py:247(next)\n    17408    0.012    0.000    0.018    0.000 rlmeta.py:279(__init__)\n...\n     2177    0.006    0.000    0.009    0.000 rlmeta.py:157(write)\n...\n",
"type":"code"
}
],
"id":"41a51526c38b44e992df8bc05b39a404",
"type":"code"
},
{
"fragments":[
{
"text":"roughly the same time but much less time spent in write",
"type":"text"
}
],
"id":"d07638f612804b77bd8f62fc3fe6db72",
"type":"text"
}
],
"title":"Faster string concatenation"
},
{
"children":[],
"id":"006ce805fef64eb88c4b8214d7e85495",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.592s\nuser\t0m0.560s\nsys\t0m0.031s\n",
"type":"code"
}
],
"id":"831f44f667f14625bf32fca1f8f5b57b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         508708 function calls (437696 primitive calls) in 0.380 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4898/230    0.039    0.000    0.351    0.002 rlmeta.py:12(_or)\n    15852    0.025    0.000    0.041    0.000 rlmeta.py:215(fail)\n  10620/2    0.019    0.000    0.354    0.177 rlmeta.py:48(_match_rule)\n  21301/2    0.018    0.000    0.354    0.177 rlmeta.py:21(_and)\n    23516    0.018    0.000    0.078    0.000 rlmeta.py:247(next)\n    19154    0.013    0.000    0.020    0.000 rlmeta.py:279(__init__)\n   8323/1    0.012    0.000    0.184    0.184 rlmeta.py:93(_match_list)\n    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)\n     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)\n...\n",
"type":"code"
}
],
"id":"e91a744e842d49f896706bfbca4c4a75",
"type":"code"
},
{
"fragments":[
{
"text":"a little faster, but not abvoius less time spend in or and and",
"type":"text"
}
],
"id":"7a814a8f0b9040f4a7146b072cb62562",
"type":"text"
}
],
"title":"And/Or again"
},
{
"children":[],
"id":"a06ba4a722cc461f9f3eabe2c0f60e53",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.565s\nuser\t0m0.530s\nsys\t0m0.034s\n",
"type":"code"
}
],
"id":"8cdfc1e73a1646a59b4efde7495ce4fb",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         457174 function calls (396876 primitive calls) in 0.343 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4518/230    0.039    0.000    0.343    0.001 rlmeta.py:12(_or)\n    15769    0.024    0.000    0.040    0.000 rlmeta.py:215(fail)\n  10240/2    0.019    0.000    0.347    0.174 rlmeta.py:48(_match_rule)\n    23516    0.017    0.000    0.078    0.000 rlmeta.py:247(next)\n  20921/2    0.017    0.000    0.347    0.174 rlmeta.py:21(_and)\n    19154    0.014    0.000    0.020    0.000 rlmeta.py:279(__init__)\n   8323/1    0.012    0.000    0.176    0.176 rlmeta.py:93(_match_list)\n     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)\n    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)\n    27805    0.010    0.000    0.010    0.000 rlmeta.py:239(__init__)\n    17623    0.010    0.000    0.010    0.000 {method 'format' of 'str' objects}\n...\n",
"type":"code"
}
],
"id":"5435a568ac1543cab4c2287c39f4dc74",
"type":"code"
},
{
"fragments":[
{
"text":"a little overall faster (a little less readable generated code)",
"type":"text"
}
],
"id":"7a249230c40c45beabf315117d771a5f",
"type":"text"
}
],
"title":"Collapse and remove newlines/indents"
},
{
"children":[],
"id":"e7f710aa99bc4a7c895e905f60b4beb8",
"paragraphs":[
{
"fragments":[
{
"text":"Motivation is to get rid of ors in code generator.",
"type":"text"
}
],
"id":"34855f08881448499205cbcdbe4e7bdd",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.406s\nuser\t0m0.373s\nsys\t0m0.032s\n",
"type":"code"
}
],
"id":"cfe430e9506f423a8a5f70d3019da5ba",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         274963 function calls (238101 primitive calls) in 0.220 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  11129/2    0.021    0.000    0.215    0.107 rlmeta.py:48(_match_rule)\n 4177/252    0.020    0.000    0.209    0.001 rlmeta.py:12(_or)\n     8460    0.013    0.000    0.022    0.000 rlmeta.py:219(fail)\n     7021    0.011    0.000    0.056    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.010    0.000    0.215    0.107 rlmeta.py:21(_and)\n     9099    0.009    0.000    0.020    0.000 rlmeta.py:269(_advance)\n    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)\n     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)\n    12801    0.006    0.000    0.006    0.000 {method 'format' of 'str' objects}\n     1443    0.006    0.000    0.008    0.000 rlmeta.py:161(write)\n    26070    0.005    0.000    0.005    0.000 rlmeta.py:266(position)\n     8460    0.005    0.000    0.005    0.000 rlmeta.py:227(__init__)\n    10908    0.005    0.000    0.005    0.000 rlmeta.py:243(__init__)\n...\n",
"type":"code"
}
],
"id":"99fb90ddb610472ca4c6f860db393ad4",
"type":"code"
},
{
"fragments":[
{
"text":"real performance gain!",
"type":"text"
}
],
"id":"1b757ac706ff4a1380bd6321bab75fad",
"type":"text"
}
],
"title":"Match call rule"
},
{
"children":[],
"id":"5160cbceeb9f45bb992c65cc688c3c18",
"paragraphs":[
{
"fragments":[
{
"text":"This was not really significant.",
"type":"text"
}
],
"id":"3f4185deb25b4f08a6b167b25844871f",
"type":"text"
}
],
"title":"Don't memoize code generator"
},
{
"children":[],
"id":"f0338cf15ddb49099abf6a135a0961d7",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.392s\nuser\t0m0.364s\nsys\t0m0.026s\n",
"type":"code"
}
],
"id":"d618172eff37461e9be22d1d2b3d02a4",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         274963 function calls (238101 primitive calls) in 0.220 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4177/252    0.020    0.000    0.206    0.001 rlmeta.py:12(_or)\n  11129/2    0.020    0.000    0.212    0.106 rlmeta.py:48(_match_rule)\n     8460    0.014    0.000    0.022    0.000 rlmeta.py:219(fail)\n     7021    0.012    0.000    0.057    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.010    0.000    0.212    0.106 rlmeta.py:21(_and)\n     9099    0.009    0.000    0.021    0.000 rlmeta.py:269(_advance)\n    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)\n     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)\n    12801    0.006    0.000    0.006    0.000 {method 'format' of 'str' objects}\n     1443    0.006    0.000    0.009    0.000 rlmeta.py:161(write)\n...\n",
"type":"code"
}
],
"id":"6f1b72363ee8429ca4c55b24fcc1be12",
"type":"code"
},
{
"fragments":[
{
"text":"Slightly better.",
"type":"text"
}
],
"id":"d89cfb31abe04f36abc33dab1572f62e",
"type":"text"
}
],
"title":"Optimize position"
},
{
"children":[],
"id":"a5f5f3907de04b28bdf52a8ba57b4a71",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.370s\nuser\t0m0.336s\nsys\t0m0.034s\n",
"type":"code"
}
],
"id":"a21c297ab39041ee83df0f602e95e037",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         268387 function calls (231525 primitive calls) in 0.204 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4177/252    0.020    0.000    0.194    0.001 rlmeta.py:12(_or)\n  11129/2    0.019    0.000    0.199    0.100 rlmeta.py:48(_match_rule)\n     8460    0.013    0.000    0.021    0.000 rlmeta.py:219(fail)\n     7021    0.010    0.000    0.050    0.000 rlmeta.py:79(_match_charseq)\n     9099    0.010    0.000    0.021    0.000 rlmeta.py:269(_advance)\n   9010/2    0.009    0.000    0.199    0.100 rlmeta.py:21(_and)\n    10540    0.008    0.000    0.038    0.000 rlmeta.py:251(next)\n     9100    0.007    0.000    0.011    0.000 rlmeta.py:261(__init__)\n     8460    0.006    0.000    0.006    0.000 rlmeta.py:227(__init__)\n     1443    0.005    0.000    0.008    0.000 rlmeta.py:161(write)\n    10908    0.004    0.000    0.004    0.000 rlmeta.py:243(__init__)\n     8460    0.004    0.000    0.025    0.000 rlmeta.py:248(fail)\n    10993    0.004    0.000    0.005    0.000 rlmeta.py:256(is_at_end)\n    885/5    0.004    0.000    0.199    0.040 rlmeta.py:27(_star)\n 3274/747    0.004    0.000    0.005    0.000 rlmeta.py:141(create)\n    12616    0.003    0.000    0.003    0.000 {method 'write' of 'cStringIO.StringO' objects}\n    17881    0.002    0.000    0.002    0.000 rlmeta.py:266(position)\n     1802    0.002    0.000    0.014    0.000 rlmeta.py:59(_match_range)\n     6225    0.002    0.000    0.002    0.000 {method 'format' of 'str' objects}\n...\n",
"type":"code"
}
],
"id":"d924bf5c2ea4444fa9cb3afc812ae719",
"type":"code"
},
{
"fragments":[
{
"text":"[ ] forgot one lazy_message (eof)",
"type":"text"
}
],
"id":"40a2d091d08f4d1e8f4a9eb03e53c990",
"type":"text"
}
],
"title":"Make fail messages lazy"
},
{
"children":[],
"id":"898ec92a13304692857a6d4de445e4d2",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.351s\nuser\t0m0.319s\nsys\t0m0.031s\n",
"type":"code"
}
],
"id":"291c53933d4645f884397d8c102c3d4d",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         248506 function calls (211644 primitive calls) in 0.187 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  11129/2    0.019    0.000    0.182    0.091 rlmeta.py:48(_match_rule)\n 4177/252    0.018    0.000    0.177    0.001 rlmeta.py:12(_or)\n     8460    0.013    0.000    0.022    0.000 rlmeta.py:221(fail)\n     7021    0.010    0.000    0.037    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.009    0.000    0.182    0.091 rlmeta.py:21(_and)\n     8460    0.006    0.000    0.006    0.000 rlmeta.py:229(__init__)\n    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)\n     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)\n    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)\n    885/5    0.004    0.000    0.182    0.036 rlmeta.py:27(_star)\n     8460    0.004    0.000    0.025    0.000 rlmeta.py:250(fail)\n 3274/747    0.003    0.000    0.005    0.000 rlmeta.py:143(create)\n     1802    0.003    0.000    0.011    0.000 rlmeta.py:59(_match_range)\n     2574    0.003    0.000    0.006    0.000 rlmeta.py:271(advance)\n    17881    0.002    0.000    0.002    0.000 rlmeta.py:268(position)\n    12616    0.002    0.000    0.002    0.000 {method 'write' of 'cStringIO.StringO' objects}\n     2575    0.002    0.000    0.004    0.000 rlmeta.py:263(__init__)\n     6225    0.002    0.000    0.002    0.000 {method 'format' of 'str' objects}\n...\n",
"type":"code"
}
],
"id":"20e97823102d44eebb5e45a8cb796cd1",
"type":"code"
}
],
"title":"Peek"
},
{
"children":[],
"id":"84d9e890742c41d48fc1afc2009815c7",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.344s\nuser\t0m0.312s\nsys\t0m0.030s\n",
"type":"code"
}
],
"id":"75570d667bf9476dba654f518e07b538",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         240951 function calls (204089 primitive calls) in 0.185 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  11129/2    0.019    0.000    0.180    0.090 rlmeta.py:48(_match_rule)\n 4177/252    0.017    0.000    0.175    0.001 rlmeta.py:12(_or)\n     6949    0.011    0.000    0.017    0.000 rlmeta.py:221(fail)\n     7021    0.010    0.000    0.038    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.010    0.000    0.180    0.090 rlmeta.py:21(_and)\n    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)\n     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)\n     6949    0.004    0.000    0.004    0.000 rlmeta.py:229(__init__)\n    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)\n    885/5    0.004    0.000    0.180    0.036 rlmeta.py:27(_star)\n...\n",
"type":"code"
}
],
"id":"8e730042aefa46a29692dd8e8f2afbed",
"type":"code"
},
{
"fragments":[
{
"text":"Can't really tell if better or worse. But should reduce one exception catch/trow. And I like this code better.",
"type":"text"
}
],
"id":"806aff9cb25247c5a37cea9113ca48ca",
"type":"text"
}
],
"title":"No exception last or"
},
{
"children":[],
"id":"3616eda03f5c40458ac9439def097739",
"paragraphs":[
{
"fragments":[
{
"text":"Overall performance roughly doubled.",
"type":"text"
}
],
"id":"bf140dd877764128addd0411f7210bab",
"type":"text"
},
{
"fragments":[
{
"text":"Performance measurements were not very detailed. A bigger grammar could have helped.",
"type":"text"
}
],
"id":"1034d5b114154a9986a261da947633d6",
"type":"text"
}
],
"title":"Conclusions"
},
{
"children":[
{
"children":[],
"id":"496100180e1c4c119f90be842c1b9577",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space string:x                           -> [\"MatchString\" x]\n    | space charseq:x                          -> [\"MatchCharseq\" x]\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'        -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x                     -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'                                -> [\"IndentBuilder\"]\n    | space '<'                                -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''  -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"8a67addcac4d443795a7ce297f8c7232",
"language":"",
"post_process":[],
"type":"code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"7bd8846187ad478aa17439370f0da1e6",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(_Grammar):\\n\" > ys <                       }\n  Rule           = .:x ast:y       -> { \"\\ndef _rule_\" x \"(self):\\n\" > \"return \" y \"()\\n\" <     }\n  MatchAny       =                 -> { \"self._match_any\"                                       }\n  MatchCallRule  =                 -> { \"self._match_call_rule\"                                 }\n  String         = .:x             -> { repr(x)                                                 }\n  List           = astList:x       -> { x                                                       }\n  Builder        = astItems:x      -> { \"_Builder.create([\" x \"])\"                              }\n  IndentBuilder  =                 -> { \"_IndentBuilder()\"                                      }\n  DedentBuilder  =                 -> { \"_DedentBuilder()\"                                      }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                                             }\n  VarLookup      = .:x             -> { \"_vars.lookup(\" repr(x) \").eval()\"                      }\n  Or             =\n    | ast:x !.                     -> x\n    | astItems:x                   -> { \"(lambda: self._or([\" x \"]))\"                           }\n  Scope          = ast:x           -> { \"(lambda: (lambda _vars:\\n\" > x < \"()\\n)(_Vars()))\"     }\n  And            =\n    | ast:x !.                     -> x\n    | astItems:x                   -> { \"(lambda: self._and([\" x \"]))\"                          }\n  Bind           = .:x ast:y       -> { \"(lambda: _vars.bind(\" repr(x) \", \" y \"()))\"            }\n  Star           = ast:x           -> { \"(lambda: self._star(\" x \"))\"                           }\n  Not            = ast:x           -> { \"(lambda: self._not(\" x \"))\"                            }\n  SemanticAction = ast:x           -> { \"(lambda: _SemanticAction(lambda: \" x \"))\"              }\n  MatchRule      = .:x             -> { \"(lambda: self._match_rule(\" repr(x) \"))\"               }\n  MatchRange     = .:x .:y         -> { \"(lambda: self._match_range(\" repr(x) \", \" repr(y) \"))\" }\n  MatchString    = .:x             -> { \"(lambda: self._match_string(\" repr(x) \"))\"             }\n  MatchCharseq   = .:x             -> { \"(lambda: self._match_charseq(\" repr(x) \"))\"            }\n  MatchList      = ast:x           -> { \"(lambda: self._match_list(\" x \"))\"                     }\n  ast            = [%:x]           -> x\n  astItems       = astItem*:xs     -> { \"\\n\" > xs <                                             }\n  astItem        = ast:x           -> { x \",\\n\"                                                 }\n  astList        = astListItem*:xs -> { \"(\" xs \"[])\"                                            }\n  astListItem    =\n    | [\"ListItemSplice\" ast:x]     -> {     x  \"+\"                                              }\n    | ast:x                        -> { \"[\" x \"]+\"                                              }\n}\n",
"type":"code"
}
],
"id":"196fc11ef11c47468ccf0a093e338906",
"language":"",
"type":"code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"ecfe26a58495420b8871e522c6859a4a",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\nclass _Grammar(object):\n\n    def _or(self, matchers):\n        original_stream = self._stream\n        for matcher in matchers[:-1]:\n            try:\n                return matcher()\n            except _MatchError:\n                self._stream = original_stream\n        return matchers[-1]()\n\n    def _and(self, matchers):\n        result = None\n        for matcher in matchers:\n            result = matcher()\n        return result\n\n    def _star(self, matcher):\n        result = []\n        while True:\n            original_stream = self._stream\n            try:\n                result.append(matcher())\n            except _MatchError:\n                self._stream = original_stream\n                return _SemanticAction(lambda: [x.eval() for x in result])\n\n    def _not(self, matcher):\n        original_stream = self._stream\n        try:\n            matcher()\n        except _MatchError:\n            return _SemanticAction(lambda: None)\n        else:\n            original_stream.fail(lambda: \"match found\")\n        finally:\n            self._stream = original_stream\n\n    def _match_rule(self, rule_name):\n        key = (rule_name, self._stream.position())\n        if key in self._memo:\n            result, _, self._stream = self._memo[key]\n        else:\n            start = self._stream\n            result = getattr(self, \"_rule_{}\".format(rule_name))()\n            end = self._stream\n            self._memo[key] = (result, start, end)\n        return result\n\n    def _match_range(self, start, end):\n        next_objext = self._stream.peek()\n        if next_objext >= start and next_objext <= end:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: next_objext)\n        else:\n            self._stream.fail(\n                lambda: \"expected range {!r}-{!r} but found {!r}\".format(start, end, next_objext)\n            )\n\n    def _match_string(self, string):\n        next_object = self._stream.peek()\n        if next_object == string:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: string)\n        else:\n            self._stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(string, next_object)\n            )\n\n    def _match_charseq(self, charseq):\n        for char in charseq:\n            next_object = self._stream.peek()\n            if next_object != char:\n                self._stream.fail(\n                    lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n                )\n            self._stream = self._stream.advance()\n        return _SemanticAction(lambda: charseq)\n\n    def _match_any(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return _SemanticAction(lambda: next_object)\n\n    def _match_call_rule(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return self._match_rule(str(next_object))\n\n    def _match_list(self, matcher):\n        original_stream = self._stream\n        next_object = self._stream.peek()\n        if isinstance(next_object, list):\n            self._stream = self._stream.nested(next_object)\n            matcher()\n            if self._stream.is_at_end():\n                self._stream = original_stream.advance()\n                return _SemanticAction(lambda: next_object)\n        original_stream.fail(lambda: \"list match failed\")\n\n    def run(self, rule_name, input_object):\n        self._memo = _Memo()\n        self._stream = _Stream.from_object(self._memo, input_object)\n        result = self._match_rule(rule_name).eval()\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Vars(dict):\n\n    def bind(self, name, value):\n        self[name] = value\n        return value\n\n    def lookup(self, name):\n        return self[name]\n\nclass _SemanticAction(object):\n\n    def __init__(self, fn):\n        self.fn = fn\n\n    def eval(self):\n        return self.fn()\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _Memo(dict):\n\n    def __init__(self):\n        dict.__init__(self)\n        self._latest_stream = _ObjectStream(self, [], -1)\n        self._latest_lazy_message = lambda: \"\"\n\n    def describe(self):\n        items = []\n        for (rule_name, _), (_, start, end) in self.items():\n            if end > start:\n                items.append((rule_name, start, end))\n        items.sort(key=lambda item: (item[2].position(), item[1].position()))\n        message = []\n        for item in items:\n            message.append(\"matched {: <20} {} -> {}\\n\".format(*item))\n        message.append(\"\\n\")\n        message.append(\"ERROR: {}: {}\\n\".format(\n            self._latest_stream,\n            self._latest_lazy_message()\n        ))\n        return \"\".join(message)\n\n    def fail(self, stream, lazy_message):\n        if stream.position() >= self._latest_stream.position():\n            self._latest_stream = stream\n            self._latest_lazy_message = lazy_message\n        raise _MatchError(self)\n\nclass _MatchError(Exception):\n\n    def __init__(self, memo):\n        Exception.__init__(self)\n        self._memo = memo\n\n    def describe(self):\n        return self._memo.describe()\n\nclass _Stream(object):\n\n    @classmethod\n    def from_object(cls, memo, input_object):\n        if isinstance(input_object, basestring):\n            return _CharStream(memo, input_object, 0)\n        else:\n            return _ObjectStream(memo, [input_object], 0)\n\n    def __init__(self, memo, objects, index):\n        self._memo = memo\n        self._objects = objects\n        self._index = index\n\n    def fail(self, lazy_message):\n        self._memo.fail(self, lazy_message)\n\n    def peek(self):\n        if self.is_at_end():\n            self.fail(\"not eof\")\n        return self._objects[self._index]\n\n    def is_at_end(self):\n        return self._index >= len(self._objects)\n\nclass _CharStream(_Stream):\n\n    def __init__(self, memo, objects, index, line=1, column=1):\n        _Stream.__init__(self, memo, objects, index)\n        self._line = line\n        self._column = column\n\n    def position(self):\n        return self._index\n\n    def advance(self):\n        if self._objects[self._index] == \"\\n\":\n            line = self._line + 1\n            column = 1\n        else:\n            line = self._line\n            column = self._column + 1\n        return _CharStream(self._memo, self._objects, self._index+1, line, column)\n\n    def __str__(self):\n        return \"L{:03d}:C{:03d}\".format(self._line, self._column)\n\nclass _ObjectStream(_Stream):\n\n    def __init__(self, memo, objects, index, parent=()):\n        _Stream.__init__(self, memo, objects, index)\n        self._parent_position = parent\n        self._position = self._parent_position + (self._index,)\n\n    def position(self):\n        return self._position\n\n    def nested(self, input_object):\n        return _ObjectStream(self._memo, input_object, 0, self._position)\n\n    def advance(self):\n        return _ObjectStream(self._memo, self._objects, self._index+1, self._parent_position)\n\n    def __str__(self):\n        return \"[{}]\".format(\", \".join(str(x) for x in self.position()))\n",
"type":"code"
}
],
"id":"42f83fae0f734a9a9248859c70bd285c",
"type":"code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"1ee923adb0ed4f3b8a5cc72700aad2dd",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"6299de61907642ed92cffaa3764f2c61",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"d09466ef920844788d5e63457decfd86",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"471910823d0c46e2be98600df125bd34",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"3aafb64996414339b01b0d407e6e1810",
"paragraphs":[],
"title":"Code listings for RLMeta"
}
],
"id":"89a873850f674da6a812ca31b0b943d6",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I describe how I optimized the first version of RLMeta.",
"type":"text"
}
],
"id":"51307b1cf6714bcc822cd0c169e8f3de",
"type":"text"
}
],
"title":"Optimizing RLMeta"
},
"variables":{}
}