{
"root_page":{
"children":[
{
"children":[],
"id":"31e3c712b4ce4f16bb8e5d352e76fb0e",
"paragraphs":[
{
"fragments":[
{
"text":"Before optimizing something for speed it is important to measure how long it takes. We are interested in optimizing the time it takes for RLMeta to compile itself. If it compiles itself faster, it will most likely also compile other RLMeta programs faster.",
"type":"text"
}
],
"id":"521b7a601c67426c8f6bd298c13bd93e",
"type":"text"
},
{
"fragments":[
{
"text":"RLMeta compiles itself in the following steps:",
"type":"text"
}
],
"id":"985edf70d12a484ca84294b8c14ba294",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Generate support libraries",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Compile parser",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Compile code generator",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Assemble the pieces into a Python file",
"type":"text"
}
]
}
],
"id":"a34186a39a1b4fc5bff2e511fe90e5b5",
"type":"list"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"compile.sh",
"type":"code"
},
{
"text":" script performs those steps like follows:",
"type":"text"
}
],
"id":"f7f26c78660b4f3689dd2b45e5576d62",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"python template"
],
"prefix":"",
"type":"chunk"
},
{
"text":"EOF\n",
"type":"code"
}
],
"id":"6299de61907642ed92cffaa3764f2c61",
"type":"code"
},
{
"fragments":[
{
"text":"The Python file template rendered at the end of the script looks like this:",
"type":"text"
}
],
"id":"5a1ea51cecd24d2c908b25e932c22782",
"type":"text"
},
{
"chunkpath":[
"python template"
],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"import sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except _MatchError as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\n",
"type":"code"
}
],
"id":"2b5a39bd729f4463b703b7647220596e",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"To measure how long it takes for RLMeta to compile itself, we use the ",
"type":"text"
},
{
"text":"time",
"type":"code"
},
{
"text":" command:",
"type":"text"
}
],
"id":"0e17cb244d5c44559c5a9e8043c77652",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.756s\nuser\t0m0.701s\nsys\t0m0.054s\n",
"type":"code"
}
],
"id":"7353abcf68334f5cb322813d3cc21d15",
"type":"code"
},
{
"fragments":[
{
"text":"It takes ",
"type":"text"
},
{
"text":"0.756s",
"type":"strong"
},
{
"text":". The goal of our optimizations is to decrease this time.",
"type":"text"
}
],
"id":"572fc8860696403f951de597e21532ea",
"type":"text"
},
{
"fragments":[
{
"text":"To get a better understanding of what takes time, we measure how long it takes to compile the parser and the code generator individually:",
"type":"text"
}
],
"id":"56a345b93d2d48b89c310eb50d21dc0f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time python rlmeta.py < parser.rlmeta > /dev/null\n\nreal\t0m0.380s\nuser\t0m0.363s\nsys\t0m0.015s\n",
"type":"code"
}
],
"id":"3e4ed2e3741a4adcaf053218c7aff51c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time python rlmeta.py < codegenerator.rlmeta > /dev/null\n\nreal\t0m0.351s\nuser\t0m0.331s\nsys\t0m0.019s\n",
"type":"code"
}
],
"id":"4fa0e0e48b4844c496c1a8ad71f6b1ee",
"type":"code"
},
{
"fragments":[
{
"text":"Both grammars take roughly the same time to compile (",
"type":"text"
},
{
"text":"0.380s",
"type":"strong"
},
{
"text":" and ",
"type":"text"
},
{
"text":"0.351s",
"type":"strong"
},
{
"text":"). Moreover, the compilation of the grammars take up most of the time. The rest (generating the support libraries and rendering the Python file template) takes only ",
"type":"text"
},
{
"text":"0.025s",
"type":"strong"
},
{
"text":" (0.756-0.380-0.351). We will therefore focus on making compilation of grammars faster.",
"type":"text"
}
],
"id":"5bace825a3ee46348cd0c8422ea89d8c",
"type":"text"
},
{
"fragments":[
{
"text":"To get a better understanding of what takes time when compiling grammars, we compile the parser and the code generator with the Python profiler turned on:",
"type":"text"
}
],
"id":"40b668292c97425c9fe0473a1499dca8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n             513780 function calls (430760 primitive calls) in 0.476 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8182/2    0.053    0.000    0.427    0.213 rlmeta.py:7(_or)\n    22758    0.040    0.000    0.106    0.000 rlmeta.py:234(next)\n    17411    0.027    0.000    0.046    0.000 rlmeta.py:203(fail)\n  26658/2    0.023    0.000    0.427    0.213 rlmeta.py:16(_and)\n  10730/2    0.020    0.000    0.427    0.213 rlmeta.py:43(_match_rule)\n     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)\n        1    0.013    0.013    0.013    0.013 {method 'write' of 'file' objects}\n...\n",
"type":"code"
}
],
"id":"020968a024554716aa6db67d511fd04e",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < codegenerator.rlmeta\n...\n         450885 function calls (377441 primitive calls) in 0.433 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8152/2    0.052    0.000    0.396    0.198 rlmeta.py:7(_or)\n    19754    0.046    0.000    0.097    0.000 rlmeta.py:234(next)\n    15838    0.026    0.000    0.049    0.000 rlmeta.py:203(fail)\n  23478/2    0.020    0.000    0.396    0.198 rlmeta.py:16(_and)\n   9883/2    0.018    0.000    0.396    0.198 rlmeta.py:43(_match_rule)\n    15838    0.016    0.000    0.016    0.000 rlmeta.py:211(__init__)\n        1    0.012    0.012    0.012    0.012 {method 'write' of 'file' objects}\n...\n",
"type":"code"
}
],
"id":"77424da4068d4cba8d77373149853250",
"type":"code"
},
{
"fragments":[
{
"text":"This again shows that both grammars take roughly the same time to compile (",
"type":"text"
},
{
"text":"0.476s",
"type":"strong"
},
{
"text":" and ",
"type":"text"
},
{
"text":"0.433s",
"type":"strong"
},
{
"text":"). (These numbers are higher than the ",
"type":"text"
},
{
"text":"time",
"type":"code"
},
{
"text":" measurements. Probably because profiling is turned on.) It also shows what functions take most time. Both grammars have roughly the same functions at the top of the list: ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"fail",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":", and ",
"type":"text"
},
{
"text":"write",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"55354fb22db94925a6774620ca225a57",
"type":"text"
},
{
"fragments":[
{
"text":"Because the profiling output looks similar for the two grammars, we will only profile compilation of the parser.",
"type":"text"
}
],
"id":"55e3ad058dc14c109895c306d2c78600",
"type":"text"
},
{
"fragments":[
{
"text":"Let's start by examining the ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" function, because most time is spent there, and see if we can make it any faster.",
"type":"text"
}
],
"id":"66d646055a1f4012926e0859ac282ad5",
"type":"text"
}
],
"title":"What to measure?"
},
{
"children":[],
"id":"2ac127d411b749919b45ae11c1e47975",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" function is called any time there is a choice in a grammar and it looks like this:",
"type":"text"
}
],
"id":"b7784aca13ae469090a01f2e848e1072",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _or(self, matchers):\n    original_stream = self._stream\n    for matcher in matchers:\n        try:\n            return matcher()\n        except _MatchError:\n            self._stream = original_stream\n    original_stream.fail(\"no choice matched\")\n",
"type":"code"
}
],
"id":"fbb934f6ca3a48c2a34ff06e790937f6",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"There is no obvious way to optimize it so instead we try to reduce the number of calls to it. The code generator always generates calls to ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" even if there is only one choice: ",
"type":"text"
},
{
"text":"self._or([matcher])",
"type":"code"
},
{
"text":". In this case the call to ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" is unnecessary because the single matcher can be called directly: ",
"type":"text"
},
{
"text":"matcher()",
"type":"code"
},
{
"text":". The same reasoning goes for ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"bd82c8729bf44697a4b5df1236c536e3",
"type":"text"
},
{
"fragments":[
{
"text":"To make the code generator skip the calls to ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":", we add the following cases to it:",
"type":"text"
}
],
"id":"f04c0be1594f45cf984a4d50f14c5953",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"| [\"Or\" ast:x]  -> x\n| [\"And\" ast:x] -> x\n",
"type":"code"
}
],
"id":"273e39ffd9ef4e7999674677fed06fdc",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"If it sees an ",
"type":"text"
},
{
"text":"Or",
"type":"code"
},
{
"text":" or an ",
"type":"text"
},
{
"text":"And",
"type":"code"
},
{
"text":" ast node with only one child, it will skip the calls to ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":" and just generate the child matcher.",
"type":"text"
}
],
"id":"14dc897e3f4e43b8b97b12bcd8f073b6",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta as described in ",
"type":"text"
},
{
"text":"Modifying the RLMeta metacompiler",
"type":"link",
"url":"/writing/modifying-rlmeta/index.html"
},
{
"text":" and then we measure.",
"type":"text"
}
],
"id":"6b45bd89bb7b484488730d74ac208ded",
"type":"text"
},
{
"fragments":[
{
"text":"Unfortunately, this does not seem to have any effect on the speed. Why is that? Perhaps because the two added cases to the code generator also makes it slower.",
"type":"text"
}
],
"id":"df0b7ed6167e4139a369016bb38d789e",
"type":"text"
},
{
"fragments":[
{
"text":"We discard this change for now and move on to the ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function which is second on the list.",
"type":"text"
}
],
"id":"c62d17cbff144e5f83f3e1aec924c3da",
"type":"text"
}
],
"title":"And/Or optimization"
},
{
"children":[],
"id":"f4741ec692124b31af139231151e3a29",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function is used to get the next object from an input stream and it looks like this:",
"type":"text"
}
],
"id":"c776771e7e24443182189d40f5bcda8f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def next(self):\n    if self.is_at_end():\n        self.fail(\"not eof\")\n    next_object = self._objects[0]\n    return (\n        next_object,\n        self._advance(next_object, self._objects[1:]),\n    )\n",
"type":"code"
}
],
"id":"431199a71a704d759438687a0d02dbc8",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"Every time it is called, which is once per object in the input stream, the input stream is sliced: ",
"type":"text"
},
{
"text":"self._objects[1:]",
"type":"code"
},
{
"text":". This creates a new list with all objects except the first. For example, if the input stream is the string \"print(1)\", it will create the substrings \"rint(1)\", \"int(1)\", \"nt(1)\", and so on. This is wasteful.",
"type":"text"
}
],
"id":"80e0c6d0e6d1490eb4e7eb29bab162df",
"type":"text"
},
{
"fragments":[
{
"text":"To avoid slicing the input stream we rewrite it to instead maintain an index where it's at. The next object is retrieved by indexing, and the rest of the objects no longer has to be computed. The index is just incremented instead. With this change, the ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function looks like this:",
"type":"text"
}
],
"id":"5ba7aafaf41a430ba5b58eaeafc1ab4f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def next(self):\n    if self.is_at_end():\n        self.fail(\"not eof\")\n    return (self._objects[self._index], self._advance())\n",
"type":"code"
}
],
"id":"0fc87189a13b4d9cb5b574f1cb0c95ea",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The complete diff can be ",
"type":"text"
},
{
"text":"viewed online",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/a358b1921a5f9afae769512ca27db795af947648#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":".",
"type":"text"
}
],
"id":"6ebf06c35b184a6c892a050ec61a4b7d",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"4000afeb3a0348cb871af30f5d6d738a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.608s\nuser\t0m0.585s\nsys\t0m0.022s\n",
"type":"code"
}
],
"id":"2622660f128446a2b8a9fdd37f09e92c",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         513780 function calls (430760 primitive calls) in 0.415 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8182/2    0.042    0.000    0.366    0.183 rlmeta.py:7(_or)\n    17411    0.026    0.000    0.044    0.000 rlmeta.py:203(fail)\n  26658/2    0.021    0.000    0.366    0.183 rlmeta.py:16(_and)\n  10730/2    0.019    0.000    0.366    0.183 rlmeta.py:43(_match_rule)\n     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)\n    22758    0.017    0.000    0.077    0.000 rlmeta.py:235(next)\n        1    0.014    0.014    0.014    0.014 {method 'write' of 'file' objects}\n...\n",
"type":"code"
}
],
"id":"6a334e88422c479fb696729a3a7f1ed2",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.756s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.608s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.476s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.415s",
"type":"strong"
},
{
"text":". The ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function moved down the list from ",
"type":"text"
},
{
"text":"0.040s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.017s",
"type":"strong"
},
{
"text":".",
"type":"text"
}
],
"id":"b63692cca6ac4450b7d52a79c5ef3746",
"type":"text"
},
{
"fragments":[
{
"text":"Finally some progress.",
"type":"text"
}
],
"id":"90a6d8d35c624cc9af3e7c2fd4f9d26c",
"type":"text"
},
{
"fragments":[
{
"text":"We still don't have an obvious way to optimize ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":". Next on the list is the ",
"type":"text"
},
{
"text":"fail",
"type":"code"
},
{
"text":" function which looks like this:",
"type":"text"
}
],
"id":"98d7e7a9360c4481a94567fba763def7",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def fail(self, stream, message):\n    if stream.position() >= self._latest_stream.position():\n        self._latest_stream = stream\n        self._latest_message = message\n    raise _MatchError(self)\n",
"type":"code"
}
],
"id":"eb9b0839dae94b65ab4bf3a73feb34b2",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"There is no obvious way to make this faster either. The same goes for the ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":" function which looks like this:",
"type":"text"
}
],
"id":"d9d89f2922c841c5aefbc7f29d66c47d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_rule(self, rule_name):\n    key = (rule_name, self._stream.position())\n    if key in self._memo:\n        result, _, self._stream = self._memo[key]\n    else:\n        start = self._stream\n        result = getattr(self, \"_rule_{}\".format(rule_name))()\n        end = self._stream\n        self._memo[key] = (result, start, end)\n    return result\n",
"type":"code"
}
],
"id":"398eca11ba7a457fabcb7d6138463868",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"We move down the list and examine the ",
"type":"text"
},
{
"text":"write",
"type":"code"
},
{
"text":" function.",
"type":"text"
}
],
"id":"46be33a0c9454581a90890586240f48c",
"type":"text"
}
],
"title":"Avoid slicing input"
},
{
"children":[],
"id":"8deb8e7f493a474d8555eb7db34a89dc",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"write",
"type":"code"
},
{
"text":" function in the ",
"type":"text"
},
{
"text":"_Output",
"type":"code"
},
{
"text":" class looks like this:",
"type":"text"
}
],
"id":"7f8a065809ef4734bee1424e5afca6a6",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class _Output(object):\n\n    def __init__(self):\n        self.value = \"\"\n        self.indentation = 0\n\n    def write(self, value):\n        for ch in value:\n            if self.value and ch != \"\\n\" and self.value[-1] == \"\\n\":\n                self.value += \"    \"*self.indentation\n            self.value += ch\n",
"type":"code"
}
],
"id":"351831073afe4f19976c736abcb9739a",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"It is used by the code generator to generate string output. It builds up the value by concatenating strings to the current value: ",
"type":"text"
},
{
"text":"self.value += ..",
"type":"code"
},
{
"text":". This concatenation is done once per generated character. Concatenating strings in Python this way is not the fastest way to do it.",
"type":"text"
}
],
"id":"84c5b2ac6942424e9ad8cf0b6122170e",
"type":"text"
},
{
"fragments":[
{
"text":"A better way is to use the ",
"type":"text"
},
{
"text":"StringIO",
"type":"code"
},
{
"text":" class. Its ",
"type":"text"
},
{
"text":"write",
"type":"code"
},
{
"text":" function is used to build up the value, and its ",
"type":"text"
},
{
"text":"getvalue",
"type":"code"
},
{
"text":" function is used to return it:",
"type":"text"
}
],
"id":"c69d698ef693433e9a72a88ddf466668",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n",
"type":"code"
}
],
"id":"d0de1fa5579d488e8a27cc36443fcc64",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The complete diff can be ",
"type":"text"
},
{
"text":"viewed online",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/d5327b86d3de97a621f9ca0a8d11e445484d0fcb#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":".",
"type":"text"
}
],
"id":"33c01c5feb944e2080fe3e440c249405",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"da9f1b29fab24411a0c58fa35a8944d4",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.603s\nuser\t0m0.564s\nsys\t0m0.038s\n",
"type":"code"
}
],
"id":"6d47ef329bf24092879aac74e86e34b9",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         527910 function calls (444890 primitive calls) in 0.397 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   8182/2    0.042    0.000    0.370    0.185 rlmeta.py:12(_or)\n    17411    0.026    0.000    0.045    0.000 rlmeta.py:215(fail)\n  26658/2    0.021    0.000    0.370    0.185 rlmeta.py:21(_and)\n  10730/2    0.019    0.000    0.370    0.185 rlmeta.py:48(_match_rule)\n    22758    0.017    0.000    0.078    0.000 rlmeta.py:247(next)\n    17408    0.012    0.000    0.018    0.000 rlmeta.py:279(__init__)\n...\n     2177    0.006    0.000    0.009    0.000 rlmeta.py:157(write)\n...\n",
"type":"code"
}
],
"id":"41a51526c38b44e992df8bc05b39a404",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.608s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.603s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.415s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.397s",
"type":"strong"
},
{
"text":". This is not significant. But much less time is spent in the ",
"type":"text"
},
{
"text":"write",
"type":"code"
},
{
"text":" function (",
"type":"text"
},
{
"text":"0.006s",
"type":"strong"
},
{
"text":" compared to ",
"type":"text"
},
{
"text":"0.019s",
"type":"strong"
},
{
"text":") so we keep this change. It might be that some more time is spent doing the ",
"type":"text"
},
{
"text":"getvalue",
"type":"code"
},
{
"text":" call. But it does not show up at the top of the list.",
"type":"text"
}
],
"id":"d07638f612804b77bd8f62fc3fe6db72",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":" functions are still high up on the list. Now that we have made other parts of RLMeta faster, will the and/or optimization be more useful?",
"type":"text"
}
],
"id":"99c7f43fb54844afa4f132a4cb869458",
"type":"text"
}
],
"title":"Faster string concatenation"
},
{
"children":[],
"id":"006ce805fef64eb88c4b8214d7e85495",
"paragraphs":[
{
"fragments":[
{
"text":"We apply the and/or optimization again, create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"4a564795514347da8f9dbd5c9fc03018",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.592s\nuser\t0m0.560s\nsys\t0m0.031s\n",
"type":"code"
}
],
"id":"831f44f667f14625bf32fca1f8f5b57b",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         508708 function calls (437696 primitive calls) in 0.380 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4898/230    0.039    0.000    0.351    0.002 rlmeta.py:12(_or)\n    15852    0.025    0.000    0.041    0.000 rlmeta.py:215(fail)\n  10620/2    0.019    0.000    0.354    0.177 rlmeta.py:48(_match_rule)\n  21301/2    0.018    0.000    0.354    0.177 rlmeta.py:21(_and)\n    23516    0.018    0.000    0.078    0.000 rlmeta.py:247(next)\n    19154    0.013    0.000    0.020    0.000 rlmeta.py:279(__init__)\n   8323/1    0.012    0.000    0.184    0.184 rlmeta.py:93(_match_list)\n    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)\n     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)\n...\n",
"type":"code"
}
],
"id":"e91a744e842d49f896706bfbca4c4a75",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.603s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.592s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.397s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.380s",
"type":"strong"
},
{
"text":". This is not significant, but less time is spend in ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"_and",
"type":"code"
},
{
"text":", so we keep this change now.",
"type":"text"
}
],
"id":"dfdab4b9190c4b2d80ed922ffddd395c",
"type":"text"
},
{
"fragments":[
{
"text":"We previously observed that writing output took some time. We made the ",
"type":"text"
},
{
"text":"write",
"type":"code"
},
{
"text":" function faster. Now we will try another change that will cause less characters to be written to the output. This will change the grammar, and not just the support library.",
"type":"text"
}
],
"id":"3578213d608b451eb478bb241f2217b3",
"type":"text"
}
],
"title":"And/Or again"
},
{
"children":[],
"id":"a06ba4a722cc461f9f3eabe2c0f60e53",
"paragraphs":[
{
"fragments":[
{
"text":"The main part of the code generator has two rules that generate code for ast nodes:",
"type":"text"
}
],
"id":"c93daaec0e1745f0a301df283b259d92",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"CodeGenerator {\n  ast =\n    | [\"Grammar\" .:x ast*:ys] -> { \"class \" x \"(_Grammar):\\n\" > ys < }\n    ...\n    | astFnBody:x             -> { \"(lambda:\\n\" > x < \"\\n)\" }\n  astFnBody =\n    | [\"Or\" astItems:x]       -> { \"self._or([\" x \"])\"               }\n    ...\n  ...\n}\n",
"type":"code"
}
],
"id":"a9c5bf6ea32743c9b1205c8ee8905109",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"If an ast node's body should be wrapped in a lambda, it is put in the ",
"type":"text"
},
{
"text":"astFnBody",
"type":"code"
},
{
"text":" rule and the lambda is generated by the last choice in the ",
"type":"text"
},
{
"text":"ast",
"type":"code"
},
{
"text":" rule. The lambda is generated with newlines and indentation like this:",
"type":"text"
}
],
"id":"c63b2dccbca04e86b2f5d4284ca7b15a",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda:\n    body\n)\n",
"type":"code"
}
],
"id":"61a73f2758ad4a3983817fb1f723132a",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The newlines and indentation are not necessary. It might make the generated code easier to the read at the expense of outputting at least 6 more characters (two newlines and at least 4 spaces of indent). Instead we could generate this:",
"type":"text"
}
],
"id":"bd96ddc557c646a189bb472505c0c3b9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(lambda: body)\n",
"type":"code"
}
],
"id":"50b70f0e04ed450495685ee37d8ee7a1",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"We rewrite the code generator like this:",
"type":"text"
}
],
"id":"427013a8f3994fd592f1e57a48f66f63",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"CodeGenerator {\n  ast =\n    | [\"Grammar\" .:x ast*:ys] -> { \"class \" x \"(_Grammar):\\n\" > ys < }\n    ...\n    | [\"Or\" astItems:x]       -> { \"(lambda: self._or([\" x \"]))\"     }\n    ...\n  ...\n}\n",
"type":"code"
}
],
"id":"b92bc3eb6f294076b7f9953489ab1b5a",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"This also removes the ",
"type":"text"
},
{
"text":"astFnBody",
"type":"code"
},
{
"text":" rule in favor of duplicating the lambda output code. This removes one function call, but more importantly lays the groundwork for the next optimization.",
"type":"text"
}
],
"id":"7ac771e9267c427d9acc01b8bad8494b",
"type":"text"
},
{
"fragments":[
{
"text":"The complete diff can be ",
"type":"text"
},
{
"text":"viewed online",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/496c98d367a5dce2def17680d92f095cd2c274a5#diff-14e1afbb5e4a4c88a29fd7256cd350fb"
},
{
"text":".",
"type":"text"
}
],
"id":"bcfa7fa533ec4d099365cce755c0315b",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"871da1d7d52945cf9a028868932312a3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.565s\nuser\t0m0.530s\nsys\t0m0.034s\n",
"type":"code"
}
],
"id":"8cdfc1e73a1646a59b4efde7495ce4fb",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         457174 function calls (396876 primitive calls) in 0.343 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4518/230    0.039    0.000    0.343    0.001 rlmeta.py:12(_or)\n    15769    0.024    0.000    0.040    0.000 rlmeta.py:215(fail)\n  10240/2    0.019    0.000    0.347    0.174 rlmeta.py:48(_match_rule)\n    23516    0.017    0.000    0.078    0.000 rlmeta.py:247(next)\n  20921/2    0.017    0.000    0.347    0.174 rlmeta.py:21(_and)\n    19154    0.014    0.000    0.020    0.000 rlmeta.py:279(__init__)\n   8323/1    0.012    0.000    0.176    0.176 rlmeta.py:93(_match_list)\n     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)\n    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)\n    27805    0.010    0.000    0.010    0.000 rlmeta.py:239(__init__)\n    17623    0.010    0.000    0.010    0.000 {method 'format' of 'str' objects}\n...\n",
"type":"code"
}
],
"id":"5435a568ac1543cab4c2287c39f4dc74",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.592s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.565s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.380s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.343s",
"type":"strong"
},
{
"text":".",
"type":"text"
}
],
"id":"c837c11677a5464b9537266d0e6fd08e",
"type":"text"
},
{
"fragments":[
{
"text":"Now that we've made an optimization by modifying the source code, we think about how we can further modify the source code to make RLMeta faster.",
"type":"text"
}
],
"id":"fd39dbcf20b2476fbe0b7755202c77a7",
"type":"text"
}
],
"title":"Remove newlines and indentation"
},
{
"children":[],
"id":"e7f710aa99bc4a7c895e905f60b4beb8",
"paragraphs":[
{
"fragments":[
{
"text":"The largest part of the code generator is the ",
"type":"text"
},
{
"text":"ast",
"type":"code"
},
{
"text":" rule. It has many choices that are tried in order to generate code for different type of ast nodes:",
"type":"text"
}
],
"id":"b5f4f2ebe7cd4ec3bd630370d2afb036",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"CodeGenerator {\n  ast =\n    | [\"Grammar\" .:x ast*:ys] -> { \"class \" x \"(_Grammar):\\n\" > ys <   }\n    ... (22 choices omitted) ...\n    | [\"MatchList\" ast:x]     -> { \"(lambda: self._match_list(\" x \"))\" }\n  ...\n}\n",
"type":"code"
}
],
"id":"a0d4c57e227b4a39871967181a660336",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"To generate code for the ",
"type":"text"
},
{
"text":"MatchList",
"type":"code"
},
{
"text":" ast node, the ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" function first needs to fail 23 times before it reaches the last choice that matches.",
"type":"text"
}
],
"id":"66d8dd8b39684776b9fff7cf48187987",
"type":"text"
},
{
"fragments":[
{
"text":"We introduce a new operator in RLMeta, ",
"type":"text"
},
{
"text":"%",
"type":"code"
},
{
"text":", which means read one object from the input stream and treat it as the name of a rule in the grammar. Then call that rule. It is implemented like this:",
"type":"text"
}
],
"id":"34855f08881448499205cbcdbe4e7bdd",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_call_rule(self):\n    next_object, self._stream = self._stream.next()\n    return self._match_rule(str(next_object))\n",
"type":"code"
}
],
"id":"2b3492eff13c4f93b3f1ad90405f4dbb",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"We then rewrite the code generator using this operator. The ",
"type":"text"
},
{
"text":"ast",
"type":"code"
},
{
"text":" rule simply becomes matching a list, then calling the rule for that ast node. All choices are converted to rules where the ast node name becomes the rule name:",
"type":"text"
}
],
"id":"2dfa146a6f534577b87011b612611a20",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"CodeGenerator {\n  Grammar   = .:x ast*:ys -> { \"class \" x \"(_Grammar):\\n\" > ys <   }\n  ...\n  MatchList = ast:x       -> { \"(lambda: self._match_list(\" x \"))\" }\n  ast       = [%:x]       -> x\n  ...\n}\n",
"type":"code"
}
],
"id":"db24db78fb4840b091d6e294ff09b90b",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"With this change, the main part of the code generator is completely free of choice operators which should eliminate many calls to ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"5d07402498c94a1cb3ada07c94611dc2",
"type":"text"
},
{
"fragments":[
{
"text":"The complete diff can be viewed online ",
"type":"text"
},
{
"text":"here",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/61ff2132a057cf986ae0eae8575d24b066ab3e43"
},
{
"text":" and ",
"type":"text"
},
{
"text":"here",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/f054fdca6c939506e2820d86d466fe1763244c43#diff-14e1afbb5e4a4c88a29fd7256cd350fb"
},
{
"text":".",
"type":"text"
}
],
"id":"991870bc9fdb41b0bd564d68ce5f1bea",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"d2e634f9e6504ff29a3eee6f5672d128",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.406s\nuser\t0m0.373s\nsys\t0m0.032s\n",
"type":"code"
}
],
"id":"cfe430e9506f423a8a5f70d3019da5ba",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         274963 function calls (238101 primitive calls) in 0.220 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  11129/2    0.021    0.000    0.215    0.107 rlmeta.py:48(_match_rule)\n 4177/252    0.020    0.000    0.209    0.001 rlmeta.py:12(_or)\n     8460    0.013    0.000    0.022    0.000 rlmeta.py:219(fail)\n     7021    0.011    0.000    0.056    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.010    0.000    0.215    0.107 rlmeta.py:21(_and)\n     9099    0.009    0.000    0.020    0.000 rlmeta.py:269(_advance)\n    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)\n     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)\n    12801    0.006    0.000    0.006    0.000 {method 'format' of 'str' objects}\n     1443    0.006    0.000    0.008    0.000 rlmeta.py:161(write)\n    26070    0.005    0.000    0.005    0.000 rlmeta.py:266(position)\n     8460    0.005    0.000    0.005    0.000 rlmeta.py:227(__init__)\n    10908    0.005    0.000    0.005    0.000 rlmeta.py:243(__init__)\n...\n",
"type":"code"
}
],
"id":"99fb90ddb610472ca4c6f860db393ad4",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.565s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.406s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.343s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.220s",
"type":"strong"
},
{
"text":". This is some real performance gain. Also the ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" function is kicked down to the second position.",
"type":"text"
}
],
"id":"aab6484037fe44589bde970ba5e725c0",
"type":"text"
},
{
"fragments":[
{
"text":"Now that the code generator is mostly free from choices, is it still worthwhile to memoize results?",
"type":"text"
}
],
"id":"e9804cf9d95d4624a0be8b05bbe47693",
"type":"text"
}
],
"title":"Match call rule"
},
{
"children":[],
"id":"5160cbceeb9f45bb992c65cc688c3c18",
"paragraphs":[
{
"fragments":[
{
"text":"Memoizing results is done in ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":" which looks like this:",
"type":"text"
}
],
"id":"89247bec6c9b4d418b6993ffc8df0463",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_rule(self, rule_name):\n    key = (rule_name, self._stream.position())\n    if key in self._memo:\n        result, _, self._stream = self._memo[key]\n    else:\n        start = self._stream\n        result = getattr(self, \"_rule_{}\".format(rule_name))()\n        end = self._stream\n        self._memo[key] = (result, start, end)\n    return result\n",
"type":"code"
}
],
"id":"cbb1c2679ec6426bb1dcb750e881fe65",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"If the rule has matched before at the current position, the memoized result is returned. In the new code generator there will not be many such cases because most choices have been eliminated. For the code generator, we can instead just do this:",
"type":"text"
}
],
"id":"dce8bd60ae124475bf08f14d63b5bd54",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_rule(self, rule_name):\n    return getattr(self, \"_rule_{}\".format(rule_name))()\n",
"type":"code"
}
],
"id":"dce682dbfa36429dab6b415068433a07",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure.",
"type":"text"
}
],
"id":"20af77f424cb411c8ccdcb36892122a7",
"type":"text"
},
{
"fragments":[
{
"text":"It turns out this is not really significant. The code generator will still benefit from memoization.",
"type":"text"
}
],
"id":"3f4185deb25b4f08a6b167b25844871f",
"type":"text"
},
{
"fragments":[
{
"text":"Now the ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":" function takes most time. We previously saw no way to optimize it, but we observe now that it makes a call to the ",
"type":"text"
},
{
"text":"position",
"type":"code"
},
{
"text":" function. Can we make it faster?",
"type":"text"
}
],
"id":"1ee33db43a0f412b84385c440b730178",
"type":"text"
}
],
"title":"Don't memoize code generator"
},
{
"children":[],
"id":"f0338cf15ddb49099abf6a135a0961d7",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"position",
"type":"code"
},
{
"text":" function exists on streams and looks like this:",
"type":"text"
}
],
"id":"a9e08109298549559e38d177321df855",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class _CharStream(_Stream):\n\n    def position(self):\n        return (self._line, self._column)\n\n    ...\n",
"type":"code"
}
],
"id":"e9ace2797bf44cc4b7ba988c19d545fa",
"language":"python",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class _ObjectStream(_Stream):\n\n    def position(self):\n        return self._parent + (self._position,)\n\n    ...\n",
"type":"code"
}
],
"id":"da20711bd0ce4a8fa02efbce168c354a",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"Every time it is called, a new tuple is created. What if we refactor it to create the position only once and return it when the ",
"type":"text"
},
{
"text":"position",
"type":"code"
},
{
"text":" function is called?",
"type":"text"
}
],
"id":"29e312f78f4f4be088dac1796ed15035",
"type":"text"
},
{
"fragments":[
{
"text":"With this change, the position is created in the constructor and just returned. The complete diff can be ",
"type":"text"
},
{
"text":"viewed online",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/3cbf3437cf0478bd899ec6c6c839b3f07c32f86b#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":".",
"type":"text"
}
],
"id":"aa591747e68c4049a220cf9c5e382e99",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"09f0a5f199ca490abe3ba81c9a33ef4d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.392s\nuser\t0m0.364s\nsys\t0m0.026s\n",
"type":"code"
}
],
"id":"d618172eff37461e9be22d1d2b3d02a4",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         274963 function calls (238101 primitive calls) in 0.220 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4177/252    0.020    0.000    0.206    0.001 rlmeta.py:12(_or)\n  11129/2    0.020    0.000    0.212    0.106 rlmeta.py:48(_match_rule)\n     8460    0.014    0.000    0.022    0.000 rlmeta.py:219(fail)\n     7021    0.012    0.000    0.057    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.010    0.000    0.212    0.106 rlmeta.py:21(_and)\n     9099    0.009    0.000    0.021    0.000 rlmeta.py:269(_advance)\n    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)\n     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)\n    12801    0.006    0.000    0.006    0.000 {method 'format' of 'str' objects}\n     1443    0.006    0.000    0.009    0.000 rlmeta.py:161(write)\n...\n",
"type":"code"
}
],
"id":"6f1b72363ee8429ca4c55b24fcc1be12",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.406s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.392s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar did not change. Did anything improve? Perhaps not. But because the overall compilation time improved and the resulting code is not worse, we keep this change.",
"type":"text"
}
],
"id":"c7c97427a22e4cd287cbb979fc76d182",
"type":"text"
},
{
"fragments":[
{
"text":"A new function has floated up the list, and that is ",
"type":"text"
},
{
"text":"_match_charseq",
"type":"code"
},
{
"text":". It looks like this:",
"type":"text"
}
],
"id":"6853acdc7769465097536d8b60dfe23f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_charseq(self, charseq):\n    for char in charseq:\n        original_stream = self._stream\n        next_object, self._stream = self._stream.next()\n        if next_object != char:\n            original_stream.fail(\n                \"expected {!r} but found {!r}\".format(char, next_object)\n            )\n    return _SemanticAction(lambda: charseq)\n",
"type":"code"
}
],
"id":"55b2e8b948d94c168b90607b2bf2de85",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"There is no obvious way to optimize it. But we notice the formatting of the fail message. The ",
"type":"text"
},
{
"text":"format",
"type":"code"
},
{
"text":" function shows up on the list a bit further down. We observe that fail messages are seldom used. Only the last fail message is presented to the user. So formatting all fail messages is unnecessary. But we still want nice looking fail messages. We try to defer the formatting until it is actually needed.",
"type":"text"
}
],
"id":"0ab0b5413c6b46e6a9c57df29f857dfb",
"type":"text"
}
],
"title":"Optimize position"
},
{
"children":[],
"id":"a5f5f3907de04b28bdf52a8ba57b4a71",
"paragraphs":[
{
"fragments":[
{
"text":"To defer fail messages we change them from strings to lambdas. To format a fail message, the lambda has to be called. With this change, the ",
"type":"text"
},
{
"text":"_match_charseq",
"type":"code"
},
{
"text":" function looks like this:",
"type":"text"
}
],
"id":"38154909a6664044b11ff19046304588",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_charseq(self, charseq):\n    for char in charseq:\n        original_stream = self._stream\n        next_object, self._stream = self._stream.next()\n        if next_object != char:\n            original_stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n            )\n    return _SemanticAction(lambda: charseq)\n",
"type":"code"
}
],
"id":"45663400188a471184f22ca28442a3b3",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The complete diff can be viewed online ",
"type":"text"
},
{
"text":"here",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/d32dfb7235b2d1353d8045dc1999a6dc07f493bf#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":" and ",
"type":"text"
},
{
"text":"here",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/dd3d3b8c35744b6d5e5ef42dbd46aafa9e1331ad#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":".",
"type":"text"
}
],
"id":"33ef278f33554dd3b9d9d5dbb24cd12a",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"4d43da3016f24c7ea891d2a264136dbf",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.370s\nuser\t0m0.336s\nsys\t0m0.034s\n",
"type":"code"
}
],
"id":"a21c297ab39041ee83df0f602e95e037",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         268387 function calls (231525 primitive calls) in 0.204 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 4177/252    0.020    0.000    0.194    0.001 rlmeta.py:12(_or)\n  11129/2    0.019    0.000    0.199    0.100 rlmeta.py:48(_match_rule)\n     8460    0.013    0.000    0.021    0.000 rlmeta.py:219(fail)\n     7021    0.010    0.000    0.050    0.000 rlmeta.py:79(_match_charseq)\n     9099    0.010    0.000    0.021    0.000 rlmeta.py:269(_advance)\n   9010/2    0.009    0.000    0.199    0.100 rlmeta.py:21(_and)\n    10540    0.008    0.000    0.038    0.000 rlmeta.py:251(next)\n     9100    0.007    0.000    0.011    0.000 rlmeta.py:261(__init__)\n     8460    0.006    0.000    0.006    0.000 rlmeta.py:227(__init__)\n     1443    0.005    0.000    0.008    0.000 rlmeta.py:161(write)\n    10908    0.004    0.000    0.004    0.000 rlmeta.py:243(__init__)\n     8460    0.004    0.000    0.025    0.000 rlmeta.py:248(fail)\n    10993    0.004    0.000    0.005    0.000 rlmeta.py:256(is_at_end)\n    885/5    0.004    0.000    0.199    0.040 rlmeta.py:27(_star)\n 3274/747    0.004    0.000    0.005    0.000 rlmeta.py:141(create)\n    12616    0.003    0.000    0.003    0.000 {method 'write' of 'cStringIO.StringO' objects}\n    17881    0.002    0.000    0.002    0.000 rlmeta.py:266(position)\n     1802    0.002    0.000    0.014    0.000 rlmeta.py:59(_match_range)\n     6225    0.002    0.000    0.002    0.000 {method 'format' of 'str' objects}\n...\n",
"type":"code"
}
],
"id":"d924bf5c2ea4444fa9cb3afc812ae719",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.392s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.370s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.220s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.204s",
"type":"strong"
},
{
"text":". Time spent formatting strings went from ",
"type":"text"
},
{
"text":"0.006s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.002s",
"type":"strong"
},
{
"text":".",
"type":"text"
}
],
"id":"0ba32f7bf8184887aabffa6b21331acd",
"type":"text"
},
{
"fragments":[
{
"text":"When we take another look at ",
"type":"text"
},
{
"text":"_match_charseq",
"type":"code"
},
{
"text":", which is still taking much time, we see that the ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function is called, resulting in a tuple being created and returned. But if the check fails, we have done some unnecessary work like assigning to ",
"type":"text"
},
{
"text":"self._stream",
"type":"code"
},
{
"text":" and advancing the stream. Let's see if we can avoid that by implementing a peek function.",
"type":"text"
}
],
"id":"b3138ae5d85c469b811cb0619e7c98e6",
"type":"text"
}
],
"title":"Make fail messages lazy"
},
{
"children":[],
"id":"898ec92a13304692857a6d4de445e4d2",
"paragraphs":[
{
"fragments":[
{
"text":"Streams implement a ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function which returns the next object and a new stream representing the rest of the objects. If a matcher fails after examining the next object, the rest of the objects are never used. We therefore split the ",
"type":"text"
},
{
"text":"next",
"type":"code"
},
{
"text":" function into two: ",
"type":"text"
},
{
"text":"peek",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"advance",
"type":"code"
},
{
"text":". The ",
"type":"text"
},
{
"text":"_match_charseq",
"type":"code"
},
{
"text":" function then looks like this:",
"type":"text"
}
],
"id":"bfc20072e2594ea3a0b0490bc65b915f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _match_charseq(self, charseq):\n    for char in charseq:\n        next_object = self._stream.peek()\n        if next_object != char:\n            self._stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n            )\n        self._stream = self._stream.advance()\n    return _SemanticAction(lambda: charseq)\n",
"type":"code"
}
],
"id":"578e0dc62b2844fcb0f8c96a0bcb8106",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The complete diff can be ",
"type":"text"
},
{
"text":"viewed online",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/6bcd1457c0fc4726c0d7bc5020a77dcef7f05ed3#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":".",
"type":"text"
}
],
"id":"384cd111a3bd4a20a895766d215d655c",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"5816276fd7c843c2b4d733caa8807020",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.351s\nuser\t0m0.319s\nsys\t0m0.031s\n",
"type":"code"
}
],
"id":"291c53933d4645f884397d8c102c3d4d",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         248506 function calls (211644 primitive calls) in 0.187 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  11129/2    0.019    0.000    0.182    0.091 rlmeta.py:48(_match_rule)\n 4177/252    0.018    0.000    0.177    0.001 rlmeta.py:12(_or)\n     8460    0.013    0.000    0.022    0.000 rlmeta.py:221(fail)\n     7021    0.010    0.000    0.037    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.009    0.000    0.182    0.091 rlmeta.py:21(_and)\n     8460    0.006    0.000    0.006    0.000 rlmeta.py:229(__init__)\n    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)\n     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)\n    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)\n    885/5    0.004    0.000    0.182    0.036 rlmeta.py:27(_star)\n     8460    0.004    0.000    0.025    0.000 rlmeta.py:250(fail)\n 3274/747    0.003    0.000    0.005    0.000 rlmeta.py:143(create)\n     1802    0.003    0.000    0.011    0.000 rlmeta.py:59(_match_range)\n     2574    0.003    0.000    0.006    0.000 rlmeta.py:271(advance)\n    17881    0.002    0.000    0.002    0.000 rlmeta.py:268(position)\n    12616    0.002    0.000    0.002    0.000 {method 'write' of 'cStringIO.StringO' objects}\n     2575    0.002    0.000    0.004    0.000 rlmeta.py:263(__init__)\n     6225    0.002    0.000    0.002    0.000 {method 'format' of 'str' objects}\n...\n",
"type":"code"
}
],
"id":"20e97823102d44eebb5e45a8cb796cd1",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.370s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.351s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.204s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.187s",
"type":"strong"
},
{
"text":".",
"type":"text"
}
],
"id":"28bae40877d84db78e28286d8bb02b30",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"fail",
"type":"code"
},
{
"text":" functions are still high on the list. We think of one more optimization we can do there.",
"type":"text"
}
],
"id":"7b9be03955e1493fac81d95614716401",
"type":"text"
}
],
"title":"Peek"
},
{
"children":[],
"id":"84d9e890742c41d48fc1afc2009815c7",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" function looks like this:",
"type":"text"
}
],
"id":"8a2ca966c33d471f964b5c96054a9d2f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _or(self, matchers):\n    original_stream = self._stream\n    for matcher in matchers:\n        try:\n            return matcher()\n        except _MatchError:\n            self._stream = original_stream\n    original_stream.fail(lambda: \"no choice matched\")\n",
"type":"code"
}
],
"id":"03c62c086d3340f08af6e090fa1a782b",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"If it gets three matchers that all fail, the ",
"type":"text"
},
{
"text":"fail",
"type":"code"
},
{
"text":" function will be called four times. This is unnecessary. If all but the last matchers have failed, there is no need to catch the exception from the last matcher. We can just let it fail and the failure will be handled higher up the call stack. We rewrite the ",
"type":"text"
},
{
"text":"_or",
"type":"code"
},
{
"text":" function so that it instead looks like this:",
"type":"text"
}
],
"id":"094fb86028874fa8bafceead8cea5ef4",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def _or(self, matchers):\n    original_stream = self._stream\n    for matcher in matchers[:-1]:\n        try:\n            return matcher()\n        except _MatchError:\n            self._stream = original_stream\n    return matchers[-1]()\n",
"type":"code"
}
],
"id":"b77d2aebe22748ca96625f41101d8ce0",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"This could have been done earlier as well, but we didn't see it then.",
"type":"text"
}
],
"id":"517b08c16f964ba898e41b53aa9ed72e",
"type":"text"
},
{
"fragments":[
{
"text":"The complete diff can be ",
"type":"text"
},
{
"text":"viewed online",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/commit/079d437dee27cca6cf7aa18d4fffdb5b2dd26172#diff-f500390afaa13cfd96d938b9065dc0c1"
},
{
"text":".",
"type":"text"
}
],
"id":"a84b0514ddda4806a8ac1804235abe47",
"type":"text"
},
{
"fragments":[
{
"text":"We create a new version of RLMeta and then we measure:",
"type":"text"
}
],
"id":"aa96e3fa9bf340158dce9c9da26321f8",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ time ./compile.sh rlmeta.py > /dev/null\n\nreal\t0m0.344s\nuser\t0m0.312s\nsys\t0m0.030s\n",
"type":"code"
}
],
"id":"75570d667bf9476dba654f518e07b538",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"$ python -m cProfile -s tottime rlmeta.py < parser.rlmeta\n...\n         240951 function calls (204089 primitive calls) in 0.185 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  11129/2    0.019    0.000    0.180    0.090 rlmeta.py:48(_match_rule)\n 4177/252    0.017    0.000    0.175    0.001 rlmeta.py:12(_or)\n     6949    0.011    0.000    0.017    0.000 rlmeta.py:221(fail)\n     7021    0.010    0.000    0.038    0.000 rlmeta.py:79(_match_charseq)\n   9010/2    0.010    0.000    0.180    0.090 rlmeta.py:21(_and)\n    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)\n     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)\n     6949    0.004    0.000    0.004    0.000 rlmeta.py:229(__init__)\n    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)\n    885/5    0.004    0.000    0.180    0.036 rlmeta.py:27(_star)\n...\n",
"type":"code"
}
],
"id":"8e730042aefa46a29692dd8e8f2afbed",
"type":"code"
},
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.351s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.344s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.187s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.185s",
"type":"strong"
},
{
"text":".",
"type":"text"
}
],
"id":"716ffb55967a4103844b0857e4c6a651",
"type":"text"
},
{
"fragments":[
{
"text":"We can't tell if better or worse. But it should reduce one exception catch/throw. We therefore keep it.",
"type":"text"
}
],
"id":"806aff9cb25247c5a37cea9113ca48ca",
"type":"text"
},
{
"fragments":[
{
"text":"We are seeing mostly small performance gains now, so we will stop here.",
"type":"text"
}
],
"id":"002e03eb44d448db865027fec5b771c2",
"type":"text"
}
],
"title":"No exception for last or"
},
{
"children":[],
"id":"3616eda03f5c40458ac9439def097739",
"paragraphs":[
{
"fragments":[
{
"text":"The overall compilation time went from ",
"type":"text"
},
{
"text":"0.756s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.344s",
"type":"strong"
},
{
"text":". The compilation time for a single grammar went from ",
"type":"text"
},
{
"text":"0.476s",
"type":"strong"
},
{
"text":" to ",
"type":"text"
},
{
"text":"0.185s",
"type":"strong"
},
{
"text":". This is roughly twice as fast. Not that bad. Below is a graph that shows how performance improved with the different optimizations:",
"type":"text"
}
],
"id":"692f0b3b69504923988210033d604134",
"type":"text"
},
{
"fragments":[
{
"text":"",
"type":"text"
}
],
"id":"f57f512fcdc648ac9605888ba47851f0",
"image_base64":"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",
"type":"image"
},
{
"fragments":[
{
"text":"Some of the optimizations were significant, others not. Should we have focused only on the ones that were significant and discarded the rest? Usually better performance means less readable code. So if the performance gain is not significant, but the code becomes less readable, is it worth it? In particular, did we fall in love with the and/or optimization? We have read that ",
"type":"text"
},
{
"text":"OMeta",
"type":"link",
"url":"http://www.vpri.org/pdf/tr2008003_experimenting.pdf"
},
{
"text":" uses it, so we wanted to be equally cool, but our measurements showed only slight performance increase.",
"type":"text"
}
],
"id":"eb7ab3ad65694d5f8ae8c553e0c3546c",
"type":"text"
},
{
"fragments":[
{
"text":"Sometimes it was difficult to determine if a change led to faster compilation or not. The ",
"type":"text"
},
{
"text":"time",
"type":"code"
},
{
"text":" command is not a reliable tool for performance measurements. We could perhaps have gotten better results by compiling bigger grammars so that small changes in time had been less significant.",
"type":"text"
}
],
"id":"1034d5b114154a9986a261da947633d6",
"type":"text"
},
{
"fragments":[
{
"text":"There are probably many more optimizations that can be done to RLMeta that we didn't think of in this article. If you find any, let me know.",
"type":"text"
}
],
"id":"fd7b821d82f5411bb17c4b50c168293f",
"type":"text"
}
],
"title":"Conclusions"
},
{
"children":[
{
"children":[],
"id":"496100180e1c4c119f90be842c1b9577",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space string:x                           -> [\"MatchString\" x]\n    | space charseq:x                          -> [\"MatchCharseq\" x]\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'        -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x                     -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'                                -> [\"IndentBuilder\"]\n    | space '<'                                -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''  -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"8a67addcac4d443795a7ce297f8c7232",
"language":"",
"post_process":[],
"type":"code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"7bd8846187ad478aa17439370f0da1e6",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(_Grammar):\\n\" > ys <                       }\n  Rule           = .:x ast:y       -> { \"\\ndef _rule_\" x \"(self):\\n\" > \"return \" y \"()\\n\" <     }\n  MatchAny       =                 -> { \"self._match_any\"                                       }\n  MatchCallRule  =                 -> { \"self._match_call_rule\"                                 }\n  String         = .:x             -> { repr(x)                                                 }\n  List           = astList:x       -> { x                                                       }\n  Builder        = astItems:x      -> { \"_Builder.create([\" x \"])\"                              }\n  IndentBuilder  =                 -> { \"_IndentBuilder()\"                                      }\n  DedentBuilder  =                 -> { \"_DedentBuilder()\"                                      }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                                             }\n  VarLookup      = .:x             -> { \"_vars.lookup(\" repr(x) \").eval()\"                      }\n  Or             =\n    | ast:x !.                     -> x\n    | astItems:x                   -> { \"(lambda: self._or([\" x \"]))\"                           }\n  Scope          = ast:x           -> { \"(lambda: (lambda _vars:\\n\" > x < \"()\\n)(_Vars()))\"     }\n  And            =\n    | ast:x !.                     -> x\n    | astItems:x                   -> { \"(lambda: self._and([\" x \"]))\"                          }\n  Bind           = .:x ast:y       -> { \"(lambda: _vars.bind(\" repr(x) \", \" y \"()))\"            }\n  Star           = ast:x           -> { \"(lambda: self._star(\" x \"))\"                           }\n  Not            = ast:x           -> { \"(lambda: self._not(\" x \"))\"                            }\n  SemanticAction = ast:x           -> { \"(lambda: _SemanticAction(lambda: \" x \"))\"              }\n  MatchRule      = .:x             -> { \"(lambda: self._match_rule(\" repr(x) \"))\"               }\n  MatchRange     = .:x .:y         -> { \"(lambda: self._match_range(\" repr(x) \", \" repr(y) \"))\" }\n  MatchString    = .:x             -> { \"(lambda: self._match_string(\" repr(x) \"))\"             }\n  MatchCharseq   = .:x             -> { \"(lambda: self._match_charseq(\" repr(x) \"))\"            }\n  MatchList      = ast:x           -> { \"(lambda: self._match_list(\" x \"))\"                     }\n  ast            = [%:x]           -> x\n  astItems       = astItem*:xs     -> { \"\\n\" > xs <                                             }\n  astItem        = ast:x           -> { x \",\\n\"                                                 }\n  astList        = astListItem*:xs -> { \"(\" xs \"[])\"                                            }\n  astListItem    =\n    | [\"ListItemSplice\" ast:x]     -> {     x  \"+\"                                              }\n    | ast:x                        -> { \"[\" x \"]+\"                                              }\n}\n",
"type":"code"
}
],
"id":"196fc11ef11c47468ccf0a093e338906",
"language":"",
"type":"code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"ecfe26a58495420b8871e522c6859a4a",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n\nclass _Grammar(object):\n\n    def _or(self, matchers):\n        original_stream = self._stream\n        for matcher in matchers[:-1]:\n            try:\n                return matcher()\n            except _MatchError:\n                self._stream = original_stream\n        return matchers[-1]()\n\n    def _and(self, matchers):\n        result = None\n        for matcher in matchers:\n            result = matcher()\n        return result\n\n    def _star(self, matcher):\n        result = []\n        while True:\n            original_stream = self._stream\n            try:\n                result.append(matcher())\n            except _MatchError:\n                self._stream = original_stream\n                return _SemanticAction(lambda: [x.eval() for x in result])\n\n    def _not(self, matcher):\n        original_stream = self._stream\n        try:\n            matcher()\n        except _MatchError:\n            return _SemanticAction(lambda: None)\n        else:\n            original_stream.fail(lambda: \"match found\")\n        finally:\n            self._stream = original_stream\n\n    def _match_rule(self, rule_name):\n        key = (rule_name, self._stream.position())\n        if key in self._memo:\n            result, _, self._stream = self._memo[key]\n        else:\n            start = self._stream\n            result = getattr(self, \"_rule_{}\".format(rule_name))()\n            end = self._stream\n            self._memo[key] = (result, start, end)\n        return result\n\n    def _match_range(self, start, end):\n        next_objext = self._stream.peek()\n        if next_objext >= start and next_objext <= end:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: next_objext)\n        else:\n            self._stream.fail(\n                lambda: \"expected range {!r}-{!r} but found {!r}\".format(start, end, next_objext)\n            )\n\n    def _match_string(self, string):\n        next_object = self._stream.peek()\n        if next_object == string:\n            self._stream = self._stream.advance()\n            return _SemanticAction(lambda: string)\n        else:\n            self._stream.fail(\n                lambda: \"expected {!r} but found {!r}\".format(string, next_object)\n            )\n\n    def _match_charseq(self, charseq):\n        for char in charseq:\n            next_object = self._stream.peek()\n            if next_object != char:\n                self._stream.fail(\n                    lambda: \"expected {!r} but found {!r}\".format(char, next_object)\n                )\n            self._stream = self._stream.advance()\n        return _SemanticAction(lambda: charseq)\n\n    def _match_any(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return _SemanticAction(lambda: next_object)\n\n    def _match_call_rule(self):\n        next_object = self._stream.peek()\n        self._stream = self._stream.advance()\n        return self._match_rule(str(next_object))\n\n    def _match_list(self, matcher):\n        original_stream = self._stream\n        next_object = self._stream.peek()\n        if isinstance(next_object, list):\n            self._stream = self._stream.nested(next_object)\n            matcher()\n            if self._stream.is_at_end():\n                self._stream = original_stream.advance()\n                return _SemanticAction(lambda: next_object)\n        original_stream.fail(lambda: \"list match failed\")\n\n    def run(self, rule_name, input_object):\n        self._memo = _Memo()\n        self._stream = _Stream.from_object(self._memo, input_object)\n        result = self._match_rule(rule_name).eval()\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n\nclass _Vars(dict):\n\n    def bind(self, name, value):\n        self[name] = value\n        return value\n\n    def lookup(self, name):\n        return self[name]\n\nclass _SemanticAction(object):\n\n    def __init__(self, fn):\n        self.fn = fn\n\n    def eval(self):\n        return self.fn()\n\nclass _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n\nclass _Memo(dict):\n\n    def __init__(self):\n        dict.__init__(self)\n        self._latest_stream = _ObjectStream(self, [], -1)\n        self._latest_lazy_message = lambda: \"\"\n\n    def describe(self):\n        items = []\n        for (rule_name, _), (_, start, end) in self.items():\n            if end > start:\n                items.append((rule_name, start, end))\n        items.sort(key=lambda item: (item[2].position(), item[1].position()))\n        message = []\n        for item in items:\n            message.append(\"matched {: <20} {} -> {}\\n\".format(*item))\n        message.append(\"\\n\")\n        message.append(\"ERROR: {}: {}\\n\".format(\n            self._latest_stream,\n            self._latest_lazy_message()\n        ))\n        return \"\".join(message)\n\n    def fail(self, stream, lazy_message):\n        if stream.position() >= self._latest_stream.position():\n            self._latest_stream = stream\n            self._latest_lazy_message = lazy_message\n        raise _MatchError(self)\n\nclass _MatchError(Exception):\n\n    def __init__(self, memo):\n        Exception.__init__(self)\n        self._memo = memo\n\n    def describe(self):\n        return self._memo.describe()\n\nclass _Stream(object):\n\n    @classmethod\n    def from_object(cls, memo, input_object):\n        if isinstance(input_object, basestring):\n            return _CharStream(memo, input_object, 0)\n        else:\n            return _ObjectStream(memo, [input_object], 0)\n\n    def __init__(self, memo, objects, index):\n        self._memo = memo\n        self._objects = objects\n        self._index = index\n\n    def fail(self, lazy_message):\n        self._memo.fail(self, lazy_message)\n\n    def peek(self):\n        if self.is_at_end():\n            self.fail(lambda: \"not eof\")\n        return self._objects[self._index]\n\n    def is_at_end(self):\n        return self._index >= len(self._objects)\n\nclass _CharStream(_Stream):\n\n    def __init__(self, memo, objects, index, line=1, column=1):\n        _Stream.__init__(self, memo, objects, index)\n        self._line = line\n        self._column = column\n\n    def position(self):\n        return self._index\n\n    def advance(self):\n        if self._objects[self._index] == \"\\n\":\n            line = self._line + 1\n            column = 1\n        else:\n            line = self._line\n            column = self._column + 1\n        return _CharStream(self._memo, self._objects, self._index+1, line, column)\n\n    def __str__(self):\n        return \"L{:03d}:C{:03d}\".format(self._line, self._column)\n\nclass _ObjectStream(_Stream):\n\n    def __init__(self, memo, objects, index, parent=()):\n        _Stream.__init__(self, memo, objects, index)\n        self._parent_position = parent\n        self._position = self._parent_position + (self._index,)\n\n    def position(self):\n        return self._position\n\n    def nested(self, input_object):\n        return _ObjectStream(self._memo, input_object, 0, self._position)\n\n    def advance(self):\n        return _ObjectStream(self._memo, self._objects, self._index+1, self._parent_position)\n\n    def __str__(self):\n        return \"[{}]\".format(\", \".join(str(x) for x in self.position()))\n",
"type":"code"
}
],
"id":"42f83fae0f734a9a9248859c70bd285c",
"type":"code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"1ee923adb0ed4f3b8a5cc72700aad2dd",
"paragraphs":[
{
"code_id":"6299de61907642ed92cffaa3764f2c61",
"id":"b639c030e2a243cebc7ae78c556db96d",
"type":"expanded_code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"d09466ef920844788d5e63457decfd86",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"471910823d0c46e2be98600df125bd34",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"3aafb64996414339b01b0d407e6e1810",
"paragraphs":[],
"title":"Code listings for RLMeta"
}
],
"id":"89a873850f674da6a812ca31b0b943d6",
"paragraphs":[
{
"fragments":[
{
"text":"In this article we optimize ",
"type":"text"
},
{
"text":"RLMeta",
"type":"link",
"url":"/writing/rlmeta/index.html"
},
{
"text":" to run faster. The first version did not take performance into account, so it is not surprising that we will get it to run roughly twice as fast.",
"type":"text"
}
],
"id":"51307b1cf6714bcc822cd0c169e8f3de",
"type":"text"
}
],
"title":"Optimizing RLMeta"
},
"variables":{}
}