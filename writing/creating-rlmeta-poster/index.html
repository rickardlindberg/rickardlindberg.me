<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      Creating the RLMeta poster | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>Creating the RLMeta poster</h1>

<p><em>Published on 24 May 2020.</em></p>

<p>RLMeta is the most interesting program I've written. I find the grammar syntax beautiful to read and the meta-approach intriguing. To me, it approaches art. I wanted to showcase it by putting the whole implementation on a poster. Here is a preview:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
Preview of poster.
</center>
<p>Read on to learn how I created the poster and the RLMeta version displayed on it.</p>
<hr>
<p>This article is about how I created the RLMeta poster. Do you want to get the poster yourself?</p>
<p><a href="../../pages/rlmeta-poster/" class="btn btn-primary btn-lg">Check this page out!</a></p>
<hr>
<ul>
<li><a href="#822b34b481dd40c797d64d7d4dc1c83a">Poster design</a></li>
<li><a href="#227a05deecde41ad94738cb5cde516a0">RLMeta version</a>
<ul>
<li><a href="#2e83db1fb82b47c087bf7a6eb93d9440">Remove string builder</a></li>
<li><a href="#b391fa9375a5457cb91d265a597c6f0a">Move error reporting out of support</a></li>
<li><a href="#aeb916fedcdd47d5bb42e8d21b198c5b">Move assemble function to support</a></li>
<li><a href="#eb05ba1c676e4061a91f61e7c6234957">Compact and modify formatting</a></li>
<li><a href="#d2ab43bf941642b68c5af6af5937b17d">Have only one semantic action class</a></li>
<li><a href="#49f769c882b84649bcac36fe7401ce73">Allow unlimited splice</a></li>
<li><a href="#789c6116aa5449d691284a7fe3d36f9e">Redefine matching of character sequences</a></li>
</ul></li>
<li><a href="#b070abcd2f134cf894e33e63188a9fee">Future posters</a></li>
<li><a href="#730eea3f33b24e07b3714ef4c1981fd1">Code listings for RLMeta</a>
<ul>
<li><a href="#9ce22f137e4a4bf3b4080f4803f3205d">parser.rlmeta</a></li>
<li><a href="#af73e151e4a847e98832b2460fd43cc1">codegenerator.rlmeta</a></li>
<li><a href="#79d15a72ff31485ea0204c8f79d3a641">support.py</a></li>
<li><a href="#7142a9c9c93e4aa2aaf35c7962eb3c88">compile.sh</a></li>
<li><a href="#8c47ff964a3f43a29a4413bbf5b0132d">meta_compile.sh</a></li>
</ul></li>
</ul>
<h2 id="b34b481dd40c797d64d7d4dc1c83aposter-design">[]{#822b34b481dd40c797d64d7d4dc1c83a}Poster design</h2>
<p>I created the poster using <a href="https://inkscape.org/">Inkscape</a>. I have used Inkscape on and off in the past, but I am by no means an expert. I used the <a href="https://github.com/etlapale/inksyntax">inksyntax</a> plugin to create syntax highlighted text.</p>
<p>To come up with the design for the poster, I started by creating text objects for each file in the implementation. Then I tried to fit them on a page. Portrait mode worked best since I did not want to break the VM implementation, which was the longest piece of text and determined the main layout of the poster. I also concluded that I needed three columns to fit all code and that I wanted them to be of equal width for symmetry. I modified the source code to better fit the poster layout. In particular I worked on reducing the number of lines of code. After a while, making the VM code shorter would not help to fit more on the page because I still needed three columns. I made lots of test printouts and edits. You can see some of them in the pictures below.</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
I experimented with landscape mode. I figured that it would be bad usage of available space. I also had an idea about drawing arrows to show how the source code flow in the compiler. I decided that it would just clutter the poster.
</center>
<p><img src="image3.png" /></p>
<!-- image text -->
<center>
I printed half the poster on an A4 page to simulate text size on an A3 page. I concluded that the smallest text would probably be big enough if printed with a good printer.
</center>
<p><img src="image4.png" /></p>
<!-- image text -->
<center>
Here I have gravitated toward the final base design. I still haven't given up on the arrows.
</center>
<p><img src="image5.png" /></p>
<!-- image text -->
<center>
Here I have added introduction text and an example. My notes indicate improvements to RLMeta to make it a better fit for the poster. So even if this was printed on an A4 page on my cheap printer, it was possible to read, but not comfortable.
</center>
<p><img src="image6.png" /></p>
<!-- image text -->
<center>
I did some test printouts on two A4 papers and taped them together to simulate final size. <a href="https://pdfposter.readthedocs.io/en/stable/">pdfposter</a> was a useful tool here. Here is the command I used to split one A3 page in portrait mode into two A4 pages in landscape mode: <code>pdfposter /tmp/rlmeta-a3.pdf /tmp/rlmeta-a4.pdf -m a4 -p 2x1a4</code>.
</center>
<p><img src="image7.png" /></p>
<!-- image text -->
<center>
Here is the final beta poster printed on an A4 page. This is the one that I ordered for myself but in 12x16 inch format (close to A3).
</center>
<p><img src="image8.png" /></p>
<!-- image text -->
<center>
Finally, the poster arrived in my mail.
</center>
<hr>
<p>Do you want to have this poster in your hands as well?</p>
<p><a href="../../pages/rlmeta-poster/" class="btn btn-primary btn-lg">Check this page out!</a></p>
<hr>
<h2 id="a05deecde41ad94738cb5cde516a0rlmeta-version">[]{#227a05deecde41ad94738cb5cde516a0}RLMeta version</h2>
<p>The version of RLMeta on the poster is based on the VM based version from the <a href="../../writing/rlmeta-memoize-failures/">memoizing failures</a> article. In order to fit it nicely on a poster I had to make it smaller by reducing the number of lines of code. I also took the opportunity to clean up some things that annoyed me to make the poster extra beautiful. I believe this is the most beautiful version of RLMeta to date.</p>
<p>I though the memoizing version was already quite small. So I was not confident that I could make the poster version smaller. But when thinking about it a few things came to mind and I was able to reduce it by 103 lines. As a result, the poster version is also the smallest version of RLMeta to date. The changes also made it faster. So it is also the fastest version of RLMeta to date. I'm sure it can become even shorter and faster, and it's probably something I will think about again. But at some point I had to say it was good enough for a first version of a poster.</p>
<p><img src="image9.png" /></p>
<!-- image text -->
<center>
Performance measurements.
</center>
<p>Next I will describe the changes I did compared to the memoizing version.</p>
<h3 id="e83db1fb82b47c087bf7a6eb93d9440remove-string-builder">[]{#2e83db1fb82b47c087bf7a6eb93d9440}Remove string builder</h3>
<p>In the memoizing version, curly brace expressions in semantic actions are compiled to builder objects. Take the following example:</p>
<pre class="text"><code>Example {
  rule = .:x -&gt; { &quot;build a string with &quot; x &quot;!&quot; }
}</code></pre>
<p>The semantic action is compiled to the following Python code:</p>
<pre class="text"><code>lambda scope: _Builder.create([
    'build a string with ',
    scope['x'].eval(),
    '!'
])</code></pre>
<p>And in the <code>run</code> method that kicks off matching, there is code to check if the result is a builder, and if so, the result of building the string is returned:</p>
<pre class="text"><code>if isinstance(result, _Builder):
    return result.build_string()
else:
    return result</code></pre>
<p>I figured that all builder logic was not really needed. Instead curly brace expressions could be compiled to Python expressions that directly build and return strings.</p>
<p>With this change, the example semantic action is compiled to this:</p>
<pre class="text"><code>lambda scope: join([
    'build a string with ',
    scope['x'].eval(),
    '!'
])</code></pre>
<p>Where <code>join</code> is defined like this:</p>
<pre class="text"><code>def join(items):
    return &quot;&quot;.join(
        join(item) if isinstance(item, list) else str(item)
        for item in items
    )</code></pre>
<p>Indentation is handled similarly by directly indenting the string with the <code>indent</code> function:</p>
<pre class="text"><code>def indent(text):
    return join(join([&quot;    &quot;, line]) for line in text.splitlines(True))</code></pre>
<p>This change made lots of code obsolete:</p>
<ul>
<li>All builder-related classes could be removed (-61 lines)</li>
<li>The top level builder check could be removed (-3 lines)</li>
<li>The parser and the codegenerator actually got a little cleaner (-2 lines)</li>
<li>Import of <code>StringIO</code> could be removed (-5 lines)</li>
<li>Two string formatting functions (<code>join</code> and <code>indent</code>) had to be added (+9 lines)</li>
</ul>
<p>In total, it made RLMeta <strong>62 lines shorter</strong>.</p>
<p>I suspect that this change is also what made the poster version a little faster. So simpler, cleaner, and faster.</p>
<h3 id="move-error-reporting-out-of-support"><span id="b391fa9375a5457cb91d265a597c6f0a"></span>Move error reporting out of support</h3>
<p>In the memoizing version, the main function looks like this:</p>
<pre class="text"><code>try:
    sys.stdout.write(compile_grammar(sys.stdin.read()))
except _MatchError as e:
    sys.stderr.write(e.describe())
    sys.exit(1)</code></pre>
<p>If an error occurs, the <code>describe</code> method of the exception is used to format an error message suitable for printing to the console.</p>
<p>I decided that this was not really a responsibility of the support library. The support library should only provide information about the error, and it should be up to the handler of the error how to present it.</p>
<p>I therefore removed the <code>describe</code> method and replaced it with a much simpler error reporting scheme directly in the main method that looks like this:</p>
<pre class="text"><code>try:
    ...
except MatchError as e:
    stream = e.stream
    for pos in e.pos[:-1]:
        stream = stream[pos]
    pos = e.pos[-1]
    MARKER = &quot;\\033[0;31m&lt;ERROR POSITION&gt;\\033[0m&quot;
    if isinstance(stream, basestring):
        stream_string = stream[:pos] + MARKER + stream[pos:]
    else:
        stream_string = pprint.pformat(stream)
    sys.exit(&quot;ERROR: {}\\nPOSITION: {}\\nSTREAM:\\n{}&quot;.format(
      e.message,
      pos,
      indent(stream_string)
    ))</code></pre>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/b24d5cce5b684a62b9b85a48cd62443e48ccfb04">here</a>.</p>
<p>This change made RLMeta <strong>21 lines shorter</strong>.</p>
<p>This error reporting scheme is not that bad, and also doesn't suffer from edge case bugs like the one in the memoizing version does. But more importantly it is more clean. It is now the responsibility of the handler of the error to do formatting.</p>
<h3 id="move-assemble-function-to-support"><span id="aeb916fedcdd47d5bb42e8d21b198c5b"></span>Move assemble function to support</h3>
<p>In the memoizing version, the <code>Grammar</code> rule in the code generator looks like this:</p>
<pre class="text"><code>Grammar = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(_Grammar):\n\n&quot; &gt;
                             &quot;def __init__(self):\n&quot; &gt;
                               &quot;self._instructions = i = []\n&quot;
                               &quot;self._labels = l = {}\n&quot;
                               &quot;def I(name, x=None, y=None):\n&quot; &gt;
                                 &quot;i.append((name, x, y))\n&quot;
                               &lt;
                               &quot;def LABEL(name):\n&quot; &gt;
                                 &quot;l[name] = len(i)\n&quot;
                               &lt;
                               ys
                             &lt;
                           &lt;                                    }</code></pre>
<p>Having lot's of Python code in the code generator makes it harder to read. I therefore decided to put this code in the support library instead.</p>
<p>The new <code>Grammar</code> rule looks like this:</p>
<pre class="text"><code>Grammar = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(Grammar):\n\n&quot; &gt;
                             &quot;def assemble(self, I, LABEL):\n&quot; &gt;
                               ys
                             &lt;
                           &lt;                                    }</code></pre>
<p>And the support function looks like this:</p>
<pre class="text"><code>def run(self, rule_name, stream):
    instructions = []
    labels = {}
    def I(name, arg1=None, arg2=None):
        instructions.append((name, arg1, arg2))
    def LABEL(name):
        labels[name] = len(instructions)
    self.assemble(I, LABEL)
    return vm(instructions, labels, rule_name, stream)</code></pre>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/7709ec4b72c1c8c2dfbbef1f75b1e2946d5ee0fd">here</a>.</p>
<p>This change made RLMeta <strong>1 line shorter</strong>. But more importantly, it made the code generator easier to read.</p>
<h3 id="compact-and-modify-formatting"><span id="eb05ba1c676e4061a91f61e7c6234957"></span>Compact and modify formatting</h3>
<p>I made many small changes to improve the readability of RLMeta as well as some formatting to make it fit better on the poster. They did not affect performance or lines of code significantly. Here are some of them:</p>
<ul>
<li>I dropped <code>_</code> in names because it is easier to read.</li>
<li>I split long lines to make the code easier to read.</li>
<li>I reordered pieces of code for a more logical presentation order.</li>
</ul>
<h3 id="have-only-one-semantic-action-class"><span id="d2ab43bf941642b68c5af6af5937b17d"></span>Have only one semantic action class</h3>
<p>In the memoizing version, there are two semantic action classes:</p>
<pre class="text"><code>class _ConstantSemanticAction(object):

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

class _UserSemanticAction(object):

    def __init__(self, fn, scope):
        self.fn = fn
        self.scope = scope

    def eval(self):
        return self.fn(self.scope)</code></pre>
<p>I realized that this could be written more cleanly with only one class and the identity function being the default for the function:</p>
<pre class="text"><code>class SemanticAction(object):

    def __init__(self, value, fn=lambda value: value):
        self.value = value
        self.fn = fn

    def eval(self):
        return self.fn(self.value)</code></pre>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/31d01ad0db1bd1e76e51929f2b508601ed6caa4e">here</a>.</p>
<p>This change made RLMeta <strong>8 lines shorter</strong>.</p>
<h3 id="f769c882b84649bcac36fe7401ce73allow-unlimited-splice">[]{#49f769c882b84649bcac36fe7401ce73}Allow unlimited splice</h3>
<p>In the memoizing version, the splice operator inside lists (<code>~</code>) can only be used once.</p>
<p>I have written grammars where multiple splices were needed, so I have added support for it in a different version of RLMeta. I knew it would make the grammars a bit easier to read at the expense of a few more lines of code.</p>
<p>The full diff can seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/0d29337b8e21eb76a68708d2156c07bc42118fc1">here</a>.</p>
<p>This change made RLMeta <strong>6 lines longer</strong> but made the parser and codegenerator cleaner to read plus increasing flexibility.</p>
<p>This change also allowed the string matching to be removed since it was no longer used.</p>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/2bdd81fdf9eabcc30b29673c5eca760c0257a0fe">here</a> (ignoring the next change which is included in the diff).</p>
<p>This change made RLMeta <strong>10 lines shorter</strong>.</p>
<h3 id="c6116aa5449d691284a7fe3d36f9eredefine-matching-of-character-sequences">[]{#789c6116aa5449d691284a7fe3d36f9e}Redefine matching of character sequences</h3>
<p>In the memoizing version, the meaning of matching a character sequence is to match all characters and return that character sequence as a string. The following two rules are therefore identical:</p>
<pre class="text"><code>rule1 = 'hello'
rule2 = 'h' 'e' 'l' 'l' 'o' -&gt; &quot;hello&quot;</code></pre>
<p>This requires a special VM instruction. I decided that I could instead just have it mean match all the characters in the sequence and return the last matched character. That is <code>rule2</code> without the semantic action added. When matching a sequence of characters, you always know what the result is, so most of the time you don't need the full sequence as a result anyway, and when you do, you know what it is.</p>
<p>The full diff can be seen <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/2bdd81fdf9eabcc30b29673c5eca760c0257a0fe">here</a> (ignoring the previous change which is included in the diff).</p>
<p>This change made RLMeta <strong>1 line shorter</strong>. But more importantly, it made the VM a little cleaner.</p>
<h2 id="future-posters"><span id="b070abcd2f134cf894e33e63188a9fee"></span>Future posters</h2>
<p>The main feature of RLMeta is that you can easily extend it to be whatever you need it to be. The poster version or the base version should have the smallest subset of features just enough to support compiling itself. The smaller it is, the easier it is to understand and therefore extend. The more flexible it is to extend the better. If I make another poster version it would therefore focus on being smaller and more flexible. Since all successive version of RLMeta have been faster than the ones before, performance is also important. But small size, clarity, and flexibility come first.</p>
<p>Things that still annoy me with the poster version that I left:</p>
<ul>
<li>Assembly code in code generator is hard to read. I suspect it is because of all the different quotes. I'm not sure how to easily improve it at this moment.</li>
<li>The label counter is incremented at match time, not at semantic action evaluation time. This is really an incorrect behavior, but it will not lead to anything bad. It is just annoying. Labels should really be generated by semantic actions. I did not come up with an easy fix for this. But I have some ideas that I might try to implement in the future.</li>
<li>The compilation depends on Bash as well. I decided that it was okay because compilation can be done manually if it had to. It is not essential. It is more of a tool to put everything together for convenience. But it also contains crucial code which is the main function. So it's sort of glue that both compiles and has some code. It annoys me because it does not feel clean. But I don't have ideas right now how to improve it.</li>
</ul>
<h2 id="eea3f33b24e07b3714ef4c1981fd1code-listings-for-rlmeta">[]{#730eea3f33b24e07b3714ef4c1981fd1}Code listings for RLMeta</h2>
<p>The code here is exactly the same as on the poster. The <code>meta_compile.sh</code> script is not shown on the poster because it is not strictly part of the implementation. It is more of a developer tool.</p>
<h3 id="ce22f137e4a4bf3b4080f4803f3205dparser.rlmeta">[]{#9ce22f137e4a4bf3b4080f4803f3205d}parser.rlmeta</h3>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  grammar =
    | name:x space '{' rule*:ys space '}'      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space '=' choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space '|')?
      sequence:x (space '|' sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space ':' name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space '*'                        -&gt; [&quot;Star&quot; x]
    | expr2:x space '?'                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space '!' expr2:x                        -&gt; [&quot;Not&quot; x]
    | space '%'                                -&gt; [&quot;MatchCallRule&quot;]
    | space '#'                                -&gt; [&quot;Label&quot;]
    | expr2
  expr2 =
    | space '-&gt;' hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space '=')                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x '-' char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space charseq
    | space '.'                                -&gt; [&quot;MatchAny&quot;]
    | space '(' choice:x space ')'             -&gt; x
    | space '[' expr*:xs space ']'             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space '[' hostExprListItem*:xs space ']' -&gt; [&quot;List&quot; ~xs]
    | space '{' formatExpr*:xs space '}'       -&gt; [&quot;Format&quot; ~xs]
    | name:x space '(' hostExpr*:ys space ')'  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space '~'*:ys hostExpr:x                 -&gt; [&quot;ListItem&quot; len(ys) x]
  formatExpr =
    | space '&gt;' formatExpr*:xs space '&lt;'       -&gt; [&quot;Indent&quot; [&quot;Format&quot; ~xs]]
    | hostExpr
  charseq   = '\'' (!'\'' matchChar)*:xs '\''  -&gt; [&quot;And&quot; ~xs]
  matchChar = innerChar:x                      -&gt; [&quot;MatchObject&quot; x]
  string    = '&quot;'  (!'&quot;'  innerChar)*:xs '&quot;'   -&gt; { xs }
  char      = '\''  !'\'' innerChar  :x  '\''  -&gt; x
  innerChar = '\\' escape | .
  escape    = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
            | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; { x xs }
  nameStart = 'a'-'z' | 'A'-'Z'
  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'
  space     = (' ' | '\n')*
}</code></pre>
<h3 id="codegenerator.rlmeta"><span id="af73e151e4a847e98832b2460fd43cc1"></span>codegenerator.rlmeta</h3>
<pre><code>1.  codegenerator.rlmeta</code></pre>
<pre class="rlmeta"><code>CodeGenerator {
  ast            = [%:x]          -&gt; x
  Grammar        = .:x ast*:ys    -&gt; { &quot;class &quot; x &quot;(Grammar):\n\n&quot; &gt;
                                         &quot;def assemble(self, I, LABEL):\n&quot; &gt;
                                           ys
                                         &lt;
                                       &lt;                                    }
  Rule           = py:x ast:y     -&gt; { &quot;LABEL(&quot; x &quot;)\n&quot;
                                       y
                                       &quot;I('RETURN')\n&quot;                      }
  Or             =
    | ast:x Or:y #:a #:b          -&gt; { &quot;I('BACKTRACK', &quot; a &quot;)\n&quot;
                                       x
                                       &quot;I('COMMIT', &quot; b &quot;)\n&quot;
                                       &quot;LABEL(&quot; a &quot;)\n&quot;
                                       y
                                       &quot;LABEL(&quot; b &quot;)\n&quot;                     }
    | ast
  Scope          = ast:x          -&gt; { &quot;I('PUSH_SCOPE')\n&quot;
                                       x
                                       &quot;I('POP_SCOPE')\n&quot;                   }
  And            = ast*
  Bind           = py:x ast:y     -&gt; { y
                                       &quot;I('BIND', &quot; x &quot;)\n&quot;                 }
  Star           = ast:x #:a #:b  -&gt; { &quot;I('LIST_START')\n&quot;
                                       &quot;LABEL(&quot; a &quot;)\n&quot;
                                       &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                                       x
                                       &quot;I('LIST_APPEND')\n&quot;
                                       &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                                       &quot;LABEL(&quot; b &quot;)\n&quot;
                                       &quot;I('LIST_END')\n&quot;                    }
  Not            = ast:x #:a #:b  -&gt; { &quot;I('BACKTRACK', &quot; b &quot;)\n&quot;
                                       x
                                       &quot;I('COMMIT', &quot; a &quot;)\n&quot;
                                       &quot;LABEL(&quot; a &quot;)\n&quot;
                                       &quot;I('FAIL', 'no match expected')\n&quot;
                                       &quot;LABEL(&quot; b &quot;)\n&quot;                     }
  MatchCallRule  =                -&gt; { &quot;I('MATCH_CALL_RULE')\n&quot;             }
  Label          =                -&gt; { &quot;I('LABEL')\n&quot;                       }
  SemanticAction = ast:x          -&gt; { &quot;I('ACTION', lambda scope: &quot; x &quot;)\n&quot; }
  MatchRule      = py:x           -&gt; { &quot;I('CALL', &quot; x &quot;)\n&quot;                 }
  MatchRange     = py:x py:y      -&gt; { &quot;I('MATCH_RANGE', &quot; x &quot;, &quot; y &quot;)\n&quot;   }
  MatchObject    = py:x           -&gt; { &quot;I('MATCH_OBJECT', &quot; x &quot;)\n&quot;         }
  MatchAny       =                -&gt; { &quot;I('MATCH_ANY')\n&quot;                   }
  MatchList      = ast:x          -&gt; { &quot;I('PUSH_STREAM')\n&quot;
                                       x
                                       &quot;I('POP_STREAM')\n&quot;                  }
  String         = py
  List           = astItems:x     -&gt; { &quot;concat([&quot; x &quot;])&quot;                    }
  ListItem       = py:x ast:y     -&gt; { &quot;splice(&quot; x &quot;, &quot; y &quot;)&quot;               }
  Format         = astItems:x     -&gt; { &quot;join([&quot; x &quot;])&quot;                      }
  Indent         = ast:x          -&gt; { &quot;indent(&quot; x &quot;)&quot;                      }
  FnCall         = .:x astItems:y -&gt; { x &quot;(&quot; y &quot;)&quot;                          }
  VarLookup      = py:x           -&gt; { &quot;scope[&quot; x &quot;].eval()&quot;                }
  astItems       =
    | ast:x astItem*:xs           -&gt; { x xs                                 }
    |                             -&gt; {                                      }
  astItem        = ast:x          -&gt; { &quot;, &quot; x                               }
  py             = .:x            -&gt; repr(x)
}</code></pre>
<h3 id="d15a72ff31485ea0204c8f79d3a641support.py">[]{#79d15a72ff31485ea0204c8f79d3a641}support.py</h3>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb20"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">def</span> vm(instructions, labels, start_rule, stream):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    label_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    action <span class="op">=</span> SemanticAction(<span class="va">None</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    pc <span class="op">=</span> labels[start_rule]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    call_backtrack_stack <span class="op">=</span> []</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    stream, pos, stream_pos_stack <span class="op">=</span> (stream, <span class="dv">0</span>, [])</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    scope, scope_stack <span class="op">=</span> (<span class="va">None</span>, [])</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    fail_message <span class="op">=</span> <span class="va">None</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>    latest_fail_message, latest_fail_pos <span class="op">=</span> (<span class="va">None</span>, <span class="bu">tuple</span>())</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>    memo <span class="op">=</span> {}</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>        name, arg1, arg2 <span class="op">=</span> instructions[pc]</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>        <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;PUSH_SCOPE&quot;</span>:</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>            scope_stack.append(scope)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>            scope <span class="op">=</span> {}</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BACKTRACK&quot;</span>:</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>            call_backtrack_stack.append((</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>                labels[arg1], pos, <span class="bu">len</span>(stream_pos_stack), <span class="bu">len</span>(scope_stack)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>            ))</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;CALL&quot;</span>:</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>            key <span class="op">=</span> (arg1, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>            <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a>                <span class="cf">if</span> memo[key][<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a>                    fail_message <span class="op">=</span> memo[key][<span class="dv">1</span>]</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a>                <span class="cf">else</span>:</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>                    action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a>                    stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a>                    stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a>                    pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>                    <span class="cf">continue</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>                call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a>                pc <span class="op">=</span> labels[arg1]</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_SCOPE&quot;</span>:</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true"></a>            scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_OBJECT&quot;</span>:</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> stream[pos] <span class="op">!=</span> arg1:</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1)</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true"></a>                action <span class="op">=</span> SemanticAction(arg1)</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;COMMIT&quot;</span>:</span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true"></a>            call_backtrack_stack.pop()</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true"></a>            pc <span class="op">=</span> labels[arg1]</span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;RETURN&quot;</span>:</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_stack) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true"></a>                <span class="cf">return</span> action.<span class="bu">eval</span>()</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true"></a>            pc, key <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true"></a>            memo[key] <span class="op">=</span> (action, stream_pos_stack<span class="op">+</span>[(stream, pos)])</span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_APPEND&quot;</span>:</span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true"></a>            scope.append(action)</span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;BIND&quot;</span>:</span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true"></a>            scope[arg1] <span class="op">=</span> action</span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;ACTION&quot;</span>:</span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true"></a>            action <span class="op">=</span> SemanticAction(scope, arg1)</span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_RANGE&quot;</span>:</span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> (arg1 <span class="op">&lt;=</span> stream[pos] <span class="op">&lt;=</span> arg2):</span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected range </span><span class="sc">{!r}</span><span class="st">-</span><span class="sc">{!r}</span><span class="st">&quot;</span>, arg1, arg2)</span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true"></a>                action <span class="op">=</span> SemanticAction(stream[pos])</span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_START&quot;</span>:</span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true"></a>            scope_stack.append(scope)</span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true"></a>            scope <span class="op">=</span> []</span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LIST_END&quot;</span>:</span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true"></a>            action <span class="op">=</span> SemanticAction(scope, <span class="kw">lambda</span> xs: [x.<span class="bu">eval</span>() <span class="cf">for</span> x <span class="kw">in</span> xs])</span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true"></a>            scope <span class="op">=</span> scope_stack.pop()</span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_ANY&quot;</span>:</span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true"></a>                action <span class="op">=</span> SemanticAction(stream[pos])</span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;PUSH_STREAM&quot;</span>:</span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream) <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(stream[pos], <span class="bu">list</span>):</span>
<span id="cb20-101"><a href="#cb20-101" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected list&quot;</span>,)</span>
<span id="cb20-102"><a href="#cb20-102" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-103"><a href="#cb20-103" aria-hidden="true"></a>                stream_pos_stack.append((stream, pos))</span>
<span id="cb20-104"><a href="#cb20-104" aria-hidden="true"></a>                stream <span class="op">=</span> stream[pos]</span>
<span id="cb20-105"><a href="#cb20-105" aria-hidden="true"></a>                pos <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-106"><a href="#cb20-106" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-107"><a href="#cb20-107" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-108"><a href="#cb20-108" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;POP_STREAM&quot;</span>:</span>
<span id="cb20-109"><a href="#cb20-109" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&lt;</span> <span class="bu">len</span>(stream):</span>
<span id="cb20-110"><a href="#cb20-110" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected end of list&quot;</span>,)</span>
<span id="cb20-111"><a href="#cb20-111" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-112"><a href="#cb20-112" aria-hidden="true"></a>                stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb20-113"><a href="#cb20-113" aria-hidden="true"></a>                pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-114"><a href="#cb20-114" aria-hidden="true"></a>                pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-115"><a href="#cb20-115" aria-hidden="true"></a>                <span class="cf">continue</span></span>
<span id="cb20-116"><a href="#cb20-116" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;MATCH_CALL_RULE&quot;</span>:</span>
<span id="cb20-117"><a href="#cb20-117" aria-hidden="true"></a>            <span class="cf">if</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(stream):</span>
<span id="cb20-118"><a href="#cb20-118" aria-hidden="true"></a>                fail_message <span class="op">=</span> (<span class="st">&quot;expected any&quot;</span>,)</span>
<span id="cb20-119"><a href="#cb20-119" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-120"><a href="#cb20-120" aria-hidden="true"></a>                fn_name <span class="op">=</span> <span class="bu">str</span>(stream[pos])</span>
<span id="cb20-121"><a href="#cb20-121" aria-hidden="true"></a>                key <span class="op">=</span> (fn_name, <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos]))</span>
<span id="cb20-122"><a href="#cb20-122" aria-hidden="true"></a>                <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb20-123"><a href="#cb20-123" aria-hidden="true"></a>                    <span class="cf">if</span> memo[key][<span class="dv">0</span>] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-124"><a href="#cb20-124" aria-hidden="true"></a>                        fail_message <span class="op">=</span> memo[key][<span class="dv">1</span>]</span>
<span id="cb20-125"><a href="#cb20-125" aria-hidden="true"></a>                    <span class="cf">else</span>:</span>
<span id="cb20-126"><a href="#cb20-126" aria-hidden="true"></a>                        action, stream_pos_stack <span class="op">=</span> memo[key]</span>
<span id="cb20-127"><a href="#cb20-127" aria-hidden="true"></a>                        stream_pos_stack <span class="op">=</span> stream_pos_stack[:]</span>
<span id="cb20-128"><a href="#cb20-128" aria-hidden="true"></a>                        stream, pos <span class="op">=</span> stream_pos_stack.pop()</span>
<span id="cb20-129"><a href="#cb20-129" aria-hidden="true"></a>                        pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-130"><a href="#cb20-130" aria-hidden="true"></a>                        <span class="cf">continue</span></span>
<span id="cb20-131"><a href="#cb20-131" aria-hidden="true"></a>                <span class="cf">else</span>:</span>
<span id="cb20-132"><a href="#cb20-132" aria-hidden="true"></a>                    call_backtrack_stack.append((pc<span class="op">+</span><span class="dv">1</span>, key))</span>
<span id="cb20-133"><a href="#cb20-133" aria-hidden="true"></a>                    pc <span class="op">=</span> labels[fn_name]</span>
<span id="cb20-134"><a href="#cb20-134" aria-hidden="true"></a>                    pos <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-135"><a href="#cb20-135" aria-hidden="true"></a>                    <span class="cf">continue</span></span>
<span id="cb20-136"><a href="#cb20-136" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;FAIL&quot;</span>:</span>
<span id="cb20-137"><a href="#cb20-137" aria-hidden="true"></a>            fail_message <span class="op">=</span> (arg1,)</span>
<span id="cb20-138"><a href="#cb20-138" aria-hidden="true"></a>        <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;LABEL&quot;</span>:</span>
<span id="cb20-139"><a href="#cb20-139" aria-hidden="true"></a>            action <span class="op">=</span> SemanticAction(label_counter)</span>
<span id="cb20-140"><a href="#cb20-140" aria-hidden="true"></a>            label_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-141"><a href="#cb20-141" aria-hidden="true"></a>            pc <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-142"><a href="#cb20-142" aria-hidden="true"></a>            <span class="cf">continue</span></span>
<span id="cb20-143"><a href="#cb20-143" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb20-144"><a href="#cb20-144" aria-hidden="true"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&quot;unknown instruction </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(name))</span>
<span id="cb20-145"><a href="#cb20-145" aria-hidden="true"></a>        fail_pos <span class="op">=</span> <span class="bu">tuple</span>([x[<span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> stream_pos_stack]<span class="op">+</span>[pos])</span>
<span id="cb20-146"><a href="#cb20-146" aria-hidden="true"></a>        <span class="cf">if</span> fail_pos <span class="op">&gt;=</span> latest_fail_pos:</span>
<span id="cb20-147"><a href="#cb20-147" aria-hidden="true"></a>            latest_fail_message <span class="op">=</span> fail_message</span>
<span id="cb20-148"><a href="#cb20-148" aria-hidden="true"></a>            latest_fail_pos <span class="op">=</span> fail_pos</span>
<span id="cb20-149"><a href="#cb20-149" aria-hidden="true"></a>        call_backtrack_entry <span class="op">=</span> <span class="bu">tuple</span>()</span>
<span id="cb20-150"><a href="#cb20-150" aria-hidden="true"></a>        <span class="cf">while</span> call_backtrack_stack:</span>
<span id="cb20-151"><a href="#cb20-151" aria-hidden="true"></a>            call_backtrack_entry <span class="op">=</span> call_backtrack_stack.pop()</span>
<span id="cb20-152"><a href="#cb20-152" aria-hidden="true"></a>            <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">==</span> <span class="dv">4</span>:</span>
<span id="cb20-153"><a href="#cb20-153" aria-hidden="true"></a>                <span class="cf">break</span></span>
<span id="cb20-154"><a href="#cb20-154" aria-hidden="true"></a>            <span class="cf">else</span>:</span>
<span id="cb20-155"><a href="#cb20-155" aria-hidden="true"></a>                _, key <span class="op">=</span> call_backtrack_entry</span>
<span id="cb20-156"><a href="#cb20-156" aria-hidden="true"></a>                memo[key] <span class="op">=</span> (<span class="va">None</span>, fail_message)</span>
<span id="cb20-157"><a href="#cb20-157" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(call_backtrack_entry) <span class="op">!=</span> <span class="dv">4</span>:</span>
<span id="cb20-158"><a href="#cb20-158" aria-hidden="true"></a>            <span class="cf">raise</span> MatchError(</span>
<span id="cb20-159"><a href="#cb20-159" aria-hidden="true"></a>                latest_fail_message[<span class="dv">0</span>].<span class="bu">format</span>(<span class="op">*</span>latest_fail_message[<span class="dv">1</span>:]),</span>
<span id="cb20-160"><a href="#cb20-160" aria-hidden="true"></a>                latest_fail_pos,</span>
<span id="cb20-161"><a href="#cb20-161" aria-hidden="true"></a>                stream_pos_stack[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">if</span> stream_pos_stack <span class="cf">else</span> stream</span>
<span id="cb20-162"><a href="#cb20-162" aria-hidden="true"></a>            )</span>
<span id="cb20-163"><a href="#cb20-163" aria-hidden="true"></a>        (pc, pos, stream_stack_len, scope_stack_len) <span class="op">=</span> call_backtrack_entry</span>
<span id="cb20-164"><a href="#cb20-164" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(stream_pos_stack) <span class="op">&gt;</span> stream_stack_len:</span>
<span id="cb20-165"><a href="#cb20-165" aria-hidden="true"></a>            stream <span class="op">=</span> stream_pos_stack[stream_stack_len][<span class="dv">0</span>]</span>
<span id="cb20-166"><a href="#cb20-166" aria-hidden="true"></a>        stream_pos_stack <span class="op">=</span> stream_pos_stack[:stream_stack_len]</span>
<span id="cb20-167"><a href="#cb20-167" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">len</span>(scope_stack) <span class="op">&gt;</span> scope_stack_len:</span>
<span id="cb20-168"><a href="#cb20-168" aria-hidden="true"></a>            scope <span class="op">=</span> scope_stack[scope_stack_len]</span>
<span id="cb20-169"><a href="#cb20-169" aria-hidden="true"></a>        scope_stack <span class="op">=</span> scope_stack[:scope_stack_len]</span>
<span id="cb20-170"><a href="#cb20-170" aria-hidden="true"></a></span>
<span id="cb20-171"><a href="#cb20-171" aria-hidden="true"></a><span class="kw">class</span> SemanticAction(<span class="bu">object</span>):</span>
<span id="cb20-172"><a href="#cb20-172" aria-hidden="true"></a></span>
<span id="cb20-173"><a href="#cb20-173" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value, fn<span class="op">=</span><span class="kw">lambda</span> value: value):</span>
<span id="cb20-174"><a href="#cb20-174" aria-hidden="true"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb20-175"><a href="#cb20-175" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb20-176"><a href="#cb20-176" aria-hidden="true"></a></span>
<span id="cb20-177"><a href="#cb20-177" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb20-178"><a href="#cb20-178" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn(<span class="va">self</span>.value)</span>
<span id="cb20-179"><a href="#cb20-179" aria-hidden="true"></a></span>
<span id="cb20-180"><a href="#cb20-180" aria-hidden="true"></a><span class="kw">class</span> MatchError(<span class="pp">Exception</span>):</span>
<span id="cb20-181"><a href="#cb20-181" aria-hidden="true"></a></span>
<span id="cb20-182"><a href="#cb20-182" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, message, pos, stream):</span>
<span id="cb20-183"><a href="#cb20-183" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb20-184"><a href="#cb20-184" aria-hidden="true"></a>        <span class="va">self</span>.message <span class="op">=</span> message</span>
<span id="cb20-185"><a href="#cb20-185" aria-hidden="true"></a>        <span class="va">self</span>.pos <span class="op">=</span> pos</span>
<span id="cb20-186"><a href="#cb20-186" aria-hidden="true"></a>        <span class="va">self</span>.stream <span class="op">=</span> stream</span>
<span id="cb20-187"><a href="#cb20-187" aria-hidden="true"></a></span>
<span id="cb20-188"><a href="#cb20-188" aria-hidden="true"></a><span class="kw">class</span> Grammar(<span class="bu">object</span>):</span>
<span id="cb20-189"><a href="#cb20-189" aria-hidden="true"></a></span>
<span id="cb20-190"><a href="#cb20-190" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule_name, stream):</span>
<span id="cb20-191"><a href="#cb20-191" aria-hidden="true"></a>        instructions <span class="op">=</span> []</span>
<span id="cb20-192"><a href="#cb20-192" aria-hidden="true"></a>        labels <span class="op">=</span> {}</span>
<span id="cb20-193"><a href="#cb20-193" aria-hidden="true"></a>        <span class="kw">def</span> I(name, arg1<span class="op">=</span><span class="va">None</span>, arg2<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb20-194"><a href="#cb20-194" aria-hidden="true"></a>            instructions.append((name, arg1, arg2))</span>
<span id="cb20-195"><a href="#cb20-195" aria-hidden="true"></a>        <span class="kw">def</span> LABEL(name):</span>
<span id="cb20-196"><a href="#cb20-196" aria-hidden="true"></a>            labels[name] <span class="op">=</span> <span class="bu">len</span>(instructions)</span>
<span id="cb20-197"><a href="#cb20-197" aria-hidden="true"></a>        <span class="va">self</span>.assemble(I, LABEL)</span>
<span id="cb20-198"><a href="#cb20-198" aria-hidden="true"></a>        <span class="cf">return</span> vm(instructions, labels, rule_name, stream)</span>
<span id="cb20-199"><a href="#cb20-199" aria-hidden="true"></a></span>
<span id="cb20-200"><a href="#cb20-200" aria-hidden="true"></a><span class="kw">def</span> splice(depth, item):</span>
<span id="cb20-201"><a href="#cb20-201" aria-hidden="true"></a>    <span class="cf">if</span> depth <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-202"><a href="#cb20-202" aria-hidden="true"></a>        <span class="cf">return</span> [item]</span>
<span id="cb20-203"><a href="#cb20-203" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb20-204"><a href="#cb20-204" aria-hidden="true"></a>        <span class="cf">return</span> concat([splice(depth<span class="op">-</span><span class="dv">1</span>, subitem) <span class="cf">for</span> subitem <span class="kw">in</span> item])</span>
<span id="cb20-205"><a href="#cb20-205" aria-hidden="true"></a></span>
<span id="cb20-206"><a href="#cb20-206" aria-hidden="true"></a><span class="kw">def</span> concat(lists):</span>
<span id="cb20-207"><a href="#cb20-207" aria-hidden="true"></a>    <span class="cf">return</span> [x <span class="cf">for</span> xs <span class="kw">in</span> lists <span class="cf">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb20-208"><a href="#cb20-208" aria-hidden="true"></a></span>
<span id="cb20-209"><a href="#cb20-209" aria-hidden="true"></a><span class="kw">def</span> join(items):</span>
<span id="cb20-210"><a href="#cb20-210" aria-hidden="true"></a>    <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join(</span>
<span id="cb20-211"><a href="#cb20-211" aria-hidden="true"></a>        join(item) <span class="cf">if</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>) <span class="cf">else</span> <span class="bu">str</span>(item)</span>
<span id="cb20-212"><a href="#cb20-212" aria-hidden="true"></a>        <span class="cf">for</span> item <span class="kw">in</span> items</span>
<span id="cb20-213"><a href="#cb20-213" aria-hidden="true"></a>    )</span>
<span id="cb20-214"><a href="#cb20-214" aria-hidden="true"></a></span>
<span id="cb20-215"><a href="#cb20-215" aria-hidden="true"></a><span class="kw">def</span> indent(text):</span>
<span id="cb20-216"><a href="#cb20-216" aria-hidden="true"></a>    <span class="cf">return</span> join(join([<span class="st">&quot;    &quot;</span>, line]) <span class="cf">for</span> line <span class="kw">in</span> text.splitlines(<span class="va">True</span>))</span></code></pre></div>
<h3 id="a9c9c93e4aa2aaf35c7962eb3c88compile.sh">[]{#7142a9c9c93e4aa2aaf35c7962eb3c88}compile.sh</h3>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">'import sys; sys.stdout.write(repr(sys.stdin.read()))'</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>import sys</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a>import pprint</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>SUPPORT = <span class="va">$support_py_string</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true"></a></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true"></a>if __name__ == &quot;__main__&quot;:</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true"></a>    if &quot;--support&quot; in sys.argv:</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true"></a>        sys.stdout.write(SUPPORT)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true"></a>    else:</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true"></a>        try:</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true"></a>            sys.stdout.write(</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true"></a>                CodeGenerator().run(</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true"></a>                    &quot;ast&quot;,</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true"></a>                    [Parser().run(&quot;grammar&quot;, sys.stdin.read())]</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true"></a>                )</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true"></a>            )</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true"></a>        except MatchError as e:</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true"></a>            stream = e.stream</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true"></a>            for pos in e.pos[:-1]:</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true"></a>                stream = stream[pos]</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true"></a>            pos = e.pos[-1]</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true"></a>            MARKER = &quot;<span class="dt">\\</span>033[0;31m&lt;ERROR POSITION&gt;<span class="dt">\\</span>033[0m&quot;</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true"></a>            if isinstance(stream, basestring):</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true"></a>                stream_string = stream[:pos] + MARKER + stream[pos:]</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true"></a>            else:</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true"></a>                stream_string = pprint.pformat(stream)</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true"></a>            sys.exit(&quot;ERROR: {}<span class="dt">\\</span>nPOSITION: {}<span class="dt">\\</span>nSTREAM:<span class="dt">\\</span>n{}&quot;.format(</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true"></a>              e.message,</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true"></a>              pos,</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true"></a>              indent(stream_string)</span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true"></a>            ))</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<h3 id="c47ff964a3f43a29a4413bbf5b0132dmeta_compile.sh">[]{#8c47ff964a3f43a29a4413bbf5b0132d}meta_compile.sh</h3>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Test: Reproduces itself&quot;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Test: Has its own support library embedded&quot;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Test: Error reporting string input&quot;</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;Grammar { foo = . &quot;</span> <span class="kw">|</span> <span class="ex">python</span> rlmeta3.py <span class="kw">&amp;&amp;</span> <span class="fu">false</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;OK&quot;</span></span></code></pre></div>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
