{
"root_page":{
"children":[
{
"children":[],
"id":"a83adf407dbd43929bfbb4ab7f7311e5",
"paragraphs":[
{
"fragments":[
{
"text":"The parser is the same as from the previous article. It turns a subset of mathematical expression into an AST:",
"type":"text"
}
],
"id":"5dba2fad4bdf4e7ebcf37a42a418db8c",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  expr  = digit:x (op:y digit:z -> [y z])*:xs -> parseOps(x xs)\n  digit = '0'-'9':x                           -> int(x)\n  op    =\n    | '+' -> Op(makeAstNode(\"ADD\") 1 \"left\")\n    | '-' -> Op(makeAstNode(\"SUB\") 1 \"left\")\n    | '*' -> Op(makeAstNode(\"MUL\") 2 \"left\")\n    | '/' -> Op(makeAstNode(\"DIV\") 2 \"left\")\n    | '^' -> Op(makeAstNode(\"POW\") 3 \"right\")\n}\n",
"type":"code"
}
],
"id":"d3a45ae9dc0345bebfbf390d7247c39b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"function"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class Op(object):\n\n    def __init__(self, fn, prec, assoc):\n        self.fn = fn\n        self.prec = prec\n        self.assoc = assoc\n",
"type":"code"
}
],
"id":"5bebd448e842433fae61351f23f67451",
"type":"code"
},
{
"chunkpath":[
"function"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def makeAstNode(name):\n    def op(left, right):\n        return [name, left, right]\n    return op\n",
"type":"code"
}
],
"id":"d447ef7f73c3449a86562dc994bd14aa",
"type":"code"
},
{
"chunkpath":[
"function"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def parseOps(expr, items, min_level=0):\n    while items and items[0][0].prec >= min_level:\n        op, rhs = items.pop(0)\n        if op.assoc == \"left\":\n            next_level = op.prec + 1\n        else:\n            next_level = op.prec\n        expr = op.fn(expr, parseOps(rhs, items, next_level))\n    return expr\n",
"type":"code"
}
],
"id":"0e3c33cbca0f4cb296429066f8a80146",
"type":"code"
},
{
"fragments":[
{
"text":"Example:",
"type":"text"
}
],
"id":"033e3ade955d422eb2f63707200022a7",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"a28c516d70f34a0395bb9904c5c379d1",
"post_process":[
"bash",
"compile.sh",
"parser"
],
"type":"code"
},
{
"code_id":"a28c516d70f34a0395bb9904c5c379d1",
"id":"137ce8857b5c4a8d8c38b74917c41504",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"9^5^3\n",
"type":"code"
}
],
"id":"1fc52c98099045eda742312fba3b0532",
"post_process":[
"bash",
"compile.sh",
"parser"
],
"type":"code"
},
{
"code_id":"1fc52c98099045eda742312fba3b0532",
"id":"1d4e925083db4b46b4f3b387bcd9374c",
"type":"expanded_code"
}
],
"title":"Parser"
},
{
"children":[],
"id":"0488143f851349bf876169b04770e6bf",
"paragraphs":[
{
"fragments":[
{
"text":"The abstract code generator converts an AST into instructions for an imaginary stack machine:",
"type":"text"
}
],
"id":"5b3df405b7ce42dc9e0e172d5785b4b3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"abstractcodegen.rlmeta"
],
"fragments":[
{
"text":"AbstractCodeGen {\n  expr =\n    | [.:name expr:left expr:right] -> [~right ~left name]\n    | .:leaf                        -> [\"PUSH\" leaf]\n}\n",
"type":"code"
}
],
"id":"0fa99ac78bf24f558aecc3a4760c95bd",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"4598cfbceed64836b4c4ee934a90eed6",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen"
],
"type":"code"
},
{
"code_id":"4598cfbceed64836b4c4ee934a90eed6",
"id":"c17173be18e643c5889acd3b28796ca7",
"type":"expanded_code"
}
],
"title":"Abstract code generator"
},
{
"children":[],
"id":"bb76bbbba48d4c23b982e5c90af36d86",
"paragraphs":[
{
"fragments":[
{
"text":"The X86 code generator converts instructions for the imaginary stack machine into assembly instructions for the x86 architecture.",
"type":"text"
}
],
"id":"f24adb7c9f584f4fb8b41f6f404323dd",
"type":"text"
},
{
"fragments":[
{
"text":"An assembly instruction is represented as a list with its mnemonic and operands:",
"type":"text"
}
],
"id":"ecbfb6c880e84024905f6a113e641b50",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"[\"mnemonic\" op1 op2 ..]\n",
"type":"code"
}
],
"id":"d27ca27fb5c44278ad58a4140a41088b",
"type":"code"
},
{
"fragments":[
{
"text":"For an instruction performing a binary operation, ",
"type":"text"
},
{
"text":"op1",
"type":"code"
},
{
"text":" is the destination and ",
"type":"text"
},
{
"text":"op2",
"type":"code"
},
{
"text":" is the source. The binary operation performed is therefore the following:",
"type":"text"
}
],
"id":"0d5fb26dd6ef41428b551530fb3ad559",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"op1 = op1 `operation` op2\n",
"type":"code"
}
],
"id":"8deced1c937f4c6ebc8d224acf1ce7fe",
"type":"code"
},
{
"fragments":[
{
"text":"An operand can be either a constant, a register, or a memory location.",
"type":"text"
}
],
"id":"396333999b874e1b9f935cce78b19ddd",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"X86CodeGen {\n  expr = [%*:xs] -> [~~xs]\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"instructions"
],
"prefix":"  ",
"type":"chunk"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"82c7f0b301fe414daed3ccf01f1a3004",
"language":"",
"post_process":[],
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"rdi",
"type":"code"
},
{
"text":" is the stack pointer where the stack grows downwards (64-bit integer)",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"eax",
"type":"code"
},
{
"text":" is a TOS (top of stack) register (32-bit signed integer)",
"type":"text"
}
]
}
],
"id":"b92e18b1c525415e9dc01876f3051269",
"type":"list"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"ADD = -> [\n  [\"add\" [\"reg\" \"eax\"] [\"addr\" \"rdi\"]]\n  [\"sub\" [\"reg\" \"rdi\"] [\"const\" 4   ]]\n]\n",
"type":"code"
}
],
"id":"3817c30ae29547c7ba43d4a09da383d7",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"SUB = -> [\n  [\"sub\" [\"reg\" \"eax\"] [\"addr\" \"rdi\"]]\n  [\"sub\" [\"reg\" \"rdi\"] [\"const\" 4   ]]\n]\n",
"type":"code"
}
],
"id":"617031f2a4cc49da98979cd4e4c323ce",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"MUL = -> [\n  [\"imul\" [\"reg\" \"eax\"] [\"addr\" \"rdi\"]]\n  [\"sub\"  [\"reg\" \"rdi\"] [\"const\" 4   ]]\n]\n",
"type":"code"
}
],
"id":"ba98b56127bb42d6b60fb57ad9385645",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"DIV = -> [\n  [\"cdq\"                                   ]\n  [\"idiv\" \"long\" [\"addr\" \"rdi\"]            ]\n  [\"sub\"         [\"reg\"  \"rdi\"] [\"const\" 4]]\n]\n",
"type":"code"
}
],
"id":"45560909864b48ebaeae6a9aebbfad2b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"POW = -> [\n]\n",
"type":"code"
}
],
"id":"becc0894c3de4a46b700eef621a53fb6",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"PUSH = .:x -> [\n  [\"add\" [\"reg\"  \"rdi\"] [\"const\" 4    ]]\n  [\"mov\" [\"addr\" \"rdi\"] [\"reg\"   \"eax\"]]\n  [\"mov\" [\"reg\"  \"eax\"] [\"const\" x    ]]\n]\n",
"type":"code"
}
],
"id":"de75b501f61049dfad8182c6c5748b87",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"8\n",
"type":"code"
}
],
"id":"6cf60873293d4f8a815f29443ddd954c",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen"
],
"type":"code"
},
{
"code_id":"6cf60873293d4f8a815f29443ddd954c",
"id":"8852d3b4a5464870a71e4fabff92fb75",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"11dc92720f48433aa94748bc281d4b34",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen"
],
"type":"code"
},
{
"code_id":"11dc92720f48433aa94748bc281d4b34",
"id":"9eaab6a4915344089a47e2de54d9e35a",
"type":"expanded_code"
}
],
"title":"X86 code generator"
},
{
"children":[],
"id":"12e4e39c6b494b30a425f4570e8b8d53",
"paragraphs":[
{
"fragments":[
{
"text":"The GAS generator converts assembly instructions into a file suitable for compilation with the GNU assembler: ",
"type":"text"
},
{
"text":"gcc -nostdlib file.s",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"679dddb6aac04f20bdd82e14bab671ec",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"gas.rlmeta"
],
"fragments":[
{
"text":"GasGen {\n  expr = [instr*:xs] -> {\n    \".global expr\\n\"\n    \"expr:\\n\"\n    xs\n    \"ret\\n\"\n  }\n  instr =\n    | [mnemonic:x op:target op:source] -> { x \"  \" source \",\" target \"\\n\" }\n    | [mnemonic:x op:arg]              -> { x \"  \" arg \"\\n\" }\n    | [mnemonic:x]                     -> { x \"\\n\" }\n  op =\n    | [\"reg\"    .:name] -> { \"%\" name      }\n    | [\"addr\"   .:name] -> { \"(%\" name \")\" }\n    | [\"const\" .:value] -> { \"$\" value     }\n  mnemonic = .:x size:y -> pad(x y)\n  size = \"long\" -> \"l\" | -> \"\"\n}\n",
"type":"code"
}
],
"id":"a3c752a8e4fc42cfbd6cfdf5bb8c2674",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"function"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def pad(text, suffix):\n    return (text+suffix).ljust(7)\n",
"type":"code"
}
],
"id":"42da3457d2a9450bbb21aaccdf8398aa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"driver.c"
],
"fragments":[
{
"text":"#include <stdlib.h>\n#include <stdio.h>\n\nint expr(void* mem);\n\nint main() {\n    void* mem = (void*)malloc(32*sizeof(int));\n    int result = expr(mem);\n    printf(\"%d\\n\", result);\n}\n",
"type":"code"
}
],
"id":"81af165cdf824fc390d506bb88ea3b37",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"gas.sh"
],
"fragments":[
{
"text":"set -e\n\necho \"$1\" | bash compile.sh parser acodegen xcodegen gas @expr.s\n\ngcc driver.c expr.s -o expr\n\necho \"\"\necho \"=V==============================\"\necho \"\"\n\necho \"$1 = $(./expr)\"\n",
"type":"code"
}
],
"id":"98d1d6b2aaff4cb9b0498870e82fda8f",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"9\n",
"type":"code"
}
],
"id":"04e14524f1b34b6f940d0922a6bfc6f4",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen",
"gas"
],
"type":"code"
},
{
"code_id":"04e14524f1b34b6f940d0922a6bfc6f4",
"id":"7857b19690284563bbdaff9437c5c454",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"2e82d76819b4491083d800d7f30579d7",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen",
"gas"
],
"type":"code"
},
{
"code_id":"2e82d76819b4491083d800d7f30579d7",
"id":"eb8b5287d1424564a67559ea9e07abc3",
"type":"expanded_code"
}
],
"title":"GAS generator"
},
{
"children":[],
"id":"d3ece5a4ba484033ac47d9190e513acd",
"paragraphs":[
{
"fragments":[
{
"text":"The assembler converts assembly instructions into machine code:",
"type":"text"
}
],
"id":"438792dcf3084cd3846b45441a1bae85",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"assembler.rlmeta"
],
"fragments":[
{
"text":"Assembler {\n  expr   = [instr*:xs]       -> [~~xs]\n  instr  = [%:x]             -> x\n  add    =\n    | reg64:r const:i        -> [0x48 0x83 directModRm(r) ensureByte(i)]\n    | reg32:r addr:m         -> []\n  sub    =\n    | reg64:r const:i        -> []\n    | reg32:r addr:m         -> []\n  imul   =\n    | reg32:r addr:m         -> []\n  cdq    =                   -> []\n  idiv   =\n    | \"long\" addr:m          -> []\n  mov    =\n    | addr:m  reg32:r        -> []\n    | reg32:r const:i        -> []\n  addr   = [\"addr\" reg64n:n] -> n\n  reg64  = [\"reg\"  reg64n:n] -> n\n  reg64n =\n    | \"rdi\" -> 7\n  reg32  = [\"reg\"  reg32n:n] -> n\n  reg32n =\n    | \"eax\" -> 0\n  const  = [\"const\" .:i]     -> i\n}\n",
"type":"code"
}
],
"id":"e2ea2040aa4f453482e9d850f5205d2f",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"function"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def directModRm(register):\n    return 0xc0 | register\n",
"type":"code"
}
],
"id":"0b73083d0676456686ca909e554ed52b",
"type":"code"
},
{
"chunkpath":[
"function"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def ensureByte(number):\n    if number > 0xFF:\n        raise ValueError(\"{} is larger than a byte\".format(number))\n    return number\n",
"type":"code"
}
],
"id":"4e6f7298b5f14801b348a78fb83ccbac",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1\n",
"type":"code"
}
],
"id":"1e52e522c9f34e49a3027204d14e43a7",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen",
"assembler"
],
"type":"code"
},
{
"code_id":"1e52e522c9f34e49a3027204d14e43a7",
"id":"984c9169bbe74c63b57cadbe6ff58061",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"ff816c9ee43446ea85d6a2802ad24f65",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen",
"assembler"
],
"type":"code"
},
{
"code_id":"ff816c9ee43446ea85d6a2802ad24f65",
"id":"8a350bca8c1b4b7f847f5c4cd102bf92",
"type":"expanded_code"
}
],
"title":"Assembler"
},
{
"children":[],
"id":"a047c1b417bc42799170c0e3632cc3f9",
"paragraphs":[
{
"fragments":[
{
"text":"Parser:",
"type":"text"
}
],
"id":"74f3bfbd16ab4593b0c8e3948710d6e3",
"type":"text"
},
{
"code_id":"d3a45ae9dc0345bebfbf390d7247c39b",
"id":"99e5c2052a5a4854aa5973f0296f55dc",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"Abstract code generator:",
"type":"text"
}
],
"id":"bd207457588c4a1b90712ef1115efa24",
"type":"text"
},
{
"code_id":"0fa99ac78bf24f558aecc3a4760c95bd",
"id":"95a8356f49de42b890206da6147f9ba3",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"X86 code generator:",
"type":"text"
}
],
"id":"35b2daab65b942e3a70fd0be47d8e068",
"type":"text"
},
{
"code_id":"82c7f0b301fe414daed3ccf01f1a3004",
"id":"7596bd4ebee24df48dc325774efb01c9",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"GAS generator:",
"type":"text"
}
],
"id":"9497306bebb74420b1987d011a3a871a",
"type":"text"
},
{
"code_id":"a3c752a8e4fc42cfbd6cfdf5bb8c2674",
"id":"48bb8953fc9f4d7e968dad7c7427a8c5",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"C driver:",
"type":"text"
}
],
"id":"fa20aa762d6442c0ba57595a1fe03ffa",
"type":"text"
},
{
"code_id":"81af165cdf824fc390d506bb88ea3b37",
"id":"1e4275c4f2d047e3a54ebf237c541499",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"Assembler:",
"type":"text"
}
],
"id":"f9fa6b3d029c4b6fae934eefdc1c3967",
"type":"text"
},
{
"code_id":"e2ea2040aa4f453482e9d850f5205d2f",
"id":"854ae121351344c19528aac9958291ef",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"Support functions:",
"type":"text"
}
],
"id":"dde8b4381e54409c8af8673f4e0437ca",
"type":"text"
},
{
"code_id":"26892d627896439aa7b3080a02ad7ffa",
"id":"b63a8065f6914413bf606bb5823e9251",
"type":"expanded_code"
}
],
"title":"Appendix: All source code"
},
{
"children":[],
"id":"ff74bacb76bf40f082f88738ebc5d8b0",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I use a version of RLMeta that builds upon the VM based version from ",
"type":"text"
},
{
"text":"memoizing failures",
"type":"link",
"url":"/writing/rlmeta-memoize-failures/index.html"
},
{
"text":", but has the following changes:",
"type":"text"
}
],
"id":"2908143610b545ef892af4cec6305282",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It supports integers in semantic actions.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It support arbitrary many ",
"type":"text"
},
{
"text":"~",
"type":"code"
},
{
"text":" operators.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It supports repeating the ",
"type":"text"
},
{
"text":"%",
"type":"code"
},
{
"text":" operator.",
"type":"text"
}
]
}
],
"id":"81259246ed89412e90d42629b6c1017a",
"type":"list"
},
{
"fragments":[
{
"text":"I will not explain how I made those changes here. The full source code is available on ",
"type":"text"
},
{
"text":"GitHub",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/tree/master/writing/expr-to-x86-compiler/rlmeta"
},
{
"text":".",
"type":"text"
}
],
"id":"c0afc230562e44a687569508fdc6449d",
"type":"text"
}
],
"title":"Appendix: RLMeta"
},
{
"children":[],
"id":"7790eca23f484ea7b7430ef607b491c2",
"paragraphs":[
{
"fragments":[
{
"text":"I used the following script to run the examples:",
"type":"text"
}
],
"id":"0b932564205d4770842eedefaebe91e5",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"set -e\n\ncompile() {\n    echo \"import sys\"\n    echo \"import pprint\"\n    python rlmeta/rlmeta.py --support\n    cat \"support.py\"\n    python rlmeta/rlmeta.py < parser.rlmeta\n    python rlmeta/rlmeta.py < abstractcodegen.rlmeta\n    python rlmeta/rlmeta.py < x86codegen.rlmeta\n    python rlmeta/rlmeta.py < gas.rlmeta\n    python rlmeta/rlmeta.py < assembler.rlmeta\n    echo \"main()\"\n}\n\npython <(compile) \"$@\"\n",
"type":"code"
}
],
"id":"3d82622d2bab436ebb7f6d53eefb985f",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"blank_lines_before":1,
"path":[
"function"
],
"prefix":"",
"type":"chunk"
}
],
"id":"26892d627896439aa7b3080a02ad7ffa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def main():\n    grammars = {\n        \"parser\": Parser(),\n        \"acodegen\": AbstractCodeGen(),\n        \"xcodegen\": X86CodeGen(),\n        \"gas\": GasGen(),\n        \"assembler\": Assembler(),\n    }\n    try:\n        expr = sys.stdin.read().strip()\n        for grammar_name in sys.argv[1:]:\n            if grammar_name.startswith(\"@\"):\n                with open(grammar_name[1:], \"w\") as f:\n                    f.write(str(expr))\n                continue\n            grammar = grammars[grammar_name]\n            print_expr(expr)\n            print_box(grammar.__class__.__name__)\n            expr = grammar.run(\"expr\", expr)\n        print_expr(expr)\n    except _MatchError as e:\n        sys.stderr.write(e.describe())\n\ndef print_expr(expr):\n    if isinstance(expr, str):\n        print(expr.strip())\n    else:\n        pprint.pprint(expr, width=20)\n\ndef print_box(name):\n    print(\"\")\n    print(\"=V{}==\".format(\" {} \".format(name).center(28, \"=\")))\n    print(\"\")\n",
"type":"code"
}
],
"id":"f1d6ba61587e43a5878aff3bbdbf8cac",
"type":"code"
}
],
"title":"Appendix: Test script"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"In ",
"type":"text"
},
{
"text":"Parsing left associative operators using RLMeta",
"type":"link",
"url":"/writing/rlmeta-left-associativity/index.html"
},
{
"text":" we looked at how to parse a subset of mathematical expressions. In this article we will take it further and compile such expressions to x86 machine code.",
"type":"text"
}
],
"id":"799208205d6444bd8781878d0a7e55a7",
"type":"text"
}
],
"title":"Compiling expressions to x86 machine code"
},
"variables":{}
}