{
"root_page":{
"children":[
{
"children":[],
"id":"a83adf407dbd43929bfbb4ab7f7311e5",
"paragraphs":[
{
"fragments":[
{
"text":"The parser is the same as from the previous article. It turns a subset of mathematical expression into an AST:",
"type":"text"
}
],
"id":"5dba2fad4bdf4e7ebcf37a42a418db8c",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  expr  = digit:x (op:y digit:z -> [y z])*:xs -> parseOps(x xs)\n  digit = '0'-'9':x                           -> int(x)\n  op    =\n    | '+' -> Op(makeAstNode(\"ADD\") 1 \"left\")\n    | '-' -> Op(makeAstNode(\"SUB\") 1 \"left\")\n    | '*' -> Op(makeAstNode(\"MUL\") 2 \"left\")\n    | '/' -> Op(makeAstNode(\"DIV\") 2 \"left\")\n    | '^' -> Op(makeAstNode(\"POW\") 3 \"right\")\n}\n",
"type":"code"
}
],
"id":"d3a45ae9dc0345bebfbf390d7247c39b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class Op(object):\n\n    def __init__(self, fn, prec, assoc):\n        self.fn = fn\n        self.prec = prec\n        self.assoc = assoc\n",
"type":"code"
}
],
"id":"26892d627896439aa7b3080a02ad7ffa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def makeAstNode(name):\n    def op(left, right):\n        return [name, left, right]\n    return op\n",
"type":"code"
}
],
"id":"d447ef7f73c3449a86562dc994bd14aa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def parseOps(expr, items, min_level=0):\n    while items and items[0][0].prec >= min_level:\n        op, rhs = items.pop(0)\n        if op.assoc == \"left\":\n            next_level = op.prec + 1\n        else:\n            next_level = op.prec\n        expr = op.fn(expr, parseOps(rhs, items, next_level))\n    return expr\n",
"type":"code"
}
],
"id":"0e3c33cbca0f4cb296429066f8a80146",
"type":"code"
},
{
"fragments":[
{
"text":"Example:",
"type":"text"
}
],
"id":"033e3ade955d422eb2f63707200022a7",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n9^5\n",
"type":"code"
}
],
"id":"a28c516d70f34a0395bb9904c5c379d1",
"post_process":[
"bash",
"compile.sh",
"parser"
],
"type":"code"
},
{
"code_id":"a28c516d70f34a0395bb9904c5c379d1",
"id":"137ce8857b5c4a8d8c38b74917c41504",
"type":"expanded_code"
}
],
"title":"Parser"
},
{
"children":[],
"id":"0488143f851349bf876169b04770e6bf",
"paragraphs":[
{
"fragments":[
{
"text":"The abstract code generator converts an AST into instructions for an imaginary stack machine:",
"type":"text"
}
],
"id":"5b3df405b7ce42dc9e0e172d5785b4b3",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"abstractcodegen.rlmeta"
],
"fragments":[
{
"text":"AbstractCodeGen {\n  expr =\n    | [.:name expr:left expr:right] -> [~left ~right [name]]\n    | .:leaf                        -> [[\"CONST\" leaf]]\n}\n",
"type":"code"
}
],
"id":"0fa99ac78bf24f558aecc3a4760c95bd",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2*3\n",
"type":"code"
}
],
"id":"4598cfbceed64836b4c4ee934a90eed6",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen"
],
"type":"code"
},
{
"code_id":"4598cfbceed64836b4c4ee934a90eed6",
"id":"c17173be18e643c5889acd3b28796ca7",
"type":"expanded_code"
}
],
"title":"Abstract code generator"
},
{
"children":[],
"id":"bb76bbbba48d4c23b982e5c90af36d86",
"paragraphs":[
{
"fragments":[
{
"text":"The X86 code generator converts instructions for the imaginary stack machine into assembly instructions for the x86 architecture.",
"type":"text"
}
],
"id":"f24adb7c9f584f4fb8b41f6f404323dd",
"type":"text"
},
{
"fragments":[
{
"text":"An assembly instruction is represented as a list with its mnemonic and operands:",
"type":"text"
}
],
"id":"ecbfb6c880e84024905f6a113e641b50",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"[\"mnemonic\" op1 op2 ..]\n",
"type":"code"
}
],
"id":"d27ca27fb5c44278ad58a4140a41088b",
"type":"code"
},
{
"fragments":[
{
"text":"For an instruction performing a binary operation, ",
"type":"text"
},
{
"text":"op1",
"type":"code"
},
{
"text":" is the destination and ",
"type":"text"
},
{
"text":"op2",
"type":"code"
},
{
"text":" is the source. The binary operation performed is therefore the following:",
"type":"text"
}
],
"id":"0d5fb26dd6ef41428b551530fb3ad559",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"op1 = op1 `operation` op2\n",
"type":"code"
}
],
"id":"8deced1c937f4c6ebc8d224acf1ce7fe",
"type":"code"
},
{
"fragments":[
{
"text":"An operand can be either a constant, a register, or a memory location.",
"type":"text"
}
],
"id":"396333999b874e1b9f935cce78b19ddd",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"X86CodeGen {\n  expr = [instruction*:xs] -> [\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"pre"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"    ~~xs\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"post"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"  ]\n  instruction = [%:x] -> x\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"instructions"
],
"prefix":"  ",
"type":"chunk"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"82c7f0b301fe414daed3ccf01f1a3004",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"pre"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"[\"section\" \"text\"]\n[\"directive\" \"global _start\"]\n[\"label\" \"_start\"]\n",
"type":"code"
}
],
"id":"3963ee8e165b4fa3afcd1350ff9b7e82",
"language":"",
"post_process":[],
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"rsp",
"type":"code"
},
{
"text":" is the stack pointer",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"rbx",
"type":"code"
},
{
"text":" is a temporary register",
"type":"text"
}
]
}
],
"id":"b92e18b1c525415e9dc01876f3051269",
"type":"list"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"ADD = -> [\n  [\"pop\" [\"reg\" \"rax\"]               ]\n  [\"add\" [\"addr\" \"rsp\"] [\"reg\" \"rax\"]]\n]\n",
"type":"code"
}
],
"id":"3817c30ae29547c7ba43d4a09da383d7",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"SUB = -> [\n  [\"pop\" [\"reg\"  \"rax\"]               ]\n  [\"sub\" [\"addr\" \"rsp\"] [\"reg\"  \"rax\"]]\n]\n",
"type":"code"
}
],
"id":"617031f2a4cc49da98979cd4e4c323ce",
"language":"",
"post_process":[],
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"RAX = right (popped)",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"result = left - RAX",
"type":"text"
}
]
}
],
"id":"ad5c306bc1fb405cb330fee171dbe41f",
"type":"list"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"MUL = -> [\n  [\"pop\"  [\"reg\"  \"rax\"]               ]\n  [\"mov\"  [\"reg\"  \"rbx\"] [\"addr\" \"rsp\"]]\n  [\"imul\" [\"reg\"  \"rbx\"] [\"reg\"  \"rax\"]]\n  [\"mov\"  [\"addr\" \"rsp\"] [\"reg\"  \"rbx\"]]\n]\n",
"type":"code"
}
],
"id":"ba98b56127bb42d6b60fb57ad9385645",
"language":"",
"post_process":[],
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"RAX = right (popped)",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"RBX = left",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"RBX = RBX * RAX",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"result = RBX",
"type":"text"
}
]
}
],
"id":"1308a3777e8245fd8c246e0217c341eb",
"type":"list"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"DIV = -> [\n  [\"pop\"  [\"reg\" \"rbx\"]            ]\n  [\"pop\"  [\"reg\" \"rax\"]            ]\n  [\"mov\"  [\"reg\" \"edx\"] [\"const\" 0]]\n  [\"idiv\" [\"reg\" \"rbx\"]            ]\n  [\"push\" [\"reg\" \"rax\"]            ]\n]\n",
"type":"code"
}
],
"id":"45560909864b48ebaeae6a9aebbfad2b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"POW = -> [\n  [\"f2xm1\" [\"reg\" \"eax\"] [\"addr\" \"rsp\"]]\n]\n",
"type":"code"
}
],
"id":"becc0894c3de4a46b700eef621a53fb6",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"instructions"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"CONST = .:x -> [\n  [\"push\" [\"const\" x]]\n]\n",
"type":"code"
}
],
"id":"290c168cd42d4e5c943426482c99494a",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"post"
],
"filepath":[
"x86codegen.rlmeta"
],
"fragments":[
{
"text":"[\"mov\"     [\"reg\" \"rdi\"] [\"addr\"  \"rsp\"]]\n[\"mov\"     [\"reg\" \"rax\"] [\"const\" 0x3c ]]\n[\"syscall\"                              ]\n",
"type":"code"
}
],
"id":"17612e8e345e43e5b640516864fc9601",
"language":"",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"TODO: how much does push push? 32-bit? 64-bit?",
"type":"strong"
},
{
"text":" Check with ",
"type":"text"
},
{
"text":"objdump -d a.out",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"9980269e129d4709a10bb7705fba1ab0",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"8\n1+2*3\n",
"type":"code"
}
],
"id":"6cf60873293d4f8a815f29443ddd954c",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen"
],
"type":"code"
},
{
"code_id":"6cf60873293d4f8a815f29443ddd954c",
"id":"8852d3b4a5464870a71e4fabff92fb75",
"type":"expanded_code"
}
],
"title":"X86 code generator"
},
{
"children":[],
"id":"12e4e39c6b494b30a425f4570e8b8d53",
"paragraphs":[
{
"fragments":[
{
"text":"The GAS generator converts assembly instructions into a file suitable for compilation with the GNU assembler: ",
"type":"text"
},
{
"text":"gcc -nostdlib file.s",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"679dddb6aac04f20bdd82e14bab671ec",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"gas.rlmeta"
],
"fragments":[
{
"text":"GasGen {\n  expr = [instr*:xs] -> { xs }\n  instr =\n    | [\"section\" .:x]                  -> { \".\" x \"\\n\" }\n    | [\"directive\" .:x]                -> { \".\" x \"\\n\" }\n    | [\"label\" .:x]                    -> { x \":\\n\" }\n    | [mnemonic:x op:target op:source] -> { x \"  \" source \",\" target \"\\n\" }\n    | [mnemonic:x op:arg]              -> { x \"  \" arg \"\\n\" }\n    | [mnemonic:x]                     -> { x \"\\n\" }\n  op =\n    | [\"reg\"    .:name] -> { \"%\" name      }\n    | [\"addr\"   .:name] -> { \"(%\" name \")\" }\n    | [\"const\" .:value] -> { \"$\" value     }\n  mnemonic = .:x -> pad(x)\n}\n",
"type":"code"
}
],
"id":"a3c752a8e4fc42cfbd6cfdf5bb8c2674",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def pad(text):\n    return text.ljust(7)\n",
"type":"code"
}
],
"id":"42da3457d2a9450bbb21aaccdf8398aa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"8\n1+2*3\n",
"type":"code"
}
],
"id":"04e14524f1b34b6f940d0922a6bfc6f4",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen",
"gas"
],
"type":"code"
},
{
"code_id":"04e14524f1b34b6f940d0922a6bfc6f4",
"id":"7857b19690284563bbdaff9437c5c454",
"type":"expanded_code"
}
],
"title":"GAS generator"
},
{
"children":[],
"id":"d3ece5a4ba484033ac47d9190e513acd",
"paragraphs":[
{
"fragments":[
{
"text":"The assembler converts assembly instructions into machine code:",
"type":"text"
}
],
"id":"438792dcf3084cd3846b45441a1bae85",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"assembler.rlmeta"
],
"fragments":[
{
"text":"Assembler {\n  expr = [instr*:xs]     -> [~~xs]\n  instr =\n    | [\"section\" .:x]    -> []\n    | [\"directive\" .:x]  -> []\n    | [\"label\" .:x]      -> []\n    | [%:x]              -> x\n  syscall =              -> [5]\n  push = const:x         -> [0x6a ensureByte(x)]\n  pop  = reg:r           -> [add(0x58 r)]\n  imul = reg:r1 reg:r2   -> [0x48 0x0f 0xaf r1 r2]\n  add  = addr:m reg:r    -> [r m]\n  mov  =\n    | reg:r  addr:m      -> [50 m r]\n    | addr:m reg:r       -> [50 r m]\n    | reg:r  const:i     -> [50 i]\n  const = [\"const\" .:i]  -> i\n  addr  = [\"addr\" .:m]   -> m\n  reg   = [\"reg\" regn:r] -> r\n  regn =\n    | \"rax\" -> 0\n    | \"rbx\" -> 3\n    | \"rdi\" -> 5\n}\n",
"type":"code"
}
],
"id":"e2ea2040aa4f453482e9d850f5205d2f",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def ensureByte(number):\n    if number > 0xFF:\n        raise ValueError(\"{} is larger than a byte\".format(number))\n    return number\n",
"type":"code"
}
],
"id":"4e6f7298b5f14801b348a78fb83ccbac",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def add(x, y):\n    return x + y\n",
"type":"code"
}
],
"id":"a30abe807d3f445c9d0d442000144030",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1\n1+2*3\n",
"type":"code"
}
],
"id":"1e52e522c9f34e49a3027204d14e43a7",
"post_process":[
"bash",
"compile.sh",
"parser",
"acodegen",
"xcodegen",
"assembler"
],
"type":"code"
},
{
"code_id":"1e52e522c9f34e49a3027204d14e43a7",
"id":"984c9169bbe74c63b57cadbe6ff58061",
"type":"expanded_code"
}
],
"title":"Assembler"
},
{
"children":[],
"id":"ff74bacb76bf40f082f88738ebc5d8b0",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I use a version of RLMeta that builds upon the VM based version from ",
"type":"text"
},
{
"text":"memoizing failures",
"type":"link",
"url":"/writing/rlmeta-memoize-failures/index.html"
},
{
"text":", but has the following changes:",
"type":"text"
}
],
"id":"2908143610b545ef892af4cec6305282",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It supports integers in semantic actions.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It support arbitrary many ",
"type":"text"
},
{
"text":"~",
"type":"code"
},
{
"text":" operators.",
"type":"text"
}
]
}
],
"id":"81259246ed89412e90d42629b6c1017a",
"type":"list"
},
{
"fragments":[
{
"text":"I will not explain how I made those changes here. The full source code is available on ",
"type":"text"
},
{
"text":"GitHub",
"type":"link",
"url":"https://github.com/rickardlindberg/rickardlindberg.me/tree/master/writing/expr-to-x86-compiler/rlmeta"
},
{
"text":".",
"type":"text"
}
],
"id":"c0afc230562e44a687569508fdc6449d",
"type":"text"
}
],
"title":"Appendix: RLMeta"
},
{
"children":[],
"id":"7790eca23f484ea7b7430ef607b491c2",
"paragraphs":[
{
"fragments":[
{
"text":"I used the following script to run the examples:",
"type":"text"
}
],
"id":"0b932564205d4770842eedefaebe91e5",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"set -e\n\ncompile() {\n    echo \"import sys\"\n    echo \"import pprint\"\n    python rlmeta/rlmeta.py --support\n    cat \"support.py\"\n    python rlmeta/rlmeta.py < parser.rlmeta\n    python rlmeta/rlmeta.py < abstractcodegen.rlmeta\n    python rlmeta/rlmeta.py < x86codegen.rlmeta\n    python rlmeta/rlmeta.py < gas.rlmeta\n    python rlmeta/rlmeta.py < assembler.rlmeta\n    echo \"main()\"\n}\n\npython <(compile) \"$@\"\n",
"type":"code"
}
],
"id":"3d82622d2bab436ebb7f6d53eefb985f",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def main():\n    grammars = {\n        \"parser\": Parser(),\n        \"acodegen\": AbstractCodeGen(),\n        \"xcodegen\": X86CodeGen(),\n        \"gas\": GasGen(),\n        \"assembler\": Assembler(),\n    }\n    try:\n        for index, expr in enumerate(sys.stdin.read().splitlines()):\n            if index > 0:\n                print(\"\")\n                print(\"-\"*32)\n                print(\"\")\n            for grammar_name in sys.argv[1:]:\n                if grammar_name.startswith(\"@\"):\n                    with open(grammar_name[1:], \"w\") as f:\n                        f.write(str(expr))\n                    continue\n                grammar = grammars[grammar_name]\n                print_expr(expr)\n                print_box(grammar.__class__.__name__)\n                expr = grammar.run(\"expr\", expr)\n            print_expr(expr)\n    except _MatchError as e:\n        sys.stderr.write(e.describe())\n\ndef print_expr(expr):\n    if isinstance(expr, str):\n        print(expr.strip())\n    else:\n        pprint.pprint(expr, width=20)\n\ndef print_box(name):\n    print(\"\")\n    print(\"=V{}==\".format(\" {} \".format(name).center(28, \"=\")))\n    print(\"\")\n",
"type":"code"
}
],
"id":"f1d6ba61587e43a5878aff3bbdbf8cac",
"type":"code"
}
],
"title":"Appendix: Test script"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"In ",
"type":"text"
},
{
"text":"Parsing left associative operators using RLMeta",
"type":"link",
"url":"/writing/rlmeta-left-associativity/index.html"
},
{
"text":" we looked at how to parse a subset of mathematical expressions. In this article we will take it further and compile such expressions to x86 machine code.",
"type":"text"
}
],
"id":"799208205d6444bd8781878d0a7e55a7",
"type":"text"
}
],
"title":"Compiling expressions to x86 machine code"
},
"variables":{}
}