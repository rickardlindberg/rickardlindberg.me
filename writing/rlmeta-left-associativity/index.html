<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      Parsing left associative operators using RLMeta | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>Parsing left associative operators using RLMeta</h1>

<p><em>Published on  7 September 2019.</em></p>

<p>The <a href="../../writing/rlmeta/">first article</a> about RLMeta has this example grammar implementing a simple calculator:</p>
<pre class="text"><code>Calculator {
  expression =
    | additive
  additive =
    | multitive:x '+' additive:y -&gt; add(x y)
    | multitive
  multitive =
    | digit:x '*' multitive:y    -&gt; mul(x y)
    | digit
  digit =
    | '0'-'9':x                  -&gt; int(x)
}</code></pre>
<p>It works, but if we were to add a second case to support subtraction, it would break because subtraction is a left associate operator but the calculator creates a right associative parse. In this article I show how it would brake and how it can be solved.</p>
<ul>
<li><a href="#37144d09790c48a3bbdc3485473b5416">What is operator associativity?</a></li>
<li><a href="#cb24f5d3a7df423e9081889d4a2d3785">Right associative calculator</a></li>
<li><a href="#8366ac579e1e4be9930317242abd5dd6">Left associative calculator</a></li>
<li><a href="#855b50c552e54c0895128e7e86da55e9">Correct left associative calculator</a></li>
<li><a href="#736626ed0c3c4fea922cc4f14c5cda38">Right associative calculator without recursion</a></li>
<li><a href="#ae39c406658e4cd287411ab2c76710f8">Calculator combining operators</a></li>
<li><a href="#063f23a343574259bf31debb9b8425bf">Cleaner handling of precedence</a></li>
<li><a href="#24d9bf94e3b64dfba2841df8b3cf00b1">Comparison of operator parsers</a></li>
<li><a href="#5cca99df2e2c4c78ab4bfe4cb946d89a">Resources</a></li>
<li><a href="#c1716e6e63034983a86a1c9f621b2a52">Appendix: Test script</a></li>
</ul>
<h2 id="d09790c48a3bbdc3485473b5416what-is-operator-associativity">[]{#37144d09790c48a3bbdc3485473b5416}What is operator associativity?</h2>
<p>Operator associativity has to do with the order that operators are evaluated. The following expression can be evaluated in two ways:</p>
<pre class="text"><code>1-2-3</code></pre>
<p>Either as this (if the operator is left associative):</p>
<pre class="text"><code>(1-2)-3</code></pre>
<p>Or as this (if the operator is right associative):</p>
<pre class="text"><code>1-(2-3)</code></pre>
<p>Let's see how the calculator evaluates expressions.</p>
<h2 id="right-associative-calculator"><span id="cb24f5d3a7df423e9081889d4a2d3785"></span>Right associative calculator</h2>
<p>The following grammar works like the calculator but only supports subtraction:</p>
<pre><code>1.  right.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x '-' expr:y -&gt; sub(x y)
        | digit
  digit = '0'-'9':x          -&gt; int(x)
}</code></pre>
<p>The <code>sub</code> function is implemented in two ways. The first creates an AST node representing a subtraction:</p>
<pre><code>1.  ast.py</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">def</span> sub(left, right):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;-&quot;</span>, left, right]</span></code></pre></div>
<p>The second evaluates the subtraction expression:</p>
<pre><code>1.  eval.py</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">def</span> sub(left, right):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">-</span> right</span></code></pre></div>
<p>Let's see how the calculator handles the following two expressions:</p>
<pre class="text"><code>1-2
1-2-3</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>['-', 1, 2]
=&gt;
-1

['-',
 1,
 ['-', 2, 3]]
=&gt;
2</code></pre>
<p>For an expression with only two numbers, the calculator works as expected. But with more numbers, the parse is incorrect. The calculator parses <code>1-2-3</code> as <code>1-(2-3)</code> which is incorrect because subtraction is left associative and should thus be parsed as <code>(1-2)-3</code>.</p>
<p>The original calculator does not have this problem because it only supports operators that evaluate the same no matter if parsed as left associative or right associative.</p>
<p>If we strip the semantic actions from the <code>expr</code> rule it is easier to see what creates this right associative parse:</p>
<pre class="text"><code>expr = digit '-' expr | digit</code></pre>
<p>The topmost expression will be parsed as a digit followed by an arbitrary complex expression: <code>(digit - (...))</code>.</p>
<p>Let's see if we can get a left associative parse instead.</p>
<h2 id="ac579e1e4be9930317242abd5dd6left-associative-calculator">[]{#8366ac579e1e4be9930317242abd5dd6}Left associative calculator</h2>
<p>In order to get a left associate parse (that we need for subtraction) we would like to write the <code>expr</code> rule like this instead:</p>
<pre class="text"><code>expr = expr '-' digit | digit</code></pre>
<p>The whole grammar would then look like this:</p>
<pre><code>1.  left.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = expr:x '-' digit:y -&gt; sub(x y)
        | digit
  digit = '0'-'9':x          -&gt; int(x)
}</code></pre>
<p>Unfortunately, this will not work with the parsing algorithm that RLMeta uses. In order to parse an <code>expr</code> it first has to parse an <code>expr</code> and so on, and it will get stuck in an infinite loop. The parsing algorithm is based on recursive descent parsing and the first choice in the <code>expr</code> rule will thus be translated into something like this:</p>
<pre class="text"><code>def expr():
    x = expr()
    atom(&quot;-&quot;)
    y = digit()
    return sub(x, y)</code></pre>
<p>We need to handle left associative operators differently.</p>
<h2 id="b50c552e54c0895128e7e86da55e9correct-left-associative-calculator">[]{#855b50c552e54c0895128e7e86da55e9}Correct left associative calculator</h2>
<p>The right associative parse that we saw earlier can be rewritten using a repetition:</p>
<pre class="text"><code>expr = digit '-' expr | digit</code></pre>
<p>It then becomes this:</p>
<pre class="text"><code>expr = digit ('-' digit)*</code></pre>
<p>It parses the same expressions, but it does not create a right associative parse. What does it create? Something that consist of a digit and a list of something. We can turn this into a parse tree using a function that we call <code>leftAssoc</code>. Here is the complete grammar:</p>
<pre><code>1.  left\_correct.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; leftAssoc(x xs)
  digit = '0'-'9':x                           -&gt; int(x)
  op    = '-'                                 -&gt; makeSub()
}</code></pre>
<p>In the semantic action for <code>expr</code>, <code>x</code> is bound to a digit, and <code>xs</code> is bound to a list of pairs consisting of an operator and a digit: <code>[[op, digit], [op, digit], ...]</code>. The operator is a function that takes two arguments: the left hand side and the right hand side. (<code>makeSub</code> returns the <code>sub</code> function. It is used because currently global variables can not be referenced from semantic actions. Only global functions.) The function <code>leftAssoc</code> turns this into a left associative tree:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">def</span> leftAssoc(expr, items):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="cf">while</span> items:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>        expr <span class="op">=</span> op(expr, rhs)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>Here is how the expression <code>1-2-3</code> is parsed:</p>
<ul>
<li><code>leftAssoc</code> is called with <code>expr=1</code> and <code>items=[[sub, 2], [sub, 3]]</code>.</li>
<li>Since there are still items, the loop is entered
<ul>
<li><code>op=sub</code> and <code>rhs=2</code></li>
<li><code>expr=sub(1, 2)</code></li>
</ul></li>
<li>Since there are still items, the loop is entered
<ul>
<li><code>op=sub</code> and <code>rhs=3</code></li>
<li><code>expr=sub(sub(1, 2), 3)</code></li>
</ul></li>
<li>Since there are no more items, <code>sub(sub(1, 2), 3)</code> is returned</li>
</ul>
<p>Let's verify that the calculator handles the following expressions as intended:</p>
<pre class="text"><code>1-2
1-2-3</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>['-', 1, 2]
=&gt;
-1

['-',
 ['-', 1, 2],
 3]
=&gt;
-4</code></pre>
<p>And indeed it does. We have now successfully parsed a left associate operator using RLMeta.</p>
<h2 id="ed0c3c4fea922cc4f14c5cda38right-associative-calculator-without-recursion">[]{#736626ed0c3c4fea922cc4f14c5cda38}Right associative calculator without recursion</h2>
<p>We can handle a right associative parse in RLMeta with a recursive rule as we have seen before:</p>
<pre class="text"><code>expr = digit '-' expr | digit</code></pre>
<p>However, we can also obtain a right associative parse by parsing operators as a list and then converting them into an AST with a <code>rightAssoc</code> function. Here is a grammar that supports only exponentiation which is right associative:</p>
<pre><code>1.  right\_no\_recursion.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; rightAssoc(x xs)
  digit = '0'-'9':x                           -&gt; int(x)
  op    = '^'                                 -&gt; makePow()
}</code></pre>
<p>It has the exact same structure as the previous calculator, only now a different function is called to create the parse tree. The <code>rightAssoc</code> function is also similar in structure to the <code>leftAssoc</code> function, but the loop is replaced with an if statement followed by a recursive call:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">def</span> rightAssoc(expr, items):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>    <span class="cf">if</span> items:</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>        expr <span class="op">=</span> op(expr, rightAssoc(rhs, items))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>Here is how the expression <code>3^2^2</code> is parsed:</p>
<ul>
<li><code>rightAssoc</code> is called with <code>expr=3</code> and <code>items=[[pow, 2], [pow, 2]]</code></li>
<li>Since there are still items, the if statement is entered
<ul>
<li><code>op=pow</code> and <code>rhs=2</code></li>
<li><code>expr=pow(3, rightAssoc(2, [[pow, 2]])</code></li>
</ul></li>
<li><code>rightAssoc</code> is called with <code>expr=2</code> and <code>items=[[pow, 2]]</code></li>
<li>Since there are still items, the if statement is entered
<ul>
<li><code>op=pow</code> and <code>rhs=2</code></li>
<li><code>expr=pow(2, rightAssoc(2, [])</code></li>
</ul></li>
<li><code>rightAssoc</code> is called with <code>expr=2</code> and <code>items=[]</code></li>
<li>Since there are no more items, <code>2</code> is returned</li>
<li>The parent call returns <code>pow(2, 2)</code></li>
<li>The parent call returns <code>pow(3, pow(2, 2))</code></li>
</ul>
<p>The two <code>pow</code> functions are defined like this:</p>
<pre><code>1.  ast.py</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">def</span> <span class="bu">pow</span>(left, right):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;^&quot;</span>, left, right]</span></code></pre></div>
<pre><code>1.  eval.py</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">def</span> <span class="bu">pow</span>(left, right):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">**</span> right</span></code></pre></div>
<p>Let's verify that the calculator handles the following expressions as intended:</p>
<pre class="text"><code>3^2
3^2^2</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>['^', 3, 2]
=&gt;
9

['^',
 3,
 ['^', 2, 2]]
=&gt;
81</code></pre>
<p>And indeed it does.</p>
<h2 id="calculator-combining-operators"><span id="ae39c406658e4cd287411ab2c76710f8"></span>Calculator combining operators</h2>
<p>Now that we know how to handle both left and right associative operators, we can extend the calculator to handle more operators:</p>
<pre><code>1.  calculator.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = expr1
  expr1 = expr2:x (op1:y expr2:z -&gt; [y z])*:xs -&gt; leftAssoc(x xs)
  expr2 = expr3:x (op2:y expr3:z -&gt; [y z])*:xs -&gt; leftAssoc(x xs)
  expr3 = digit:x (op3:y digit:z -&gt; [y z])*:xs -&gt; rightAssoc(x xs)
  digit = '0'-'9':x                            -&gt; int(x)
  op1 =
    | '+' -&gt; makeAdd()
    | '-' -&gt; makeSub()
  op2 =
    | '*' -&gt; makeMul()
    | '/' -&gt; makeDiv()
  op3 =
    | '^' -&gt; makePow()
}</code></pre>
<p>Different levels of expressions are used to handle operators having different precedence (multiplication is done before subtraction for example).</p>
<p>The additional arithmetic functions are defined like this:</p>
<pre><code>1.  ast.py</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="kw">def</span> add(left, right):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;+&quot;</span>, left, right]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a><span class="kw">def</span> mul(left, right):</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;*&quot;</span>, left, right]</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a><span class="kw">def</span> div(left, right):</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>    <span class="cf">return</span> [<span class="st">&quot;/&quot;</span>, left, right]</span></code></pre></div>
<pre><code>1.  eval.py</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="kw">def</span> add(left, right):</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">+</span> right</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a><span class="kw">def</span> mul(left, right):</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">*</span> right</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a><span class="kw">def</span> div(left, right):</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>    <span class="cf">return</span> left <span class="op">/</span> right</span></code></pre></div>
<p>Let's see how the calculator handles the following expression:</p>
<pre class="text"><code>1+2-3^2^2-5</code></pre>
<p>Below is the AST and the evaluated result:</p>
<pre class="text"><code>['-',
 ['-',
  ['+', 1, 2],
  ['^',
   3,
   ['^', 2, 2]]],
 5]
=&gt;
-83</code></pre>
<p>If we enter the same expression in the Python prompt, but replace <code>^</code> with <code>**</code> as Python uses, we get the same result:</p>
<pre class="text"><code>&gt;&gt;&gt; 1+2-3**2**2-5
-83</code></pre>
<p>We can now parse complicated expressions correctly. However, if there are many precedence levels in a grammar, it might become difficult to read. Can we do better?</p>
<h2 id="f23a343574259bf31debb9b8425bfcleaner-handling-of-precedence">[]{#063f23a343574259bf31debb9b8425bf}Cleaner handling of precedence</h2>
<p>Here is the calculator grammar from the previous section rewritten in a cleaner way:</p>
<pre><code>1.  calculator\_ops.rlmeta</code></pre>
<pre class="rlmeta"><code>Calculator {
  expr  = digit:x (op:y digit:z -&gt; [y z])*:xs -&gt; parseOps(x xs)
  digit = '0'-'9':x                           -&gt; int(x)
  op    =
    | '+' -&gt; Op(makeAdd() &quot;1&quot; &quot;left&quot;)
    | '-' -&gt; Op(makeSub() &quot;1&quot; &quot;left&quot;)
    | '*' -&gt; Op(makeMul() &quot;2&quot; &quot;left&quot;)
    | '/' -&gt; Op(makeDiv() &quot;2&quot; &quot;left&quot;)
    | '^' -&gt; Op(makePow() &quot;3&quot; &quot;right&quot;)
}</code></pre>
<p>In this version all operators are parsed as a list and then handed over to the <code>parseOps</code> function. The operators also return an <code>Op</code> object instead of just a function to evaluate the operator. The <code>Op</code> object has information about the operator's precedence (given as a string only because RLMeta can not express integers in semantic actions) and associativity:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="kw">class</span> Op(<span class="bu">object</span>):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn, prec, assoc):</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>        <span class="va">self</span>.prec <span class="op">=</span> <span class="bu">int</span>(prec)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a>        <span class="va">self</span>.assoc <span class="op">=</span> assoc</span></code></pre></div>
<p>The <code>parseOps</code> function uses that information to create a parse tree:</p>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="kw">def</span> parseOps(expr, items, min_level<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>    <span class="cf">while</span> items <span class="kw">and</span> items[<span class="dv">0</span>][<span class="dv">0</span>].prec <span class="op">&gt;=</span> min_level:</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>        op, rhs <span class="op">=</span> items.pop(<span class="dv">0</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>        <span class="cf">if</span> op.assoc <span class="op">==</span> <span class="st">&quot;left&quot;</span>:</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>            next_level <span class="op">=</span> op.prec <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>            next_level <span class="op">=</span> op.prec</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>        expr <span class="op">=</span> op.fn(expr, parseOps(rhs, items, next_level))</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a>    <span class="cf">return</span> expr</span></code></pre></div>
<p>It combines the functionality of <code>leftAssoc</code> and <code>rightAssoc</code> and additionally also handles precedence. The increment of level if the operator is left associative ensures that only operators of higher precedence are parsed in the recursive call. If the next operator is of the same precedence, the recursive call will return immediately, and <code>parseOps</code> will behave like <code>leftAssoc</code>.</p>
<p>Here is how the expression 1+2+3*4 is parsed:</p>
<ul>
<li><code>parseOps</code> is called with <code>expr=1</code>, <code>items=[[OpAdd, 2], [OpAdd, 3], [OpMul, 4]]</code> and <code>min_level=0</code></li>
<li>Since there are still items and the add operator has <code>prec &gt;= 0</code>, the loop is entered
<ul>
<li><code>op=OpAdd</code> and <code>rhs=2</code></li>
<li>Since the add operator is left associative, <code>next_level=2</code></li>
<li><code>expr=add(1, parseOps(2, [[OpAdd, 3], [OpMul, 4]], 2))</code></li>
</ul></li>
<li><code>parseOps</code> is called with <code>expr=2</code>, <code>items=[[OpAdd, 3], [OpMul, 4]]</code> and <code>min_level=2</code></li>
<li>Since the add operator has <code>prec &lt; 2</code>, the loop is not entered, and <code>2</code> is returned</li>
<li>The outer loop continues with <code>expr=add(1, 2)</code>
<ul>
<li><code>op=OpAdd</code> and <code>rhs=3</code></li>
<li>Since the add operator is left associative, <code>next_level=2</code></li>
<li><code>expr=add(add(1, 2), parseOps(3, [[OpMul, 4]], 2))</code></li>
</ul></li>
<li><code>parseOps</code> is called with <code>expr=3</code>, <code>items=[[OpMul, 4]]</code> and <code>min_level=2</code></li>
<li>Since there are still items and the mul operator has <code>prec &gt;= 2</code>, the loop is entered
<ul>
<li><code>op=OpMul</code> and <code>rhs=4</code></li>
<li>Since the mul operator is left associative, <code>next_level=3</code></li>
<li><code>expr=mul(3, parseOps(4, [], 3))</code></li>
</ul></li>
<li><code>parseOps</code> is called with <code>expr=4</code>, <code>items=[]</code> and <code>min_level=3</code></li>
<li>Since there are no more items, <code>4</code> is returned</li>
<li>The parent returns <code>mul(3, 4)</code></li>
<li>The parent returns <code>add(add(1, 2), mul(3, 4))</code></li>
</ul>
<p>Let's see how the calculator handles the following expressions:</p>
<pre class="text"><code>1+2-3
1+2-3^2^2-5</code></pre>
<p>Below are the ASTs and the evaluated results:</p>
<pre class="text"><code>['-',
 ['+', 1, 2],
 3]
=&gt;
0

['-',
 ['-',
  ['+', 1, 2],
  ['^',
   3,
   ['^', 2, 2]]],
 5]
=&gt;
-83</code></pre>
<p>This looks correct. We now have a calculator whose grammar is more cleanly written and only uses one support function instead of two.</p>
<h2 id="d9bf94e3b64dfba2841df8b3cf00b1comparison-of-operator-parsers">[]{#24d9bf94e3b64dfba2841df8b3cf00b1}Comparison of operator parsers</h2>
<p>All three operator parser functions have a similar structure to them. Here they are for comparison:</p>
<pre class="text"><code>def leftAssoc(expr, items):
    while items:
        op, rhs = items.pop(0)
        expr = op(expr, rhs)
    return expr</code></pre>
<pre class="text"><code>def rightAssoc(expr, items):
    if items:
        op, rhs = items.pop(0)
        expr = op(expr, rightAssoc(rhs, items))
    return expr</code></pre>
<pre class="text"><code>def parseOps(expr, items, min_level=0):
    while items and items[0][0].prec &gt;= min_level:
        op, rhs = items.pop(0)
        if op.assoc == &quot;left&quot;:
            next_level = op.prec + 1
        else:
            next_level = op.prec
        expr = op.fn(expr, parseOps(rhs, items, next_level))
    return expr</code></pre>
<h2 id="cca99df2e2c4c78ab4bfe4cb946d89aresources">[]{#5cca99df2e2c4c78ab4bfe4cb946d89a}Resources</h2>
<p>The following articles helped me understand how to handle left associative operators in recursive descent parsers:</p>
<ul>
<li><a href="http://beastie.cs.ua.edu/proglan/readings/precedence.pdf">Implementing Associativity and Precedence in Recursive Descent Expression Grammars</a></li>
<li><a href="https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers">Recursive descent, LL and predictive parsers</a></li>
<li><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">Some problems of recursive descent parsers</a></li>
<li><a href="https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator">A recursive descent parser with an infix expression evaluator</a></li>
<li><a href="https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing">Top-Down operator precedence parsing</a></li>
<li><a href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing">Parsing expressions by precedence climbing</a></li>
<li><a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">Pratt Parsers: Expression Parsing Made Easy</a></li>
</ul>
<h2 id="appendix-test-script"><span id="c1716e6e63034983a86a1c9f621b2a52"></span>Appendix: Test script</h2>
<p>I used the following Bash script to run the examples:</p>
<pre><code>1.  expr.sh</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="fu">compile()</span> <span class="kw">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;import sys&quot;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;import pprint&quot;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a>    <span class="ex">rlmeta</span> --support</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true"></a>    <span class="ex">rlmeta</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true"></a>    <span class="fu">cat</span> <span class="st">&quot;support.py&quot;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true"></a>    <span class="fu">cat</span> <span class="st">&quot;</span><span class="va">$2</span><span class="st">&quot;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeAdd = lambda: add&quot;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeSub = lambda: sub&quot;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeMul = lambda: mul&quot;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makeDiv = lambda: div&quot;</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;makePow = lambda: pow&quot;</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;try:&quot;</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;    for expr in sys.stdin.read().splitlines():&quot;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;        pprint.pprint(Calculator().run('expr', expr), width=20)&quot;</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;except _MatchError as e:&quot;</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;    sys.stderr.write(e.describe())&quot;</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true"></a></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true"></a><span class="kw">(</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true"></a>    <span class="kw">while</span> <span class="bu">read</span> -e <span class="va">expr</span>; <span class="kw">do</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$expr</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">python</span> <span class="op">&lt;(</span><span class="ex">compile</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="st">&quot;ast.py&quot;</span><span class="op">)</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;=&gt;&quot;</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$expr</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">python</span> <span class="op">&lt;(</span><span class="ex">compile</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="st">&quot;eval.py&quot;</span><span class="op">)</span></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true"></a>        <span class="bu">echo</span> <span class="st">&quot;&quot;</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true"></a>    <span class="kw">done</span></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true"></a><span class="kw">)</span> <span class="kw">|</span> <span class="fu">head</span> -n-1</span></code></pre></div>
<p>It reads expressions from stdin one per line. Then it evaluates them both using the AST function and the eval function and prints the result. The <code>make*</code> functions are also defined here to just return the respective function.</p>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
