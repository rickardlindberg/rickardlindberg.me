{
"root_page":{
"children":[
{
"children":[],
"id":"37144d09790c48a3bbdc3485473b5416",
"paragraphs":[
{
"fragments":[
{
"text":"Operator associativity has to do with the order that operators are evaluated. The following expression can be evaluated in two ways:",
"type":"text"
}
],
"id":"8eee2549451748e58f07508d0a76edf4",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-2-3\n",
"type":"code"
}
],
"id":"94a84480e8a042bbafa75fd81dfaef24",
"type":"code"
},
{
"fragments":[
{
"text":"Either as this (if the operator is left associative):",
"type":"text"
}
],
"id":"379a302b9dcb468fa1f2a4439dc26322",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"(1-2)-3\n",
"type":"code"
}
],
"id":"140187e907dd4701b557e76ff7734d1c",
"type":"code"
},
{
"fragments":[
{
"text":"Or as this (if the operator is right associative):",
"type":"text"
}
],
"id":"8977c2bdeaf640939f92bf625950bbe5",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-(2-3)\n",
"type":"code"
}
],
"id":"e00ab17f67534191845fa4fdee5e5329",
"type":"code"
},
{
"fragments":[
{
"text":"Let's see how the calculator evaluates expressions.",
"type":"text"
}
],
"id":"e5caa4ff5a2843a2b76e37be299d38e9",
"type":"text"
}
],
"title":"What is operator associativity?"
},
{
"children":[],
"id":"cb24f5d3a7df423e9081889d4a2d3785",
"paragraphs":[
{
"fragments":[
{
"text":"The following grammar works like the calculator but only supports the subtraction operator:",
"type":"text"
}
],
"id":"4d04045b326d456faa9479d9b910971d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"right.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = digit:x '-' expr:y -> sub(x y)\n        | digit\n  digit = '0'-'9':x          -> int(x)\n}\n",
"type":"code"
}
],
"id":"2ecbdee5c0eb4fda8f88786740704212",
"language":"",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"The following support functions either create an AST node or evaluates the expression:",
"type":"text"
}
],
"id":"af5a8c4ce42944f0a71a625b04edb239",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"ast.py"
],
"fragments":[
{
"text":"def sub(left, right):\n    return [\"-\", left, right]\n",
"type":"code"
}
],
"id":"f22a7858bbcd4a56b985e56f5c251681",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"eval.py"
],
"fragments":[
{
"text":"def sub(left, right):\n    return left - right\n",
"type":"code"
}
],
"id":"b64973599f1c4994933814a893bd3013",
"type":"code"
},
{
"fragments":[
{
"text":"For an expression with only two numbers, the grammar works as expected. But with more numbers, the expression created is incorrect.",
"type":"text"
}
],
"id":"bc7fa6229c454ce192058b92cb8b7fe2",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-2\n1-2-3\n",
"type":"code"
}
],
"id":"efe1706fb496425a8f2059574de91b19",
"post_process":[
"bash",
"expr.sh",
"right.rlmeta"
],
"type":"code"
},
{
"code_id":"efe1706fb496425a8f2059574de91b19",
"id":"d9394f9309714b6cb7388081f7bf781f",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"The calculator evaluates ",
"type":"text"
},
{
"text":"1-2-3",
"type":"code"
},
{
"text":" as ",
"type":"text"
},
{
"text":"1-(2-3)",
"type":"code"
},
{
"text":" which is incorrect because subtraction is left associative. So is addition, but evaluating addition according to a right associative parse gives the same result.",
"type":"text"
}
],
"id":"2e9a96724875435883f62761cf99bf95",
"type":"text"
},
{
"fragments":[
{
"text":"If we strip the semantic actions from the ",
"type":"text"
},
{
"text":"expr",
"type":"code"
},
{
"text":" rule it is easier to see what creates this right associative parse:",
"type":"text"
}
],
"id":"33c100918b6a4ecaa0786f3cfebc81b5",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"expr = digit '-' expr | digit\n",
"type":"code"
}
],
"id":"ccf6f0a1de824f28b6162545d8529afb",
"language":"rlmeta",
"post_process":[],
"type":"code"
}
],
"title":"Right"
},
{
"children":[],
"id":"8366ac579e1e4be9930317242abd5dd6",
"paragraphs":[
{
"fragments":[
{
"text":"In order to get a left associate parse (that we need for subtraction) we would like to write the ",
"type":"text"
},
{
"text":"expr",
"type":"code"
},
{
"text":" rule like this instead:",
"type":"text"
}
],
"id":"d911815aac204deeba36404731b7dbaa",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"expr = expr '-' digit | digit\n",
"type":"code"
}
],
"id":"a42d56d2a2b14736958d17bc34b0db7b",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"The whole grammar would then look like this:",
"type":"text"
}
],
"id":"33f28c5d7edb42e5a3e72a438592a13f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"left.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = expr:x '-' digit:y -> sub(x y)\n        | digit\n  digit = '0'-'9':x          -> int(x)\n}\n",
"type":"code"
}
],
"id":"4fa440d4d3794c929a28b3111f660d1a",
"language":"",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"But this will not work with the parsing algorithm that RLMeta uses. In order to parse an ",
"type":"text"
},
{
"text":"expr",
"type":"code"
},
{
"text":" it first has to parse an ",
"type":"text"
},
{
"text":"expr",
"type":"code"
},
{
"text":" and so on, and it will get stuck in an infinite loop.",
"type":"text"
}
],
"id":"afc81f5c7fd247298bff843abfee9686",
"type":"text"
}
],
"title":"Left"
},
{
"children":[],
"id":"855b50c552e54c0895128e7e86da55e9",
"paragraphs":[
{
"fragments":[
{
"text":"The right associative parse:",
"type":"text"
}
],
"id":"276097899a314702802e324f288c1769",
"type":"text"
},
{
"code_id":"ccf6f0a1de824f28b6162545d8529afb",
"id":"deba845b4d9b4eb3b447bbb9ef5ad93f",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"Can be expressed with a repetition instead:",
"type":"text"
}
],
"id":"4aaa9656b1874f98bd1f61d239934e12",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"expr = digit ('-' digit)*\n",
"type":"code"
}
],
"id":"176c8d5f26e541dbbd0422ae23279b93",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"This parses the same expressions. How to construct a left associate parse from this? The whole grammar looks like this:",
"type":"text"
}
],
"id":"6fb5de8b93f047889f65a0a61e630e9e",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"left_correct.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = digit:x (op:y digit:z -> [y z])*:xs -> leftAssoc(x xs)\n  digit = '0'-'9':x                           -> int(x)\n  op    = '-'                                 -> makeSub()\n}\n",
"type":"code"
}
],
"id":"448843370672495aa2b3c46276f71320",
"language":"",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"In the semantic action for ",
"type":"text"
},
{
"text":"expr",
"type":"code"
},
{
"text":", ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" is bound to a digit, and ",
"type":"text"
},
{
"text":"xs",
"type":"code"
},
{
"text":" is bound to a list of pairs consisting of an operator and a digit: ",
"type":"text"
},
{
"text":"[[op, digit], [op, digit], ...]",
"type":"code"
},
{
"text":". The function ",
"type":"text"
},
{
"text":"leftAssoc",
"type":"code"
},
{
"text":" turns this into a left associate tree:",
"type":"text"
}
],
"id":"6c68618de578466e85c21018dc35db42",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def leftAssoc(expr, items):\n    while items:\n        op, rhs = items.pop(0)\n        expr = op(expr, rhs)\n    return expr\n",
"type":"code"
}
],
"id":"bdffa34a868143e89b3dcdf0c77eb183",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-2\n1-2-3\n",
"type":"code"
}
],
"id":"ed936d888481437ca2da5776dfb50232",
"post_process":[
"bash",
"expr.sh",
"left_correct.rlmeta"
],
"type":"code"
},
{
"code_id":"ed936d888481437ca2da5776dfb50232",
"id":"46366298a2784876957c79f4108715bb",
"type":"expanded_code"
}
],
"title":"Left correct"
},
{
"children":[],
"id":"736626ed0c3c4fea922cc4f14c5cda38",
"paragraphs":[
{
"fragments":[
{
"text":"todo: example",
"type":"strong"
}
],
"id":"f9469f2cb5364f10842329b0e9b18a45",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def rightAssoc(expr, items):\n    if items:\n        op, rhs = items.pop(0)\n        expr = op(expr, rightAssoc(rhs, items))\n    return expr\n",
"type":"code"
}
],
"id":"17f2b0dec1ac4958bd79aa568963bdad",
"type":"code"
},
{
"code_id":"bdffa34a868143e89b3dcdf0c77eb183",
"id":"b9d1e57041864b0fb648fbaf8d165fd3",
"type":"expanded_code"
}
],
"title":"Right without recursion in grammar"
},
{
"children":[],
"id":"ae39c406658e4cd287411ab2c76710f8",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"calculator.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = expr1\n  expr1 = expr2:x (op1:y expr2:z -> [y z])*:xs -> leftAssoc(x xs)\n  expr2 = expr3:x (op2:y expr3:z -> [y z])*:xs -> leftAssoc(x xs)\n  expr3 = digit:x (op3:y digit:z -> [y z])*:xs -> rightAssoc(x xs)\n  digit = '0'-'9':x                            -> int(x)\n  op1 =\n    | '+' -> makeAdd()\n    | '-' -> makeSub()\n  op2 =\n    | '*' -> makeMul()\n    | '/' -> makeDiv()\n  op3 =\n    | '**' -> makePow()\n}\n",
"type":"code"
}
],
"id":"c2cbd3c58c6841089d2e7418bc5a7d8f",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"ast.py"
],
"fragments":[
{
"text":"def add(left, right):\n    return [\"+\", left, right]\n\ndef mul(left, right):\n    return [\"*\", left, right]\n\ndef div(left, right):\n    return [\"/\", left, right]\n\ndef pow(left, right):\n    return [\"**\", left, right]\n",
"type":"code"
}
],
"id":"e81957eb59744bd592c863f015a9e778",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"eval.py"
],
"fragments":[
{
"text":"def add(left, right):\n    return left + right\n\ndef mul(left, right):\n    return left * right\n\ndef div(left, right):\n    return left / right\n\ndef pow(left, right):\n    return left ** right\n",
"type":"code"
}
],
"id":"5d207e0728cf4b728a8143f72cfeefda",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2-3**2**2-5\n",
"type":"code"
}
],
"id":"d8ed162a9514476d9efdab15468e4966",
"post_process":[
"bash",
"expr.sh",
"calculator.rlmeta",
"ast.py"
],
"type":"code"
},
{
"code_id":"d8ed162a9514476d9efdab15468e4966",
"id":"a58288dc1d1d412ead712a5541260e51",
"type":"expanded_code"
}
],
"title":"More complete calculator"
},
{
"children":[],
"id":"063f23a343574259bf31debb9b8425bf",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"calculator_ops.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = digit:x (op:y digit:z -> [y z])*:xs -> parseOps(x xs)\n  digit = '0'-'9':x                           -> int(x)\n  op    =\n    | '**' -> Op(makePow() \"3\" \"right\")\n    | '*'  -> Op(makeMul() \"2\" \"left\")\n    | '/'  -> Op(makeDiv() \"2\" \"left\")\n    | '+'  -> Op(makeAdd() \"1\" \"left\")\n    | '-'  -> Op(makeSub() \"1\" \"left\")\n}\n",
"type":"code"
}
],
"id":"d3a45ae9dc0345bebfbf390d7247c39b",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class Op(object):\n\n    def __init__(self, fn, prec, assoc):\n        self.fn = fn\n        self.prec = int(prec)\n        self.assoc = assoc\n",
"type":"code"
}
],
"id":"26892d627896439aa7b3080a02ad7ffa",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def parseOps(expr, items, min_level=1):\n    while items and items[0][0].prec >= min_level:\n        op, rhs = items.pop(0)\n        if op.assoc == \"left\":\n            next_level = min_level + 1\n        else:\n            next_level = min_level\n        expr = op.fn(expr, parseOps(rhs, items, next_level))\n    return expr\n",
"type":"code"
}
],
"id":"0e3c33cbca0f4cb296429066f8a80146",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2-3\n1+2-3**2**2-5\n",
"type":"code"
}
],
"id":"68da398467b04071a836c89e17a74d8c",
"post_process":[
"bash",
"expr.sh",
"calculator_ops.rlmeta"
],
"type":"code"
},
{
"code_id":"68da398467b04071a836c89e17a74d8c",
"id":"de487e21adda44918c4d52235691dacc",
"type":"expanded_code"
}
],
"title":"Nicer handling of precedence"
},
{
"children":[],
"id":"5cca99df2e2c4c78ab4bfe4cb946d89a",
"paragraphs":[
{
"fragments":[
{
"text":"Articles that helped me understand how to handle left associative operators:",
"type":"text"
}
],
"id":"f986d87ab25d4d6395d0ec8b21461928",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Implementing Associativity and Precedence in Recursive Descent Expression Grammars",
"type":"link",
"url":"http://beastie.cs.ua.edu/proglan/readings/precedence.pdf"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Recursive descent, LL and predictive parsers",
"type":"link",
"url":"https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Some problems of recursive descent parsers",
"type":"link",
"url":"https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"A recursive descent parser with an infix expression evaluator",
"type":"link",
"url":"https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Top-Down operator precedence parsing",
"type":"link",
"url":"https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Parsing expressions by precedence climbing",
"type":"link",
"url":"https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Pratt Parsers: Expression Parsing Made Easy",
"type":"link",
"url":"http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/"
}
]
}
],
"id":"b1decd09f7664c9982377d6d894e5251",
"type":"list"
}
],
"title":"Resources"
},
{
"children":[],
"id":"c1716e6e63034983a86a1c9f621b2a52",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"expr.sh"
],
"fragments":[
{
"text":"compile() {\n    echo \"import sys\"\n    echo \"import pprint\"\n    rlmeta --support\n    rlmeta < \"$1\"\n    cat \"support.py\"\n    cat \"$2\"\n    echo \"makeAdd = lambda: add\"\n    echo \"makeSub = lambda: sub\"\n    echo \"makeMul = lambda: mul\"\n    echo \"makeDiv = lambda: div\"\n    echo \"makePow = lambda: pow\"\n    echo \"try:\"\n    echo \"    for expr in sys.stdin.read().splitlines():\"\n    echo \"        pprint.pprint(Calculator().run('expr', expr), width=20)\"\n    echo \"except _MatchError as e:\"\n    echo \"    sys.stderr.write(e.describe())\"\n}\n\n(\n    while read -e expr; do\n        echo \"$expr\" | python <(compile \"$1\" \"ast.py\")\n        echo \"=>\"\n        echo \"$expr\" | python <(compile \"$1\" \"eval.py\")\n        echo \"\"\n    done\n) | head -n-1\n",
"type":"code"
}
],
"id":"9ce0445bab6d4f3c91b3a4c157b66bfc",
"type":"code"
}
],
"title":"Appendix: Test script"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"first article",
"type":"link",
"url":"/writing/rlmeta/index.html"
},
{
"text":" about RLMeta has this example grammar for a calculator:",
"type":"text"
}
],
"id":"7a603d032c534d4d840da7d0fc533515",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"Calculator {\n  expression =\n    | additive\n  additive =\n    | multitive:x '+' additive:y -> add(x y)\n    | multitive\n  multitive =\n    | digit:x '*' multitive:y    -> mul(x y)\n    | digit\n  digit =\n    | '0'-'9':x                  -> int(x)\n}\n",
"type":"code"
}
],
"id":"65262f5f1fed4b9ebb4127d3296cef31",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"At a first glance, it looks correct, but it has a problem with operator associativity. It is avoided by only supporting operators that evaluate the same no matter if evaluated left or right.",
"type":"text"
}
],
"id":"da24fc1fbbcf45148c4ed01db3cb404c",
"type":"text"
},
{
"fragments":[
{
"text":"In this article I show how to correctly parse any binary operator expression in RLMeta.",
"type":"text"
}
],
"id":"8f342137f35746f28ee0a72901188feb",
"type":"text"
}
],
"title":"Parsing left associative operators using RLMeta"
},
"variables":{}
}