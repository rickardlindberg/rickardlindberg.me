{
"root_page":{
"children":[
{
"children":[],
"id":"5cca99df2e2c4c78ab4bfe4cb946d89a",
"paragraphs":[
{
"fragments":[
{
"text":"Associativity and precedence. A good resource: ",
"type":"text"
},
{
"text":"http://beastie.cs.ua.edu/proglan/readings/precedence.pdf",
"type":"link",
"url":"http://beastie.cs.ua.edu/proglan/readings/precedence.pdf"
},
{
"text":".",
"type":"text"
}
],
"id":"f986d87ab25d4d6395d0ec8b21461928",
"type":"text"
}
],
"title":"Notes"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"The parsing algorithm used by RLMeta does not support left associativity. How can it be achieved anyway?",
"type":"text"
}
],
"id":"7a603d032c534d4d840da7d0fc533515",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"test.py"
],
"fragments":[
{
"text":"def parse():\n    return (1, [\n        ['-', 2],\n        ['-', 3],\n    ])\n\ndef left_assoc(expr, items):\n    while items:\n        op, rhs = items.pop(0)\n        expr = [op, expr, rhs]\n    return expr\n\ndef right_assoc(expr, items):\n    if items:\n        op, rhs = items.pop(0)\n        expr = [op, expr, right_assoc(rhs, items)]\n    return expr\n\ndef eval_expr(expr):\n    if isinstance(expr, list):\n        op, lhs, rhs = expr\n        if op == \"-\":\n            return eval_expr(lhs) - eval_expr(rhs)\n        else:\n            raise Exception(\"unknown operator {!r}\".format(op))\n    else:\n        return expr\n\ndef echo_eval_expr(expr):\n    print(\"{} => {}\".format(expr, eval_expr(expr)))\n\necho_eval_expr(left_assoc(*parse()))\necho_eval_expr(right_assoc(*parse()))\n",
"type":"code"
}
],
"id":"1ce6df3de27c471b90c263fe9c07e116",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[],
"id":"ad93d70b996542dea66889e73497926d",
"post_process":[
"python",
"test.py"
],
"type":"code"
},
{
"code_id":"ad93d70b996542dea66889e73497926d",
"id":"a42fccab8e6b4a01965e94ecfb7e816f",
"type":"expanded_code"
}
],
"title":"Parsing left associative operators using RLMeta"
},
"variables":{}
}