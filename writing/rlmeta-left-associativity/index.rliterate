{
"root_page":{
"children":[
{
"children":[],
"id":"5cca99df2e2c4c78ab4bfe4cb946d89a",
"paragraphs":[
{
"fragments":[
{
"text":"Associativity and precedence. A good resource: ",
"type":"text"
},
{
"text":"http://beastie.cs.ua.edu/proglan/readings/precedence.pdf",
"type":"link",
"url":"http://beastie.cs.ua.edu/proglan/readings/precedence.pdf"
},
{
"text":".",
"type":"text"
}
],
"id":"f986d87ab25d4d6395d0ec8b21461928",
"type":"text"
}
],
"title":"Notes"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"The parsing algorithm used by RLMeta does not support left associativity. How can it be achieved anyway?",
"type":"text"
}
],
"id":"7a603d032c534d4d840da7d0fc533515",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"SubRight {\n  expr  = digit:x '-' expr:y -> add(x y)\n        | digit\n  digit = '0'-'9':x          -> int(x)\n}\n",
"type":"code"
}
],
"id":"2ecbdee5c0eb4fda8f88786740704212",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"SubLeft {\n  expr  = expr:x '-' digit:y -> add(x y)\n        | digit\n  digit = '0'-'9':x          -> int(x)\n}\n",
"type":"code"
}
],
"id":"4fa440d4d3794c929a28b3111f660d1a",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"Sub {\n  expr  = digit:x ('-':y digit:z -> [y z]):xs* -> leftAssoc(x xs)\n  digit = '0'-'9':x                            -> int(x)\n}\n",
"type":"code"
}
],
"id":"448843370672495aa2b3c46276f71320",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"chunkpath":[
"grammar"
],
"filepath":[
"calculator.py"
],
"fragments":[
{
"text":"Calculator {\n  expr = expr1\n  expr1 = expr2:x (op1:y expr2:z -> [y z])*:xs -> leftAssoc(x xs)\n  expr2 = expr3:x (op2:y expr3:z -> [y z])*:xs -> leftAssoc(x xs)\n  expr3 = '0'-'9':x                            -> int(x)\n  op1 =\n    | '+' -> add()\n    | '-' -> sub()\n  op2 =\n    | '*' -> mul()\n    | '/' -> div()\n}\n",
"type":"code"
}
],
"id":"c2cbd3c58c6841089d2e7418bc5a7d8f",
"language":"rlmeta",
"post_process":[
"rlmeta"
],
"type":"code"
},
{
"chunkpath":[
"support"
],
"filepath":[
"calculator.py"
],
"fragments":[
{
"text":"# Support library\n",
"type":"code"
}
],
"id":"a5615cdf05de4e76aa473eac1801dffc",
"language":"rlmeta",
"post_process":[
"rlmeta",
"--support"
],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"calculator.py"
],
"fragments":[
{
"text":"import sys\n\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"support"
],
"prefix":"",
"type":"chunk"
},
{
"blank_lines_before":0,
"path":[
"grammar"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\ndef add():\n    return lambda l, r: l + r\n\ndef sub():\n    return lambda l, r: l - r\n\ndef mul():\n    return lambda l, r: l * r\n\ndef div():\n    return lambda l, r: l / r\n\ndef leftAssoc(expr, items):\n    while items:\n        op, rhs = items.pop(0)\n        expr = op(expr, rhs)\n    return expr\n\nif __name__ == \"__main__\":\n    try:\n        for expr in sys.stdin.read().splitlines():\n            print(\"{} = {}\".format(\n                expr,\n                Calculator().run(\"expr\", expr)\n            ))\n    except _MatchError as e:\n        sys.exit(e.describe())\n",
"type":"code"
}
],
"id":"1cea8d775fb04047b69a306d5cb91c00",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-2-3\n1-2+3*4/5\n",
"type":"code"
}
],
"id":"b699d332326745aba9732c6e6771c573",
"post_process":[
"python",
"calculator.py"
],
"type":"code"
},
{
"code_id":"b699d332326745aba9732c6e6771c573",
"id":"301701c3a5e0473a805005b233131144",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[
"test.py"
],
"fragments":[
{
"text":"def parse():\n    return (1, [\n        [lambda l, r: ['-', l, r], 2],\n        [lambda l, r: ['-', l, r], 3],\n        [lambda l, r: ['-', l, r], 4],\n    ])\n\ndef left_assoc(expr, items):\n    while items:\n        op, rhs = items.pop(0)\n        expr = op(expr, rhs)\n    return expr\n\ndef right_assoc(expr, items):\n    if items:\n        op, rhs = items.pop(0)\n        expr = op(expr, right_assoc(rhs, items))\n    return expr\n\ndef eval_expr(expr):\n    if isinstance(expr, list):\n        op, lhs, rhs = expr\n        if op == \"-\":\n            return eval_expr(lhs) - eval_expr(rhs)\n        else:\n            raise Exception(\"unknown operator {!r}\".format(op))\n    else:\n        return expr\n\ndef echo_eval_expr(expr):\n    print(\"{} => {}\".format(expr, eval_expr(expr)))\n\necho_eval_expr(left_assoc(*parse()))\necho_eval_expr(right_assoc(*parse()))\n",
"type":"code"
}
],
"id":"1ce6df3de27c471b90c263fe9c07e116",
"type":"code"
}
],
"title":"Parsing left associative operators using RLMeta"
},
"variables":{}
}