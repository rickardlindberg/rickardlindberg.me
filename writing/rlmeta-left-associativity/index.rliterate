{
"root_page":{
"children":[
{
"children":[],
"id":"37144d09790c48a3bbdc3485473b5416",
"paragraphs":[],
"title":"What is associativity?"
},
{
"children":[],
"id":"cb24f5d3a7df423e9081889d4a2d3785",
"paragraphs":[
{
"fragments":[
{
"text":"Here is a grammar that works like the calculator but only support the subtraction operator:",
"type":"text"
}
],
"id":"4d04045b326d456faa9479d9b910971d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"right.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = digit:x '-' expr:y -> sub(x y)\n        | digit\n  digit = '0'-'9':x          -> int(x)\n}\n",
"type":"code"
}
],
"id":"2ecbdee5c0eb4fda8f88786740704212",
"language":"",
"post_process":[],
"type":"code"
},
{
"id":"af5a8c4ce42944f0a71a625b04edb239",
"type":"factory"
},
{
"chunkpath":[],
"filepath":[
"ast.py"
],
"fragments":[
{
"text":"def sub(left, right):\n    return [\"-\", left, right]\n",
"type":"code"
}
],
"id":"f22a7858bbcd4a56b985e56f5c251681",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"eval.py"
],
"fragments":[
{
"text":"def sub(left, right):\n    return left - right\n",
"type":"code"
}
],
"id":"b64973599f1c4994933814a893bd3013",
"type":"code"
},
{
"fragments":[
{
"text":"For an expression with only two numbers, the grammar works as expected. But with more numbers, the expression created is incorrect.",
"type":"text"
}
],
"id":"bc7fa6229c454ce192058b92cb8b7fe2",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-2\n1-2-3\n",
"type":"code"
}
],
"id":"efe1706fb496425a8f2059574de91b19",
"post_process":[
"bash",
"expr.sh",
"right.rlmeta"
],
"type":"code"
},
{
"code_id":"efe1706fb496425a8f2059574de91b19",
"id":"d9394f9309714b6cb7388081f7bf781f",
"type":"expanded_code"
}
],
"title":"Right"
},
{
"children":[],
"id":"8366ac579e1e4be9930317242abd5dd6",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"expr = digit '-' expr | digit\n",
"type":"code"
}
],
"id":"ccf6f0a1de824f28b6162545d8529afb",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"code_id":"ccf6f0a1de824f28b6162545d8529afb",
"id":"2bb25c6b8a0440d89510b8defce7e4f1",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"expr = expr '-' digit | digit\n",
"type":"code"
}
],
"id":"a42d56d2a2b14736958d17bc34b0db7b",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"left.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = expr:x '-' digit:y -> sub(x y)\n        | digit\n  digit = '0'-'9':x          -> int(x)\n}\n",
"type":"code"
}
],
"id":"4fa440d4d3794c929a28b3111f660d1a",
"language":"",
"post_process":[],
"type":"code"
}
],
"title":"Left"
},
{
"children":[],
"id":"855b50c552e54c0895128e7e86da55e9",
"paragraphs":[
{
"code_id":"ccf6f0a1de824f28b6162545d8529afb",
"id":"deba845b4d9b4eb3b447bbb9ef5ad93f",
"type":"expanded_code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"expr = digit ('-' digit)*\n",
"type":"code"
}
],
"id":"176c8d5f26e541dbbd0422ae23279b93",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"left_correct.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = digit:x (op:y digit:z -> [y z])*:xs -> leftAssoc(x xs)\n  digit = '0'-'9':x                           -> int(x)\n  op    = '-'                                 -> makeSub()\n}\n",
"type":"code"
}
],
"id":"448843370672495aa2b3c46276f71320",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def leftAssoc(expr, items):\n    while items:\n        op, rhs = items.pop(0)\n        expr = op(expr, rhs)\n    return expr\n",
"type":"code"
}
],
"id":"bdffa34a868143e89b3dcdf0c77eb183",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1-2\n1-2-3\n",
"type":"code"
}
],
"id":"ed936d888481437ca2da5776dfb50232",
"post_process":[
"bash",
"expr.sh",
"left_correct.rlmeta"
],
"type":"code"
},
{
"code_id":"ed936d888481437ca2da5776dfb50232",
"id":"46366298a2784876957c79f4108715bb",
"type":"expanded_code"
}
],
"title":"Left correct"
},
{
"children":[],
"id":"736626ed0c3c4fea922cc4f14c5cda38",
"paragraphs":[
{
"fragments":[
{
"text":"todo: example",
"type":"strong"
}
],
"id":"f9469f2cb5364f10842329b0e9b18a45",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def rightAssoc(expr, items):\n    if items:\n        op, rhs = items.pop(0)\n        expr = op(expr, rightAssoc(rhs, items))\n    return expr\n",
"type":"code"
}
],
"id":"17f2b0dec1ac4958bd79aa568963bdad",
"type":"code"
},
{
"code_id":"bdffa34a868143e89b3dcdf0c77eb183",
"id":"b9d1e57041864b0fb648fbaf8d165fd3",
"type":"expanded_code"
}
],
"title":"Right without recursion in grammar"
},
{
"children":[],
"id":"ae39c406658e4cd287411ab2c76710f8",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"calculator.rlmeta"
],
"fragments":[
{
"text":"Calculator {\n  expr  = expr1\n  expr1 = expr2:x (op1:y expr2:z -> [y z])*:xs -> leftAssoc(x xs)\n  expr2 = expr3:x (op2:y expr3:z -> [y z])*:xs -> leftAssoc(x xs)\n  expr3 = digit:x (op3:y digit:z -> [y z])*:xs -> rightAssoc(x xs)\n  digit = '0'-'9':x                            -> int(x)\n  op1 =\n    | '+' -> makeAdd()\n    | '-' -> makeSub()\n  op2 =\n    | '*' -> makeMul()\n    | '/' -> makeDiv()\n  op3 =\n    | '**' -> makePow()\n}\n",
"type":"code"
}
],
"id":"c2cbd3c58c6841089d2e7418bc5a7d8f",
"language":"",
"post_process":[],
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"ast.py"
],
"fragments":[
{
"text":"def add(left, right):\n    return [\"+\", left, right]\n\ndef mul(left, right):\n    return [\"*\", left, right]\n\ndef div(left, right):\n    return [\"/\", left, right]\n\ndef pow(left, right):\n    return [\"**\", left, right]\n",
"type":"code"
}
],
"id":"e81957eb59744bd592c863f015a9e778",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"eval.py"
],
"fragments":[
{
"text":"def add(left, right):\n    return left + right\n\ndef mul(left, right):\n    return left * right\n\ndef div(left, right):\n    return left / right\n\ndef pow(left, right):\n    return left ** right\n",
"type":"code"
}
],
"id":"5d207e0728cf4b728a8143f72cfeefda",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"1+2-3**2**2-5\n",
"type":"code"
}
],
"id":"d8ed162a9514476d9efdab15468e4966",
"post_process":[
"bash",
"expr.sh",
"calculator.rlmeta",
"ast.py"
],
"type":"code"
},
{
"code_id":"d8ed162a9514476d9efdab15468e4966",
"id":"a58288dc1d1d412ead712a5541260e51",
"type":"expanded_code"
}
],
"title":"More complete calculator"
},
{
"children":[],
"id":"5cca99df2e2c4c78ab4bfe4cb946d89a",
"paragraphs":[
{
"fragments":[
{
"text":"Articles that helped me understand how to handle left associative operators:",
"type":"text"
}
],
"id":"f986d87ab25d4d6395d0ec8b21461928",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Implementing Associativity and Precedence in Recursive Descent Expression Grammars",
"type":"link",
"url":"http://beastie.cs.ua.edu/proglan/readings/precedence.pdf"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Recursive descent, LL and predictive parsers",
"type":"link",
"url":"https://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Some problems of recursive descent parsers",
"type":"link",
"url":"https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"A recursive descent parser with an infix expression evaluator",
"type":"link",
"url":"https://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Top-Down operator precedence parsing",
"type":"link",
"url":"https://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Parsing expressions by precedence climbing",
"type":"link",
"url":"https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Pratt Parsers: Expression Parsing Made Easy",
"type":"link",
"url":"http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/"
}
]
}
],
"id":"b1decd09f7664c9982377d6d894e5251",
"type":"list"
}
],
"title":"Resources"
},
{
"children":[],
"id":"c1716e6e63034983a86a1c9f621b2a52",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"expr.sh"
],
"fragments":[
{
"text":"compile() {\n    echo \"import sys\"\n    echo \"import pprint\"\n    rlmeta --support\n    rlmeta < \"$1\"\n    cat \"support.py\"\n    cat \"$2\"\n    echo \"makeAdd = lambda: add\"\n    echo \"makeSub = lambda: sub\"\n    echo \"makeMul = lambda: mul\"\n    echo \"makeDiv = lambda: div\"\n    echo \"makePow = lambda: pow\"\n    echo \"try:\"\n    echo \"    for expr in sys.stdin.read().splitlines():\"\n    echo \"        pprint.pprint(Calculator().run('expr', expr), width=20)\"\n    echo \"except _MatchError as e:\"\n    echo \"    sys.stderr.write(e.describe())\"\n}\n\n(\n    while read -e expr; do\n        echo \"$expr\" | python <(compile \"$1\" \"ast.py\")\n        echo \"=>\"\n        echo \"$expr\" | python <(compile \"$1\" \"eval.py\")\n        echo \"\"\n    done\n) | head -n-1\n",
"type":"code"
}
],
"id":"9ce0445bab6d4f3c91b3a4c157b66bfc",
"type":"code"
}
],
"title":"Appendix: Test script"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"first article",
"type":"link",
"url":"/writing/rlmeta/index.html"
},
{
"text":" about RLMeta had an example with simple calculator grammar:",
"type":"text"
}
],
"id":"7a603d032c534d4d840da7d0fc533515",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"Calculator {\n  expression =\n    | additive\n  additive =\n    | multitive:x '+' additive:y -> add(x y)\n    | multitive\n  multitive =\n    | digit:x '*' multitive:y    -> mul(x y)\n    | digit\n  digit =\n    | '0'-'9':x                  -> int(x)\n}\n",
"type":"code"
}
],
"id":"65262f5f1fed4b9ebb4127d3296cef31",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"This grammar has a fault carefully avoided by supporting operators that evaluates the same no matter if left or right.",
"type":"text"
}
],
"id":"da24fc1fbbcf45148c4ed01db3cb404c",
"type":"text"
}
],
"title":"Parsing left associative operators using RLMeta"
},
"variables":{}
}