<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      Optimizing RLMeta | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>Optimizing RLMeta</h1>

<p><em>Published on 28 June 2019.</em></p>

<ul>
<li><a href="#e3c712b4ce4f16bb8e5d352e76fb0ewhat-to-measure">[]{#31e3c712b4ce4f16bb8e5d352e76fb0e}What to measure?</a></li>
<li><a href="#ac127d411b749919b45ae11c1e47975andor-optimization">[]{#2ac127d411b749919b45ae11c1e47975}And/Or optimization</a></li>
<li><a href="#avoid-slicing-input"><span id="f4741ec692124b31af139231151e3a29"></span>Avoid slicing input</a></li>
<li><a href="#deb8e7f493a474d8555eb7db34a89dcfaster-string-concatenation">[]{#8deb8e7f493a474d8555eb7db34a89dc}Faster string concatenation</a></li>
<li><a href="#ce805fef64eb88c4b8214d7e85495andor-again">[]{#006ce805fef64eb88c4b8214d7e85495}And/Or again</a></li>
<li><a href="#remove-newlines-and-indentation"><span id="a06ba4a722cc461f9f3eabe2c0f60e53"></span>Remove newlines and indentation</a></li>
<li><a href="#match-call-rule"><span id="e7f710aa99bc4a7c895e905f60b4beb8"></span>Match call rule</a></li>
<li><a href="#cbceeb9f45bb992c65cc688c3c18dont-memoize-code-generator">[]{#5160cbceeb9f45bb992c65cc688c3c18}Don't memoize code generator</a></li>
<li><a href="#optimize-position"><span id="f0338cf15ddb49099abf6a135a0961d7"></span>Optimize position</a></li>
<li><a href="#make-fail-messages-lazy"><span id="a5f5f3907de04b28bdf52a8ba57b4a71"></span>Make fail messages lazy</a></li>
<li><a href="#ec92a13304692857a6d4de445e4d2peek">[]{#898ec92a13304692857a6d4de445e4d2}Peek</a></li>
<li><a href="#d9e890742c41d48fc1afc2009815c7no-exception-for-last-or">[]{#84d9e890742c41d48fc1afc2009815c7}No exception for last or</a></li>
<li><a href="#eda03f5c40458ac9439def097739conclusions">[]{#3616eda03f5c40458ac9439def097739}Conclusions</a></li>
<li><a href="#aafb64996414339b01b0d407e6e1810code-listings-for-rlmeta">[]{#3aafb64996414339b01b0d407e6e1810}Code listings for RLMeta</a>
<ul>
<li><a href="#e1c4c119f90be842c1b9577parser.rlmeta">[]{#496100180e1c4c119f90be842c1b9577}parser.rlmeta</a></li>
<li><a href="#bd8846187ad478aa17439370f0da1e6codegenerator.rlmeta">[]{#7bd8846187ad478aa17439370f0da1e6}codegenerator.rlmeta</a></li>
<li><a href="#support.py"><span id="ecfe26a58495420b8871e522c6859a4a"></span>support.py</a></li>
<li><a href="#ee923adb0ed4f3b8a5cc72700aad2ddcompile.sh">[]{#1ee923adb0ed4f3b8a5cc72700aad2dd}compile.sh</a></li>
<li><a href="#meta_compile.sh"><span id="d09466ef920844788d5e63457decfd86"></span>meta_compile.sh</a></li>
</ul></li>
</ul>
<p>In this article we optimize <a href="../../writing/rlmeta/">RLMeta</a> to run faster. The first version did not take performance into account, so it is not surprising that we will get it to run roughly twice as fast.</p>
<ul>
<li><a href="#31e3c712b4ce4f16bb8e5d352e76fb0e">What to measure?</a></li>
<li><a href="#2ac127d411b749919b45ae11c1e47975">And/Or optimization</a></li>
<li><a href="#f4741ec692124b31af139231151e3a29">Avoid slicing input</a></li>
<li><a href="#8deb8e7f493a474d8555eb7db34a89dc">Faster string concatenation</a></li>
<li><a href="#006ce805fef64eb88c4b8214d7e85495">And/Or again</a></li>
<li><a href="#a06ba4a722cc461f9f3eabe2c0f60e53">Remove newlines and indentation</a></li>
<li><a href="#e7f710aa99bc4a7c895e905f60b4beb8">Match call rule</a></li>
<li><a href="#5160cbceeb9f45bb992c65cc688c3c18">Don't memoize code generator</a></li>
<li><a href="#f0338cf15ddb49099abf6a135a0961d7">Optimize position</a></li>
<li><a href="#a5f5f3907de04b28bdf52a8ba57b4a71">Make fail messages lazy</a></li>
<li><a href="#898ec92a13304692857a6d4de445e4d2">Peek</a></li>
<li><a href="#84d9e890742c41d48fc1afc2009815c7">No exception for last or</a></li>
<li><a href="#3616eda03f5c40458ac9439def097739">Conclusions</a></li>
<li><a href="#3aafb64996414339b01b0d407e6e1810">Code listings for RLMeta</a>
<ul>
<li><a href="#496100180e1c4c119f90be842c1b9577">parser.rlmeta</a></li>
<li><a href="#7bd8846187ad478aa17439370f0da1e6">codegenerator.rlmeta</a></li>
<li><a href="#ecfe26a58495420b8871e522c6859a4a">support.py</a></li>
<li><a href="#1ee923adb0ed4f3b8a5cc72700aad2dd">compile.sh</a></li>
<li><a href="#d09466ef920844788d5e63457decfd86">meta_compile.sh</a></li>
</ul></li>
</ul>
<h2 id="e3c712b4ce4f16bb8e5d352e76fb0ewhat-to-measure">[]{#31e3c712b4ce4f16bb8e5d352e76fb0e}What to measure?</h2>
<p>Before optimizing something for speed it is important to measure how long it takes. We are interested in optimizing the time it takes for RLMeta to compile itself. If it compiles itself faster, it will most likely also compile other RLMeta programs faster.</p>
<p>RLMeta compiles itself in the following steps:</p>
<ul>
<li>Generate support libraries</li>
<li>Compile parser</li>
<li>Compile code generator</li>
<li>Assemble the pieces into a Python file</li>
</ul>
<p>The <code>compile.sh</code> script performs those steps like follows:</p>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">'import sys; sys.stdout.write(repr(sys.stdin.read()))'</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>&lt;&lt;python template&gt;&gt;</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<p>The Python file template rendered at the end of the script looks like this:</p>
<pre><code>1.  compile.sh
2.  [python template]{.cp}</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ex">import</span> sys</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ex">SUPPORT</span> = <span class="va">$support_py_string</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="fu">join</span> = <span class="st">&quot;&quot;</span>.join</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="ex">def</span> compile_grammar(grammar)<span class="bu">:</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    <span class="ex">parser</span> = Parser()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    <span class="ex">code_generator</span> = CodeGenerator()</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    <span class="bu">return</span> code_generator.run(<span class="st">&quot;ast&quot;</span>, parser.run(<span class="st">&quot;grammar&quot;</span>, grammar))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="kw">if</span> <span class="ex">__name__</span> == <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    <span class="kw">if</span> <span class="st">&quot;--support&quot;</span> <span class="kw">in</span> <span class="ex">sys.argv</span>:</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>        <span class="ex">sys.stdout.write</span>(SUPPORT)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>    <span class="ex">else</span>:</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>        <span class="ex">try</span>:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>            <span class="ex">sys.stdout.write</span>(compile_grammar(sys.stdin.read()))</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>        <span class="ex">except</span> _MatchError as e:</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>            <span class="ex">sys.stderr.write</span>(e.describe())</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>            <span class="ex">sys.exit</span>(1)</span></code></pre></div>
<p>To measure how long it takes for RLMeta to compile itself, we use the <code>time</code> command:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.756s
user  0m0.701s
sys 0m0.054s</code></pre>
<p>It takes <strong>0.756s</strong>. The goal of our optimizations is to decrease this time.</p>
<p>To get a better understanding of what takes time, we measure how long it takes to compile the parser and the code generator individually:</p>
<pre class="text"><code>$ time python rlmeta.py &lt; parser.rlmeta &gt; /dev/null

real  0m0.380s
user  0m0.363s
sys 0m0.015s</code></pre>
<pre class="text"><code>$ time python rlmeta.py &lt; codegenerator.rlmeta &gt; /dev/null

real  0m0.351s
user  0m0.331s
sys 0m0.019s</code></pre>
<p>Both grammars take roughly the same time to compile (<strong>0.380s</strong> and <strong>0.351s</strong>). Moreover, the compilation of the grammars take up most of the time. The rest (generating the support libraries and rendering the Python file template) takes only <strong>0.025s</strong> (0.756-0.380-0.351). We will therefore focus on making compilation of grammars faster.</p>
<p>To get a better understanding of what takes time when compiling grammars, we compile the parser and the code generator with the Python profiler turned on:</p>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
             513780 function calls (430760 primitive calls) in 0.476 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8182/2    0.053    0.000    0.427    0.213 rlmeta.py:7(_or)
    22758    0.040    0.000    0.106    0.000 rlmeta.py:234(next)
    17411    0.027    0.000    0.046    0.000 rlmeta.py:203(fail)
  26658/2    0.023    0.000    0.427    0.213 rlmeta.py:16(_and)
  10730/2    0.020    0.000    0.427    0.213 rlmeta.py:43(_match_rule)
     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)
        1    0.013    0.013    0.013    0.013 {method 'write' of 'file' objects}
...</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; codegenerator.rlmeta
...
         450885 function calls (377441 primitive calls) in 0.433 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8152/2    0.052    0.000    0.396    0.198 rlmeta.py:7(_or)
    19754    0.046    0.000    0.097    0.000 rlmeta.py:234(next)
    15838    0.026    0.000    0.049    0.000 rlmeta.py:203(fail)
  23478/2    0.020    0.000    0.396    0.198 rlmeta.py:16(_and)
   9883/2    0.018    0.000    0.396    0.198 rlmeta.py:43(_match_rule)
    15838    0.016    0.000    0.016    0.000 rlmeta.py:211(__init__)
        1    0.012    0.012    0.012    0.012 {method 'write' of 'file' objects}
...</code></pre>
<p>This again shows that both grammars take roughly the same time to compile (<strong>0.476s</strong> and <strong>0.433s</strong>). (These numbers are higher than the <code>time</code> measurements. Probably because profiling is turned on.) It also shows what functions take most time. Both grammars have roughly the same functions at the top of the list: <code>_or</code>, <code>next</code>, <code>fail</code>, <code>_and</code>, <code>_match_rule</code>, and <code>write</code>.</p>
<p>Because the profiling output looks similar for the two grammars, we will only profile compilation of the parser.</p>
<p>Let's start by examining the <code>_or</code> function, because most time is spent there, and see if we can make it any faster.</p>
<h2 id="ac127d411b749919b45ae11c1e47975andor-optimization">[]{#2ac127d411b749919b45ae11c1e47975}And/Or optimization</h2>
<p>The <code>_or</code> function is called any time there is a choice in a grammar and it looks like this:</p>
<pre class="text"><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    original_stream.fail(&quot;no choice matched&quot;)</code></pre>
<p>There is no obvious way to optimize it so instead we try to reduce the number of calls to it. The code generator always generates calls to <code>_or</code> even if there is only one choice: <code>self._or([matcher])</code>. In this case the call to <code>_or</code> is unnecessary because the single matcher can be called directly: <code>matcher()</code>. The same reasoning goes for <code>_and</code>.</p>
<p>To make the code generator skip unnecessary calls to <code>_or</code> and <code>_and</code>, we add the following cases to it:</p>
<pre class="text"><code>| [&quot;Or&quot; ast:x]  -&gt; x
| [&quot;And&quot; ast:x] -&gt; x</code></pre>
<p>If it sees an <code>Or</code> or an <code>And</code> ast node with only one child, it will skip the calls to <code>_or</code> and <code>_and</code> and just generate the child matcher.</p>
<p>We create a new version of RLMeta as described in <a href="../../writing/modifying-rlmeta/">Modifying the RLMeta metacompiler</a> and then we measure.</p>
<p>Unfortunately, this does not seem to have any effect on the speed. Why is that? Perhaps because the two added cases to the code generator also makes it slower.</p>
<p>We discard this change for now and move on to the <code>next</code> function which is second on the list.</p>
<h2 id="avoid-slicing-input"><span id="f4741ec692124b31af139231151e3a29"></span>Avoid slicing input</h2>
<p>The <code>next</code> function is used to get the next object from an input stream and it looks like this:</p>
<pre class="text"><code>def next(self):
    if self.is_at_end():
        self.fail(&quot;not eof&quot;)
    next_object = self._objects[0]
    return (
        next_object,
        self._advance(next_object, self._objects[1:]),
    )</code></pre>
<p>Every time it is called, which is once per object in the input stream, the input stream is sliced: <code>self._objects[1:]</code>. This creates a new list with all objects except the first. For example, if the input stream is the string "print(1)", it will create the substrings "rint(1)", "int(1)", "nt(1)", and so on. This is wasteful.</p>
<p>To avoid slicing the input stream we rewrite it to instead maintain an index where it's at. The next object is retrieved by indexing, and the rest of the objects no longer has to be computed. The index is just incremented instead. With this change, the <code>next</code> function looks like this:</p>
<pre class="text"><code>def next(self):
    if self.is_at_end():
        self.fail(&quot;not eof&quot;)
    return (self._objects[self._index], self._advance())</code></pre>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/a358b1921a5f9afae769512ca27db795af947648#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.608s
user  0m0.585s
sys 0m0.022s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         513780 function calls (430760 primitive calls) in 0.415 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8182/2    0.042    0.000    0.366    0.183 rlmeta.py:7(_or)
    17411    0.026    0.000    0.044    0.000 rlmeta.py:203(fail)
  26658/2    0.021    0.000    0.366    0.183 rlmeta.py:16(_and)
  10730/2    0.019    0.000    0.366    0.183 rlmeta.py:43(_match_rule)
     2177    0.019    0.000    0.019    0.000 rlmeta.py:147(write)
    22758    0.017    0.000    0.077    0.000 rlmeta.py:235(next)
        1    0.014    0.014    0.014    0.014 {method 'write' of 'file' objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.756s</strong> to <strong>0.608s</strong>. The compilation time for a single grammar went from <strong>0.476s</strong> to <strong>0.415s</strong>. The <code>next</code> function moved down the list from <strong>0.040s</strong> to <strong>0.017s</strong>.</p>
<p>Finally some progress.</p>
<p>We still don't have an obvious way to optimize <code>_or</code> and <code>_and</code>. Next on the list is the <code>fail</code> function which looks like this:</p>
<pre class="text"><code>def fail(self, stream, message):
    if stream.position() &gt;= self._latest_stream.position():
        self._latest_stream = stream
        self._latest_message = message
    raise _MatchError(self)</code></pre>
<p>There is no obvious way to make this faster either. The same goes for the <code>_match_rule</code> function which looks like this:</p>
<pre class="text"><code>def _match_rule(self, rule_name):
    key = (rule_name, self._stream.position())
    if key in self._memo:
        result, _, self._stream = self._memo[key]
    else:
        start = self._stream
        result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
        end = self._stream
        self._memo[key] = (result, start, end)
    return result</code></pre>
<p>We move down the list and examine the <code>write</code> function.</p>
<h2 id="deb8e7f493a474d8555eb7db34a89dcfaster-string-concatenation">[]{#8deb8e7f493a474d8555eb7db34a89dc}Faster string concatenation</h2>
<p>The <code>write</code> function in the <code>_Output</code> class looks like this:</p>
<pre class="text"><code>class _Output(object):

    def __init__(self):
        self.value = &quot;&quot;
        self.indentation = 0

    def write(self, value):
        for ch in value:
            if self.value and ch != &quot;\n&quot; and self.value[-1] == &quot;\n&quot;:
                self.value += &quot;    &quot;*self.indentation
            self.value += ch</code></pre>
<p>It is used by the code generator to generate string output. It builds up the value by concatenating strings to the current value: <code>self.value += ..</code>. This concatenation is done once per generated character. Concatenating strings in Python this way is not the fastest way to do it.</p>
<p>A better way is to use the <code>StringIO</code> class. Its <code>write</code> function is used to build up the value, and its <code>getvalue</code> function is used to return it:</p>
<pre class="text"><code>class _Output(object):

    def __init__(self):
        self.buffer = StringIO()
        self.indentation = 0
        self.on_newline = True

    @property
    def value(self):
        return self.buffer.getvalue()

    def write(self, value):
        for ch in value:
            is_linebreak = ch == &quot;\n&quot;
            if self.indentation and self.on_newline and not is_linebreak:
                self.buffer.write(&quot;    &quot;*self.indentation)
            self.buffer.write(ch)
            self.on_newline = is_linebreak</code></pre>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/d5327b86d3de97a621f9ca0a8d11e445484d0fcb#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.603s
user  0m0.564s
sys 0m0.038s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         527910 function calls (444890 primitive calls) in 0.397 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   8182/2    0.042    0.000    0.370    0.185 rlmeta.py:12(_or)
    17411    0.026    0.000    0.045    0.000 rlmeta.py:215(fail)
  26658/2    0.021    0.000    0.370    0.185 rlmeta.py:21(_and)
  10730/2    0.019    0.000    0.370    0.185 rlmeta.py:48(_match_rule)
    22758    0.017    0.000    0.078    0.000 rlmeta.py:247(next)
    17408    0.012    0.000    0.018    0.000 rlmeta.py:279(__init__)
...
     2177    0.006    0.000    0.009    0.000 rlmeta.py:157(write)
...</code></pre>
<p>The overall compilation time went from <strong>0.608s</strong> to <strong>0.603s</strong>. The compilation time for a single grammar went from <strong>0.415s</strong> to <strong>0.397s</strong>. This is not significant. But much less time is spent in the <code>write</code> function (<strong>0.006s</strong> compared to <strong>0.019s</strong>) so we keep this change. It might be that some more time is spent doing the <code>getvalue</code> call. But it does not show up at the top of the list.</p>
<p>The <code>_or</code> and <code>_and</code> functions are still high up on the list. Now that we have made other parts of RLMeta faster, will the and/or optimization be more useful?</p>
<h2 id="ce805fef64eb88c4b8214d7e85495andor-again">[]{#006ce805fef64eb88c4b8214d7e85495}And/Or again</h2>
<p>We apply the and/or optimization again, create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.592s
user  0m0.560s
sys 0m0.031s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         508708 function calls (437696 primitive calls) in 0.380 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4898/230    0.039    0.000    0.351    0.002 rlmeta.py:12(_or)
    15852    0.025    0.000    0.041    0.000 rlmeta.py:215(fail)
  10620/2    0.019    0.000    0.354    0.177 rlmeta.py:48(_match_rule)
  21301/2    0.018    0.000    0.354    0.177 rlmeta.py:21(_and)
    23516    0.018    0.000    0.078    0.000 rlmeta.py:247(next)
    19154    0.013    0.000    0.020    0.000 rlmeta.py:279(__init__)
   8323/1    0.012    0.000    0.184    0.184 rlmeta.py:93(_match_list)
    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)
     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)
...</code></pre>
<p>The overall compilation time went from <strong>0.603s</strong> to <strong>0.592s</strong>. The compilation time for a single grammar went from <strong>0.397s</strong> to <strong>0.380s</strong>. This is not significant, but less time is spend in <code>_or</code> and <code>_and</code>, so we keep this change now.</p>
<p>We previously observed that writing output took some time. We made the <code>write</code> function faster. Now we will try another change that will cause less characters to be written to the output. This will change the grammar, and not just the support library.</p>
<h2 id="remove-newlines-and-indentation"><span id="a06ba4a722cc461f9f3eabe2c0f60e53"></span>Remove newlines and indentation</h2>
<p>The main part of the code generator has two rules that generate code for ast nodes:</p>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt; }
    ...
    | astFnBody:x             -&gt; { &quot;(lambda:\n&quot; &gt; x &lt; &quot;\n)&quot; }
  astFnBody =
    | [&quot;Or&quot; astItems:x]       -&gt; { &quot;self._or([&quot; x &quot;])&quot;               }
    ...
  ...
}</code></pre>
<p>If an ast node's body should be wrapped in a lambda, it is put in the <code>astFnBody</code> rule and the lambda is generated by the last choice in the <code>ast</code> rule. The lambda is generated with newlines and indentation like this:</p>
<pre class="text"><code>(lambda:
    body
)</code></pre>
<p>The newlines and indentation are not necessary. It might make the generated code easier to the read at the expense of outputting at least 6 more characters (two newlines and at least 4 spaces of indent). Instead we could generate this:</p>
<pre class="text"><code>(lambda: body)</code></pre>
<p>We rewrite the code generator like this:</p>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt; }
    ...
    | [&quot;Or&quot; astItems:x]       -&gt; { &quot;(lambda: self._or([&quot; x &quot;]))&quot;     }
    ...
  ...
}</code></pre>
<p>This also removes the <code>astFnBody</code> rule in favor of duplicating the lambda output code. This removes one function call, but more importantly lays the groundwork for the next optimization.</p>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/496c98d367a5dce2def17680d92f095cd2c274a5#diff-14e1afbb5e4a4c88a29fd7256cd350fb">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.565s
user  0m0.530s
sys 0m0.034s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         457174 function calls (396876 primitive calls) in 0.343 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4518/230    0.039    0.000    0.343    0.001 rlmeta.py:12(_or)
    15769    0.024    0.000    0.040    0.000 rlmeta.py:215(fail)
  10240/2    0.019    0.000    0.347    0.174 rlmeta.py:48(_match_rule)
    23516    0.017    0.000    0.078    0.000 rlmeta.py:247(next)
  20921/2    0.017    0.000    0.347    0.174 rlmeta.py:21(_and)
    19154    0.014    0.000    0.020    0.000 rlmeta.py:279(__init__)
   8323/1    0.012    0.000    0.176    0.176 rlmeta.py:93(_match_list)
     6613    0.010    0.000    0.052    0.000 rlmeta.py:79(_match_charseq)
    12847    0.010    0.000    0.024    0.000 rlmeta.py:290(_advance)
    27805    0.010    0.000    0.010    0.000 rlmeta.py:239(__init__)
    17623    0.010    0.000    0.010    0.000 {method 'format' of 'str' objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.592s</strong> to <strong>0.565s</strong>. The compilation time for a single grammar went from <strong>0.380s</strong> to <strong>0.343s</strong>.</p>
<p>Now that we've made an optimization by modifying the source code, we think about how we can further modify the source code to make RLMeta faster.</p>
<h2 id="match-call-rule"><span id="e7f710aa99bc4a7c895e905f60b4beb8"></span>Match call rule</h2>
<p>The largest part of the code generator is the <code>ast</code> rule. It has many choices that are tried in order to generate code for different type of ast nodes:</p>
<pre class="text"><code>CodeGenerator {
  ast =
    | [&quot;Grammar&quot; .:x ast*:ys] -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;   }
    ... (22 choices omitted) ...
    | [&quot;MatchList&quot; ast:x]     -&gt; { &quot;(lambda: self._match_list(&quot; x &quot;))&quot; }
  ...
}</code></pre>
<p>To generate code for the <code>MatchList</code> ast node, the <code>_or</code> function first needs to fail 23 times before it reaches the last choice that matches.</p>
<p>We introduce a new operator in RLMeta, <code>%</code>, which means read one object from the input stream and treat it as the name of a rule in the grammar. Then call that rule. It is implemented like this:</p>
<pre class="text"><code>def _match_call_rule(self):
    next_object, self._stream = self._stream.next()
    return self._match_rule(str(next_object))</code></pre>
<p>We then rewrite the code generator using this operator. The <code>ast</code> rule simply becomes matching a list, then calling the rule for that ast node. All choices are converted to rules where the ast node name becomes the rule name:</p>
<pre class="text"><code>CodeGenerator {
  Grammar   = .:x ast*:ys -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;   }
  ...
  MatchList = ast:x       -&gt; { &quot;(lambda: self._match_list(&quot; x &quot;))&quot; }
  ast       = [%:x]       -&gt; x
  ...
}</code></pre>
<p>With this change, the main part of the code generator is completely free of choice operators which should eliminate many calls to <code>_or</code>.</p>
<p>The complete diff can be viewed online <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/61ff2132a057cf986ae0eae8575d24b066ab3e43">here</a> and <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/f054fdca6c939506e2820d86d466fe1763244c43#diff-14e1afbb5e4a4c88a29fd7256cd350fb">here</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.406s
user  0m0.373s
sys 0m0.032s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         274963 function calls (238101 primitive calls) in 0.220 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  11129/2    0.021    0.000    0.215    0.107 rlmeta.py:48(_match_rule)
 4177/252    0.020    0.000    0.209    0.001 rlmeta.py:12(_or)
     8460    0.013    0.000    0.022    0.000 rlmeta.py:219(fail)
     7021    0.011    0.000    0.056    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.010    0.000    0.215    0.107 rlmeta.py:21(_and)
     9099    0.009    0.000    0.020    0.000 rlmeta.py:269(_advance)
    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)
     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)
    12801    0.006    0.000    0.006    0.000 {method 'format' of 'str' objects}
     1443    0.006    0.000    0.008    0.000 rlmeta.py:161(write)
    26070    0.005    0.000    0.005    0.000 rlmeta.py:266(position)
     8460    0.005    0.000    0.005    0.000 rlmeta.py:227(__init__)
    10908    0.005    0.000    0.005    0.000 rlmeta.py:243(__init__)
...</code></pre>
<p>The overall compilation time went from <strong>0.565s</strong> to <strong>0.406s</strong>. The compilation time for a single grammar went from <strong>0.343s</strong> to <strong>0.220s</strong>. This is some real performance gain. Also the <code>_or</code> function is kicked down to the second position.</p>
<p>Now that the code generator is mostly free from choices, is it still worthwhile to memoize results?</p>
<h2 id="cbceeb9f45bb992c65cc688c3c18dont-memoize-code-generator">[]{#5160cbceeb9f45bb992c65cc688c3c18}Don't memoize code generator</h2>
<p>Memoizing results is done in <code>_match_rule</code> which looks like this:</p>
<pre class="text"><code>def _match_rule(self, rule_name):
    key = (rule_name, self._stream.position())
    if key in self._memo:
        result, _, self._stream = self._memo[key]
    else:
        start = self._stream
        result = getattr(self, &quot;_rule_{}&quot;.format(rule_name))()
        end = self._stream
        self._memo[key] = (result, start, end)
    return result</code></pre>
<p>If the rule has matched before at the current position, the memoized result is returned. In the new code generator there will not be many such cases because most choices have been eliminated. For the code generator, we can instead just do this:</p>
<pre class="text"><code>def _match_rule(self, rule_name):
    return getattr(self, &quot;_rule_{}&quot;.format(rule_name))()</code></pre>
<p>We create a new version of RLMeta and then we measure.</p>
<p>It turns out this is not really significant. The code generator is not getting faster without memoization.</p>
<p>Now the <code>_match_rule</code> function takes most time. We previously saw no way to optimize it, but we observe now that it makes a call to the <code>position</code> function. Can we make it faster?</p>
<h2 id="optimize-position"><span id="f0338cf15ddb49099abf6a135a0961d7"></span>Optimize position</h2>
<p>The <code>position</code> function exists on streams and looks like this:</p>
<pre class="text"><code>class _CharStream(_Stream):

    def position(self):
        return (self._line, self._column)

    ...</code></pre>
<pre class="text"><code>class _ObjectStream(_Stream):

    def position(self):
        return self._parent + (self._position,)

    ...</code></pre>
<p>Every time it is called, a new tuple is created. What if we refactor it to create the position only once and return it when the <code>position</code> function is called?</p>
<p>With this change, the position is created in the constructor and just returned. The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/3cbf3437cf0478bd899ec6c6c839b3f07c32f86b#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.392s
user  0m0.364s
sys 0m0.026s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         274963 function calls (238101 primitive calls) in 0.220 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4177/252    0.020    0.000    0.206    0.001 rlmeta.py:12(_or)
  11129/2    0.020    0.000    0.212    0.106 rlmeta.py:48(_match_rule)
     8460    0.014    0.000    0.022    0.000 rlmeta.py:219(fail)
     7021    0.012    0.000    0.057    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.010    0.000    0.212    0.106 rlmeta.py:21(_and)
     9099    0.009    0.000    0.021    0.000 rlmeta.py:269(_advance)
    10540    0.009    0.000    0.039    0.000 rlmeta.py:251(next)
     9100    0.008    0.000    0.011    0.000 rlmeta.py:261(__init__)
    12801    0.006    0.000    0.006    0.000 {method 'format' of 'str' objects}
     1443    0.006    0.000    0.009    0.000 rlmeta.py:161(write)
...</code></pre>
<p>The overall compilation time went from <strong>0.406s</strong> to <strong>0.392s</strong>. The compilation time for a single grammar did not change. Did anything improve? Perhaps not. But because the overall compilation time improved and the resulting code is not worse, we keep this change.</p>
<p>A new function has floated up the list, and that is <code>_match_charseq</code>. It looks like this:</p>
<pre class="text"><code>def _match_charseq(self, charseq):
    for char in charseq:
        original_stream = self._stream
        next_object, self._stream = self._stream.next()
        if next_object != char:
            original_stream.fail(
                &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
    return _SemanticAction(lambda: charseq)</code></pre>
<p>There is no obvious way to optimize it. But we notice the formatting of the fail message. The <code>format</code> function shows up on the list a bit further down. We observe that fail messages are seldom used. Only the last fail message is presented to the user. So formatting all fail messages is unnecessary. But we still want nice looking fail messages. We try to defer the formatting until it is actually needed.</p>
<h2 id="make-fail-messages-lazy"><span id="a5f5f3907de04b28bdf52a8ba57b4a71"></span>Make fail messages lazy</h2>
<p>To defer fail messages we change them from strings to lambdas. To format a fail message, the lambda has to be called. With this change, the <code>_match_charseq</code> function looks like this:</p>
<pre class="text"><code>def _match_charseq(self, charseq):
    for char in charseq:
        original_stream = self._stream
        next_object, self._stream = self._stream.next()
        if next_object != char:
            original_stream.fail(
                lambda: &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
    return _SemanticAction(lambda: charseq)</code></pre>
<p>The complete diff can be viewed online <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/d32dfb7235b2d1353d8045dc1999a6dc07f493bf#diff-f500390afaa13cfd96d938b9065dc0c1">here</a> and <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/dd3d3b8c35744b6d5e5ef42dbd46aafa9e1331ad#diff-f500390afaa13cfd96d938b9065dc0c1">here</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.370s
user  0m0.336s
sys 0m0.034s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         268387 function calls (231525 primitive calls) in 0.204 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 4177/252    0.020    0.000    0.194    0.001 rlmeta.py:12(_or)
  11129/2    0.019    0.000    0.199    0.100 rlmeta.py:48(_match_rule)
     8460    0.013    0.000    0.021    0.000 rlmeta.py:219(fail)
     7021    0.010    0.000    0.050    0.000 rlmeta.py:79(_match_charseq)
     9099    0.010    0.000    0.021    0.000 rlmeta.py:269(_advance)
   9010/2    0.009    0.000    0.199    0.100 rlmeta.py:21(_and)
    10540    0.008    0.000    0.038    0.000 rlmeta.py:251(next)
     9100    0.007    0.000    0.011    0.000 rlmeta.py:261(__init__)
     8460    0.006    0.000    0.006    0.000 rlmeta.py:227(__init__)
     1443    0.005    0.000    0.008    0.000 rlmeta.py:161(write)
    10908    0.004    0.000    0.004    0.000 rlmeta.py:243(__init__)
     8460    0.004    0.000    0.025    0.000 rlmeta.py:248(fail)
    10993    0.004    0.000    0.005    0.000 rlmeta.py:256(is_at_end)
    885/5    0.004    0.000    0.199    0.040 rlmeta.py:27(_star)
 3274/747    0.004    0.000    0.005    0.000 rlmeta.py:141(create)
    12616    0.003    0.000    0.003    0.000 {method 'write' of 'cStringIO.StringO' objects}
    17881    0.002    0.000    0.002    0.000 rlmeta.py:266(position)
     1802    0.002    0.000    0.014    0.000 rlmeta.py:59(_match_range)
     6225    0.002    0.000    0.002    0.000 {method 'format' of 'str' objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.392s</strong> to <strong>0.370s</strong>. The compilation time for a single grammar went from <strong>0.220s</strong> to <strong>0.204s</strong>. Time spent formatting strings went from <strong>0.006s</strong> to <strong>0.002s</strong>.</p>
<p>When we take another look at <code>_match_charseq</code>, which is still taking much time, we see that the <code>next</code> function is called, resulting in a tuple being created and returned. But if the check fails, we have done some unnecessary work like assigning to <code>self._stream</code> and advancing the stream. Let's see if we can avoid that by implementing a peek function.</p>
<h2 id="ec92a13304692857a6d4de445e4d2peek">[]{#898ec92a13304692857a6d4de445e4d2}Peek</h2>
<p>Streams implement a <code>next</code> function which returns the next object and a new stream representing the rest of the objects. If a matcher fails after examining the next object, the rest of the objects are never used. We therefore split the <code>next</code> function into two: <code>peek</code> and <code>advance</code>. The <code>_match_charseq</code> function then looks like this:</p>
<pre class="text"><code>def _match_charseq(self, charseq):
    for char in charseq:
        next_object = self._stream.peek()
        if next_object != char:
            self._stream.fail(
                lambda: &quot;expected {!r} but found {!r}&quot;.format(char, next_object)
            )
        self._stream = self._stream.advance()
    return _SemanticAction(lambda: charseq)</code></pre>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/6bcd1457c0fc4726c0d7bc5020a77dcef7f05ed3#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.351s
user  0m0.319s
sys 0m0.031s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         248506 function calls (211644 primitive calls) in 0.187 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  11129/2    0.019    0.000    0.182    0.091 rlmeta.py:48(_match_rule)
 4177/252    0.018    0.000    0.177    0.001 rlmeta.py:12(_or)
     8460    0.013    0.000    0.022    0.000 rlmeta.py:221(fail)
     7021    0.010    0.000    0.037    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.009    0.000    0.182    0.091 rlmeta.py:21(_and)
     8460    0.006    0.000    0.006    0.000 rlmeta.py:229(__init__)
    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)
     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)
    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)
    885/5    0.004    0.000    0.182    0.036 rlmeta.py:27(_star)
     8460    0.004    0.000    0.025    0.000 rlmeta.py:250(fail)
 3274/747    0.003    0.000    0.005    0.000 rlmeta.py:143(create)
     1802    0.003    0.000    0.011    0.000 rlmeta.py:59(_match_range)
     2574    0.003    0.000    0.006    0.000 rlmeta.py:271(advance)
    17881    0.002    0.000    0.002    0.000 rlmeta.py:268(position)
    12616    0.002    0.000    0.002    0.000 {method 'write' of 'cStringIO.StringO' objects}
     2575    0.002    0.000    0.004    0.000 rlmeta.py:263(__init__)
     6225    0.002    0.000    0.002    0.000 {method 'format' of 'str' objects}
...</code></pre>
<p>The overall compilation time went from <strong>0.370s</strong> to <strong>0.351s</strong>. The compilation time for a single grammar went from <strong>0.204s</strong> to <strong>0.187s</strong>.</p>
<p>The <code>_or</code> and <code>fail</code> functions are still high on the list. We think of one more optimization we can do there.</p>
<h2 id="d9e890742c41d48fc1afc2009815c7no-exception-for-last-or">[]{#84d9e890742c41d48fc1afc2009815c7}No exception for last or</h2>
<p>The <code>_or</code> function looks like this:</p>
<pre class="text"><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    original_stream.fail(lambda: &quot;no choice matched&quot;)</code></pre>
<p>If it gets three matchers that all fail, the <code>fail</code> function will be called four times. This is unnecessary. If all but the last matchers have failed, there is no need to catch the exception from the last matcher. We can just let it fail and the failure will be handled higher up the call stack. We rewrite the <code>_or</code> function so that it instead looks like this:</p>
<pre class="text"><code>def _or(self, matchers):
    original_stream = self._stream
    for matcher in matchers[:-1]:
        try:
            return matcher()
        except _MatchError:
            self._stream = original_stream
    return matchers[-1]()</code></pre>
<p>This could have been done earlier as well, but we didn't see it then.</p>
<p>The complete diff can be <a href="https://github.com/rickardlindberg/rickardlindberg.me/commit/079d437dee27cca6cf7aa18d4fffdb5b2dd26172#diff-f500390afaa13cfd96d938b9065dc0c1">viewed online</a>.</p>
<p>We create a new version of RLMeta and then we measure:</p>
<pre class="text"><code>$ time ./compile.sh rlmeta.py &gt; /dev/null

real  0m0.344s
user  0m0.312s
sys 0m0.030s</code></pre>
<pre class="text"><code>$ python -m cProfile -s tottime rlmeta.py &lt; parser.rlmeta
...
         240951 function calls (204089 primitive calls) in 0.185 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  11129/2    0.019    0.000    0.180    0.090 rlmeta.py:48(_match_rule)
 4177/252    0.017    0.000    0.175    0.001 rlmeta.py:12(_or)
     6949    0.011    0.000    0.017    0.000 rlmeta.py:221(fail)
     7021    0.010    0.000    0.038    0.000 rlmeta.py:79(_match_charseq)
   9010/2    0.010    0.000    0.180    0.090 rlmeta.py:21(_and)
    10540    0.005    0.000    0.011    0.000 rlmeta.py:253(peek)
     1443    0.005    0.000    0.008    0.000 rlmeta.py:163(write)
     6949    0.004    0.000    0.004    0.000 rlmeta.py:229(__init__)
    10993    0.004    0.000    0.005    0.000 rlmeta.py:258(is_at_end)
    885/5    0.004    0.000    0.180    0.036 rlmeta.py:27(_star)
...</code></pre>
<p>The overall compilation time went from <strong>0.351s</strong> to <strong>0.344s</strong>. The compilation time for a single grammar went from <strong>0.187s</strong> to <strong>0.185s</strong>.</p>
<p>We can't tell if it is better or worse. But it should reduce one exception catch/throw. We therefore keep it.</p>
<p>We are seeing mostly small performance gains now, so we will stop here.</p>
<h2 id="eda03f5c40458ac9439def097739conclusions">[]{#3616eda03f5c40458ac9439def097739}Conclusions</h2>
<p>The overall compilation time went from <strong>0.756s</strong> to <strong>0.344s</strong>. The compilation time for a single grammar went from <strong>0.476s</strong> to <strong>0.185s</strong>. This is roughly twice as fast. Not that bad. Below is a graph that shows how performance improved with the different optimizations:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
</center>
<p>Some of the optimizations were significant, others not. Should we have focused only on the ones that were significant and discarded the rest? Usually better performance means less readable code. So if the performance gain is not significant, but the code becomes less readable, is it worth it? In particular, did we fall in love with the and/or optimization? We have read that <a href="http://www.vpri.org/pdf/tr2008003_experimenting.pdf">OMeta</a> uses it, so we wanted to be equally cool, but our measurements showed only slight performance increase.</p>
<p>Sometimes it was difficult to determine if a change led to faster compilation or not. The <code>time</code> command is not a reliable tool for performance measurements. We could perhaps have gotten better results by compiling bigger grammars so that small changes in time had been less significant.</p>
<p>There are probably many more optimizations that can be done to RLMeta that we didn't think of in this article. If you find any, let me know.</p>
<h2 id="aafb64996414339b01b0d407e6e1810code-listings-for-rlmeta">[]{#3aafb64996414339b01b0d407e6e1810}Code listings for RLMeta</h2>
<h3 id="e1c4c119f90be842c1b9577parser.rlmeta">[]{#496100180e1c4c119f90be842c1b9577}parser.rlmeta</h3>
<pre><code>1.  parser.rlmeta</code></pre>
<pre class="rlmeta"><code>Parser {
  grammar =
    | name:x space '{' rule*:ys space '}'      -&gt; [&quot;Grammar&quot; x ~ys]
  rule =
    | name:x space '=' choice:y                -&gt; [&quot;Rule&quot; x y]
  choice =
    | (space '|')?
      sequence:x (space '|' sequence)*:xs      -&gt; [&quot;Or&quot; x ~xs]
  sequence =
    | expr:x expr*:xs                          -&gt; [&quot;Scope&quot; [&quot;And&quot; x ~xs]]
  expr =
    | expr1:x space ':' name:y                 -&gt; [&quot;Bind&quot; y x]
    | expr1
  expr1 =
    | expr2:x space '*'                        -&gt; [&quot;Star&quot; x]
    | expr2:x space '?'                        -&gt; [&quot;Or&quot; x [&quot;And&quot;]]
    | space '!' expr2:x                        -&gt; [&quot;Not&quot; x]
    | space '%'                                -&gt; [&quot;MatchCallRule&quot;]
    | expr2
  expr2 =
    | space '-&gt;' hostExpr:x                    -&gt; [&quot;SemanticAction&quot; x]
    | name:x !(space '=')                      -&gt; [&quot;MatchRule&quot; x]
    | space char:x '-' char:y                  -&gt; [&quot;MatchRange&quot; x y]
    | space string:x                           -&gt; [&quot;MatchString&quot; x]
    | space charseq:x                          -&gt; [&quot;MatchCharseq&quot; x]
    | space '.'                                -&gt; [&quot;MatchAny&quot;]
    | space '(' choice:x space ')'             -&gt; x
    | space '[' expr*:xs space ']'             -&gt; [&quot;MatchList&quot; [&quot;And&quot; ~xs]]
  hostExpr =
    | space string:x                           -&gt; [&quot;String&quot; x]
    | space '[' hostExprListItem*:xs space ']' -&gt; [&quot;List&quot; ~xs]
    | space '{' buildExpr*:xs space '}'        -&gt; [&quot;Builder&quot; ~xs]
    | name:x space '(' hostExpr*:ys space ')'  -&gt; [&quot;FnCall&quot; x ~ys]
    | name:x                                   -&gt; [&quot;VarLookup&quot; x]
  hostExprListItem =
    | space '~' hostExpr:x                     -&gt; [&quot;ListItemSplice&quot; x]
    | hostExpr
  buildExpr =
    | space '&gt;'                                -&gt; [&quot;IndentBuilder&quot;]
    | space '&lt;'                                -&gt; [&quot;DedentBuilder&quot;]
    | hostExpr
  string    = '&quot;'  (!'&quot;'  innerChar)*:xs '&quot;'   -&gt; join(xs)
  charseq   = '\'' (!'\'' innerChar)*:xs '\''  -&gt; join(xs)
  char      = '\''  !'\'' innerChar  :x  '\''  -&gt; x
  innerChar = '\\' escape | .
  escape    = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
            | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
  name      = space nameStart:x nameChar*:xs   -&gt; join([x ~xs])
  nameStart = 'a'-'z' | 'A'-'Z'
  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'
  space     = (' ' | '\n')*
}</code></pre>
<h3 id="bd8846187ad478aa17439370f0da1e6codegenerator.rlmeta">[]{#7bd8846187ad478aa17439370f0da1e6}codegenerator.rlmeta</h3>
<pre><code>1.  codegenerator.rlmeta</code></pre>
<pre class="rlmeta"><code>CodeGenerator {
  Grammar        = .:x ast*:ys     -&gt; { &quot;class &quot; x &quot;(_Grammar):\n&quot; &gt; ys &lt;                       }
  Rule           = .:x ast:y       -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt;     }
  MatchAny       =                 -&gt; { &quot;self._match_any&quot;                                       }
  MatchCallRule  =                 -&gt; { &quot;self._match_call_rule&quot;                                 }
  String         = .:x             -&gt; { repr(x)                                                 }
  List           = astList:x       -&gt; { x                                                       }
  Builder        = astItems:x      -&gt; { &quot;_Builder.create([&quot; x &quot;])&quot;                              }
  IndentBuilder  =                 -&gt; { &quot;_IndentBuilder()&quot;                                      }
  DedentBuilder  =                 -&gt; { &quot;_DedentBuilder()&quot;                                      }
  FnCall         = .:x astItems:y  -&gt; { x &quot;(&quot; y &quot;)&quot;                                             }
  VarLookup      = .:x             -&gt; { &quot;_vars.lookup(&quot; repr(x) &quot;).eval()&quot;                      }
  Or             =
    | ast:x !.                     -&gt; x
    | astItems:x                   -&gt; { &quot;(lambda: self._or([&quot; x &quot;]))&quot;                           }
  Scope          = ast:x           -&gt; { &quot;(lambda: (lambda _vars:\n&quot; &gt; x &lt; &quot;()\n)(_Vars()))&quot;     }
  And            =
    | ast:x !.                     -&gt; x
    | astItems:x                   -&gt; { &quot;(lambda: self._and([&quot; x &quot;]))&quot;                          }
  Bind           = .:x ast:y       -&gt; { &quot;(lambda: _vars.bind(&quot; repr(x) &quot;, &quot; y &quot;()))&quot;            }
  Star           = ast:x           -&gt; { &quot;(lambda: self._star(&quot; x &quot;))&quot;                           }
  Not            = ast:x           -&gt; { &quot;(lambda: self._not(&quot; x &quot;))&quot;                            }
  SemanticAction = ast:x           -&gt; { &quot;(lambda: _SemanticAction(lambda: &quot; x &quot;))&quot;              }
  MatchRule      = .:x             -&gt; { &quot;(lambda: self._match_rule(&quot; repr(x) &quot;))&quot;               }
  MatchRange     = .:x .:y         -&gt; { &quot;(lambda: self._match_range(&quot; repr(x) &quot;, &quot; repr(y) &quot;))&quot; }
  MatchString    = .:x             -&gt; { &quot;(lambda: self._match_string(&quot; repr(x) &quot;))&quot;             }
  MatchCharseq   = .:x             -&gt; { &quot;(lambda: self._match_charseq(&quot; repr(x) &quot;))&quot;            }
  MatchList      = ast:x           -&gt; { &quot;(lambda: self._match_list(&quot; x &quot;))&quot;                     }
  ast            = [%:x]           -&gt; x
  astItems       = astItem*:xs     -&gt; { &quot;\n&quot; &gt; xs &lt;                                             }
  astItem        = ast:x           -&gt; { x &quot;,\n&quot;                                                 }
  astList        = astListItem*:xs -&gt; { &quot;(&quot; xs &quot;[])&quot;                                            }
  astListItem    =
    | [&quot;ListItemSplice&quot; ast:x]     -&gt; {     x  &quot;+&quot;                                              }
    | ast:x                        -&gt; { &quot;[&quot; x &quot;]+&quot;                                              }
}</code></pre>
<h3 id="support.py"><span id="ecfe26a58495420b8871e522c6859a4a"></span>support.py</h3>
<pre><code>1.  support.py</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="cf">try</span>:</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>    <span class="im">from</span> cStringIO <span class="im">import</span> StringIO</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a><span class="cf">except</span>:</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>    <span class="im">from</span> StringIO <span class="im">import</span> StringIO</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a><span class="kw">class</span> _Grammar(<span class="bu">object</span>):</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>    <span class="kw">def</span> _or(<span class="va">self</span>, matchers):</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>        original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>        <span class="cf">for</span> matcher <span class="kw">in</span> matchers[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a>            <span class="cf">try</span>:</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true"></a>                <span class="cf">return</span> matcher()</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true"></a>            <span class="cf">except</span> _MatchError:</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true"></a>                <span class="va">self</span>._stream <span class="op">=</span> original_stream</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true"></a>        <span class="cf">return</span> matchers[<span class="op">-</span><span class="dv">1</span>]()</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true"></a></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true"></a>    <span class="kw">def</span> _and(<span class="va">self</span>, matchers):</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true"></a>        result <span class="op">=</span> <span class="va">None</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true"></a>        <span class="cf">for</span> matcher <span class="kw">in</span> matchers:</span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true"></a>            result <span class="op">=</span> matcher()</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true"></a>        <span class="cf">return</span> result</span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true"></a></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true"></a>    <span class="kw">def</span> _star(<span class="va">self</span>, matcher):</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true"></a>        result <span class="op">=</span> []</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true"></a>            original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true"></a>            <span class="cf">try</span>:</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true"></a>                result.append(matcher())</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true"></a>            <span class="cf">except</span> _MatchError:</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true"></a>                <span class="va">self</span>._stream <span class="op">=</span> original_stream</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true"></a>                <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: [x.<span class="bu">eval</span>() <span class="cf">for</span> x <span class="kw">in</span> result])</span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true"></a></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true"></a>    <span class="kw">def</span> _not(<span class="va">self</span>, matcher):</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true"></a>        original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true"></a>        <span class="cf">try</span>:</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true"></a>            matcher()</span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true"></a>        <span class="cf">except</span> _MatchError:</span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true"></a>            <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: <span class="va">None</span>)</span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true"></a>            original_stream.fail(<span class="kw">lambda</span>: <span class="st">&quot;match found&quot;</span>)</span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true"></a>        <span class="cf">finally</span>:</span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> original_stream</span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true"></a></span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true"></a>    <span class="kw">def</span> _match_rule(<span class="va">self</span>, rule_name):</span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true"></a>        key <span class="op">=</span> (rule_name, <span class="va">self</span>._stream.position())</span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true"></a>        <span class="cf">if</span> key <span class="kw">in</span> <span class="va">self</span>._memo:</span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true"></a>            result, _, <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._memo[key]</span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true"></a>            start <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true"></a>            result <span class="op">=</span> <span class="bu">getattr</span>(<span class="va">self</span>, <span class="st">&quot;_rule_</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(rule_name))()</span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true"></a>            end <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true"></a>            <span class="va">self</span>._memo[key] <span class="op">=</span> (result, start, end)</span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true"></a>        <span class="cf">return</span> result</span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true"></a></span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true"></a>    <span class="kw">def</span> _match_range(<span class="va">self</span>, start, end):</span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true"></a>        next_objext <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true"></a>        <span class="cf">if</span> next_objext <span class="op">&gt;=</span> start <span class="kw">and</span> next_objext <span class="op">&lt;=</span> end:</span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true"></a>            <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: next_objext)</span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-61"><a href="#cb57-61" aria-hidden="true"></a>            <span class="va">self</span>._stream.fail(</span>
<span id="cb57-62"><a href="#cb57-62" aria-hidden="true"></a>                <span class="kw">lambda</span>: <span class="st">&quot;expected range </span><span class="sc">{!r}</span><span class="st">-</span><span class="sc">{!r}</span><span class="st"> but found </span><span class="sc">{!r}</span><span class="st">&quot;</span>.<span class="bu">format</span>(start, end, next_objext)</span>
<span id="cb57-63"><a href="#cb57-63" aria-hidden="true"></a>            )</span>
<span id="cb57-64"><a href="#cb57-64" aria-hidden="true"></a></span>
<span id="cb57-65"><a href="#cb57-65" aria-hidden="true"></a>    <span class="kw">def</span> _match_string(<span class="va">self</span>, string):</span>
<span id="cb57-66"><a href="#cb57-66" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-67"><a href="#cb57-67" aria-hidden="true"></a>        <span class="cf">if</span> next_object <span class="op">==</span> string:</span>
<span id="cb57-68"><a href="#cb57-68" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-69"><a href="#cb57-69" aria-hidden="true"></a>            <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: string)</span>
<span id="cb57-70"><a href="#cb57-70" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-71"><a href="#cb57-71" aria-hidden="true"></a>            <span class="va">self</span>._stream.fail(</span>
<span id="cb57-72"><a href="#cb57-72" aria-hidden="true"></a>                <span class="kw">lambda</span>: <span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st"> but found </span><span class="sc">{!r}</span><span class="st">&quot;</span>.<span class="bu">format</span>(string, next_object)</span>
<span id="cb57-73"><a href="#cb57-73" aria-hidden="true"></a>            )</span>
<span id="cb57-74"><a href="#cb57-74" aria-hidden="true"></a></span>
<span id="cb57-75"><a href="#cb57-75" aria-hidden="true"></a>    <span class="kw">def</span> _match_charseq(<span class="va">self</span>, charseq):</span>
<span id="cb57-76"><a href="#cb57-76" aria-hidden="true"></a>        <span class="cf">for</span> char <span class="kw">in</span> charseq:</span>
<span id="cb57-77"><a href="#cb57-77" aria-hidden="true"></a>            next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-78"><a href="#cb57-78" aria-hidden="true"></a>            <span class="cf">if</span> next_object <span class="op">!=</span> char:</span>
<span id="cb57-79"><a href="#cb57-79" aria-hidden="true"></a>                <span class="va">self</span>._stream.fail(</span>
<span id="cb57-80"><a href="#cb57-80" aria-hidden="true"></a>                    <span class="kw">lambda</span>: <span class="st">&quot;expected </span><span class="sc">{!r}</span><span class="st"> but found </span><span class="sc">{!r}</span><span class="st">&quot;</span>.<span class="bu">format</span>(char, next_object)</span>
<span id="cb57-81"><a href="#cb57-81" aria-hidden="true"></a>                )</span>
<span id="cb57-82"><a href="#cb57-82" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-83"><a href="#cb57-83" aria-hidden="true"></a>        <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: charseq)</span>
<span id="cb57-84"><a href="#cb57-84" aria-hidden="true"></a></span>
<span id="cb57-85"><a href="#cb57-85" aria-hidden="true"></a>    <span class="kw">def</span> _match_any(<span class="va">self</span>):</span>
<span id="cb57-86"><a href="#cb57-86" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-87"><a href="#cb57-87" aria-hidden="true"></a>        <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-88"><a href="#cb57-88" aria-hidden="true"></a>        <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: next_object)</span>
<span id="cb57-89"><a href="#cb57-89" aria-hidden="true"></a></span>
<span id="cb57-90"><a href="#cb57-90" aria-hidden="true"></a>    <span class="kw">def</span> _match_call_rule(<span class="va">self</span>):</span>
<span id="cb57-91"><a href="#cb57-91" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-92"><a href="#cb57-92" aria-hidden="true"></a>        <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.advance()</span>
<span id="cb57-93"><a href="#cb57-93" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._match_rule(<span class="bu">str</span>(next_object))</span>
<span id="cb57-94"><a href="#cb57-94" aria-hidden="true"></a></span>
<span id="cb57-95"><a href="#cb57-95" aria-hidden="true"></a>    <span class="kw">def</span> _match_list(<span class="va">self</span>, matcher):</span>
<span id="cb57-96"><a href="#cb57-96" aria-hidden="true"></a>        original_stream <span class="op">=</span> <span class="va">self</span>._stream</span>
<span id="cb57-97"><a href="#cb57-97" aria-hidden="true"></a>        next_object <span class="op">=</span> <span class="va">self</span>._stream.peek()</span>
<span id="cb57-98"><a href="#cb57-98" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(next_object, <span class="bu">list</span>):</span>
<span id="cb57-99"><a href="#cb57-99" aria-hidden="true"></a>            <span class="va">self</span>._stream <span class="op">=</span> <span class="va">self</span>._stream.nested(next_object)</span>
<span id="cb57-100"><a href="#cb57-100" aria-hidden="true"></a>            matcher()</span>
<span id="cb57-101"><a href="#cb57-101" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>._stream.is_at_end():</span>
<span id="cb57-102"><a href="#cb57-102" aria-hidden="true"></a>                <span class="va">self</span>._stream <span class="op">=</span> original_stream.advance()</span>
<span id="cb57-103"><a href="#cb57-103" aria-hidden="true"></a>                <span class="cf">return</span> _SemanticAction(<span class="kw">lambda</span>: next_object)</span>
<span id="cb57-104"><a href="#cb57-104" aria-hidden="true"></a>        original_stream.fail(<span class="kw">lambda</span>: <span class="st">&quot;list match failed&quot;</span>)</span>
<span id="cb57-105"><a href="#cb57-105" aria-hidden="true"></a></span>
<span id="cb57-106"><a href="#cb57-106" aria-hidden="true"></a>    <span class="kw">def</span> run(<span class="va">self</span>, rule_name, input_object):</span>
<span id="cb57-107"><a href="#cb57-107" aria-hidden="true"></a>        <span class="va">self</span>._memo <span class="op">=</span> _Memo()</span>
<span id="cb57-108"><a href="#cb57-108" aria-hidden="true"></a>        <span class="va">self</span>._stream <span class="op">=</span> _Stream.from_object(<span class="va">self</span>._memo, input_object)</span>
<span id="cb57-109"><a href="#cb57-109" aria-hidden="true"></a>        result <span class="op">=</span> <span class="va">self</span>._match_rule(rule_name).<span class="bu">eval</span>()</span>
<span id="cb57-110"><a href="#cb57-110" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(result, _Builder):</span>
<span id="cb57-111"><a href="#cb57-111" aria-hidden="true"></a>            <span class="cf">return</span> result.build_string()</span>
<span id="cb57-112"><a href="#cb57-112" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-113"><a href="#cb57-113" aria-hidden="true"></a>            <span class="cf">return</span> result</span>
<span id="cb57-114"><a href="#cb57-114" aria-hidden="true"></a></span>
<span id="cb57-115"><a href="#cb57-115" aria-hidden="true"></a><span class="kw">class</span> _Vars(<span class="bu">dict</span>):</span>
<span id="cb57-116"><a href="#cb57-116" aria-hidden="true"></a></span>
<span id="cb57-117"><a href="#cb57-117" aria-hidden="true"></a>    <span class="kw">def</span> bind(<span class="va">self</span>, name, value):</span>
<span id="cb57-118"><a href="#cb57-118" aria-hidden="true"></a>        <span class="va">self</span>[name] <span class="op">=</span> value</span>
<span id="cb57-119"><a href="#cb57-119" aria-hidden="true"></a>        <span class="cf">return</span> value</span>
<span id="cb57-120"><a href="#cb57-120" aria-hidden="true"></a></span>
<span id="cb57-121"><a href="#cb57-121" aria-hidden="true"></a>    <span class="kw">def</span> lookup(<span class="va">self</span>, name):</span>
<span id="cb57-122"><a href="#cb57-122" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>[name]</span>
<span id="cb57-123"><a href="#cb57-123" aria-hidden="true"></a></span>
<span id="cb57-124"><a href="#cb57-124" aria-hidden="true"></a><span class="kw">class</span> _SemanticAction(<span class="bu">object</span>):</span>
<span id="cb57-125"><a href="#cb57-125" aria-hidden="true"></a></span>
<span id="cb57-126"><a href="#cb57-126" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, fn):</span>
<span id="cb57-127"><a href="#cb57-127" aria-hidden="true"></a>        <span class="va">self</span>.fn <span class="op">=</span> fn</span>
<span id="cb57-128"><a href="#cb57-128" aria-hidden="true"></a></span>
<span id="cb57-129"><a href="#cb57-129" aria-hidden="true"></a>    <span class="kw">def</span> <span class="bu">eval</span>(<span class="va">self</span>):</span>
<span id="cb57-130"><a href="#cb57-130" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.fn()</span>
<span id="cb57-131"><a href="#cb57-131" aria-hidden="true"></a></span>
<span id="cb57-132"><a href="#cb57-132" aria-hidden="true"></a><span class="kw">class</span> _Builder(<span class="bu">object</span>):</span>
<span id="cb57-133"><a href="#cb57-133" aria-hidden="true"></a></span>
<span id="cb57-134"><a href="#cb57-134" aria-hidden="true"></a>    <span class="kw">def</span> build_string(<span class="va">self</span>):</span>
<span id="cb57-135"><a href="#cb57-135" aria-hidden="true"></a>        output <span class="op">=</span> _Output()</span>
<span id="cb57-136"><a href="#cb57-136" aria-hidden="true"></a>        <span class="va">self</span>.write(output)</span>
<span id="cb57-137"><a href="#cb57-137" aria-hidden="true"></a>        <span class="cf">return</span> output.value</span>
<span id="cb57-138"><a href="#cb57-138" aria-hidden="true"></a></span>
<span id="cb57-139"><a href="#cb57-139" aria-hidden="true"></a>    <span class="at">@classmethod</span></span>
<span id="cb57-140"><a href="#cb57-140" aria-hidden="true"></a>    <span class="kw">def</span> create(<span class="va">self</span>, item):</span>
<span id="cb57-141"><a href="#cb57-141" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(item, _Builder):</span>
<span id="cb57-142"><a href="#cb57-142" aria-hidden="true"></a>            <span class="cf">return</span> item</span>
<span id="cb57-143"><a href="#cb57-143" aria-hidden="true"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(item, <span class="bu">list</span>):</span>
<span id="cb57-144"><a href="#cb57-144" aria-hidden="true"></a>            <span class="cf">return</span> _ListBuilder([_Builder.create(x) <span class="cf">for</span> x <span class="kw">in</span> item])</span>
<span id="cb57-145"><a href="#cb57-145" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-146"><a href="#cb57-146" aria-hidden="true"></a>            <span class="cf">return</span> _AtomBuilder(item)</span>
<span id="cb57-147"><a href="#cb57-147" aria-hidden="true"></a></span>
<span id="cb57-148"><a href="#cb57-148" aria-hidden="true"></a><span class="kw">class</span> _Output(<span class="bu">object</span>):</span>
<span id="cb57-149"><a href="#cb57-149" aria-hidden="true"></a></span>
<span id="cb57-150"><a href="#cb57-150" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb57-151"><a href="#cb57-151" aria-hidden="true"></a>        <span class="va">self</span>.<span class="bu">buffer</span> <span class="op">=</span> StringIO()</span>
<span id="cb57-152"><a href="#cb57-152" aria-hidden="true"></a>        <span class="va">self</span>.indentation <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb57-153"><a href="#cb57-153" aria-hidden="true"></a>        <span class="va">self</span>.on_newline <span class="op">=</span> <span class="va">True</span></span>
<span id="cb57-154"><a href="#cb57-154" aria-hidden="true"></a></span>
<span id="cb57-155"><a href="#cb57-155" aria-hidden="true"></a>    <span class="at">@property</span></span>
<span id="cb57-156"><a href="#cb57-156" aria-hidden="true"></a>    <span class="kw">def</span> value(<span class="va">self</span>):</span>
<span id="cb57-157"><a href="#cb57-157" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">buffer</span>.getvalue()</span>
<span id="cb57-158"><a href="#cb57-158" aria-hidden="true"></a></span>
<span id="cb57-159"><a href="#cb57-159" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, value):</span>
<span id="cb57-160"><a href="#cb57-160" aria-hidden="true"></a>        <span class="cf">for</span> ch <span class="kw">in</span> value:</span>
<span id="cb57-161"><a href="#cb57-161" aria-hidden="true"></a>            is_linebreak <span class="op">=</span> ch <span class="op">==</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb57-162"><a href="#cb57-162" aria-hidden="true"></a>            <span class="cf">if</span> <span class="va">self</span>.indentation <span class="kw">and</span> <span class="va">self</span>.on_newline <span class="kw">and</span> <span class="kw">not</span> is_linebreak:</span>
<span id="cb57-163"><a href="#cb57-163" aria-hidden="true"></a>                <span class="va">self</span>.<span class="bu">buffer</span>.write(<span class="st">&quot;    &quot;</span><span class="op">*</span><span class="va">self</span>.indentation)</span>
<span id="cb57-164"><a href="#cb57-164" aria-hidden="true"></a>            <span class="va">self</span>.<span class="bu">buffer</span>.write(ch)</span>
<span id="cb57-165"><a href="#cb57-165" aria-hidden="true"></a>            <span class="va">self</span>.on_newline <span class="op">=</span> is_linebreak</span>
<span id="cb57-166"><a href="#cb57-166" aria-hidden="true"></a></span>
<span id="cb57-167"><a href="#cb57-167" aria-hidden="true"></a><span class="kw">class</span> _ListBuilder(_Builder):</span>
<span id="cb57-168"><a href="#cb57-168" aria-hidden="true"></a></span>
<span id="cb57-169"><a href="#cb57-169" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, builders):</span>
<span id="cb57-170"><a href="#cb57-170" aria-hidden="true"></a>        <span class="va">self</span>.builders <span class="op">=</span> builders</span>
<span id="cb57-171"><a href="#cb57-171" aria-hidden="true"></a></span>
<span id="cb57-172"><a href="#cb57-172" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-173"><a href="#cb57-173" aria-hidden="true"></a>        <span class="cf">for</span> builder <span class="kw">in</span> <span class="va">self</span>.builders:</span>
<span id="cb57-174"><a href="#cb57-174" aria-hidden="true"></a>            builder.write(output)</span>
<span id="cb57-175"><a href="#cb57-175" aria-hidden="true"></a></span>
<span id="cb57-176"><a href="#cb57-176" aria-hidden="true"></a><span class="kw">class</span> _AtomBuilder(_Builder):</span>
<span id="cb57-177"><a href="#cb57-177" aria-hidden="true"></a></span>
<span id="cb57-178"><a href="#cb57-178" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, atom):</span>
<span id="cb57-179"><a href="#cb57-179" aria-hidden="true"></a>        <span class="va">self</span>.atom <span class="op">=</span> atom</span>
<span id="cb57-180"><a href="#cb57-180" aria-hidden="true"></a></span>
<span id="cb57-181"><a href="#cb57-181" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-182"><a href="#cb57-182" aria-hidden="true"></a>        output.write(<span class="bu">str</span>(<span class="va">self</span>.atom))</span>
<span id="cb57-183"><a href="#cb57-183" aria-hidden="true"></a></span>
<span id="cb57-184"><a href="#cb57-184" aria-hidden="true"></a><span class="kw">class</span> _IndentBuilder(_Builder):</span>
<span id="cb57-185"><a href="#cb57-185" aria-hidden="true"></a></span>
<span id="cb57-186"><a href="#cb57-186" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-187"><a href="#cb57-187" aria-hidden="true"></a>        output.indentation <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb57-188"><a href="#cb57-188" aria-hidden="true"></a></span>
<span id="cb57-189"><a href="#cb57-189" aria-hidden="true"></a><span class="kw">class</span> _DedentBuilder(_Builder):</span>
<span id="cb57-190"><a href="#cb57-190" aria-hidden="true"></a></span>
<span id="cb57-191"><a href="#cb57-191" aria-hidden="true"></a>    <span class="kw">def</span> write(<span class="va">self</span>, output):</span>
<span id="cb57-192"><a href="#cb57-192" aria-hidden="true"></a>        output.indentation <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb57-193"><a href="#cb57-193" aria-hidden="true"></a></span>
<span id="cb57-194"><a href="#cb57-194" aria-hidden="true"></a><span class="kw">class</span> _Memo(<span class="bu">dict</span>):</span>
<span id="cb57-195"><a href="#cb57-195" aria-hidden="true"></a></span>
<span id="cb57-196"><a href="#cb57-196" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb57-197"><a href="#cb57-197" aria-hidden="true"></a>        <span class="bu">dict</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb57-198"><a href="#cb57-198" aria-hidden="true"></a>        <span class="va">self</span>._latest_stream <span class="op">=</span> _ObjectStream(<span class="va">self</span>, [], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb57-199"><a href="#cb57-199" aria-hidden="true"></a>        <span class="va">self</span>._latest_lazy_message <span class="op">=</span> <span class="kw">lambda</span>: <span class="st">&quot;&quot;</span></span>
<span id="cb57-200"><a href="#cb57-200" aria-hidden="true"></a></span>
<span id="cb57-201"><a href="#cb57-201" aria-hidden="true"></a>    <span class="kw">def</span> describe(<span class="va">self</span>):</span>
<span id="cb57-202"><a href="#cb57-202" aria-hidden="true"></a>        items <span class="op">=</span> []</span>
<span id="cb57-203"><a href="#cb57-203" aria-hidden="true"></a>        <span class="cf">for</span> (rule_name, _), (_, start, end) <span class="kw">in</span> <span class="va">self</span>.items():</span>
<span id="cb57-204"><a href="#cb57-204" aria-hidden="true"></a>            <span class="cf">if</span> end <span class="op">&gt;</span> start:</span>
<span id="cb57-205"><a href="#cb57-205" aria-hidden="true"></a>                items.append((rule_name, start, end))</span>
<span id="cb57-206"><a href="#cb57-206" aria-hidden="true"></a>        items.sort(key<span class="op">=</span><span class="kw">lambda</span> item: (item[<span class="dv">2</span>].position(), item[<span class="dv">1</span>].position()))</span>
<span id="cb57-207"><a href="#cb57-207" aria-hidden="true"></a>        message <span class="op">=</span> []</span>
<span id="cb57-208"><a href="#cb57-208" aria-hidden="true"></a>        <span class="cf">for</span> item <span class="kw">in</span> items:</span>
<span id="cb57-209"><a href="#cb57-209" aria-hidden="true"></a>            message.append(<span class="st">&quot;matched </span><span class="sc">{: &lt;20}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> -&gt; </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="op">*</span>item))</span>
<span id="cb57-210"><a href="#cb57-210" aria-hidden="true"></a>        message.append(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb57-211"><a href="#cb57-211" aria-hidden="true"></a>        message.append(<span class="st">&quot;ERROR: </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">&quot;</span>.<span class="bu">format</span>(</span>
<span id="cb57-212"><a href="#cb57-212" aria-hidden="true"></a>            <span class="va">self</span>._latest_stream,</span>
<span id="cb57-213"><a href="#cb57-213" aria-hidden="true"></a>            <span class="va">self</span>._latest_lazy_message()</span>
<span id="cb57-214"><a href="#cb57-214" aria-hidden="true"></a>        ))</span>
<span id="cb57-215"><a href="#cb57-215" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;&quot;</span>.join(message)</span>
<span id="cb57-216"><a href="#cb57-216" aria-hidden="true"></a></span>
<span id="cb57-217"><a href="#cb57-217" aria-hidden="true"></a>    <span class="kw">def</span> fail(<span class="va">self</span>, stream, lazy_message):</span>
<span id="cb57-218"><a href="#cb57-218" aria-hidden="true"></a>        <span class="cf">if</span> stream.position() <span class="op">&gt;=</span> <span class="va">self</span>._latest_stream.position():</span>
<span id="cb57-219"><a href="#cb57-219" aria-hidden="true"></a>            <span class="va">self</span>._latest_stream <span class="op">=</span> stream</span>
<span id="cb57-220"><a href="#cb57-220" aria-hidden="true"></a>            <span class="va">self</span>._latest_lazy_message <span class="op">=</span> lazy_message</span>
<span id="cb57-221"><a href="#cb57-221" aria-hidden="true"></a>        <span class="cf">raise</span> _MatchError(<span class="va">self</span>)</span>
<span id="cb57-222"><a href="#cb57-222" aria-hidden="true"></a></span>
<span id="cb57-223"><a href="#cb57-223" aria-hidden="true"></a><span class="kw">class</span> _MatchError(<span class="pp">Exception</span>):</span>
<span id="cb57-224"><a href="#cb57-224" aria-hidden="true"></a></span>
<span id="cb57-225"><a href="#cb57-225" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo):</span>
<span id="cb57-226"><a href="#cb57-226" aria-hidden="true"></a>        <span class="pp">Exception</span>.<span class="fu">__init__</span>(<span class="va">self</span>)</span>
<span id="cb57-227"><a href="#cb57-227" aria-hidden="true"></a>        <span class="va">self</span>._memo <span class="op">=</span> memo</span>
<span id="cb57-228"><a href="#cb57-228" aria-hidden="true"></a></span>
<span id="cb57-229"><a href="#cb57-229" aria-hidden="true"></a>    <span class="kw">def</span> describe(<span class="va">self</span>):</span>
<span id="cb57-230"><a href="#cb57-230" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._memo.describe()</span>
<span id="cb57-231"><a href="#cb57-231" aria-hidden="true"></a></span>
<span id="cb57-232"><a href="#cb57-232" aria-hidden="true"></a><span class="kw">class</span> _Stream(<span class="bu">object</span>):</span>
<span id="cb57-233"><a href="#cb57-233" aria-hidden="true"></a></span>
<span id="cb57-234"><a href="#cb57-234" aria-hidden="true"></a>    <span class="at">@classmethod</span></span>
<span id="cb57-235"><a href="#cb57-235" aria-hidden="true"></a>    <span class="kw">def</span> from_object(cls, memo, input_object):</span>
<span id="cb57-236"><a href="#cb57-236" aria-hidden="true"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(input_object, <span class="bu">basestring</span>):</span>
<span id="cb57-237"><a href="#cb57-237" aria-hidden="true"></a>            <span class="cf">return</span> _CharStream(memo, input_object, <span class="dv">0</span>)</span>
<span id="cb57-238"><a href="#cb57-238" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-239"><a href="#cb57-239" aria-hidden="true"></a>            <span class="cf">return</span> _ObjectStream(memo, [input_object], <span class="dv">0</span>)</span>
<span id="cb57-240"><a href="#cb57-240" aria-hidden="true"></a></span>
<span id="cb57-241"><a href="#cb57-241" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index):</span>
<span id="cb57-242"><a href="#cb57-242" aria-hidden="true"></a>        <span class="va">self</span>._memo <span class="op">=</span> memo</span>
<span id="cb57-243"><a href="#cb57-243" aria-hidden="true"></a>        <span class="va">self</span>._objects <span class="op">=</span> objects</span>
<span id="cb57-244"><a href="#cb57-244" aria-hidden="true"></a>        <span class="va">self</span>._index <span class="op">=</span> index</span>
<span id="cb57-245"><a href="#cb57-245" aria-hidden="true"></a></span>
<span id="cb57-246"><a href="#cb57-246" aria-hidden="true"></a>    <span class="kw">def</span> fail(<span class="va">self</span>, lazy_message):</span>
<span id="cb57-247"><a href="#cb57-247" aria-hidden="true"></a>        <span class="va">self</span>._memo.fail(<span class="va">self</span>, lazy_message)</span>
<span id="cb57-248"><a href="#cb57-248" aria-hidden="true"></a></span>
<span id="cb57-249"><a href="#cb57-249" aria-hidden="true"></a>    <span class="kw">def</span> peek(<span class="va">self</span>):</span>
<span id="cb57-250"><a href="#cb57-250" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>.is_at_end():</span>
<span id="cb57-251"><a href="#cb57-251" aria-hidden="true"></a>            <span class="va">self</span>.fail(<span class="kw">lambda</span>: <span class="st">&quot;not eof&quot;</span>)</span>
<span id="cb57-252"><a href="#cb57-252" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._objects[<span class="va">self</span>._index]</span>
<span id="cb57-253"><a href="#cb57-253" aria-hidden="true"></a></span>
<span id="cb57-254"><a href="#cb57-254" aria-hidden="true"></a>    <span class="kw">def</span> is_at_end(<span class="va">self</span>):</span>
<span id="cb57-255"><a href="#cb57-255" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._index <span class="op">&gt;=</span> <span class="bu">len</span>(<span class="va">self</span>._objects)</span>
<span id="cb57-256"><a href="#cb57-256" aria-hidden="true"></a></span>
<span id="cb57-257"><a href="#cb57-257" aria-hidden="true"></a><span class="kw">class</span> _CharStream(_Stream):</span>
<span id="cb57-258"><a href="#cb57-258" aria-hidden="true"></a></span>
<span id="cb57-259"><a href="#cb57-259" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index, line<span class="op">=</span><span class="dv">1</span>, column<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb57-260"><a href="#cb57-260" aria-hidden="true"></a>        _Stream.<span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index)</span>
<span id="cb57-261"><a href="#cb57-261" aria-hidden="true"></a>        <span class="va">self</span>._line <span class="op">=</span> line</span>
<span id="cb57-262"><a href="#cb57-262" aria-hidden="true"></a>        <span class="va">self</span>._column <span class="op">=</span> column</span>
<span id="cb57-263"><a href="#cb57-263" aria-hidden="true"></a></span>
<span id="cb57-264"><a href="#cb57-264" aria-hidden="true"></a>    <span class="kw">def</span> position(<span class="va">self</span>):</span>
<span id="cb57-265"><a href="#cb57-265" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._index</span>
<span id="cb57-266"><a href="#cb57-266" aria-hidden="true"></a></span>
<span id="cb57-267"><a href="#cb57-267" aria-hidden="true"></a>    <span class="kw">def</span> advance(<span class="va">self</span>):</span>
<span id="cb57-268"><a href="#cb57-268" aria-hidden="true"></a>        <span class="cf">if</span> <span class="va">self</span>._objects[<span class="va">self</span>._index] <span class="op">==</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>:</span>
<span id="cb57-269"><a href="#cb57-269" aria-hidden="true"></a>            line <span class="op">=</span> <span class="va">self</span>._line <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb57-270"><a href="#cb57-270" aria-hidden="true"></a>            column <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb57-271"><a href="#cb57-271" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb57-272"><a href="#cb57-272" aria-hidden="true"></a>            line <span class="op">=</span> <span class="va">self</span>._line</span>
<span id="cb57-273"><a href="#cb57-273" aria-hidden="true"></a>            column <span class="op">=</span> <span class="va">self</span>._column <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb57-274"><a href="#cb57-274" aria-hidden="true"></a>        <span class="cf">return</span> _CharStream(<span class="va">self</span>._memo, <span class="va">self</span>._objects, <span class="va">self</span>._index<span class="op">+</span><span class="dv">1</span>, line, column)</span>
<span id="cb57-275"><a href="#cb57-275" aria-hidden="true"></a></span>
<span id="cb57-276"><a href="#cb57-276" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb57-277"><a href="#cb57-277" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;L</span><span class="sc">{:03d}</span><span class="st">:C</span><span class="sc">{:03d}</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="va">self</span>._line, <span class="va">self</span>._column)</span>
<span id="cb57-278"><a href="#cb57-278" aria-hidden="true"></a></span>
<span id="cb57-279"><a href="#cb57-279" aria-hidden="true"></a><span class="kw">class</span> _ObjectStream(_Stream):</span>
<span id="cb57-280"><a href="#cb57-280" aria-hidden="true"></a></span>
<span id="cb57-281"><a href="#cb57-281" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index, parent<span class="op">=</span>()):</span>
<span id="cb57-282"><a href="#cb57-282" aria-hidden="true"></a>        _Stream.<span class="fu">__init__</span>(<span class="va">self</span>, memo, objects, index)</span>
<span id="cb57-283"><a href="#cb57-283" aria-hidden="true"></a>        <span class="va">self</span>._parent_position <span class="op">=</span> parent</span>
<span id="cb57-284"><a href="#cb57-284" aria-hidden="true"></a>        <span class="va">self</span>._position <span class="op">=</span> <span class="va">self</span>._parent_position <span class="op">+</span> (<span class="va">self</span>._index,)</span>
<span id="cb57-285"><a href="#cb57-285" aria-hidden="true"></a></span>
<span id="cb57-286"><a href="#cb57-286" aria-hidden="true"></a>    <span class="kw">def</span> position(<span class="va">self</span>):</span>
<span id="cb57-287"><a href="#cb57-287" aria-hidden="true"></a>        <span class="cf">return</span> <span class="va">self</span>._position</span>
<span id="cb57-288"><a href="#cb57-288" aria-hidden="true"></a></span>
<span id="cb57-289"><a href="#cb57-289" aria-hidden="true"></a>    <span class="kw">def</span> nested(<span class="va">self</span>, input_object):</span>
<span id="cb57-290"><a href="#cb57-290" aria-hidden="true"></a>        <span class="cf">return</span> _ObjectStream(<span class="va">self</span>._memo, input_object, <span class="dv">0</span>, <span class="va">self</span>._position)</span>
<span id="cb57-291"><a href="#cb57-291" aria-hidden="true"></a></span>
<span id="cb57-292"><a href="#cb57-292" aria-hidden="true"></a>    <span class="kw">def</span> advance(<span class="va">self</span>):</span>
<span id="cb57-293"><a href="#cb57-293" aria-hidden="true"></a>        <span class="cf">return</span> _ObjectStream(<span class="va">self</span>._memo, <span class="va">self</span>._objects, <span class="va">self</span>._index<span class="op">+</span><span class="dv">1</span>, <span class="va">self</span>._parent_position)</span>
<span id="cb57-294"><a href="#cb57-294" aria-hidden="true"></a></span>
<span id="cb57-295"><a href="#cb57-295" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb57-296"><a href="#cb57-296" aria-hidden="true"></a>        <span class="cf">return</span> <span class="st">&quot;[</span><span class="sc">{}</span><span class="st">]&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;, &quot;</span>.join(<span class="bu">str</span>(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.position()))</span></code></pre></div>
<h3 id="ee923adb0ed4f3b8a5cc72700aad2ddcompile.sh">[]{#1ee923adb0ed4f3b8a5cc72700aad2dd}compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

rlmeta_compiler=&quot;$(pwd)/$1&quot;

cd &quot;$(dirname &quot;$0&quot;)&quot;

to_python_string() {
    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'
}

support_py_string=$(to_python_string &lt; support.py)
support_py=$(python &quot;$rlmeta_compiler&quot; --support)
parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
import sys

SUPPORT = $support_py_string

$support_py

$parser_py

$codegenerator_py

join = &quot;&quot;.join

def compile_grammar(grammar):
    parser = Parser()
    code_generator = CodeGenerator()
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))

if __name__ == &quot;__main__&quot;:
    if &quot;--support&quot; in sys.argv:
        sys.stdout.write(SUPPORT)
    else:
        try:
            sys.stdout.write(compile_grammar(sys.stdin.read()))
        except _MatchError as e:
            sys.stderr.write(e.describe())
            sys.exit(1)
EOF</code></pre>
<h3 id="meta_compile.sh"><span id="d09466ef920844788d5e63457decfd86"></span>meta_compile.sh</h3>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true"></a></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true"></a></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true"></a></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true"></a><span class="bu">echo</span> OK</span></code></pre></div>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
