<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      Modifying the RLMeta metacompiler | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>Modifying the RLMeta metacompiler</h1>

<p><em>Published on 28 May 2019.</em></p>

<p>In the first article about <a href="../../writing/rlmeta/">RLMeta</a> I wrote that its small implementation makes it feasible to understand and modify. But modifying the RLMeta metacompiler differs from modifying a regular program. In this article I explain how it differs and show examples of how different parts of RLMeta can be modified.</p>
<ul>
<li><a href="#39efe623ff374daba9830984300fcde2">Meta what?</a></li>
<li><a href="#93d9030e0e4849c5a8d8ca0fffdf7592">Modifying a metacompiler</a></li>
<li><a href="#bf2e6a99e41f478f884dd15ea243c111">Compiling RLMeta</a></li>
<li><a href="#75ad82923a2142789d01ca5be1d11942">Verifying metacompiler</a></li>
<li><a href="#5f6a1c91143146dbb3b865ac42562135">Modifying format of generated code</a></li>
<li><a href="#d54bbeda3d9846bca027f2c2995775a5">Meta compile script</a></li>
<li><a href="#6bfdc073cd4041238b169caa671c9652">Breaking modification</a></li>
<li><a href="#0130b76cb3d24f458bb47debb6fc2780">Modifying support library</a></li>
<li><a href="#1a090bb868154140a167968d8b4b15dc">Extending parser escape codes</a></li>
<li><a href="#22e574102e394218b874f03bb879c92f">Modifying parser</a></li>
<li><a href="#60cb5d0ff4ca4d94920bfe635ffd2142">Code listings for RLMeta</a>
<ul>
<li><a href="#df676d8cca604142bd1049c5e86c68a2">compile.sh</a></li>
<li><a href="#38ee00b5ef7c40f79d24fa61f052368f">meta_compile.sh</a></li>
<li><a href="#596acbaab3614dc787158be918bd9d32">is_metacompiler.sh</a></li>
</ul></li>
</ul>
<h2 id="efe623ff374daba9830984300fcde2meta-what">[]{#39efe623ff374daba9830984300fcde2}Meta what?</h2>
<p>What is a metacompiler and how does it differ from a regular compiler?</p>
<p>A compiler translates source code into an executable:</p>
<p><img src="image1.png" /></p>
<!-- image text -->
<center>
</center>
<p>A C compiler translates source code written in C into an executable:</p>
<p><img src="image2.png" /></p>
<!-- image text -->
<center>
</center>
<p>A metacompiler translates source code written in a metalanguage into an executable:</p>
<p><img src="image3.png" /></p>
<!-- image text -->
<center>
</center>
<p>A metalanguage is a domain specific language for describing other languages. It can be used to describe what languages look like (their syntax) and how to translate them into executables (their semantics). In essence, it can be used to describe compilers.</p>
<p>Because a metalanguage can be used to describe any compiler, it can also be used to describe the metacompiler itself. The metacompiler translates such a description into itself:</p>
<p><img src="image4.png" /></p>
<!-- image text -->
<center>
</center>
<p>A metacompiler does not have to be implemented in the metalanguage itself, but I suspect that it is common that it is. RLMeta is indeed implemented in its own language. This is also known as self-hosting. For the rest of this article, I will assume that a metacompiler is also self-hosting.</p>
<p>A C compiler written in C is not a metacompiler because C is not a metalanguage. It is a general purpose programming language not designed specifically to describe other languages. Such a compiler is merely a self-hosting compiler.</p>
<h2 id="d9030e0e4849c5a8d8ca0fffdf7592modifying-a-metacompiler">[]{#93d9030e0e4849c5a8d8ca0fffdf7592}Modifying a metacompiler</h2>
<p>How is modifying a metacompiler different from modifying a regular program?</p>
<p>In general, to modify a program written in a compiled language, its source code and a compiler is needed. Modifying the program is a matter of modifying the source code and compiling it:</p>
<p><img src="image5.png" /></p>
<!-- image text -->
<center>
</center>
<p><img src="image6.png" /></p>
<!-- image text -->
<center>
</center>
<p>In the case of a metacompiler, the compiler and the executable is the same. However, if the source code is modified, the executable might not be the metacompiler itself:</p>
<p><img src="image7.png" /></p>
<!-- image text -->
<center>
</center>
<p><img src="image8.png" /></p>
<!-- image text -->
<center>
</center>
<p>At this point, the metacompiler is needed to keep maintaining the modified executable. But the source code for the metacompiler itself is "lost" because the metacompiler can not be reproduced from the modified source code:</p>
<p><img src="image9.png" /></p>
<!-- image text -->
<center>
</center>
<p>Because there is no source code, the original metacompiler can not be modified either.</p>
<p>When modifying a metacompiler, care has to be taken to ensure that, in the end, the executable is still a metacompiler. Otherwise the metacompiler can not be modified further. This is a key difference from modifying a regular program. (Similar care has to be taken when modifying a self-hosting compiler.)</p>
<h2 id="compiling-rlmeta"><span id="bf2e6a99e41f478f884dd15ea243c111"></span>Compiling RLMeta</h2>
<p>This is a recap of how RLMeta is compiled.</p>
<p>RLMeta is compiled with the <code>compile.sh</code> script. It takes one argument which is the path to the RLMeta compiler. The script uses that compiler to compile the source code and then assemble the output to a Python file that looks like this:</p>
<pre><code>1.  compile.sh
2.  [rlmeta template]{.cp}</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">import</span> sys</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ex">SUPPORT</span> = <span class="va">$support_py_string</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="va">$support_py</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="va">$parser_py</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="va">$codegenerator_py</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="fu">join</span> = <span class="st">&quot;&quot;</span>.join</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="ex">def</span> compile_grammar(grammar)<span class="bu">:</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>    <span class="ex">parser</span> = Parser()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>    <span class="ex">code_generator</span> = CodeGenerator()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>    <span class="bu">return</span> code_generator.run(<span class="st">&quot;ast&quot;</span>, parser.run(<span class="st">&quot;grammar&quot;</span>, grammar))</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="kw">if</span> <span class="ex">__name__</span> == <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>    <span class="kw">if</span> <span class="st">&quot;--support&quot;</span> <span class="kw">in</span> <span class="ex">sys.argv</span>:</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>        <span class="ex">sys.stdout.write</span>(SUPPORT)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>    <span class="ex">else</span>:</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>        <span class="ex">try</span>:</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>            <span class="ex">sys.stdout.write</span>(compile_grammar(sys.stdin.read()))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>        <span class="ex">except</span> _MatchError as e:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>            <span class="ex">sys.stderr.write</span>(e.describe())</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>            <span class="ex">sys.exit</span>(1)</span></code></pre></div>
<p>The variables <code>$support_py</code>, <code>$parser_py</code>, and <code>$codegenerator_py</code> are produced by the RLMeta compiler. The variable <code>$support_py_string</code> is produced by converting the support library to a Python string. Here is the rest of the <code>compile.sh</code> script:</p>
<pre><code>1.  compile.sh</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="va">rlmeta_compiler=</span><span class="st">&quot;</span><span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="fu">to_python_string()</span> <span class="kw">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="ex">python</span> -c <span class="st">'import sys; sys.stdout.write(repr(sys.stdin.read()))'</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="kw">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="va">support_py_string=$(</span><span class="ex">to_python_string</span> <span class="op">&lt;</span> support.py<span class="va">)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="va">support_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> --support<span class="va">)</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="va">parser_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> parser.rlmeta<span class="va">)</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="va">codegenerator_py=$(</span><span class="ex">python</span> <span class="st">&quot;</span><span class="va">$rlmeta_compiler</span><span class="st">&quot;</span> <span class="op">&lt;</span> codegenerator.rlmeta<span class="va">)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>&lt;&lt;rlmeta template&gt;&gt;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a><span class="op">EOF</span></span></code></pre></div>
<h2 id="ad82923a2142789d01ca5be1d11942verifying-metacompiler">[]{#75ad82923a2142789d01ca5be1d11942}Verifying metacompiler</h2>
<p>How can it be verified that RLMeta is a metacompiler?</p>
<p>The <code>is_metacompiler.sh</code> script checks if a given file is a metacompiler. It does so by comparing the file to the file generated by the <code>compile.sh</code> script. If they are equal, the file is a metacompiler because it reproduced itself exactly. Otherwise the two files differ.</p>
<pre><code>1.  is\_metacompiler.sh</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="kw">if</span> <span class="fu">diff</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="op">&lt;(</span><span class="ex">./compile.sh</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span><span class="op">)</span><span class="kw">;</span> <span class="kw">then</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st"> is a metacompiler!&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="kw">else</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st"> is not a metacompiler. See diff above.&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="kw">fi</span></span></code></pre></div>
<p>RLMeta is a metacompiler because its source code is written in a metalanguage and it is able to reproduce itself:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta.py
rlmeta.py is a metacompiler!</code></pre>
<p>The following sections show examples of how to make modifications to RLMeta that ensure that the modified version is still a metacompiler.</p>
<h2 id="f6a1c91143146dbb3b865ac42562135modifying-format-of-generated-code">[]{#5f6a1c91143146dbb3b865ac42562135}Modifying format of generated code</h2>
<p>The code generator in RLMeta generates lambda expressions with newlines and indentation:</p>
<pre class="text"><code>(lambda:
    ...
)</code></pre>
<p>This example shows how to modify it to generate equivalent lambda expressions without the additional punctuation like this:</p>
<pre class="text"><code>(lambda: ...)</code></pre>
<p>First, the following line in the code generator is changed from</p>
<pre class="text"><code>| astFnBody:x -&gt; { &quot;(lambda:\n&quot; &gt; x &lt; &quot;\n)&quot; }</code></pre>
<p>to</p>
<pre class="text"><code>| astFnBody:x -&gt; { &quot;(lambda: &quot; x &quot;)&quot; }</code></pre>
<p>The modified source code describes a metacompiler whose code generator generates lambda expressions without the additional punctuation. How is a new metacompiler created from this modified source code?</p>
<p>Compiling the modified source code gives a new executable:</p>
<pre class="text"><code>$ ./compile.sh rlmeta.py &gt; rlmeta1.py</code></pre>
<p><img src="image10.png" /></p>
<!-- image text -->
<center>
</center>
<p>With this modification, <code>rlmeta.py</code> is no longer a metacompiler because it differs from <code>rlmeta1.py</code>:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta.py
1685,1686c1685
&lt;                                         '(lambda:\n',
&lt;                                         _IndentBuilder(),
---
&gt;                                         '(lambda:',
1688,1689c1687
&lt;                                         _DedentBuilder(),
&lt;                                         '\n)',
---
&gt;                                         ')',
rlmeta.py is not a metacompiler. See diff above.</code></pre>
<p>The difference is that the code for generating lambda expressions is different. <code>rlmeta1.py</code> should still be a compiler that recognizes the same source language so it can be used to compile the modified source code again, giving yet another executable:</p>
<pre class="text"><code>$ ./compile.sh rlmeta1.py &gt; rlmeta2.py</code></pre>
<p><img src="image11.png" /></p>
<!-- image text -->
<center>
</center>
<p><code>rlmeta1.py</code> is not a metacompiler either because it differs from <code>rlmeta2.py</code>:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta1.py
287,325c287,299
&lt;         return (lambda:
&lt;             self._or([
&lt;                 (lambda:
&lt;                     (lambda _vars:
&lt;                         (lambda:
&lt;                             self._and([
&lt;                                 (lambda:
&lt;                                     _vars.bind('x', (lambda:
&lt;                                         self._match_rule('name')
&lt;                                     )())
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_rule('space')
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_charseq('{')
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     _vars.bind('ys', (lambda:
&lt;                                         self._star((lambda:
&lt;                                             self._match_rule('rule')
&lt;                                         ))
&lt;                                     )())
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_rule('space')
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     self._match_charseq('}')
&lt;                                 ),
&lt;                                 (lambda:
&lt;                                     _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))
&lt;                                 ),
&lt;                             ])
&lt;                         )()
&lt;                     )(_Vars())
&lt;                 ),
&lt;             ])
&lt;         )()
---
&gt;         return (lambda: self._or([
&gt;             (lambda: (lambda _vars:
&gt;                 (lambda: self._and([
&gt;                     (lambda: _vars.bind('x', (lambda: self._match_rule('name'))())),
&gt;                     (lambda: self._match_rule('space')),
&gt;                     (lambda: self._match_charseq('{')),
&gt;                     (lambda: _vars.bind('ys', (lambda: self._star((lambda: self._match_rule('rule'))))())),
&gt;                     (lambda: self._match_rule('space')),
&gt;                     (lambda: self._match_charseq('}')),
&gt;                     (lambda: _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))),
&gt;                 ]))()
&gt;             )(_Vars())),
&gt;         ]))()
...
rlmeta1.py is not a metacompiler. See diff above.</code></pre>
<p>This time the difference is only in formatting. The two programs should be semantically equivalent. The original modification set out to remove additional punctuation in lambda expressions and this can now be seen in the generated code. <code>rlmeta2.py</code> can be used to compile the modified source code again, giving yet another executable:</p>
<pre class="text"><code>$ ./compile.sh rlmeta2.py &gt; rlmeta3.py</code></pre>
<p><img src="image12.png" /></p>
<!-- image text -->
<center>
</center>
<p><code>rlmeta2.py</code> is now a metacompiler because it is the same as <code>rlmeta3.py</code>:</p>
<pre class="text"><code>$ ./is_metacompiler.sh rlmeta2.py
rlmeta2.py is a metacompiler!</code></pre>
<p><code>rlmeta2.py</code> together with the modified source becomes the next version of the RLMeta metacompiler. All other intermediate compilers can be discarded.</p>
<p><img src="image13.png" /></p>
<!-- image text -->
<center>
</center>
<h2 id="meta-compile-script"><span id="d54bbeda3d9846bca027f2c2995775a5"></span>Meta compile script</h2>
<p>The steps to create the next version of RLMeta can be scripted like this:</p>
<pre><code>1.  meta\_compile.sh</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">#!/bin/bash</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">-e</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="bu">cd</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">dirname</span> <span class="st">&quot;</span><span class="va">$0</span><span class="st">&quot;</span><span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta.py <span class="op">&gt;</span> rlmeta1.py</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta1.py <span class="op">&gt;</span> rlmeta2.py</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="ex">./compile.sh</span> rlmeta2.py <span class="op">&gt;</span> rlmeta3.py</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="fu">diff</span> rlmeta2.py rlmeta3.py</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="fu">diff</span> support.py <span class="op">&lt;(</span><span class="ex">python</span> rlmeta3.py --support<span class="op">)</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a><span class="fu">mv</span> rlmeta3.py rlmeta2.py</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a><span class="fu">mv</span> rlmeta2.py rlmeta1.py</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a><span class="fu">mv</span> rlmeta1.py rlmeta.py</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a><span class="bu">echo</span> OK</span></code></pre></div>
<p>It starts with a <code>set -e</code> directive that makes the script stop immediately when a command fails. Then it changes directory to the same directory as the script itself is in. That directory is assumed to also contain the <code>compile.sh</code> script. It then uses the <code>compile.sh</code> script to create the intermediate compilers. If all compile commands succeed, the two last compilers are compared. If they differ, it was not possible to create a metacompiler. The <code>diff</code> command then fails and the script fails. The intermediate compilers are left on disk for inspection. If the two last compilers are the same, a sanity check that the support libraries are the same is done. Then intermediate compilers are removed. At the end, an 'OK' is printed, signifying that a new version of RLMeta was successfully created.</p>
<p>This script will be used in the following examples.</p>
<h2 id="bfdc073cd4041238b169caa671c9652breaking-modification">[]{#6bfdc073cd4041238b169caa671c9652}Breaking modification</h2>
<p>This example shows what happens if the source code is modified so that it no longer correctly describes a metacompiler.</p>
<p>A dummy modification that should break things is changing the following line that generates code for rules from</p>
<pre class="text"><code>| [&quot;Rule&quot; .:x ast:y] -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;return &quot; y &quot;()\n&quot; &lt; }</code></pre>
<p>to</p>
<pre class="text"><code>| [&quot;Rule&quot; .:x ast:y] -&gt; { &quot;\ndef _rule_&quot; x &quot;(self):\n&quot; &gt; &quot;pass\n&quot; &lt; }</code></pre>
<p>Instead of generating a function body, the <code>y</code> ast node is ignored and a <code>pass</code> statement is generated instead.</p>
<p>Running the meta compile script on the modified source code indeed gives an error:</p>
<pre class="text"><code>$ ./meta_compile.sh
Traceback (most recent call last):
  File &quot;rlmeta2.py&quot;, line 375, in &lt;module&gt;
    sys.stdout.write(compile_grammar(sys.stdin.read()))
  File &quot;rlmeta2.py&quot;, line 368, in compile_grammar
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))
  File &quot;rlmeta2.py&quot;, line 102, in run
    result = self._match_rule(rule_name).eval()
AttributeError: 'NoneType' object has no attribute 'eval'</code></pre>
<p>This means that a new metacompiler could not be created. Why?</p>
<p>The error happens in <code>rlmeta2.py</code> when the following compilation step is run:</p>
<pre class="text"><code>./compile.sh rlmeta2.py &gt; rlmeta3.py</code></pre>
<p>It means that both <code>rlmeta1.py</code> and <code>rlmeta2.py</code> were successfully created, but it failed to create <code>rlmeta3.py</code>. The difference between <code>rlmeta.py</code> and <code>rlmeta1.py</code> is that the code for generating code for rules is different:</p>
<pre class="text"><code>$ diff rlmeta.py rlmeta1.py
1453,1455c1453
&lt;                                         'return ',
&lt;                                         _vars.lookup('y').eval(),
&lt;                                         '()\n',
---
&gt;                                         'pass\n',</code></pre>
<p><code>rlmeta1.py</code> is still a compiler that recognizes the same source language so it was successfully used to create <code>rlmeta2.py</code>. The difference between <code>rlmeta1.py</code> and <code>rlmeta2.py</code> is that the code for rules just have a <code>pass</code> statement instead of code for doing matching and returning results:</p>
<pre class="text"><code>$ diff rlmeta1.py rlmeta2.py 
287,325c287
&lt;         return (lambda:
&lt;             self._or([
...
&lt;             ])
&lt;         )()
---
&gt;         pass
...</code></pre>
<p>So <code>rlmeta2.py</code> will not work because all rules return <code>None</code>. When <code>_match_rule</code> is called it will get <code>None</code> back but expect a semantic action. When <code>eval</code> is run it will fail because the result is not a semantic action, but instead <code>None</code>.</p>
<p>Because the modified source code does not correctly describe how code for rules should be generated, it does not describe a metacompiler, and it can never be used to create a new metacompiler.</p>
<h2 id="b76cb3d24f458bb47debb6fc2780modifying-support-library">[]{#0130b76cb3d24f458bb47debb6fc2780}Modifying support library</h2>
<p>This example shows how to make a modification that requires modifying both the support library and the code generator. It shows how the arguments to the <code>bind</code> function can be swapped.</p>
<p>In the support library, the following line that defines the <code>bind</code> function is changed from</p>
<pre class="text"><code>def bind(self, name, value):</code></pre>
<p>to</p>
<pre class="text"><code>def bind(self, value, name):</code></pre>
<p>In the code generator, the following line that generates calls to <code>bind</code> is changed from</p>
<pre class="text"><code>| [&quot;Bind&quot; .:x ast:y] -&gt; { &quot;_vars.bind(&quot; repr(x) &quot;, &quot; y &quot;())&quot; }</code></pre>
<p>to</p>
<pre class="text"><code>| [&quot;Bind&quot; .:x ast:y] -&gt; { &quot;_vars.bind(&quot; y &quot;(), &quot; repr(x) &quot;)&quot; }</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The difference between the two metacompilers is that the two versions of the support library are modified, all <code>bind</code> calls have swapped arguments, and code that generates calls to <code>bind</code> have swapped arguments:</p>
<pre class="text"><code>$ diff rlmeta.py.orig rlmeta.py
3c3
&lt; SUPPORT = ...
---
&gt; SUPPORT = ...
110c110
&lt;     def bind(self, name, value):
---
&gt;     def bind(self, value, name):
294c294
&lt;                                     _vars.bind('x', (lambda:
---
&gt;                                     _vars.bind((lambda:
296c296
&lt;                                     )())
---
&gt;                                     )(), 'x')
1814a1815,1816
&gt;                                         _vars.lookup('y').eval(),
&gt;                                         '(), ',
1818,1820c1820
&lt;                                         ', ',
&lt;                                         _vars.lookup('y').eval(),
&lt;                                         '())',
---
&gt;                                         ')',
...</code></pre>
<p>This modification creates a new version of RLMeta that works exactly the same as the previous version, but internally the <code>bind</code> function has a different signature.</p>
<p>These compilation steps were not possible in the first version of RLMeta because the <code>compile.sh</code> script generated the support library incorrectly. All RLMeta compilers have two versions of the support library: the one that it generates (stored in the <code>SUPPORT</code> variable), and the one it uses itself. If the compiler is a metacompiler, the two versions are the same, but in intermediate compilers they might differ.</p>
<p>The first version of RLMeta generated the support library like this:</p>
<pre class="text"><code>support_py=$(cat support.py)</code></pre>
<p>It meant that the intermediate compilers always had the latest support library, and the two versions of the support library were always the same.</p>
<p>Running the meta compile script on the modified source code with the old version of <code>compile.sh</code> gives an error:</p>
<pre class="text"><code>$ ./meta_compile.sh
Traceback (most recent call last):
  File &quot;rlmeta1.py&quot;, line 2217, in &lt;module&gt;
    sys.stdout.write(compile_grammar(sys.stdin.read()))
  File &quot;rlmeta1.py&quot;, line 2210, in compile_grammar
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))
  File &quot;rlmeta1.py&quot;, line 102, in run
    result = self._match_rule(rule_name).eval()
  File &quot;rlmeta1.py&quot;, line 123, in eval
    return self.fn()
  File &quot;rlmeta1.py&quot;, line 318, in &lt;lambda&gt;
    _SemanticAction(lambda: (['Grammar']+[_vars.lookup('x').eval()]+_vars.lookup('ys').eval()+[]))
  File &quot;rlmeta1.py&quot;, line 115, in lookup
    return self[name]
KeyError: 'x'</code></pre>
<p>Now <code>rlmeta1.py</code> has swapped arguments in the support library, but the generated code (generated by <code>rlmeta.py</code>) still expects not swapped arguments. Notice the absence of swapped arguments in <code>bind</code> calls in the diff:</p>
<pre class="text"><code>$ diff rlmeta.py rlmeta1.py
3c3
&lt; SUPPORT = ...
---
&gt; SUPPORT = ...
110c110
&lt;     def bind(self, name, value):
---
&gt;     def bind(self, value, name):
1814a1815,1816
&gt;                                         _vars.lookup('y').eval(),
&gt;                                         '(), ',
1818,1820c1820
&lt;                                         ', ',
&lt;                                         _vars.lookup('y').eval(),
&lt;                                         '())',
---
&gt;                                         ')',</code></pre>
<p>This in turn leads to <code>rlmeta1.py</code> not functioning because its <code>bind</code> calls have not stored the name as key, but the value. Hence the key error.</p>
<p>The version of RLMeta in this article fixes the generation of the <code>$support_py</code> variable like this:</p>
<pre class="text"><code>support_py=$(python &quot;$rlmeta_compiler&quot; --support)</code></pre>
<p>This ensures that the code that the code generator generates is always in sync with the support library.</p>
<h2 id="a090bb868154140a167968d8b4b15dcextending-parser-escape-codes">[]{#1a090bb868154140a167968d8b4b15dc}Extending parser escape codes</h2>
<p>The escape codes possible in strings in RLMeta are '<code>\\</code>', '<code>\'</code>', '<code>\"</code>', and '<code>\n</code>':</p>
<pre class="text"><code>escape = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
       | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;</code></pre>
<p>This example shows how a new escape code, '<code>\t</code>', can be added.</p>
<p>A first attempt might be to extend the <code>escape</code> rule in the parser like this:</p>
<pre class="text"><code>escape = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
       | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
       | 't'  -&gt; &quot;\t&quot;</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The code generated for the tab case looks like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        (lambda:
            self._and([
                (lambda:
                    self._match_charseq('t')
                ),
                (lambda:
                    _SemanticAction(lambda: '\\t')
                ),
            ])
        )()
    )(_Vars())
),</code></pre>
<p>It doesn't look quite right. The semantic action does not return a tab character but rather two characters: '<code>\</code>' and '<code>t</code>'. The reason for this is that the modified source code tries to use the new escape code before the parser understands it. Since the parser does not recognize the new escape code, it will treat it as two separate characters.</p>
<p>How can the semantic action be modified to return an single tab character? The escape code can not be used until it is implemented, so the only solution is to call a function that returns a tab character:</p>
<pre class="text"><code>escape = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
       | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
       | 't'  -&gt; tab()</code></pre>
<p>The <code>tab</code> function is added to the Python template to give generated code access to it:</p>
<pre class="text"><code>tab = lambda: &quot;\t&quot;</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The code generated for the tab case now looks like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        (lambda:
            self._and([
                (lambda:
                    self._match_charseq('t')
                ),
                (lambda:
                    _SemanticAction(lambda: tab(
                    ))
                ),
            ])
        )()
    )(_Vars())
),</code></pre>
<p>The semantic action now correctly generates a tab character by calling the <code>tab</code> function.</p>
<p>Now the new escape code can be used inside strings and the <code>tab</code> function can be discarded:</p>
<pre class="text"><code>escape = '\\' -&gt; &quot;\\&quot; | '\'' -&gt; &quot;'&quot;
       | '&quot;'  -&gt; &quot;\&quot;&quot; | 'n'  -&gt; &quot;\n&quot;
       | 't'  -&gt; &quot;\t&quot;</code></pre>
<p>Running the meta compile script on the modified source code gives a new metacompiler:</p>
<pre class="text"><code>$ ./meta_compile.sh
OK</code></pre>
<p>The code generated for the tab case now looks like this:</p>
<pre class="text"><code>(lambda:
    (lambda _vars:
        (lambda:
            self._and([
                (lambda:
                    self._match_charseq('t')
                ),
                (lambda:
                    _SemanticAction(lambda: '\t')
                ),
            ])
        )()
    )(_Vars())
),</code></pre>
<p>The semantic action now returns a single tab character without using the <code>tab</code> function.</p>
<p>Adding the tab escape code required two passes: one to recognize it and one to use it.</p>
<h2 id="e574102e394218b874f03bb879c92fmodifying-parser">[]{#22e574102e394218b874f03bb879c92f}Modifying parser</h2>
<p>The syntax for introducing a semantic action in RLMeta is <code>-&gt;</code>. This example shows how it can be changed to <code>=&gt;</code>. A first attempt might be to change the following line in the parser from</p>
<pre class="text"><code>| space '-&gt;' hostExpr:x -&gt; [&quot;SemanticAction&quot; x]</code></pre>
<p>to</p>
<pre class="text"><code>| space '=&gt;' hostExpr:x -&gt; [&quot;SemanticAction&quot; x]</code></pre>
<p>Running the meta compile script on the modified source code gives an error:</p>
<pre class="text"><code>$ ./meta_compile.sh
...
ERROR: L003:C048: expected '}' but found '-'</code></pre>
<p>What happened? The first compiler generated by the meta compile script (<code>rlmeta1.py</code>) has a parser that expects the syntax to be <code>=&gt;</code> for semantic actions. When the meta compile script tries to run that compiler on the modified source code it fails because the modified source code is still using the old <code>-&gt;</code> syntax. The source code can not be changed to the new syntax before the parser recognizes it, so the meta compile script does not work for this modification.</p>
<p>This can be solved in two ways. Either the parser can be changed to allow both syntaxes like this:</p>
<pre class="text"><code>| space ('-'|'=')'&gt;' hostExpr:x -&gt; [&quot;SemanticAction&quot; x]</code></pre>
<p>Once a new metacompiler has been created, the source code can be changed to use <code>=&gt;</code>, and then the choice in the parser can be removed to allow only <code>=&gt;</code>.</p>
<p>Or the source code must be changed again before creating <code>rlmeta2.py</code> like this:</p>
<pre class="text"><code>$ # make parser change
$ ./compile.sh rlmeta.py &gt; rlmeta1.py
$ # change syntax from `-&gt;` to `=&gt;`
$ ./compile.sh rlmeta1.py &gt; rlmeta2.py
$ ./is_metacompiler.sh rlmeta2.py
rlmeta2.py is a metacompiler!</code></pre>
<p><img src="image14.png" /></p>
<!-- image text -->
<center>
</center>
<h2 id="cb5d0ff4ca4d94920bfe635ffd2142code-listings-for-rlmeta">[]{#60cb5d0ff4ca4d94920bfe635ffd2142}Code listings for RLMeta</h2>
<p>The only modifications from the original <a href="../rlmeta/index.html#388bb1e8ccbd4d55b89b391c08452c33">RLMeta</a> are the tweaked <code>compile.sh</code> script and the additional <code>meta_compile.sh</code> and <code>is_metacompiler.sh</code> scripts. They are shown fully here. For the rest of the source code, see the original article.</p>
<h3 id="compile.sh"><span id="df676d8cca604142bd1049c5e86c68a2"></span>compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

rlmeta_compiler=&quot;$(pwd)/$1&quot;

cd &quot;$(dirname &quot;$0&quot;)&quot;

to_python_string() {
    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'
}

support_py_string=$(to_python_string &lt; support.py)
support_py=$(python &quot;$rlmeta_compiler&quot; --support)
parser_py=$(python &quot;$rlmeta_compiler&quot; &lt; parser.rlmeta)
codegenerator_py=$(python &quot;$rlmeta_compiler&quot; &lt; codegenerator.rlmeta)

cat &lt;&lt;EOF
import sys

SUPPORT = $support_py_string

$support_py

$parser_py

$codegenerator_py

join = &quot;&quot;.join

def compile_grammar(grammar):
    parser = Parser()
    code_generator = CodeGenerator()
    return code_generator.run(&quot;ast&quot;, parser.run(&quot;grammar&quot;, grammar))

if __name__ == &quot;__main__&quot;:
    if &quot;--support&quot; in sys.argv:
        sys.stdout.write(SUPPORT)
    else:
        try:
            sys.stdout.write(compile_grammar(sys.stdin.read()))
        except _MatchError as e:
            sys.stderr.write(e.describe())
            sys.exit(1)
EOF</code></pre>
<h3 id="ee00b5ef7c40f79d24fa61f052368fmeta_compile.sh">[]{#38ee00b5ef7c40f79d24fa61f052368f}meta_compile.sh</h3>
<pre class="text"><code>#!/bin/bash

set -e

cd &quot;$(dirname &quot;$0&quot;)&quot;

./compile.sh rlmeta.py &gt; rlmeta1.py

./compile.sh rlmeta1.py &gt; rlmeta2.py

./compile.sh rlmeta2.py &gt; rlmeta3.py

diff rlmeta2.py rlmeta3.py

diff support.py &lt;(python rlmeta3.py --support)

mv rlmeta3.py rlmeta2.py

mv rlmeta2.py rlmeta1.py

mv rlmeta1.py rlmeta.py

echo OK</code></pre>
<h3 id="acbaab3614dc787158be918bd9d32is_metacompiler.sh">[]{#596acbaab3614dc787158be918bd9d32}is_metacompiler.sh</h3>
<pre class="text"><code>#!/bin/bash

if diff &quot;$1&quot; &lt;(./compile.sh &quot;$1&quot;); then
    echo &quot;$1 is a metacompiler!&quot;
else
    echo &quot;$1 is not a metacompiler. See diff above.&quot;
fi</code></pre>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
