{
"root_page":{
"children":[
{
"children":[],
"id":"f935efac99094d30b035430ba6c263cb",
"paragraphs":[
{
"fragments":[
{
"text":"The first thing I think about is how to represent the data that RLMeta needs. In particular I think about how to store the mapping between rule names and their location in the program. The map in the standard library looks like a dict in Python. But there is also something about an allocation strategy. I need to learn more about how memory is handled in C++.",
"type":"text"
}
],
"id":"f52acf67f9d4436db92631b6666e61cc",
"type":"text"
},
{
"fragments":[
{
"text":"I read about classes, constructors, destructors and initialisation. I create a small example to clarify my thinking. Here I also learn about basic C++ syntax.",
"type":"text"
}
],
"id":"52496a6daeac472888338f9503e13763",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"#include <iostream>\n\nclass Foo {\n    private:\n        int id;\n    public:\n        Foo(int id) : id(id) {\n            std::cout << \"Creating foo \" << id << \"\\n\";\n        }\n        ~Foo() {\n            std::cout << \"Destructing foo \" << id << \"\\n\";\n        }\n};\n\nint main() {\n    std::cout << \"Entering main\\n\";\n    Foo foo1(1);\n    Foo *foo2 = new Foo(2);\n    std::cout << \"Exiting main\\n\";\n    return 0;\n}\n",
"type":"code"
}
],
"id":"9559a11ea6284ae5af9c37b30245a0c7",
"language":"cpp",
"post_process":[
"bash",
"runcpp.sh"
],
"type":"code"
},
{
"fragments":[
{
"text":"Output:",
"type":"text"
}
],
"id":"5fc71c3b05e14a41916822ee829191c8",
"type":"text"
},
{
"code_id":"9559a11ea6284ae5af9c37b30245a0c7",
"id":"cd31f940c78b4483b0f6d03744c301ba",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"This shows me that objects are destructed automatically if allocated on the stack. But not when newed.",
"type":"text"
}
],
"id":"c850ede0c7dc4a219fbf0987ed6a59ee",
"type":"text"
},
{
"fragments":[
{
"text":"I go back to the map and make a small example to learn more:",
"type":"text"
}
],
"id":"be278c54ab874ee69db5b7cfaff1a8e9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"#include <iostream>\n#include <map>\n\nint main() {\n    std::map<std::string, int> rules;\n    rules.insert(std::pair<std::string, int>(\"foo\", 10));\n    rules.insert(std::pair<std::string, int>(\"bar\", 15));\n    std::cout << \"foo = \" << rules[\"foo\"] << \"\\n\";\n    std::cout << \"bar = \" << rules[\"bar\"] << \"\\n\";\n    return 0;\n}\n",
"type":"code"
}
],
"id":"dbac88ccdb554a149960b1fb80cc61e1",
"language":"cpp",
"post_process":[
"bash",
"runcpp.sh"
],
"type":"code"
},
{
"fragments":[
{
"text":"Output:",
"type":"text"
}
],
"id":"f2dc71bb38e54a55858322223933c50f",
"type":"text"
},
{
"code_id":"dbac88ccdb554a149960b1fb80cc61e1",
"id":"97e7b204a6d44c268b9eccc45f0423c2",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"I think the type declarations make the code hard to read. But the map seems to do what I want. So I'm happy. I also conclude that the map allocates memory to make space for all pairs. But at the end of ",
"type":"text"
},
{
"text":"main",
"type":"code"
},
{
"text":" it will all be freed automatically. So no memory will leak.",
"type":"text"
}
],
"id":"1b4a1d40748f42a28bbd9872b2d63acc",
"type":"text"
},
{
"fragments":[
{
"text":"Next I'm thinking about how to represent instructions. In the Python version an instruction is represented as a tuple ",
"type":"text"
},
{
"text":"(name, arg1, arg2)",
"type":"code"
},
{
"text":". Where the arguments can be of arbitrary type (string, integer, lambda, etc.).",
"type":"text"
}
],
"id":"78eb56b011a24d28a3db2f3e3ceca89d",
"type":"text"
},
{
"fragments":[
{
"text":"Getting stuck. I think about how to represent the values that RLMeta works with instead. Lists, strings, integers, characters.",
"type":"text"
}
],
"id":"4a81459169e049d19ab27b944df569d9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"#include <iostream>\n#include <list>\n#include <memory>\n\nclass RLMetaObject {\n    public:\n        virtual ~RLMetaObject() {\n        }\n};\n\nclass RLMetaInteger : public RLMetaObject {\n    private:\n        int value;\n    public:\n        RLMetaInteger(int value) : value(value) {\n        }\n        ~RLMetaInteger() {\n            std::cout << \"Destructing integer \" << value << \"\\n\";\n        }\n};\n\nclass RLMetaString : public RLMetaObject {\n    private:\n        std::string value;\n    public:\n        RLMetaString(std::string value) : value(value) {\n        }\n        ~RLMetaString() {\n            std::cout << \"Destructing string \" << value << \"\\n\";\n        }\n};\n\nint main() {\n    std::list<RLMetaObject> objects;\n    objects.push_back(RLMetaInteger(5));\n    objects.push_back(RLMetaString(\"hello\"));\n    std::list<std::unique_ptr<RLMetaObject>> objectPointers;\n    objectPointers.push_back(\n        std::make_unique<RLMetaInteger>(6)\n    );\n    objectPointers.push_back(\n        std::make_unique<RLMetaString>(\"world\")\n    );\n    return 0;\n}\n",
"type":"code"
}
],
"id":"94cb90e231174f20a6c72c03cd51af07",
"language":"cpp",
"post_process":[
"bash",
"runcpp.sh"
],
"type":"code"
},
{
"code_id":"94cb90e231174f20a6c72c03cd51af07",
"id":"0f108e5fcaa04c78b6253d6873a78c61",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"Needed virtual destructor to make proper destruction using smart pointer.",
"type":"text"
}
],
"id":"2a726895e0954f239f222a142f3bb87e",
"type":"text"
},
{
"fragments":[
{
"text":"Dynamic cast can work as ",
"type":"text"
},
{
"text":"isinstance",
"type":"code"
},
{
"text":" in Python.",
"type":"text"
}
],
"id":"5f8d3050d90a46d3887690ba849c34d8",
"type":"text"
},
{
"fragments":[
{
"text":"Smart pointers.",
"type":"text"
}
],
"id":"c1335d75aafc4b8888474cf5ffe08dad",
"type":"text"
}
],
"title":"Representing data"
},
{
"children":[],
"id":"8fe0f8cbf13f49c0a4d9aa4f92fa2540",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"runcpp.sh"
],
"fragments":[
{
"text":"cat > tmp.cpp && g++ tmp.cpp -o tmp && ./tmp && rm tmp.cpp tmp\n",
"type":"code"
}
],
"id":"07e9cf1d308a45b7b6844ec3d2a21268",
"type":"code"
}
],
"title":"Misc"
}
],
"id":"1b548157320a4aa4a1faad63e33ecbff",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I will port RLMeta to C++. The main reason for doing it is to learn C++. I have the impression that C++ is a large and complex language, but I think I should be able to grasp the basics pretty quickly because I know C quite well and am also familiar with object oriented programming. This article will describe my learning journey as well as the port. Another reason for doing the port is to see how RLMeta looks like when C++ is the target language. Will it fit well? Will performance increase?",
"type":"text"
}
],
"id":"869b6e56191f4b3c89dbb8a79d07d910",
"type":"text"
}
],
"title":"Porting RLMeta to C++"
},
"variables":{}
}