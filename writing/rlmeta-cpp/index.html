<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>
      DRAFT: Porting RLMeta to C++ | Rickard Lindberg
    </title>

    <!-- Bootstrap -->
    <link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard Lindberg">
    <link rel="stylesheet" href="../../static/layout.css" type="text/css">
    <link rel="stylesheet" href="../../static/syntax.css" type="text/css">
    <link rel="alternate" href="../../atom.xml" type="application/atom+xml" title="Atom feed">
    <link rel="alternate" href="../../rss.xml" type="application/rss+xml" title="RSS feed">
    <link rel="me" href="https://hachyderm.io/@rickardlindberg">
  </head>
  <body>

    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">rickardlindberg.me</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse navbar-right">
          <ul class="nav navbar-nav">
            <li><a href="../../">Home</a></li>
            <li><a href="../../writing/">Writing</a></li>
            <li><a href="../../writing/newsletter/">Newsletter</a></li>
            <li><a href="../../projects/">Projects</a></li>
            <li><a href="../../contact/">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <h1>DRAFT: Porting RLMeta to C++</h1>

<p><em>Published on 10 April 2020.</em></p>

<p><strong>This is a work in progress that will change. Like to see it finished? Let me know by sending me an email.</strong></p>
<p>In this article I will port RLMeta to C++. The main reason for doing it is to learn C++. I have the impression that C++ is a large and complex language, but I think I should be able to grasp the basics pretty quickly because I know C quite well and I am also familiar with object oriented programming. This article will describe my learning journey as well as the port. Another reason for doing the port is to see how RLMeta looks like when C++ is the target language. Will it fit well? Will performance increase?</p>
<ul>
<li><a href="#f935efac99094d30b035430ba6c263cb">Representing data</a></li>
<li><a href="#8fe0f8cbf13f49c0a4d9aa4f92fa2540">Misc</a></li>
</ul>
<h2 id="representing-data"><span id="f935efac99094d30b035430ba6c263cb"></span>Representing data</h2>
<p>The first thing I think about is how to represent the data that RLMeta needs. In particular I think about how to store the mapping between rule names and their location in the program. The map in the C++ standard library looks like a dict in Python. But there is also something about an allocation strategy. I need to learn more about how memory is handled in C++.</p>
<p>I read about classes, constructors, destructors and initialisation. I create a small example to clarify my thinking. Here I also learn about basic C++ syntax.</p>
<pre class="text"><code>#include &lt;iostream&gt;

class Foo {
    private:
        int id;
    public:
        Foo(int id) : id(id) {
            std::cout &lt;&lt; &quot;Creating foo &quot; &lt;&lt; id &lt;&lt; &quot;\n&quot;;
        }
        ~Foo() {
            std::cout &lt;&lt; &quot;Destructing foo &quot; &lt;&lt; id &lt;&lt; &quot;\n&quot;;
        }
};

int main() {
    std::cout &lt;&lt; &quot;Entering main\n&quot;;
    Foo foo1(1);
    Foo *foo2 = new Foo(2);
    std::cout &lt;&lt; &quot;Exiting main\n&quot;;
    return 0;
}</code></pre>
<p>Output:</p>
<pre class="text"><code>Entering main
Creating foo 1
Creating foo 2
Exiting main
Destructing foo 1</code></pre>
<p>This shows me that objects are destructed automatically if allocated on the stack. But not when newed.</p>
<p>I go back to the map and make a small example to learn how to use it:</p>
<pre class="text"><code>#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::map&lt;std::string, int&gt; rules;
    rules.insert(std::pair&lt;std::string, int&gt;(&quot;foo&quot;, 10));
    rules.insert(std::pair&lt;std::string, int&gt;(&quot;bar&quot;, 15));
    std::cout &lt;&lt; &quot;foo = &quot; &lt;&lt; rules[&quot;foo&quot;] &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;bar = &quot; &lt;&lt; rules[&quot;bar&quot;] &lt;&lt; &quot;\n&quot;;
    return 0;
}</code></pre>
<p>Output:</p>
<pre class="text"><code>foo = 10
bar = 15</code></pre>
<p>I think the type declarations make the code hard to read. But the map seems to do what I want. So I'm happy. I also conclude that the map allocates memory to make space for all pairs. But at the end of <code>main</code> it will all be freed automatically. So no memory will leak.</p>
<p>Next I'm thinking about how to represent instructions. In the Python version an instruction is represented as a tuple <code>(name, arg1, arg2)</code>. Where the arguments can be of arbitrary type (string, integer, lambda, etc.).</p>
<p>Getting stuck. I think about how to represent the values that RLMeta works with instead. Lists, strings, integers, characters.</p>
<pre class="text"><code>#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;memory&gt;

class RLMetaObject {
    public:
        virtual ~RLMetaObject() {
        }
};

class RLMetaInteger : public RLMetaObject {
    private:
        int value;
    public:
        RLMetaInteger(int value) : value(value) {
        }
        ~RLMetaInteger() {
            std::cout &lt;&lt; &quot;Destructing integer &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
        }
};

class RLMetaString : public RLMetaObject {
    private:
        std::string value;
    public:
        RLMetaString(std::string value) : value(value) {
        }
        ~RLMetaString() {
            std::cout &lt;&lt; &quot;Destructing string &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
        }
};

int main() {
    std::list&lt;RLMetaObject&gt; objects;
    objects.push_back(RLMetaInteger(5));
    objects.push_back(RLMetaString(&quot;hello&quot;));
    std::list&lt;std::unique_ptr&lt;RLMetaObject&gt;&gt; objectPointers;
    objectPointers.push_back(
        std::make_unique&lt;RLMetaInteger&gt;(6)
    );
    objectPointers.push_back(
        std::make_unique&lt;RLMetaString&gt;(&quot;world&quot;)
    );
    return 0;
}</code></pre>
<pre class="text"><code>Destructing integer 5
Destructing string hello
Destructing integer 6
Destructing string world</code></pre>
<p>Since C++ containers can not store objects of arbitrary type, I introduce a base class. I also experiment with smart pointers. I find out that a virtual destructor is needed to make proper destruction. That really confused me.</p>
<p>Dynamic cast can work as <code>isinstance</code> in Python.</p>
<pre class="text"><code>#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;memory&gt;

class RLMetaObject {
    virtual bool matches(const RLMetaObject &amp;other) {
        return false;
    }
};

class RLMetaInteger : public RLMetaObject {
    private:
        int value;
    public:
        RLMetaInteger(int value) : value(value) {
        }
        bool matches(const RLMetaObject &amp;other) {
            try {
                const RLMetaInteger &amp;otherInt = dynamic_cast&lt;const RLMetaInteger&amp;&gt;(other);
                return otherInt.value == value;
            } catch (std::bad_cast) {}
            return false;
        }
};

int main() {
    RLMetaObject obj;
    RLMetaInteger int5(5);
    RLMetaInteger int6(6);
    std::cout &lt;&lt; &quot;Integer(5) matches Object?     &quot; &lt;&lt; int5.matches(obj)  &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;Integer(5) matches Integer(6)? &quot; &lt;&lt; int5.matches(int6)  &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;Integer(6) matches Integer(6)? &quot; &lt;&lt; int6.matches(int6)  &lt;&lt; &quot;\n&quot;;
    return 0;
}</code></pre>
<pre class="text"><code>Integer(5) matches Object?     0
Integer(5) matches Integer(6)? 0
Integer(6) matches Integer(6)? 1</code></pre>
<p>For this to work, there has to be some virtual member in the base class.</p>
<h2 id="fe0f8cbf13f49c0a4d9aa4f92fa2540misc">[]{#8fe0f8cbf13f49c0a4d9aa4f92fa2540}Misc</h2>
<pre><code>1.  runcpp.sh</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&gt;</span> tmp.cpp <span class="kw">&amp;&amp;</span> <span class="ex">g++</span> tmp.cpp -o tmp <span class="kw">&amp;&amp;</span> <span class="ex">./tmp</span> <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> tmp.cpp tmp</span></code></pre></div>

      <div class="jumbotron">
<div class="row">
<div class="col-md-12">

<p>What is Rickard working on and thinking about <strong>right
now</strong>?</p>

<p>Every month I write a <em>newsletter</em> about just that. You will get
updates about my <em>current projects</em> and <em>thoughts about
programming</em>, and also get a chance to hit reply and <em>interact</em> with
me. Subscribe to it below.</p>

</div>
</div>
<div class="row">
<div class="col-md-12">
<iframe scrolling="no" style="width:100%!important;height:220px;border:1px #ccc solid !important" src="https://buttondown.email/rickardlindberg?as_embed=true"></iframe>
</div>
</div>
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../../static/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
