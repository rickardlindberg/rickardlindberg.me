{
"root_page":{
"children":[
{
"children":[],
"id":"3df386e2afb1452b87a29185c2de0673",
"paragraphs":[
{
"fragments":[
{
"text":"The optimized version of RLMeta compiles grammars into Python classes which can be used like this:",
"type":"text"
}
],
"id":"2be765e8aac244ec9d8f00b89c97690d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"g = Grammar()\nresult = g.run(\"foo\", \"input string\")\n",
"type":"code"
}
],
"id":"220c9a12505344b2943560b1ca1adba5",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The VM based version uses the exact same interface. The difference is how the ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method is implemented. In the optimized version, it calls methods that represent rules in the grammar. The above call would result in ",
"type":"text"
},
{
"text":"_rule_foo",
"type":"code"
},
{
"text":" being called. That in turn would make calls to other methods representing other rules in the grammar. The VM based version instead has a sequence of instructions and a program counter that keeps track of which instruction to execute. The VM is invoked from the ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method.",
"type":"text"
}
],
"id":"0b695995e2434be7b4c363d147acbb26",
"type":"text"
},
{
"fragments":[
{
"text":"Let's look at the following grammar:",
"type":"text"
}
],
"id":"0905a88ed23d496f91063bd270e2c9e9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"Grammar {\n    foo = bar*\n    bar = .\n}\n",
"type":"code"
}
],
"id":"7f6647a8299145bc92f25e9b5dd2f09c",
"language":"rlmeta",
"type":"code"
},
{
"fragments":[
{
"text":"The original version compiles it into the following class with one method per rule in the grammar:",
"type":"text"
}
],
"id":"6e5eda3c12ca4c3c92b1b150d467ba6e",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class Grammar(_Grammar):\n\n    def _rule_foo(self):\n        return (lambda:\n            self._or([\n                (lambda:\n                    (lambda _vars:\n                        (lambda:\n                            self._and([\n                                (lambda:\n                                    self._star((lambda:\n                                        self._match_rule('bar')\n                                    ))\n                                ),\n                            ])\n                        )()\n                    )(_Vars())\n                ),\n            ])\n        )()\n\n    def _rule_bar(self):\n        return (lambda:\n            self._or([\n                (lambda:\n                    (lambda _vars:\n                        (lambda:\n                            self._and([\n                                self._match_any,\n                            ])\n                        )()\n                    )(_Vars())\n                ),\n            ])\n        )()\n",
"type":"code"
}
],
"id":"beb6ce197a734bc5b2d596f836d08d14",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The VM based version compiles it into the following class with a sequence of instructions:",
"type":"text"
}
],
"id":"25730620110f43b0bbad7cbc22351e35",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class Grammar(_Grammar):\n\n    def __init__(self):\n        self._instructions = i = []\n        self._labels = l = {}\n        def I(name, x=None, y=None):\n            i.append((name, x, y))\n        def LABEL(name):\n            l[name] = len(i)\n        LABEL('foo')\n        I('PUSH_SCOPE')\n        I('LIST_START')\n        LABEL(0)\n        I('BACKTRACK', 1)\n        I('CALL', 'bar')\n        I('LIST_APPEND')\n        I('COMMIT', 0)\n        LABEL(1)\n        I('LIST_END')\n        I('POP_SCOPE')\n        I('RETURN')\n        LABEL('bar')\n        I('PUSH_SCOPE')\n        I('MATCH_ANY')\n        I('POP_SCOPE')\n        I('RETURN')\n",
"type":"code"
}
],
"id":"c7d435c9c6714df98f5fd1709a6e1804",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The interface is exactly the same, but the two classes look rather different. The ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method in the original version looks like this:",
"type":"text"
}
],
"id":"99ed4abae55e43e7b6df26caa6468a0d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def run(self, rule_name, input_object):\n    self._memo = _Memo()\n    self._stream = _Stream.from_object(self._memo, input_object)\n    result = self._match_rule(rule_name).eval()\n    if isinstance(result, _Builder):\n        return result.build_string()\n    else:\n        return result\n",
"type":"code"
}
],
"id":"c0966aed1bd14c84a45f025fba4f9dc5",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"It does some setup and then calls ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":" to start matching.",
"type":"text"
}
],
"id":"b1ae724cee0f423cb4445baafbbf6225",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method in the VM based version looks like this:",
"type":"text"
}
],
"id":"e092d58a192c45d2becccf7dea1a8c17",
"type":"text"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _Grammar(object):\n\n    def run(self, rule_name, input_object):\n        if isinstance(input_object, basestring):\n            stream = input_object\n        else:\n            stream = [input_object]\n        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n",
"type":"code"
}
],
"id":"23389acd149c413aa2eb051b1733e79f",
"type":"code"
},
{
"fragments":[
{
"text":"It also does some setup, but then it hands over the instructions (created in the ",
"type":"text"
},
{
"text":"__init__",
"type":"code"
},
{
"text":" method) to the VM that then executes them.",
"type":"text"
}
],
"id":"b383f81f81294a04a559bb3d1277d1cf",
"type":"text"
},
{
"fragments":[
{
"text":"In the rest of this article I explain how grammars are compiled into VM instructions and how the VM is implemented.",
"type":"text"
}
],
"id":"835ddd05753e4f0093aa9df649ea825b",
"type":"text"
}
],
"title":"Difference from original"
},
{
"children":[],
"id":"d1a2d050fcc444cfa4991b968a02a315",
"paragraphs":[
{
"fragments":[
{
"text":"The parser in the VM based version has one additional rule for labels:",
"type":"text"
}
],
"id":"a3521271f17b4678bef1d97dd6c53ae0",
"type":"text"
},
{
"chunkpath":[
"expr1"
],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"| space '#'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Label\"]\n",
"type":"code"
}
],
"id":"7d940fabcc25497ab54b069f282f179c",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"A label is a semantic action that evaluates to a unique number. You will see later (in ",
"type":"text"
},
{
"page_id":"613d04f41a3e4521ad022a3d4e0237ea",
"text":null,
"type":"reference"
},
{
"text":", ",
"type":"text"
},
{
"page_id":"963d53648b304544be75045e59c6e183",
"text":null,
"type":"reference"
},
{
"text":", and ",
"type":"text"
},
{
"page_id":"0efe424b680f477a9bb8c1b9f679ff84",
"text":null,
"type":"reference"
},
{
"text":") how it is used in the code generator.",
"type":"text"
}
],
"id":"d05bd8f2d426436a8374f153a70f4fb2",
"type":"text"
},
{
"fragments":[
{
"text":"The rest of the parser is exactly the same as in the optimized version of RLMeta:",
"type":"text"
}
],
"id":"d2713c5c31814c30b086f60757b7f6df",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Star\" x]\n    | expr2:x space '?'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Not\" x]\n    | space '%'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchCallRule\"]\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"expr1"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"    | expr2\n  expr2 =\n    | space '->' hostExpr:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"SemanticAction\" x]\n    | name:x !(space '=')",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchRule\" x]\n    | space char:x '-' char:y",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchRange\" x y]\n    | space string:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchString\" x]\n    | space charseq:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchCharseq\" x]\n    | space '.'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchAny\"]\n    | space '(' choice:x space ')'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> x\n    | space '[' expr*:xs space ']'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"FnCall\" x ~ys]\n    | name:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"IndentBuilder\"]\n    | space '<'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"0a3d1c1a8c4c49ab803ba2aabb11f6b1",
"language":"",
"type":"code"
}
],
"title":"Parser"
},
{
"children":[
{
"children":[],
"id":"8fc432da8cb94c91baeba2ee6b69f40b",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Grammar",
"type":"code"
},
{
"text":" AST node is matched, a Python class inheriting ",
"type":"text"
},
{
"text":"_Grammar",
"type":"code"
},
{
"text":" is generated:",
"type":"text"
}
],
"id":"8486ff5b719645eab49940a26d36242d",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Grammar ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= .:x ast*:ys ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"class \" x \"(_Grammar):\\n\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"       \"def __init__(self):\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"self._instructions = i = []\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"self._labels = l = {}\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"def I(name, x=None, y=None):\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"           \"i.append((name, x, y))\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         <\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"def LABEL(name):\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"           \"l[name] = len(i)\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         <\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         ys\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"       <\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     < ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"9111d958b8ac481a95afc4becfe2f673",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"The name of the class is the same as the name of the grammar.",
"type":"text"
}
],
"id":"1735aab3a10f43c38a926cbcea8e7759",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"__init__",
"type":"code"
},
{
"text":" method has functionality for creating instructions. An instruction is represented as a Python tuple with three elements: the name, the first argument, and the second argument. Arguments can be ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":". Instructions are stored in a list. Labels is a dictionary mapping label names to positions in the instruction list.",
"type":"text"
}
],
"id":"99eb57fd403a43078274deb9c131253e",
"type":"text"
},
{
"fragments":[
{
"text":"The reason the shorthand names ",
"type":"text"
},
{
"text":"i",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"l",
"type":"code"
},
{
"text":" are used instead of ",
"type":"text"
},
{
"text":"self._instructions",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"self._labels",
"type":"code"
},
{
"text":" is that it is faster. Not using ",
"type":"text"
},
{
"text":"self",
"type":"code"
},
{
"text":" reduces one dictionary lookup.",
"type":"text"
}
],
"id":"3a5fbbadfd654c42bc1cd57075467383",
"type":"text"
},
{
"fragments":[
{
"text":"The child AST nodes of ",
"type":"text"
},
{
"text":"Grammar",
"type":"code"
},
{
"text":" are assumed to use the ",
"type":"text"
},
{
"text":"I",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"LABEL",
"type":"code"
},
{
"text":" functions to create instructions.",
"type":"text"
}
],
"id":"0066adc26f364c9280b98d78c07d8b1c",
"type":"text"
}
],
"title":"Grammar"
},
{
"children":[],
"id":"72b77f7c8a594757a67ef61f9502f8e9",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Rule",
"type":"code"
},
{
"text":" AST node is matched, instructions representing a function is generated:",
"type":"text"
}
],
"id":"f946bf28c65242788cd1180ebae9d8d4",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Rule ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ast:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"LABEL(\" x \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     y\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('RETURN')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"0030bc01dfd4497ca5d1a1e7af5a5267",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In a textual assembly-like notation (where labels are in the first column and instructions are in the second column) it would look like this:",
"type":"text"
}
],
"id":"5e625d7f13f64c0aba40c4da05e3a232",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"<x>:\n    <y instructions>\n    RETURN\n",
"type":"code"
}
],
"id":"e12c0ee9cbd24ef79b6036c53ab1b690",
"type":"code"
},
{
"fragments":[
{
"text":"First a label with the rule name is generated so that that location can be jumped to. Then instructions for the child AST nodes are generated. It ends with a return.",
"type":"text"
}
],
"id":"b054f14bf70948f48157f29d5f365828",
"type":"text"
}
],
"title":"Rule"
},
{
"children":[],
"id":"613d04f41a3e4521ad022a3d4e0237ea",
"paragraphs":[
{
"fragments":[
{
"text":"When an ",
"type":"text"
},
{
"text":"Or",
"type":"code"
},
{
"text":" AST node is matched, instructions representing a choice is generated:",
"type":"text"
}
],
"id":"c0c1e5c530cc45c9af6af459d4cb1773",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Or ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"=\n  | ast:x !. ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> x\n  | ast:x Or:y #:a #:b ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('BACKTRACK', \" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('COMMIT', \" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     y\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" b \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"60c72ca468044457b6bcaafc4178cc05",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"If there is only one choice, only the instructions for that choice are generated. Otherwise the following sequence is generated:",
"type":"text"
}
],
"id":"97d832060c594b469d8128bcd22e4caa",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    BACKTRACK a\n    <x instructions>\n    COMMIT b\na:\n    <y instructions>\nb:\n",
"type":"code"
}
],
"id":"db7b64eddc0f42f4b0c349c380c7a525",
"type":"code"
},
{
"fragments":[
{
"text":"Backtrack instructs the VM to try the next choice at label ",
"type":"text"
},
{
"text":"a",
"type":"code"
},
{
"text":" if the following instructions fail. Commit instructs the VM that the choice denoted by backtrack was successfully matched and continue execution at label ",
"type":"text"
},
{
"text":"b",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"9a3ecf2ae87648b2897f1499fd96dfae",
"type":"text"
}
],
"title":"Or"
},
{
"children":[],
"id":"e0d721aa4fae40af8de5a54253243cb0",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Scope ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('PUSH_SCOPE')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('POP_SCOPE')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"7dfdff1e9c5b49b0b9438274eb4c9066",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    PUSH_SCOPE\n    <x instructions>\n    POP_SCOPE\n",
"type":"code"
}
],
"id":"6a44a5d5f46c45978ea745716fb015e9",
"type":"code"
}
],
"title":"Scope"
},
{
"children":[],
"id":"34ee0862096d4fd4aa3342c4b3b6c294",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"And ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast*\n",
"type":"code"
}
],
"id":"f7d10f9b03cb4de9b586b1630437c1cc",
"language":"",
"type":"code"
}
],
"title":"And"
},
{
"children":[],
"id":"8275c4d4e16c483f84be55f550e3d39c",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Bind ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ast:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { y\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('BIND', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"91b566e351da49a1b368525c3a1a9879",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    <y instructions>\n    BIND <x>\n",
"type":"code"
}
],
"id":"4677b3a2c9a34a6b8d346abe5d31add4",
"type":"code"
}
],
"title":"Bind"
},
{
"children":[],
"id":"963d53648b304544be75045e59c6e183",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Star ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x #:a #:b ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('LIST_START')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('BACKTRACK', \" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('LIST_APPEND')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('COMMIT', \" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('LIST_END')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"30ee03ac51a74627829bfcce1ac3904c",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    LIST_START\na:\n    BACKTRACK b\n    <x instructions>\n    LIST_APPEND\n    COMMIT a\nb:\n    LIST_END\n",
"type":"code"
}
],
"id":"4b242e08b44c4a5cab63a14a86b0f38e",
"type":"code"
}
],
"title":"Star"
},
{
"children":[],
"id":"0efe424b680f477a9bb8c1b9f679ff84",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Not ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x #:a #:b ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('BACKTRACK', \" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('COMMIT', \" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('FAIL', 'no match expected')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" b \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"591d05c1297e4fb88e8c38d9a3147cf5",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    BACKTRACK b\n    <x instructions>\n    COMMIT a\na:\n    FAIL 'no match expected'\nb:\n",
"type":"code"
}
],
"id":"a236ed6e09a74616a8c6a744580dfe0e",
"type":"code"
},
{
"fragments":[
{
"text":"Fail position is incorrect. Should be before any matching at all.",
"type":"text"
}
],
"id":"025cbe8b202845f28a233a0cd976460f",
"type":"text"
},
{
"fragments":[
{
"text":"Hmm. When inside a not, failures should probably not be recorded at all.",
"type":"text"
}
],
"id":"d51f8161207846ff8135a8711652610e",
"type":"text"
}
],
"title":"Not"
},
{
"children":[],
"id":"24675b6707284a99ba3d3cb17b60e3f2",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchCallRule ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_CALL_RULE')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"58615573c36b4b64a383842e606b8c3c",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_CALL_RULE\n",
"type":"code"
}
],
"id":"955e4c5838154ae1be3ad97c79b40778",
"type":"code"
}
],
"title":"MatchCallRule"
},
{
"children":[],
"id":"629b7ffad2d54725ad0af4e73bf434d8",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Label ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('LABEL')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"29f6921c01e944589f1955077ef0a589",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    LABEL\n",
"type":"code"
}
],
"id":"a38019613bfa4096bb368ea511fdf0be",
"type":"code"
}
],
"title":"Label"
},
{
"children":[],
"id":"4ddebcb41511403c8b3fa5c96f14c8f4",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"SemanticAction ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('ACTION', lambda env: \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"da478954dd5e474cab2bd28756636e33",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    ACTION <python lambda>\n",
"type":"code"
}
],
"id":"a3469ef02b8041c58a9142a2de0f170b",
"type":"code"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"String ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py\nList ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= astList:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { x ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nBuilder ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= astItems:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"_Builder.create([\" x \"])\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nIndentBuilder ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"_IndentBuilder()\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nDedentBuilder ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"_DedentBuilder()\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nFnCall ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= .:x astItems:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { x \"(\" y \")\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nVarLookup ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"env[\" x \"].eval()\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastItems ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"=\n  | ast:x astItem*:xs ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { x xs ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n  |                   ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastItem ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \", \" x ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastList ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= astListItem*:xs ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"(\" xs \"[])\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastListItem ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"=\n  | [\"ListItemSplice\" ast:x] ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> {     x  \"+\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n  | ast:x                    ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"[\" x \"]+\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"2ee5361a424942a6aa7944db88e80f22",
"language":"",
"type":"code"
},
{
"chunkpath":[
"imports"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n",
"type":"code"
}
],
"id":"4d06e64ddc8941928ee419ac82f56c4d",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n",
"type":"code"
}
],
"id":"5545be940203494ab9bcd6ce8227bba4",
"type":"code"
}
],
"title":"SemanticAction"
},
{
"children":[],
"id":"fc62b5be27fd4e40978d415ba4070a05",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchRule ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('CALL', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"7bf436c56fdc473b8e8d4102f9e9d75f",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    CALL <rule>\n",
"type":"code"
}
],
"id":"3f1433008b854027bcd35fd68c51b2f4",
"type":"code"
}
],
"title":"MatchRule"
},
{
"children":[],
"id":"ce3171f9336a4f1a961f4d6fd6665361",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchRange ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x py:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_RANGE', \" x \", \" y \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"de2ceb8e15d64c4797d956d3015f41bb",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_RANGE <x> <y>\n",
"type":"code"
}
],
"id":"c8cb5b2b91e941ee8ed35c8a8a88c1e3",
"type":"code"
}
],
"title":"MatchRange"
},
{
"children":[],
"id":"40fcdbbabfe44b009d3f405060a2055f",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchString ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_STRING', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"57444b0d737840e88781f30b1ba8d250",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_STRING <x>\n",
"type":"code"
}
],
"id":"844cbe1b28ee4f578a3f037ab94e74d4",
"type":"code"
}
],
"title":"MatchString"
},
{
"children":[],
"id":"c6e2326b6b774601b761538455918bbe",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchCharseq ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_CHARSEQ', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"ae3894890b5f46ee83f0350438e9e307",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_CHARSEQ <x>\n",
"type":"code"
}
],
"id":"aea4f196262c4096a2ba6f734076a1cc",
"type":"code"
}
],
"title":"MatchCharseq"
},
{
"children":[],
"id":"de0847d410c6495d9a8ee4e75a0423cc",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchAny ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_ANY')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"da1967debbe5402392c3b98c6b8d58ef",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_ANY\n",
"type":"code"
}
],
"id":"6a45732466244481ac5333f8bd104e11",
"type":"code"
}
],
"title":"MatchAny"
},
{
"children":[],
"id":"1dc829aba4484ed399eb025d01ed843e",
"paragraphs":[
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchList ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('PUSH_STREAM')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('POP_STREAM')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"f1cd0227605b46789a8dfd623e24d3f9",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    PUSH_STREAM\n    <x instructions>\n    POP_STREAM\n",
"type":"code"
}
],
"id":"b8c24c202db540339de7835186403f3a",
"type":"code"
}
],
"title":"MatchList"
}
],
"id":"24aa83d59704475dba2a010f1b5d3eb0",
"paragraphs":[
{
"fragments":[
{
"text":"How to generate the instructions for the VM?",
"type":"text"
}
],
"id":"77fbc0cbe00244098d618e7ec42178ca",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"rules"
],
"prefix":"  ",
"type":"chunk"
},
{
"text":"  ast ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= [%:x] ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { x ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n  py ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= .:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> repr(x)\n}\n",
"type":"code"
}
],
"id":"c4887eaa08da4799acaad6fdbde5d2f7",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"blank_lines_before":1,
"path":[
"imports"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"vm"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"classes"
],
"prefix":"",
"type":"chunk"
}
],
"id":"5dd5edbabef546a383244c3df74dc7b0",
"type":"code"
}
],
"title":"Code generator"
},
{
"children":[
{
"children":[],
"id":"49ca0a2fa665466cb90c8c128d5cc835",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"if name == \"PUSH_SCOPE\":\n    ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".append(",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = {}\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"2c1a5595c42d499bbb325bae3bd2f874",
"type":"code"
}
],
"title":"PUSH_SCOPE"
},
{
"children":[],
"id":"542906286e124874b2975d0ae23f034f",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"BACKTRACK\":\n    ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[arg1], ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":", len(",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"), len(",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":")))\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"d29ae793a57c42b5bb6e02f16abaf717",
"type":"code"
},
{
"fragments":[
{
"text":"Is lengths enough to save? Can stacks never change just topmost item?",
"type":"text"
}
],
"id":"a36b46a7d47a432a86f322cece209102",
"type":"text"
}
],
"title":"BACKTRACK"
},
{
"children":[],
"id":"8e19cbb2e71c412f95c7e241a69f0901",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"CALL\":\n    key = (arg1, tuple([x[1] for x in ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"]+[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"]))\n    if key in ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":":\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":"[key]\n        ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[:]\n        ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".pop()\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    else:\n        ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":"+1, key))\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[arg1]\n    continue\n",
"type":"code"
}
],
"id":"a0bfc0043b73482885ddcd87f913ce76",
"type":"code"
}
],
"title":"CALL"
},
{
"children":[],
"id":"df5dc1b5e5054e548d5c3606daba0d55",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_CHARSEQ\":\n    for char in arg1:\n        if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"] != char:\n            ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected {!r}\", char)\n            break\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(arg1)\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"faee63d4203f433fb4665fd4cb5abf1f",
"type":"code"
}
],
"title":"MATCH_CHARSEQ"
},
{
"children":[],
"id":"5b99ed36fbde45989829fde6e17d4821",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"COMMIT\":\n    ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[arg1]\n    continue\n",
"type":"code"
}
],
"id":"8222233eb6b140a495fb9884f4c637df",
"type":"code"
}
],
"title":"COMMIT"
},
{
"children":[],
"id":"b2510846e20d4cd08f9b0cd2dfb5c01d",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"POP_SCOPE\":\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"4d43ad60b62549fe9a4d837858a1e6b6",
"type":"code"
}
],
"title":"POP_SCOPE"
},
{
"children":[],
"id":"d104aa6d6b8e43818f662498f6566e38",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"RETURN\":\n    if len(",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":") == 0:\n        return ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":".eval()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":", key = ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":"[key] = (",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"+[(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":")])\n    continue\n",
"type":"code"
}
],
"id":"7afc540dab7b454a9805ec62225de4dc",
"type":"code"
}
],
"title":"RETURN"
},
{
"children":[],
"id":"b4aacd38dec8406c9db784e0823c3554",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LIST_APPEND\":\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":".append(",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"356f537a114549d590cbcec132d12154",
"type":"code"
}
],
"title":"LIST_APPEND"
},
{
"children":[],
"id":"1315305641224e4aa99dd00ec5b524b1",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"BIND\":\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":"[arg1] = ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":"\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"fa7420fc6e714750afb1d9a559ba60a3",
"type":"code"
}
],
"title":"BIND"
},
{
"children":[],
"id":"738356fde86e4c7290b0f99850917ba8",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"ACTION\":\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _SemanticAction(arg1, ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"ca202e729537441f88100eb2b1fb8936",
"type":"code"
}
],
"title":"ACTION"
},
{
"children":[],
"id":"d8dcb57d5da141908f28f8c52983d1a6",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_RANGE\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or not (arg1 <= ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"] <= arg2):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected range {!r}-{!r}\", arg1, arg2)\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"])\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"500a0c29c73e42448e1c4c8ea67c13cf",
"type":"code"
}
],
"title":"MATCH_RANGE"
},
{
"children":[],
"id":"b3562467300348028f04ae5034db0f34",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LIST_START\":\n    ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".append(",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = []\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"089a8080f82b404cbbb99de6dd80090a",
"type":"code"
}
],
"title":"LIST_START"
},
{
"children":[],
"id":"9940cd44d7fe4777b1c12e335bac33ae",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LIST_END\":\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _SemanticAction(lambda xs: [x.eval() for x in xs], ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"7562783a1dc34c42beb05e22ee0ae2f4",
"type":"code"
}
],
"title":"LIST_END"
},
{
"children":[],
"id":"8f0fffeab7084a1d9b01d928be4878a8",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_ANY\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected any\",)\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"])\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"97063c2aa95a48b1886545a984494caf",
"type":"code"
}
],
"title":"MATCH_ANY"
},
{
"children":[],
"id":"fee2dcf573f04ac3a9e7cfd92adbe0c8",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"PUSH_STREAM\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or not isinstance(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"], list):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected list\",)\n    else:\n        ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"+1))\n        ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"]\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = 0\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"c5ae99acbb584d718d09917f827884f4",
"type":"code"
}
],
"title":"PUSH_STREAM"
},
{
"children":[],
"id":"87a1eee2cfb94e1a9463a6561c226012",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"POP_STREAM\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" < len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected end of list\",)\n    else:\n        ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".pop()\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"5f242526e0af408ebd0038e2ec2c4797",
"type":"code"
}
],
"title":"POP_STREAM"
},
{
"children":[],
"id":"d42df29209bf475280ac510d9ae31182",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_CALL_RULE\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected any\",)\n    else:\n        fn_name = str(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"])\n        key = (fn_name, tuple([x[1] for x in ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"]+[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"]))\n        if key in ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":":\n            ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":"[key]\n            ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[:]\n            ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".pop()\n            ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        else:\n            ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":"+1, key))\n            ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[fn_name]\n            ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"05a80103eda14253a19d5770172c51b1",
"type":"code"
}
],
"title":"MATCH_CALL_RULE"
},
{
"children":[],
"id":"34915cae29994179abbe19f2f7e4c267",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"FAIL\":\n    ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (arg1,)\n",
"type":"code"
}
],
"id":"455aa8f0eafd4641a124090a5b7bdb25",
"type":"code"
},
{
"chunkpath":[
"vm",
"fail case"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"fail_pos = tuple([x[1] for x in ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"]+[pos])\nif fail_pos >= ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":":\n    ",
"type":"code"
},
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":"\n    ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":" = fail_pos\n",
"type":"code"
}
],
"id":"3aeef8c3298b44c0acb4a2ce8079d334",
"type":"code"
},
{
"chunkpath":[
"vm",
"fail case"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"call_backtrack_entry = tuple()\nwhile ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":":\n    call_backtrack_entry = ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".pop()\n    if len(call_backtrack_entry) == 4:\n        break\nif len(call_backtrack_entry) != 4:\n    raise ",
"type":"code"
},
{
"id":"67782a80b8a0487f8930e57551490023",
"type":"variable"
},
{
"text":"(\n        ",
"type":"code"
},
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":",\n        ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":",\n        ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[0] if ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" else stream\n    )\n(",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":", stream_stack_len, env_stack_len) = call_backtrack_entry\nif len(",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":") > stream_stack_len:\n    ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[stream_stack_len][0]\n",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[:stream_stack_len]\nif len(",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":") > env_stack_len:\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":"[env_stack_len]\n",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":"[:env_stack_len]\n",
"type":"code"
}
],
"id":"24208f79ca7941c390b8600e4977b413",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"67782a80b8a0487f8930e57551490023",
"type":"variable"
},
{
"text":"(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\n    def describe(self):\n        stream = self.stream\n        pos = self.pos\n        while len(pos) > 1:\n            stream = stream[pos.pop(0)]\n        pos = pos[0]\n        message = \"\"\n        if isinstance(stream, basestring):\n            pos1, error_line_before = self._extract_line(stream, pos, -1)\n            pos2, error_line_after = self._extract_line(stream, pos+1, 1)\n            _, context_before = self._extract_line(stream, pos1, -1)\n            _, context_after = self._extract_line(stream, pos2, 1)\n            if context_before:\n                message += \"> \"\n                message += context_before\n                message += \"\\n\"\n            message += \"> \"\n            message += error_line_before\n            message += error_line_after\n            message += \"\\n\"\n            message += \"--\"\n            message += \"-\"*(len(error_line_before)-1)\n            message += \"^\\n\"\n            if context_after:\n                message += \"> \"\n                message += context_after\n                message += \"\\n\"\n        else:\n            message += \"todo: list failure context\\n\"\n        message += \"Error: \"\n        message += self.message[0].format(*self.message[1:])\n        message += \"\\n\"\n        return message\n\n    def _extract_line(self, text, pos, direction):\n        line = []\n        while pos >= 0:\n            try:\n                if text[pos] == \"\\n\":\n                    if line:\n                        break\n                else:\n                    if direction == 1:\n                        line.append(text[pos])\n                    else:\n                        line.insert(0, text[pos])\n                pos += direction\n            except IndexError:\n                break\n        return (pos+direction, \"\".join(line))\n",
"type":"code"
}
],
"id":"cb26185f6f2d4de68f35b8f00712b577",
"type":"code"
},
{
"fragments":[
{
"text":"Fix list failure messages. And cleanup failure message formatting.",
"type":"text"
}
],
"id":"b96e160d222e4d28a37b51ddba1a290b",
"type":"text"
}
],
"title":"FAIL"
},
{
"children":[],
"id":"d7d285d9586b437ca7d7f51b5deb6193",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LABEL\":\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(",
"type":"code"
},
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":" += 1\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"690d125013b74bdfa88a28e52dc4c184",
"type":"code"
}
],
"title":"LABEL"
},
{
"children":[],
"id":"a8160d30b886418882ada3a2a884e580",
"paragraphs":[
{
"chunkpath":[
"vm",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_STRING\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"] != arg1:\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected {!r}\", arg1)\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(arg1)\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"2d8eef6d882b434abbb5f835f666c498",
"type":"code"
}
],
"title":"MATCH_STRING"
}
],
"id":"e66f8cec6206420abe4736ae32849c53",
"paragraphs":[
{
"child_type":"unordered",
"children":[
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Environment",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Stream",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Call/Backtrack",
"type":"text"
}
]
}
],
"fragments":[
{
"text":"Stacks",
"type":"text"
}
]
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Label counter",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Last action",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"PC",
"type":"text"
}
]
}
],
"fragments":[
{
"text":"Registers",
"type":"text"
}
]
}
],
"id":"539fcebc3c894449af9d0cf35c082ef5",
"type":"list"
},
{
"chunkpath":[
"vm"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def rlmeta_vm(",
"type":"code"
},
{
"id":"ca256b5a40ca4d7a9359374655d29b3d",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"46962506a4b34797a7bd52e4203131ef",
"type":"variable"
},
{
"text":", stream):\n    ",
"type":"code"
},
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":" = 0\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(None)\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"46962506a4b34797a7bd52e4203131ef",
"type":"variable"
},
{
"text":"]\n    ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":" = []\n    ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = (stream, 0, [])\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":" = (None, [])\n    ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":" = (None, None, tuple())\n    ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":" = {}\n    while True:\n        name, arg1, arg2 = ",
"type":"code"
},
{
"id":"ca256b5a40ca4d7a9359374655d29b3d",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":"]\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"cases"
],
"prefix":"        ",
"type":"chunk"
},
{
"text":"        else:\n            raise Exception(\"unknown command {}\".format(name))\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"fail case"
],
"prefix":"        ",
"type":"chunk"
}
],
"id":"f00b388c4529474b9925b3aa4149b0e3",
"type":"code"
},
{
"fragments":[
{
"text":"Instruction frequency analysis to optimize order of while loop.",
"type":"text"
}
],
"id":"68e3bcae66ca4daf9fd359a53559b019",
"type":"text"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _SemanticAction(object):\n\n    def __init__(self, fn, value):\n        self.fn = fn\n        self.value = value\n\n    def eval(self):\n        return self.fn(self.value)\n",
"type":"code"
}
],
"id":"64bbd9910fc94f7c9fcb5918408a9ff0",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _ConstantSemanticAction(object):\n\n    def __init__(self, value):\n        self.value = value\n\n    def eval(self):\n        return self.value\n",
"type":"code"
}
],
"id":"435a082d5e964a7e835a9362d6c5c045",
"type":"code"
}
],
"title":"VM"
},
{
"children":[
{
"children":[],
"id":"53f0708b231b468d844291df3fe17cf2",
"paragraphs":[
{
"code_id":"0a3d1c1a8c4c49ab803ba2aabb11f6b1",
"id":"82002b8dd2284b2ca2355c83aed9f216",
"type":"expanded_code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"74bf51f7e8d94bcba1747edb477137ef",
"paragraphs":[
{
"code_id":"c4887eaa08da4799acaad6fdbde5d2f7",
"id":"a376af48b31246aba6d5a8bc75857e7f",
"type":"expanded_code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"60ff77cb85fa455589e3e45cdeac8160",
"paragraphs":[
{
"code_id":"5dd5edbabef546a383244c3df74dc7b0",
"id":"a5db6607ca9547a885d956e3916cb92d",
"type":"expanded_code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"338ad257e61e4025b8859d610a475c6a",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except ",
"type":"code"
},
{
"id":"67782a80b8a0487f8930e57551490023",
"type":"variable"
},
{
"text":" as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"5603502f765e4392be55f0ad5f8ec9ac",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"272d17f2d55749b59d7e5ec7b9b8e0ec",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"59997b4d5c134c4183d2f5a1f8804543",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"7e7b4c5318ff4c849c6e98e9ddeaacf0",
"paragraphs":[],
"title":"Code listings for RLMeta"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I present an alternative implementation of ",
"type":"text"
},
{
"text":"RLMeta",
"type":"link",
"url":"/writing/rlmeta/index.html"
},
{
"text":" in which grammars are compiled into instructions for a virtual machine (VM).",
"type":"text"
}
],
"id":"ad1d041250524b98a193f9fd3fa627f5",
"type":"text"
},
{
"fragments":[
{
"text":"The VM based version builds upon the ",
"type":"text"
},
{
"text":"optimized version of RLMeta",
"type":"link",
"url":"/writing/optimizing-rlmeta/index.html"
},
{
"text":".",
"type":"text"
}
],
"id":"79ae9067afde497085d5b885fe4fb8a4",
"type":"text"
},
{
"fragments":[
{
"text":"The implementation is inspired by ",
"type":"text"
},
{
"text":"Regular Expression Matching: the Virtual Machine Approach",
"type":"link",
"url":"https://swtch.com/~rsc/regexp/regexp2.html"
},
{
"text":" and ",
"type":"text"
},
{
"text":"A Text Pattern-Matching Tool based on Parsing Expression Grammars",
"type":"link",
"url":"http://www.inf.puc-rio.br/%7Eroberto/docs/peg.pdf"
},
{
"text":".",
"type":"text"
}
],
"id":"d21cbbff552e4c8dafd419861250c3c4",
"type":"text"
}
],
"title":"RLMeta: a VM based approach"
},
"variables":{
"0799d98c45e348e59ff71aa2d228a38b":"latest_fail_pos",
"0a9fe66a6284461caec36d4cc17e0f84":"stream_pos_stack",
"1a932d7b55d945b68f7ac7a869283721":"labels",
"46962506a4b34797a7bd52e4203131ef":"start_rule",
"4ae34787de174f88ac725fd6d0132a9b":"stream",
"5a36de8ac0824e5e9e2d50ce6256b57a":"latest_fail_message",
"67782a80b8a0487f8930e57551490023":"_MatchError",
"68c9f5e79a3d4b04b5fe8c855cd71fff":"memo",
"6e2f0ba81b194ccab59fa146d23bb428":"env_stack",
"8da6870b3e814a309ac487512eb28fc6":"env",
"ad46fcaa30dd48a0b04ab6d5ed3eb6c6":"pos",
"afdefdc6c0eb44d698ceb67eda022dc8":"call_backtrack_stack",
"b097b5b85d854f2bb89c4d50e8fe5577":"label_counter",
"c21d83213c4b4e3d9fc2f0b1d6940f77":"pc",
"ca256b5a40ca4d7a9359374655d29b3d":"instructions",
"d8f11069efcf4d318774bb082784c178":"last_action",
"e3158ae25dfe4975a53ca22a70d76d01":"fail_message"
}
}