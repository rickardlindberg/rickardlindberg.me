{
"root_page":{
"children":[
{
"children":[],
"id":"5cca99df2e2c4c78ab4bfe4cb946d89a",
"paragraphs":[
{
"fragments":[
{
"text":"Not using ",
"type":"text"
},
{
"text":"self",
"type":"code"
},
{
"text":" seems to improve performance. Is self always compiled to dictionary lookup, but local variable lookup to indexing in call stack?",
"type":"text"
}
],
"id":"3a5fbbadfd654c42bc1cd57075467383",
"type":"text"
},
{
"fragments":[
{
"text":"Instruction frequency analysis to optimize order of while loop.",
"type":"text"
}
],
"id":"68e3bcae66ca4daf9fd359a53559b019",
"type":"text"
}
],
"title":"Notes"
},
{
"children":[],
"id":"7e7b4c5318ff4c849c6e98e9ddeaacf0",
"paragraphs":[
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'      -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y                -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs      -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs                          -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y                 -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'                        -> [\"Star\" x]\n    | expr2:x space '?'                        -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x                        -> [\"Not\" x]\n    | space '%'                                -> [\"MatchCallRule\"]\n    | space '#'                                -> [\"Label\"]\n    | expr2\n  expr2 =\n    | space '->' hostExpr:x                    -> [\"SemanticAction\" x]\n    | name:x !(space '=')                      -> [\"MatchRule\" x]\n    | space char:x '-' char:y                  -> [\"MatchRange\" x y]\n    | space string:x                           -> [\"MatchString\" x]\n    | space charseq:x                          -> [\"MatchCharseq\" x]\n    | space '.'                                -> [\"MatchAny\"]\n    | space '(' choice:x space ')'             -> x\n    | space '[' expr*:xs space ']'             -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x                           -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']' -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'        -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'  -> [\"FnCall\" x ~ys]\n    | name:x                                   -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x                     -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'                                -> [\"IndentBuilder\"]\n    | space '<'                                -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'   -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''  -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''  -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs   -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n\nCodeGenerator {\n  Grammar        = .:x ast*:ys     -> { \"class \" x \"(_Program):\\n\" >\n                                          \"def __init__(self):\\n\" >\n                                            \"instructions = []\\n\"\n                                            \"labels = {}\\n\"\n                                            \"def I(name, x=None, y=None):\\n\" >\n                                              \"instructions.append((name, x, y))\\n\"\n                                            <\n                                            \"def LABEL(name):\\n\" >\n                                              \"labels[name] = len(instructions)\\n\"\n                                            <\n                                            ys\n                                            \"self._instructions = instructions\\n\"\n                                            \"self._labels = labels\\n\"\n                                          <\n                                        <                                  }\n  Rule           = py:x ast:y      -> { \"LABEL(\" x \")\\n\"\n                                        y\n                                        \"I('RETURN')\\n\"                    }\n  MatchAny       =                 -> { \"I('MATCH_ANY')\\n\"                 }\n  MatchCallRule  =                 -> { \"I('MATCH_CALL_RULE')\\n\"           }\n  String         = py\n  List           = astList:x       -> { x                                  }\n  Builder        = astItems:x      -> { \"_Builder.create([\" x \"])\"         }\n  IndentBuilder  =                 -> { \"_IndentBuilder()\"                 }\n  DedentBuilder  =                 -> { \"_DedentBuilder()\"                 }\n  FnCall         = .:x astItems:y  -> { x \"(\" y \")\"                        }\n  VarLookup      = py:x            -> { \"env[\" x \"].eval()\"                }\n  Or             =\n    | ast:x !.                     -> x\n    | ast:x Or:y #:a #:b           -> { \"I('BACKTRACK', \" a \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" b \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        y\n                                        \"LABEL(\" b \")\\n\"                   }\n  Scope          = ast:x           -> { \"I('PUSH_SCOPE')\\n\"\n                                        x\n                                        \"I('POP_SCOPE')\\n\"                 }\n  And            = ast*\n  Bind           = py:x ast:y      -> { y\n                                        \"I('BIND', \" x \")\\n\"               }\n  Star           = ast:x #:a #:b   -> { \"I('LIST_START')\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('LIST_APPEND')\\n\"\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" b \")\\n\"\n                                        \"I('LIST_END')\\n\"                  }\n  Not            = ast:x #:a #:b   -> { \"I('BACKTRACK', \" b \")\\n\"\n                                        x\n                                        \"I('COMMIT', \" a \")\\n\"\n                                        \"LABEL(\" a \")\\n\"\n                                        \"I('FAIL')\\n\"\n                                        \"LABEL(\" b \")\\n\"                   }\n  SemanticAction = ast:x           -> { \"I('ACTION', lambda env: \" x \")\\n\" }\n  Label          =                 -> { \"I('LABEL')\\n\"                     }\n  MatchRule      = py:x            -> { \"I('CALL', \" x \")\\n\"               }\n  MatchRange     = py:x py:y       -> { \"I('MATCH_RANGE', \" x \", \" y \")\\n\" }\n  MatchString    = py:x            -> { \"I('MATCH_STRING', \" x \")\\n\"       }\n  MatchCharseq   = py:x            -> { \"I('MATCH_CHARSEQ', \" x \")\\n\"      }\n  MatchList      = ast:x           -> { \"I('PUSH_INPUT')\\n\"\n                                        x\n                                        \"I('POP_INPUT')\\n\"                 }\n  ast            = [%:x]           -> { x                                  }\n  astItems       =\n    | ast:x astItem*:xs            -> { x xs                               }\n    |                              -> {                                    }\n  astItem        = ast:x           -> { \", \" x                             }\n  astList        = astListItem*:xs -> { \"(\" xs \"[])\"                       }\n  astListItem    =\n    | [\"ListItemSplice\" ast:x]     -> {     x  \"+\"                         }\n    | ast:x                        -> { \"[\" x \"]+\"                         }\n  py             = .:x             -> repr(x)\n}\n",
"type":"code"
}
],
"id":"0a3d1c1a8c4c49ab803ba2aabb11f6b1",
"language":"rlmeta",
"type":"code"
}
],
"title":"Code listings"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"This builds upon the optimized version of RLMeta.",
"type":"text"
}
],
"id":"ad1d041250524b98a193f9fd3fa627f5",
"type":"text"
}
],
"title":"RLMeta a VM based approach"
},
"variables":{}
}