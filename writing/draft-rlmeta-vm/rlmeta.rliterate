{
"root_page":{
"children":[
{
"children":[],
"id":"3df386e2afb1452b87a29185c2de0673",
"paragraphs":[
{
"fragments":[
{
"text":"The optimized version compiles grammars into Python classes which can be used like this:",
"type":"text"
}
],
"id":"2be765e8aac244ec9d8f00b89c97690d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"g = Grammar()\nresult = g.run(\"foo\", \"input string\")\n",
"type":"code"
}
],
"id":"220c9a12505344b2943560b1ca1adba5",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The VM based version also compiles grammars into Python classes with the same interface. The difference is how the ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method is implemented. In the optimized version, it calls methods that represent rules in the grammar. The above call would result in ",
"type":"text"
},
{
"text":"_rule_foo",
"type":"code"
},
{
"text":" being called. That in turn would make calls to other methods representing other rules in the grammar. The VM based version instead has a sequence of instructions and a program counter that keeps track of which instruction to execute. The VM is invoked from the ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method.",
"type":"text"
}
],
"id":"0b695995e2434be7b4c363d147acbb26",
"type":"text"
},
{
"fragments":[
{
"text":"To make the difference more clear, let's look at the ",
"type":"text"
},
{
"text":"Scream",
"type":"code"
},
{
"text":" grammar that turns its input into a screaming equivalent (",
"type":"text"
},
{
"text":"hello",
"type":"code"
},
{
"text":" to ",
"type":"text"
},
{
"text":"HELLO!!",
"type":"code"
},
{
"text":" for example):",
"type":"text"
}
],
"id":"0905a88ed23d496f91063bd270e2c9e9",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"Scream {\n    scream = char*:xs -> { xs \"!!\" }\n    char   = .:x      -> upper(x)\n}\n",
"type":"code"
}
],
"id":"e1a908541846473db76a4661491f43d5",
"language":"rlmeta",
"post_process":[],
"type":"code"
},
{
"fragments":[
{
"text":"The optimized version compiles it into the following class with one method per rule in the grammar:",
"type":"text"
}
],
"id":"6e5eda3c12ca4c3c92b1b150d467ba6e",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class Scream(_Grammar):\n\n    def _rule_scream(self):\n        return (lambda: (lambda _vars:\n            (lambda: self._and([\n                (lambda: _vars.bind('xs', (lambda: self._star((lambda: self._match_rule('char'))))())),\n                (lambda: _SemanticAction(lambda: _Builder.create([\n                    _vars.lookup('xs').eval(),\n                    '!!',\n                ]))),\n            ]))()\n        )(_Vars()))()\n\n    def _rule_char(self):\n        return (lambda: (lambda _vars:\n            (lambda: self._and([\n                (lambda: _vars.bind('x', self._match_any())),\n                (lambda: _SemanticAction(lambda: upper(\n                    _vars.lookup('x').eval(),\n                ))),\n            ]))()\n        )(_Vars()))()\n",
"type":"code"
}
],
"id":"beb6ce197a734bc5b2d596f836d08d14",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The VM based version compiles it into the following class with a sequence of instructions (don't worry about understanding them now, it will be clear later what the instructions mean):",
"type":"text"
}
],
"id":"25730620110f43b0bbad7cbc22351e35",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"class Scream(_Grammar):\n\n    def __init__(self):\n        self._instructions = i = []\n        self._labels = l = {}\n        def I(name, x=None, y=None):\n            i.append((name, x, y))\n        def LABEL(name):\n            l[name] = len(i)\n        LABEL('scream')\n        I('PUSH_SCOPE')\n        I('LIST_START')\n        LABEL(0)\n        I('BACKTRACK', 1)\n        I('CALL', 'char')\n        I('LIST_APPEND')\n        I('COMMIT', 0)\n        LABEL(1)\n        I('LIST_END')\n        I('BIND', 'xs')\n        I('ACTION', lambda scope: _Builder.create([scope['xs'].eval(), '!!']))\n        I('POP_SCOPE')\n        I('RETURN')\n        LABEL('char')\n        I('PUSH_SCOPE')\n        I('MATCH_ANY')\n        I('BIND', 'x')\n        I('ACTION', lambda scope: upper(scope['x'].eval()))\n        I('POP_SCOPE')\n        I('RETURN')\n",
"type":"code"
}
],
"id":"0a31a676a4814fe3866f0d06530e4a97",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"The external interface of the classes is exactly the same, but internally they look rather different. The ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method in the optimized version looks like this:",
"type":"text"
}
],
"id":"99ed4abae55e43e7b6df26caa6468a0d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"def run(self, rule_name, input_object):\n    self._memo = _Memo()\n    self._stream = _Stream.from_object(self._memo, input_object)\n    result = self._match_rule(rule_name).eval()\n    if isinstance(result, _Builder):\n        return result.build_string()\n    else:\n        return result\n",
"type":"code"
}
],
"id":"c0966aed1bd14c84a45f025fba4f9dc5",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"It does some setup and then calls ",
"type":"text"
},
{
"text":"_match_rule",
"type":"code"
},
{
"text":" to start matching.",
"type":"text"
}
],
"id":"b1ae724cee0f423cb4445baafbbf6225",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"run",
"type":"code"
},
{
"text":" method in the VM based version looks like this:",
"type":"text"
}
],
"id":"e092d58a192c45d2becccf7dea1a8c17",
"type":"text"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _Grammar(object):\n\n    def run(self, rule_name, input_object):\n        if isinstance(input_object, basestring):\n            stream = input_object\n        else:\n            stream = [input_object]\n        result = rlmeta_vm(self._instructions, self._labels, rule_name, stream)\n        if isinstance(result, _Builder):\n            return result.build_string()\n        else:\n            return result\n",
"type":"code"
}
],
"id":"23389acd149c413aa2eb051b1733e79f",
"type":"code"
},
{
"fragments":[
{
"text":"It also does some setup, but then it hands over the instructions (that are created in the ",
"type":"text"
},
{
"text":"__init__",
"type":"code"
},
{
"text":" method) to the VM that then executes them.",
"type":"text"
}
],
"id":"b383f81f81294a04a559bb3d1277d1cf",
"type":"text"
},
{
"fragments":[
{
"text":"In the rest of this article I explain how grammars are compiled into VM instructions and how the VM is implemented.",
"type":"text"
}
],
"id":"835ddd05753e4f0093aa9df649ea825b",
"type":"text"
}
],
"title":"Big picture difference"
},
{
"children":[],
"id":"d1a2d050fcc444cfa4991b968a02a315",
"paragraphs":[
{
"fragments":[
{
"text":"The parser in the VM based version has one additional rule for labels:",
"type":"text"
}
],
"id":"a3521271f17b4678bef1d97dd6c53ae0",
"type":"text"
},
{
"chunkpath":[
"expr1"
],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"| space '#'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Label\"]\n",
"type":"code"
}
],
"id":"7d940fabcc25497ab54b069f282f179c",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"A label returns a semantic action that evaluates to a unique number. You will see later (in ",
"type":"text"
},
{
"page_id":"613d04f41a3e4521ad022a3d4e0237ea",
"text":null,
"type":"reference"
},
{
"text":", ",
"type":"text"
},
{
"page_id":"963d53648b304544be75045e59c6e183",
"text":null,
"type":"reference"
},
{
"text":", and ",
"type":"text"
},
{
"page_id":"0efe424b680f477a9bb8c1b9f679ff84",
"text":null,
"type":"reference"
},
{
"text":") how it is used in the code generator.",
"type":"text"
}
],
"id":"d05bd8f2d426436a8374f153a70f4fb2",
"type":"text"
},
{
"fragments":[
{
"text":"The label feature first had to be added to the optimized version before it could be used to compile the VM based version. That implementation is not shown in this article, but the implementation of labels in the VM based version is similar.",
"type":"text"
}
],
"id":"487e0fe4f96c471d8427709b733d4ce0",
"type":"text"
},
{
"fragments":[
{
"text":"The rest of the parser is exactly the same as in the optimized version:",
"type":"text"
}
],
"id":"d2713c5c31814c30b086f60757b7f6df",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"parser.rlmeta"
],
"fragments":[
{
"text":"Parser {\n  grammar =\n    | name:x space '{' rule*:ys space '}'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Grammar\" x ~ys]\n  rule =\n    | name:x space '=' choice:y",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Rule\" x y]\n  choice =\n    | (space '|')?\n      sequence:x (space '|' sequence)*:xs",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Or\" x ~xs]\n  sequence =\n    | expr:x expr*:xs",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Scope\" [\"And\" x ~xs]]\n  expr =\n    | expr1:x space ':' name:y",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Bind\" y x]\n    | expr1\n  expr1 =\n    | expr2:x space '*'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Star\" x]\n    | expr2:x space '?'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Or\" x [\"And\"]]\n    | space '!' expr2:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Not\" x]\n    | space '%'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchCallRule\"]\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"expr1"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"    | expr2\n  expr2 =\n    | space '->' hostExpr:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"SemanticAction\" x]\n    | name:x !(space '=')",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchRule\" x]\n    | space char:x '-' char:y",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchRange\" x y]\n    | space string:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchString\" x]\n    | space charseq:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchCharseq\" x]\n    | space '.'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchAny\"]\n    | space '(' choice:x space ')'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> x\n    | space '[' expr*:xs space ']'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"MatchList\" [\"And\" ~xs]]\n  hostExpr =\n    | space string:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"String\" x]\n    | space '[' hostExprListItem*:xs space ']'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"List\" ~xs]\n    | space '{' buildExpr*:xs space '}'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"Builder\" ~xs]\n    | name:x space '(' hostExpr*:ys space ')'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"FnCall\" x ~ys]\n    | name:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"VarLookup\" x]\n  hostExprListItem =\n    | space '~' hostExpr:x",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"ListItemSplice\" x]\n    | hostExpr\n  buildExpr =\n    | space '>'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"IndentBuilder\"]\n    | space '<'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> [\"DedentBuilder\"]\n    | hostExpr\n  string    = '\"'  (!'\"'  innerChar)*:xs '\"'",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> join(xs)\n  charseq   = '\\'' (!'\\'' innerChar)*:xs '\\''",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> join(xs)\n  char      = '\\''  !'\\'' innerChar  :x  '\\''",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> x\n  innerChar = '\\\\' escape | .\n  escape    = '\\\\' -> \"\\\\\" | '\\'' -> \"'\"\n            | '\"'  -> \"\\\"\" | 'n'  -> \"\\n\"\n  name      = space nameStart:x nameChar*:xs",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":" -> join([x ~xs])\n  nameStart = 'a'-'z' | 'A'-'Z'\n  nameChar  = 'a'-'z' | 'A'-'Z' | '0'-'9'\n  space     = (' ' | '\\n')*\n}\n",
"type":"code"
}
],
"id":"0a3d1c1a8c4c49ab803ba2aabb11f6b1",
"language":"",
"type":"code"
}
],
"title":"Parser"
},
{
"children":[
{
"children":[],
"id":"8fc432da8cb94c91baeba2ee6b69f40b",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Grammar",
"type":"code"
},
{
"text":" AST node is matched, a Python class inheriting ",
"type":"text"
},
{
"text":"_Grammar",
"type":"code"
},
{
"text":" is generated:",
"type":"text"
}
],
"id":"8486ff5b719645eab49940a26d36242d",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Grammar ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= .:x ast*:ys ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"class \" x \"(_Grammar):\\n\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"       \"def __init__(self):\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"self._instructions = i = []\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"self._labels = l = {}\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"def I(name, x=None, y=None):\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"           \"i.append((name, x, y))\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         <\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         \"def LABEL(name):\\n\" >\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"           \"l[name] = len(i)\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         <\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"         ys\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"       <\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     < ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"9111d958b8ac481a95afc4becfe2f673",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"The name of the class is the same as the name of the grammar.",
"type":"text"
}
],
"id":"1735aab3a10f43c38a926cbcea8e7759",
"type":"text"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"__init__",
"type":"code"
},
{
"text":" method has functionality for creating instructions. An instruction is represented as a Python tuple with three elements: the name, the first argument, and the second argument. Arguments can be ",
"type":"text"
},
{
"text":"None",
"type":"code"
},
{
"text":". Instructions are stored in a list. Labels is a dictionary mapping label names to positions in the instruction list.",
"type":"text"
}
],
"id":"99eb57fd403a43078274deb9c131253e",
"type":"text"
},
{
"fragments":[
{
"text":"Shorthand names ",
"type":"text"
},
{
"text":"i",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"l",
"type":"code"
},
{
"text":" are used instead of ",
"type":"text"
},
{
"text":"self._instructions",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"self._labels",
"type":"code"
},
{
"text":" because they are faster. Not using ",
"type":"text"
},
{
"text":"self",
"type":"code"
},
{
"text":" reduces one dictionary lookup.",
"type":"text"
}
],
"id":"3a5fbbadfd654c42bc1cd57075467383",
"type":"text"
},
{
"fragments":[
{
"text":"The child AST nodes of ",
"type":"text"
},
{
"text":"Grammar",
"type":"code"
},
{
"text":" are assumed to use the ",
"type":"text"
},
{
"text":"I",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"LABEL",
"type":"code"
},
{
"text":" functions to create instructions.",
"type":"text"
}
],
"id":"0066adc26f364c9280b98d78c07d8b1c",
"type":"text"
}
],
"title":"Grammar"
},
{
"children":[],
"id":"72b77f7c8a594757a67ef61f9502f8e9",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Rule",
"type":"code"
},
{
"text":" AST node is matched, instructions representing a function are generated:",
"type":"text"
}
],
"id":"f946bf28c65242788cd1180ebae9d8d4",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Rule ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ast:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"LABEL(\" x \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     y\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('RETURN')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"0030bc01dfd4497ca5d1a1e7af5a5267",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation (where labels are in the first column and instructions are in the second column) it looks like this:",
"type":"text"
}
],
"id":"5e625d7f13f64c0aba40c4da05e3a232",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"<x>:\n    <y instructions>\n    RETURN\n",
"type":"code"
}
],
"id":"e12c0ee9cbd24ef79b6036c53ab1b690",
"type":"code"
},
{
"fragments":[
{
"text":"The label name is the name of the function. ",
"type":"text"
},
{
"page_id":"d104aa6d6b8e43818f662498f6566e38",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to resume execution at wherever it was before calling the function.",
"type":"text"
}
],
"id":"b054f14bf70948f48157f29d5f365828",
"type":"text"
}
],
"title":"Rule"
},
{
"children":[],
"id":"613d04f41a3e4521ad022a3d4e0237ea",
"paragraphs":[
{
"fragments":[
{
"text":"When an ",
"type":"text"
},
{
"text":"Or",
"type":"code"
},
{
"text":" AST node is matched, instructions representing a choice are generated:",
"type":"text"
}
],
"id":"c0c1e5c530cc45c9af6af459d4cb1773",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Or ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"=\n  | ast:x Or:y #:a #:b ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('BACKTRACK', \" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('COMMIT', \" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     y\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" b \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n  | ast\n",
"type":"code"
}
],
"id":"60c72ca468044457b6bcaafc4178cc05",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"012795ebc57d4d2499ee36546cf7f54e",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    BACKTRACK a\n    <x instructions>\n    COMMIT b\na:\n    <y instructions>\nb:\n",
"type":"code"
}
],
"id":"db7b64eddc0f42f4b0c349c380c7a525",
"type":"code"
},
{
"fragments":[
{
"page_id":"542906286e124874b2975d0ae23f034f",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to push a backtrack entry onto the stack so that it can try matching again at label ",
"type":"text"
},
{
"text":"a",
"type":"code"
},
{
"text":" if the ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions fail. ",
"type":"text"
},
{
"page_id":"5b99ed36fbde45989829fde6e17d4821",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to pop the backtrack entry off the stack and continue execution at label ",
"type":"text"
},
{
"text":"b",
"type":"code"
},
{
"text":". If ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions fail, the second choice at label ",
"type":"text"
},
{
"text":"a",
"type":"code"
},
{
"text":" is tried, otherwise, execution continues at label ",
"type":"text"
},
{
"text":"b",
"type":"code"
},
{
"text":". The ",
"type":"text"
},
{
"text":"y",
"type":"code"
},
{
"text":" instructions might represent another choice or the last choice. If there is only once choice, only instructions for that choice are generated. In that case, no ",
"type":"text"
},
{
"text":"BACKTRACK",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"COMMIT",
"type":"code"
},
{
"text":" are needed.",
"type":"text"
}
],
"id":"9a3ecf2ae87648b2897f1499fd96dfae",
"type":"text"
}
],
"title":"Or"
},
{
"children":[],
"id":"e0d721aa4fae40af8de5a54253243cb0",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Scope",
"type":"code"
},
{
"text":" AST node is matched, instructions creating a new scope are generated:",
"type":"text"
}
],
"id":"47dc6dc757a34febbe533a5b46ac1b30",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Scope ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('PUSH_SCOPE')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('POP_SCOPE')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"7dfdff1e9c5b49b0b9438274eb4c9066",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"ce31c06e437d4d2e8724d272578e3283",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    PUSH_SCOPE\n    <x instructions>\n    POP_SCOPE\n",
"type":"code"
}
],
"id":"6a44a5d5f46c45978ea745716fb015e9",
"type":"code"
},
{
"fragments":[
{
"page_id":"49ca0a2fa665466cb90c8c128d5cc835",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to push a new scope onto the stack so that all bindings that are done by ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions happen in this new scope. ",
"type":"text"
},
{
"page_id":"b2510846e20d4cd08f9b0cd2dfb5c01d",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to pop the current scope off the stack.",
"type":"text"
}
],
"id":"646de6553fdd482b872abeeea3ddf180",
"type":"text"
}
],
"title":"Scope"
},
{
"children":[],
"id":"34ee0862096d4fd4aa3342c4b3b6c294",
"paragraphs":[
{
"fragments":[
{
"text":"When an ",
"type":"text"
},
{
"text":"And",
"type":"code"
},
{
"text":" AST node is matched, instructions for all items in the sequence are generated:",
"type":"text"
}
],
"id":"b0abfb986a804847b16f08cca6c8a8a3",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"And ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast*\n",
"type":"code"
}
],
"id":"f7d10f9b03cb4de9b586b1630437c1cc",
"language":"",
"type":"code"
}
],
"title":"And"
},
{
"children":[],
"id":"8275c4d4e16c483f84be55f550e3d39c",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Bind",
"type":"code"
},
{
"text":" AST node is matched, instructions binding the last result to a name are generated:",
"type":"text"
}
],
"id":"3a04e0d7672f492980593c7b482112a7",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Bind ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ast:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { y\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('BIND', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"91b566e351da49a1b368525c3a1a9879",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"1306c51b42f04e389178b1b5898bf6e1",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    <y instructions>\n    BIND <x>\n",
"type":"code"
}
],
"id":"4677b3a2c9a34a6b8d346abe5d31add4",
"type":"code"
},
{
"fragments":[
{
"page_id":"1315305641224e4aa99dd00ec5b524b1",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to bind the last result to the name ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" in the current scope.",
"type":"text"
}
],
"id":"dd2a80cd76ac4e0bb7f4a85423700124",
"type":"text"
}
],
"title":"Bind"
},
{
"children":[],
"id":"963d53648b304544be75045e59c6e183",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Star",
"type":"code"
},
{
"text":" AST node is matched, instructions representing a repetition are generated:",
"type":"text"
}
],
"id":"269c724eef5a49c4bd5988b85d5135d2",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Star ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x #:a #:b ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('LIST_START')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('BACKTRACK', \" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('LIST_APPEND')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('COMMIT', \" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('LIST_END')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"30ee03ac51a74627829bfcce1ac3904c",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"a4913bf5f669482896ceb4168ffbffc7",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    LIST_START\na:\n    BACKTRACK b\n    <x instructions>\n    LIST_APPEND\n    COMMIT a\nb:\n    LIST_END\n",
"type":"code"
}
],
"id":"4b242e08b44c4a5cab63a14a86b0f38e",
"type":"code"
},
{
"fragments":[
{
"page_id":"b3562467300348028f04ae5034db0f34",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to create a new list for accumulating results. ",
"type":"text"
},
{
"page_id":"b4aacd38dec8406c9db784e0823c3554",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to append the last result to the list. ",
"type":"text"
},
{
"page_id":"9940cd44d7fe4777b1c12e335bac33ae",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to make the list itself the last result. The ",
"type":"text"
},
{
"text":"BACKTRACK",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"COMMIT",
"type":"code"
},
{
"text":" instructions are used to create control flow for a loop. As long as ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions succeed, the program loops between label ",
"type":"text"
},
{
"text":"a",
"type":"code"
},
{
"text":" and the ",
"type":"text"
},
{
"text":"COMMIT",
"type":"code"
},
{
"text":" instruction. As soon as ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions fail, the program continues execution at label ",
"type":"text"
},
{
"text":"b",
"type":"code"
},
{
"text":".",
"type":"text"
}
],
"id":"4658f86527c447a6ac6052536e6110da",
"type":"text"
}
],
"title":"Star"
},
{
"children":[],
"id":"0efe424b680f477a9bb8c1b9f679ff84",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Not",
"type":"code"
},
{
"text":" AST node is matched, instructions representing negative lookahead are generated:",
"type":"text"
}
],
"id":"6baaca923d4942d1919c20256748ed34",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Not ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x #:a #:b ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('BACKTRACK', \" b \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('COMMIT', \" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" a \")\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('FAIL', 'no match expected')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"LABEL(\" b \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"591d05c1297e4fb88e8c38d9a3147cf5",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"46d7aeb4bccd4bf6a555ea002a669708",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    BACKTRACK b\n    <x instructions>\n    COMMIT a\na:\n    FAIL 'no match expected'\nb:\n",
"type":"code"
}
],
"id":"a236ed6e09a74616a8c6a744580dfe0e",
"type":"code"
},
{
"fragments":[
{
"page_id":"34915cae29994179abbe19f2f7e4c267",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM that it should backtrack and try matching the next choice. The ",
"type":"text"
},
{
"text":"BACKTRACK",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"COMMIT",
"type":"code"
},
{
"text":" instructions are used to create control flow for negative lookahead. If ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions succeed, the ",
"type":"text"
},
{
"text":"COMMIT",
"type":"code"
},
{
"text":" instruction makes the program continue at label ",
"type":"text"
},
{
"text":"a",
"type":"code"
},
{
"text":". That immediately fails because the negative lookahead does not expect a match. If ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions fail, the program continues execution at label ",
"type":"text"
},
{
"text":"b",
"type":"code"
},
{
"text":", and the ",
"type":"text"
},
{
"text":"FAIL",
"type":"code"
},
{
"text":" instruction is skipped.",
"type":"text"
}
],
"id":"18a338c3dd1b4b6fbeaaae0387b8577e",
"type":"text"
}
],
"title":"Not"
},
{
"children":[],
"id":"24675b6707284a99ba3d3cb17b60e3f2",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchCallRule",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"9cc367cad52541c1b94c18f5fde5f2f4",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchCallRule ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_CALL_RULE')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"58615573c36b4b64a383842e606b8c3c",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"91d552d8683b435f9cae7298a6f93ff5",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_CALL_RULE\n",
"type":"code"
}
],
"id":"955e4c5838154ae1be3ad97c79b40778",
"type":"code"
},
{
"fragments":[
{
"page_id":"d42df29209bf475280ac510d9ae31182",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to call the rule denoted by the current input object.",
"type":"text"
}
],
"id":"5766709ee3a6467bb4ea1447892c5fd4",
"type":"text"
}
],
"title":"MatchCallRule"
},
{
"children":[],
"id":"629b7ffad2d54725ad0af4e73bf434d8",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"Label",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"44fd82f1b73241c59ff0ca8d6113aab5",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"Label ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('LABEL')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"29f6921c01e944589f1955077ef0a589",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"36a0bae0278a4dbf99ff7cdb4e40e49f",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    LABEL\n",
"type":"code"
}
],
"id":"a38019613bfa4096bb368ea511fdf0be",
"type":"code"
},
{
"fragments":[
{
"page_id":"d7d285d9586b437ca7d7f51b5deb6193",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to make the last result a semantic action that returns a unique number.",
"type":"text"
}
],
"id":"f22e084c52d442df9012dfe7f17c166b",
"type":"text"
}
],
"title":"Label"
},
{
"children":[],
"id":"4ddebcb41511403c8b3fa5c96f14c8f4",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"SemanticAction",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"55095d61ae634ae394735426ac65a5ee",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"SemanticAction ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('ACTION', lambda scope: \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"da478954dd5e474cab2bd28756636e33",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"7106b5a994584b9697192e3b3eaec57c",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    ACTION <python lambda>\n",
"type":"code"
}
],
"id":"a3469ef02b8041c58a9142a2de0f170b",
"type":"code"
},
{
"fragments":[
{
"page_id":"738356fde86e4c7290b0f99850917ba8",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to make the last result a semantic action.",
"type":"text"
}
],
"id":"231d28711af949f09eed77276b7bdc20",
"type":"text"
},
{
"fragments":[
{
"text":"Semantic actions are not evaluated by the VM, but rather by Python. The VM is only responsible for matching and creating semantic actions as result.",
"type":"text"
}
],
"id":"848e2247aa6f45a6b808a7433e77afdd",
"type":"text"
},
{
"fragments":[
{
"text":"The lambda expression is generated by the following rules similarly to how it was done in the optimized version:",
"type":"text"
}
],
"id":"a54045f34d834bffaea9cc3e0150ce49",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"String ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py\nList ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= astList\nBuilder ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= astItems:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"_Builder.create([\" x \"])\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nIndentBuilder ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"_IndentBuilder()\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nDedentBuilder ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"_DedentBuilder()\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nFnCall ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= .:x astItems:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { x \"(\" y \")\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nVarLookup ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"scope[\" x \"].eval()\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastItems ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"=\n  | ast:x astItem*:xs ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { x xs ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n  |                   ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastItem ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \", \" x ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastList ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= astListItem*:xs ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"(\" xs \"[])\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\nastListItem ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"=\n  | [\"ListItemSplice\" ast:x] ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> {     x  \"+\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n  | ast:x                    ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"[\" x \"]+\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"2ee5361a424942a6aa7944db88e80f22",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"The related pieces in the support library are exactly the same as in the optimized version:",
"type":"text"
}
],
"id":"dc9e1fe0347b47ec93119cc136f0fda7",
"type":"text"
},
{
"chunkpath":[
"imports"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"try:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO\n",
"type":"code"
}
],
"id":"4d06e64ddc8941928ee419ac82f56c4d",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _Builder(object):\n\n    def build_string(self):\n        output = _Output()\n        self.write(output)\n        return output.value\n\n    @classmethod\n    def create(self, item):\n        if isinstance(item, _Builder):\n            return item\n        elif isinstance(item, list):\n            return _ListBuilder([_Builder.create(x) for x in item])\n        else:\n            return _AtomBuilder(item)\n\nclass _Output(object):\n\n    def __init__(self):\n        self.buffer = StringIO()\n        self.indentation = 0\n        self.on_newline = True\n\n    @property\n    def value(self):\n        return self.buffer.getvalue()\n\n    def write(self, value):\n        for ch in value:\n            is_linebreak = ch == \"\\n\"\n            if self.indentation and self.on_newline and not is_linebreak:\n                self.buffer.write(\"    \"*self.indentation)\n            self.buffer.write(ch)\n            self.on_newline = is_linebreak\n\nclass _ListBuilder(_Builder):\n\n    def __init__(self, builders):\n        self.builders = builders\n\n    def write(self, output):\n        for builder in self.builders:\n            builder.write(output)\n\nclass _AtomBuilder(_Builder):\n\n    def __init__(self, atom):\n        self.atom = atom\n\n    def write(self, output):\n        output.write(str(self.atom))\n\nclass _IndentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation += 1\n\nclass _DedentBuilder(_Builder):\n\n    def write(self, output):\n        output.indentation -= 1\n",
"type":"code"
}
],
"id":"5545be940203494ab9bcd6ce8227bba4",
"type":"code"
}
],
"title":"SemanticAction"
},
{
"children":[],
"id":"fc62b5be27fd4e40978d415ba4070a05",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchRule",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"64ba36891b8d47ea85042f60045f41cb",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchRule ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('CALL', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"7bf436c56fdc473b8e8d4102f9e9d75f",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"ab1f903dd10b4071814c6470d5e41745",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    CALL <x>\n",
"type":"code"
}
],
"id":"3f1433008b854027bcd35fd68c51b2f4",
"type":"code"
},
{
"fragments":[
{
"page_id":"8e19cbb2e71c412f95c7e241a69f0901",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to call the given rule.",
"type":"text"
}
],
"id":"e2f6fa8e340f4245836de6396439df22",
"type":"text"
}
],
"title":"MatchRule"
},
{
"children":[],
"id":"ce3171f9336a4f1a961f4d6fd6665361",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchRange",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"1a2f6b63b0a04ca7ab2e59a7008fa1a1",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchRange ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x py:y ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_RANGE', \" x \", \" y \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"de2ceb8e15d64c4797d956d3015f41bb",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"50948aaf24a3481eb6c9ffbd45dbc471",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_RANGE <x> <y>\n",
"type":"code"
}
],
"id":"c8cb5b2b91e941ee8ed35c8a8a88c1e3",
"type":"code"
},
{
"fragments":[
{
"page_id":"d8dcb57d5da141908f28f8c52983d1a6",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to match an object in the given range.",
"type":"text"
}
],
"id":"9d40c2556ed4484aafd1b06b8d3bc0c8",
"type":"text"
}
],
"title":"MatchRange"
},
{
"children":[],
"id":"40fcdbbabfe44b009d3f405060a2055f",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchString",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"1c31057039f74f5582ec56af91f2835b",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchString ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_STRING', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"57444b0d737840e88781f30b1ba8d250",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"0c529a14385a4c6ba437131f85800705",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_STRING <x>\n",
"type":"code"
}
],
"id":"844cbe1b28ee4f578a3f037ab94e74d4",
"type":"code"
},
{
"fragments":[
{
"page_id":"a8160d30b886418882ada3a2a884e580",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to match the given string.",
"type":"text"
}
],
"id":"4da61624b22c4718a976addc31a75c7a",
"type":"text"
}
],
"title":"MatchString"
},
{
"children":[],
"id":"c6e2326b6b774601b761538455918bbe",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchCharseq",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"9912ee1101d6461c99234a167ba63ecc",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchCharseq ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= py:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_CHARSEQ', \" x \")\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"ae3894890b5f46ee83f0350438e9e307",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"5f7c96b7b19e478db7c8db8e64dff4f2",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_CHARSEQ <x>\n",
"type":"code"
}
],
"id":"aea4f196262c4096a2ba6f734076a1cc",
"type":"code"
},
{
"fragments":[
{
"page_id":"df5dc1b5e5054e548d5c3606daba0d55",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to match the given sequence of characters.",
"type":"text"
}
],
"id":"6e6edf9c5d0a43319d885bc5d38ca4a0",
"type":"text"
}
],
"title":"MatchCharseq"
},
{
"children":[],
"id":"de0847d410c6495d9a8ee4e75a0423cc",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchAny",
"type":"code"
},
{
"text":" AST node is matched, an instruction representing that operation is generated:",
"type":"text"
}
],
"id":"d01fd361666441099b1f98f65033310a",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchAny ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('MATCH_ANY')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"da1967debbe5402392c3b98c6b8d58ef",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"8fbece7061184829b26d4a585791bd2d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    MATCH_ANY\n",
"type":"code"
}
],
"id":"6a45732466244481ac5333f8bd104e11",
"type":"code"
},
{
"fragments":[
{
"page_id":"8f0fffeab7084a1d9b01d928be4878a8",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to match any object.",
"type":"text"
}
],
"id":"26f146d6360a4012ab753eabdfd54a29",
"type":"text"
}
],
"title":"MatchAny"
},
{
"children":[],
"id":"1dc829aba4484ed399eb025d01ed843e",
"paragraphs":[
{
"fragments":[
{
"text":"When a ",
"type":"text"
},
{
"text":"MatchList",
"type":"code"
},
{
"text":" AST node is matched, instructions changing the input stream are generated:",
"type":"text"
}
],
"id":"678aef4f22a949528fc55d4162c08f05",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"MatchList ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= ast:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> { \"I('PUSH_STREAM')\\n\"\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     x\n",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"     \"I('POP_STREAM')\\n\" ",
"type":"code"
},
{
"index":30,
"type":"tabstop"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"f1cd0227605b46789a8dfd623e24d3f9",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"In assembly-like notation it looks like this:",
"type":"text"
}
],
"id":"8822398d38324131a38f871cfb9141fc",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"    PUSH_STREAM\n    <x instructions>\n    POP_STREAM\n",
"type":"code"
}
],
"id":"b8c24c202db540339de7835186403f3a",
"type":"code"
},
{
"fragments":[
{
"page_id":"fee2dcf573f04ac3a9e7cfd92adbe0c8",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to push the current input object onto the stack so that ",
"type":"text"
},
{
"text":"x",
"type":"code"
},
{
"text":" instructions see it as the current input stream. ",
"type":"text"
},
{
"page_id":"87a1eee2cfb94e1a9463a6561c226012",
"text":null,
"type":"reference"
},
{
"text":" instructs the VM to pop the current input stream off the stack.",
"type":"text"
}
],
"id":"a32122dc4bca4f70b25c3398ddf8a015",
"type":"text"
}
],
"title":"MatchList"
},
{
"children":[],
"id":"6cc83570ba674d71bccd12660fddefcc",
"paragraphs":[
{
"fragments":[
{
"text":"The generated instructions for the ",
"type":"text"
},
{
"text":"Scream",
"type":"code"
},
{
"text":" grammar from the beginning of the article should now make more sense:",
"type":"text"
}
],
"id":"7f8b6bb4e9ba4f9e9b3f633664dc9f19",
"type":"text"
},
{
"code_id":"e1a908541846473db76a4661491f43d5",
"id":"21212cd9ca4a43df850bc60916292f87",
"type":"expanded_code"
},
{
"code_id":"0a31a676a4814fe3866f0d06530e4a97",
"id":"0e102d7433cd4d14882fa53299400825",
"type":"expanded_code"
},
{
"fragments":[
{
"text":"There are two labels for the two rules in the grammar. Both blocks of instructions end with a ",
"type":"text"
},
{
"text":"RETURN",
"type":"code"
},
{
"text":" instruction so that those labels/functions can be called and returned from. The blocks are are also wrapped in ",
"type":"text"
},
{
"text":"PUSH_SCOPE",
"type":"code"
},
{
"text":"/",
"type":"text"
},
{
"text":"POP_SCOPE",
"type":"code"
},
{
"text":" instructions so that variable bindings for the different calls happen in different scopes. Otherwise they would overwrite each other. The ",
"type":"text"
},
{
"text":"scream",
"type":"code"
},
{
"text":" rule has a repetition and therefore also the ",
"type":"text"
},
{
"text":"LIST_*",
"type":"code"
},
{
"text":" instructions. It also has generated label names (",
"type":"text"
},
{
"text":"0",
"type":"code"
},
{
"text":" and ",
"type":"text"
},
{
"text":"1",
"type":"code"
},
{
"text":") to create the loop. The ",
"type":"text"
},
{
"text":"BIND",
"type":"code"
},
{
"text":" instructions bind the last result to a name in the current scope. The ",
"type":"text"
},
{
"text":"ACTION",
"type":"code"
},
{
"text":" instructions have Python lambdas as first argument that are evaluated when there is a match. They get one argument which is the scope that was active when the action was defined.",
"type":"text"
}
],
"id":"e92b1c0856c44552991c692b8db1f7a5",
"type":"text"
},
{
"fragments":[
{
"text":"Now let's move on to the implementation of the VM to understand how the execution of these instructions work.",
"type":"text"
}
],
"id":"fda603f0ae284f559dce8f54937feadb",
"type":"text"
}
],
"title":"Example revisited"
}
],
"id":"24aa83d59704475dba2a010f1b5d3eb0",
"paragraphs":[
{
"fragments":[
{
"text":"The code generator in the VM based version is similarly structured to the code generator in the optimized version with a grammar and a support library:",
"type":"text"
}
],
"id":"77fbc0cbe00244098d618e7ec42178ca",
"type":"text"
},
{
"chunkpath":[],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"CodeGenerator {\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"rules"
],
"prefix":"  ",
"type":"chunk"
},
{
"text":"}\n",
"type":"code"
}
],
"id":"c4887eaa08da4799acaad6fdbde5d2f7",
"language":"",
"type":"code"
},
{
"chunkpath":[],
"filepath":[
"support.py"
],
"fragments":[
{
"blank_lines_before":1,
"path":[
"imports"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"vm"
],
"prefix":"",
"type":"chunk"
},
{
"text":"\n",
"type":"code"
},
{
"blank_lines_before":1,
"path":[
"classes"
],
"prefix":"",
"type":"chunk"
}
],
"id":"5dd5edbabef546a383244c3df74dc7b0",
"type":"code"
},
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"ast",
"type":"code"
},
{
"text":" rule is exactly the same as in the optimized version:",
"type":"text"
}
],
"id":"99e3f6f946054bdfad07a6a75146e078",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"ast ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= [%:x] ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> x\n",
"type":"code"
}
],
"id":"c04b40e6bf5d4f239d5b7a27dd4f0953",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"Then there is an additional rule for when a Python representation of a value is needed:",
"type":"text"
}
],
"id":"e67266b960b24185b0f6e04af944e2df",
"type":"text"
},
{
"chunkpath":[
"rules"
],
"filepath":[
"codegenerator.rlmeta"
],
"fragments":[
{
"text":"py ",
"type":"code"
},
{
"index":10,
"type":"tabstop"
},
{
"text":"= .:x ",
"type":"code"
},
{
"index":20,
"type":"tabstop"
},
{
"text":"-> repr(x)\n",
"type":"code"
}
],
"id":"54bf8cb0b30e47338b9b4b87a136a3f4",
"language":"",
"type":"code"
},
{
"fragments":[
{
"text":"Let's move on and look at how VM instructions are generated.",
"type":"text"
}
],
"id":"34949b2260294790b34e90ff276d7b04",
"type":"text"
}
],
"title":"Code generator"
},
{
"children":[
{
"children":[],
"id":"49ca0a2fa665466cb90c8c128d5cc835",
"paragraphs":[
{
"fragments":[
{
"text":"The most common instruction when RLMeta compiles itself is ",
"type":"text"
},
{
"text":"PUSH_SCOPE",
"type":"code"
},
{
"text":", and it therefore appears first:",
"type":"text"
}
],
"id":"4801932cf82345f9b4132718f0582e1b",
"type":"text"
},
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"if name == \"PUSH_SCOPE\":\n    ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".append(",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = {}\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"2c1a5595c42d499bbb325bae3bd2f874",
"type":"code"
},
{
"fragments":[
{
"text":"It moves the scope at the top of the stack to the list and assigns a new scope to the top of the stack. A scope is a dictionary mapping names to values.",
"type":"text"
}
],
"id":"75805a3ac84941c6a65f6dd1d9ae14ab",
"type":"text"
},
{
"fragments":[
{
"text":"Then the program counter is incremented so that the next instruction will be executed. ",
"type":"text"
},
{
"text":"continue",
"type":"code"
},
{
"text":" ensures that the failure case is skipped and the loop starts over immediately.",
"type":"text"
}
],
"id":"24baac5cd81048fd98750abebbb2d969",
"type":"text"
},
{
"fragments":[
{
"text":"Most instructions end by modifying the program counter followed by a ",
"type":"text"
},
{
"text":"continue",
"type":"code"
},
{
"text":". If ",
"type":"text"
},
{
"text":"continue",
"type":"code"
},
{
"text":" is not used, the code after the if-chain, which is the failure handling, is executed.",
"type":"text"
}
],
"id":"cd206427a23b4a59885cbc096c6aec5b",
"type":"text"
}
],
"title":"PUSH_SCOPE"
},
{
"children":[],
"id":"542906286e124874b2975d0ae23f034f",
"paragraphs":[
{
"fragments":[
{
"text":"The next common instruction is ",
"type":"text"
},
{
"text":"BACKTRACK",
"type":"code"
},
{
"text":":",
"type":"text"
}
],
"id":"42f320913e09466a9071a7cca3b0e54f",
"type":"text"
},
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"BACKTRACK\":\n    ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[arg1], ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":", len(",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"), len(",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":")))\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"d29ae793a57c42b5bb6e02f16abaf717",
"type":"code"
},
{
"fragments":[
{
"text":"It pushes a backtrack entry which consists of the following onto the stack:",
"type":"text"
}
],
"id":"669e9e0dbe5c48cb9bac05ca3fd1b7cf",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"The position at where to continue execution. The label is passed as fist argument to ",
"type":"text"
},
{
"text":"BACKTRACK",
"type":"code"
},
{
"text":", so its position is looked up in the labels dictionary.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"The current position in the input stream. Further matches might change the input stream position, and when backtracking, we need to know where we were.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"The length of the input stream stack.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"The length of the scope stack.",
"type":"text"
}
]
}
],
"id":"e8c5cd73f61844b7981e5806787bb731",
"type":"list"
},
{
"fragments":[
{
"text":"Is lengths enough to save? Can stacks never change just topmost item?",
"type":"text"
}
],
"id":"a36b46a7d47a432a86f322cece209102",
"type":"text"
},
{
"fragments":[
{
"text":"It ends by incrementing the program counter and restarting the loop.",
"type":"text"
}
],
"id":"884fbe833fed465f92dc915357fd1fe1",
"type":"text"
}
],
"title":"BACKTRACK"
},
{
"children":[],
"id":"8e19cbb2e71c412f95c7e241a69f0901",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"CALL\":\n    key = (arg1, tuple([x[1] for x in ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"]+[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"]))\n    if key in ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":":\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":"[key]\n        ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[:]\n        ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".pop()\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    else:\n        ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":"+1, key))\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[arg1]\n    continue\n",
"type":"code"
}
],
"id":"a0bfc0043b73482885ddcd87f913ce76",
"type":"code"
},
{
"fragments":[
{
"text":"Compare this to ",
"type":"text"
},
{
"page_id":"d42df29209bf475280ac510d9ae31182",
"text":null,
"type":"reference"
},
{
"text":".",
"type":"text"
}
],
"id":"0e3099fc21e44439a77d3e55217b9994",
"type":"text"
}
],
"title":"CALL"
},
{
"children":[],
"id":"df5dc1b5e5054e548d5c3606daba0d55",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_CHARSEQ\":\n    for char in arg1:\n        if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"] != char:\n            ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected {!r}\", char)\n            break\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(arg1)\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"faee63d4203f433fb4665fd4cb5abf1f",
"type":"code"
}
],
"title":"MATCH_CHARSEQ"
},
{
"children":[],
"id":"5b99ed36fbde45989829fde6e17d4821",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"COMMIT\":\n    ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[arg1]\n    continue\n",
"type":"code"
}
],
"id":"8222233eb6b140a495fb9884f4c637df",
"type":"code"
}
],
"title":"COMMIT"
},
{
"children":[],
"id":"b2510846e20d4cd08f9b0cd2dfb5c01d",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"POP_SCOPE\":\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"4d43ad60b62549fe9a4d837858a1e6b6",
"type":"code"
}
],
"title":"POP_SCOPE"
},
{
"children":[],
"id":"d104aa6d6b8e43818f662498f6566e38",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"RETURN\":\n    if len(",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":") == 0:\n        return ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":".eval()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":", key = ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":"[key] = (",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"+[(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":")])\n    continue\n",
"type":"code"
}
],
"id":"7afc540dab7b454a9805ec62225de4dc",
"type":"code"
}
],
"title":"RETURN"
},
{
"children":[],
"id":"b4aacd38dec8406c9db784e0823c3554",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LIST_APPEND\":\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":".append(",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"356f537a114549d590cbcec132d12154",
"type":"code"
}
],
"title":"LIST_APPEND"
},
{
"children":[],
"id":"1315305641224e4aa99dd00ec5b524b1",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"BIND\":\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":"[arg1] = ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":"\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"fa7420fc6e714750afb1d9a559ba60a3",
"type":"code"
}
],
"title":"BIND"
},
{
"children":[],
"id":"738356fde86e4c7290b0f99850917ba8",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"ACTION\":\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"7a1794156546491399acbcdfd1e663c1",
"type":"variable"
},
{
"text":"(arg1, ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"ca202e729537441f88100eb2b1fb8936",
"type":"code"
}
],
"title":"ACTION"
},
{
"children":[],
"id":"d8dcb57d5da141908f28f8c52983d1a6",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_RANGE\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or not (arg1 <= ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"] <= arg2):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected range {!r}-{!r}\", arg1, arg2)\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"])\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"500a0c29c73e42448e1c4c8ea67c13cf",
"type":"code"
}
],
"title":"MATCH_RANGE"
},
{
"children":[],
"id":"b3562467300348028f04ae5034db0f34",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LIST_START\":\n    ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".append(",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = []\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"089a8080f82b404cbbb99de6dd80090a",
"type":"code"
}
],
"title":"LIST_START"
},
{
"children":[],
"id":"9940cd44d7fe4777b1c12e335bac33ae",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LIST_END\":\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"7a1794156546491399acbcdfd1e663c1",
"type":"variable"
},
{
"text":"(lambda xs: [x.eval() for x in xs], ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":".pop()\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"7562783a1dc34c42beb05e22ee0ae2f4",
"type":"code"
}
],
"title":"LIST_END"
},
{
"children":[],
"id":"8f0fffeab7084a1d9b01d928be4878a8",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_ANY\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected any\",)\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"])\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"97063c2aa95a48b1886545a984494caf",
"type":"code"
}
],
"title":"MATCH_ANY"
},
{
"children":[],
"id":"fee2dcf573f04ac3a9e7cfd92adbe0c8",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"PUSH_STREAM\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or not isinstance(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"], list):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected list\",)\n    else:\n        ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"+1))\n        ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"]\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = 0\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"c5ae99acbb584d718d09917f827884f4",
"type":"code"
}
],
"title":"PUSH_STREAM"
},
{
"children":[],
"id":"87a1eee2cfb94e1a9463a6561c226012",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"POP_STREAM\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" < len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected end of list\",)\n    else:\n        ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".pop()\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"5f242526e0af408ebd0038e2ec2c4797",
"type":"code"
}
],
"title":"POP_STREAM"
},
{
"children":[],
"id":"d42df29209bf475280ac510d9ae31182",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_CALL_RULE\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"):\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected any\",)\n    else:\n        fn_name = str(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"])\n        key = (fn_name, tuple([x[1] for x in ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"]+[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"]))\n        if key in ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":":\n            ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":"[key]\n            ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[:]\n            ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":".pop()\n            ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        else:\n            ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".append((",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":"+1, key))\n            ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[fn_name]\n            ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"05a80103eda14253a19d5770172c51b1",
"type":"code"
}
],
"title":"MATCH_CALL_RULE"
},
{
"children":[],
"id":"34915cae29994179abbe19f2f7e4c267",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"FAIL\":\n    ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (arg1,)\n",
"type":"code"
}
],
"id":"455aa8f0eafd4641a124090a5b7bdb25",
"type":"code"
}
],
"title":"FAIL"
},
{
"children":[],
"id":"d7d285d9586b437ca7d7f51b5deb6193",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"LABEL\":\n    ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(",
"type":"code"
},
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":")\n    ",
"type":"code"
},
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":" += 1\n    ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n    continue\n",
"type":"code"
}
],
"id":"690d125013b74bdfa88a28e52dc4c184",
"type":"code"
}
],
"title":"LABEL"
},
{
"children":[],
"id":"a8160d30b886418882ada3a2a884e580",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"cases"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"elif name == \"MATCH_STRING\":\n    if ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" >= len(",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":") or ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":"] != arg1:\n        ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = (\"expected {!r}\", arg1)\n    else:\n        ",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(arg1)\n        ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" += 1\n        ",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" += 1\n        continue\n",
"type":"code"
}
],
"id":"2d8eef6d882b434abbb5f835f666c498",
"type":"code"
}
],
"title":"MATCH_STRING"
},
{
"children":[],
"id":"77edfc243204447ba84468c78f05d8e5",
"paragraphs":[
{
"chunkpath":[
"vm",
"loop",
"fail case"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"fail_pos = tuple([x[1] for x in ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"]+[pos])\nif fail_pos >= ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":":\n    ",
"type":"code"
},
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":"\n    ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":" = fail_pos\n",
"type":"code"
}
],
"id":"3aeef8c3298b44c0acb4a2ce8079d334",
"type":"code"
},
{
"chunkpath":[
"vm",
"loop",
"fail case"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"call_backtrack_entry = tuple()\nwhile ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":":\n    call_backtrack_entry = ",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":".pop()\n    if len(call_backtrack_entry) == 4:\n        break\nif len(call_backtrack_entry) != 4:\n    raise ",
"type":"code"
},
{
"id":"67782a80b8a0487f8930e57551490023",
"type":"variable"
},
{
"text":"(",
"type":"code"
},
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":", pos, stream)\n(",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":", stream_stack_len, scope_stack_len) = call_backtrack_entry\nif len(",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":") > stream_stack_len:\n    ",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[stream_stack_len][0]\n",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":"[:stream_stack_len]\nif len(",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":") > scope_stack_len:\n    ",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":"[scope_stack_len]\n",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":"[:scope_stack_len]\n",
"type":"code"
}
],
"id":"24208f79ca7941c390b8600e4977b413",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"67782a80b8a0487f8930e57551490023",
"type":"variable"
},
{
"text":"(Exception):\n\n    def __init__(self, message, pos, stream):\n        Exception.__init__(self)\n        self.message = message\n        self.pos = pos\n        self.stream = stream\n\n    def describe(self):\n        message = \"\"\n        if isinstance(self.stream, basestring):\n            pos1, error_line_before = self._extract_line(self.stream, self.pos, -1)\n            pos2, error_line_after = self._extract_line(self.stream, self.pos+1, 1)\n            _, context_before = self._extract_line(self.stream, pos1, -1)\n            _, context_after = self._extract_line(self.stream, pos2, 1)\n            if context_before:\n                message += \"> \"\n                message += context_before\n                message += \"\\n\"\n            message += \"> \"\n            message += error_line_before\n            message += error_line_after\n            message += \"\\n\"\n            message += \"--\"\n            message += \"-\"*(len(error_line_before)-1)\n            message += \"^\\n\"\n            if context_after:\n                message += \"> \"\n                message += context_after\n                message += \"\\n\"\n        else:\n            message += \"todo: list failure context\\n\"\n        message += \"Error: \"\n        message += self.message[0].format(*self.message[1:])\n        message += \"\\n\"\n        return message\n\n    def _extract_line(self, text, pos, direction):\n        line = []\n        while pos >= 0:\n            try:\n                if text[pos] == \"\\n\":\n                    if line:\n                        break\n                else:\n                    if direction == 1:\n                        line.append(text[pos])\n                    else:\n                        line.insert(0, text[pos])\n                pos += direction\n            except IndexError:\n                break\n        return (pos+direction, \"\".join(line))\n",
"type":"code"
}
],
"id":"cb26185f6f2d4de68f35b8f00712b577",
"type":"code"
},
{
"fragments":[
{
"text":"Fix list failure messages. And cleanup failure message formatting.",
"type":"text"
}
],
"id":"b96e160d222e4d28a37b51ddba1a290b",
"type":"text"
}
],
"title":"Handling failure"
},
{
"children":[],
"id":"95ffb1abf59546e1972c78ee7159b758",
"paragraphs":[
{
"fragments":[
{
"text":"The ",
"type":"text"
},
{
"text":"rlmeta_vm",
"type":"code"
},
{
"text":" functions is heavily optimized for speed. Here are a few choices made:",
"type":"text"
}
],
"id":"d9ff5c16d157459dbff751b1caa7ec3e",
"type":"text"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It is implemented as a single function to avoid function calls.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"It handles instructions in a specific order based on how often they are used.",
"type":"text"
}
]
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"Most instructions increments the program counter. That could be done always, and then only instructions that needs to do something other than incrementing could do that. But in those cases, some extra Python instructions would be executed.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"text":"The code for the two call instructions has some similar code.",
"type":"text"
}
]
}
],
"fragments":[
{
"text":"It duplicates code to avoid some Python instructions",
"type":"text"
}
]
}
],
"id":"c1e182ac57b342fc852bfb6666b53ad5",
"type":"list"
},
{
"fragments":[
{
"text":"These optimizations makes the VM faster and also a little harder to maintain because of duplicated code. But it's a trade off.",
"type":"text"
}
],
"id":"bb844c184a4747bd9fae009767fd5b03",
"type":"text"
}
],
"title":"Optimizations"
}
],
"id":"e66f8cec6206420abe4736ae32849c53",
"paragraphs":[
{
"fragments":[
{
"text":"The VM is implemented as a single Python function with the following definition:",
"type":"text"
}
],
"id":"cbf9ca288e5748bdbbaba447c4f8172e",
"type":"text"
},
{
"chunkpath":[
"vm"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"def rlmeta_vm(",
"type":"code"
},
{
"id":"ca256b5a40ca4d7a9359374655d29b3d",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"46962506a4b34797a7bd52e4203131ef",
"type":"variable"
},
{
"text":", stream):\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"init"
],
"prefix":"    ",
"type":"chunk"
},
{
"blank_lines_before":0,
"path":[
"loop"
],
"prefix":"    ",
"type":"chunk"
}
],
"id":"f00b388c4529474b9925b3aa4149b0e3",
"type":"code"
},
{
"fragments":[
{
"text":"It takes a list of instructions to execute, a dictionary of labels, the name of the start rule, and the input stream. The init section sets up the VM state:",
"type":"text"
}
],
"id":"8ca6c5d1ddaf494d8f685be16e5a207b",
"type":"text"
},
{
"chunkpath":[
"vm",
"init"
],
"filepath":[
"support.py"
],
"fragments":[
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":" = 0\n",
"type":"code"
},
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" = _ConstantSemanticAction(None)\n",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" = ",
"type":"code"
},
{
"id":"1a932d7b55d945b68f7ac7a869283721",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"46962506a4b34797a7bd52e4203131ef",
"type":"variable"
},
{
"text":"]\n",
"type":"code"
},
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":" = []\n",
"type":"code"
},
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" = (stream, 0, [])\n",
"type":"code"
},
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":" = (None, [])\n",
"type":"code"
},
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" = None\n",
"type":"code"
},
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":", ",
"type":"code"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":" = (None, tuple())\n",
"type":"code"
},
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":" = {}\n",
"type":"code"
}
],
"id":"69eb8113e74047f1a049c2edd33ddb3b",
"type":"code"
},
{
"child_type":"unordered",
"children":[
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"b097b5b85d854f2bb89c4d50e8fe5577",
"type":"variable"
},
{
"text":" is used to generate unique labels (",
"type":"text"
},
{
"page_id":"d7d285d9586b437ca7d7f51b5deb6193",
"text":null,
"type":"reference"
},
{
"text":").",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"d8f11069efcf4d318774bb082784c178",
"type":"variable"
},
{
"text":" stores the result of the last match.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":" is the program counter that determines what instruction to execute. It is initialized to the position that the start rule points to.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"afdefdc6c0eb44d698ceb67eda022dc8",
"type":"variable"
},
{
"text":" keeps track of what calls and backtrack entries have been made.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"4ae34787de174f88ac725fd6d0132a9b",
"type":"variable"
},
{
"text":" and ",
"type":"text"
},
{
"id":"ad46fcaa30dd48a0b04ab6d5ed3eb6c6",
"type":"variable"
},
{
"text":" is the topmost item in ",
"type":"text"
},
{
"id":"0a9fe66a6284461caec36d4cc17e0f84",
"type":"variable"
},
{
"text":" which keeps track of where we are in the input stream. (Input streams can be nested.) The topmost item is not stored in the list because it would make it slightly more difficult to modify.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"8da6870b3e814a309ac487512eb28fc6",
"type":"variable"
},
{
"text":" is the topmost item in ",
"type":"text"
},
{
"id":"6e2f0ba81b194ccab59fa146d23bb428",
"type":"variable"
},
{
"text":" which keeps track of which scope we are in.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"e3158ae25dfe4975a53ca22a70d76d01",
"type":"variable"
},
{
"text":" stores the current fail message.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"5a36de8ac0824e5e9e2d50ce6256b57a",
"type":"variable"
},
{
"text":" and ",
"type":"text"
},
{
"id":"0799d98c45e348e59ff71aa2d228a38b",
"type":"variable"
},
{
"text":" store the latest failure message that will be presented to the user if all choices have failed.",
"type":"text"
}
]
},
{
"child_type":null,
"children":[],
"fragments":[
{
"id":"68c9f5e79a3d4b04b5fe8c855cd71fff",
"type":"variable"
},
{
"text":" is the memoization table that stores results of functions calls.",
"type":"text"
}
]
}
],
"id":"cff07a3b1e114309ac8bbba43851895f",
"type":"list"
},
{
"fragments":[
{
"text":"The VM loop looks like this:",
"type":"text"
}
],
"id":"1c1717869fb040d08859d1775a887349",
"type":"text"
},
{
"chunkpath":[
"vm",
"loop"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"while True:\n    name, arg1, arg2 = ",
"type":"code"
},
{
"id":"ca256b5a40ca4d7a9359374655d29b3d",
"type":"variable"
},
{
"text":"[",
"type":"code"
},
{
"id":"c21d83213c4b4e3d9fc2f0b1d6940f77",
"type":"variable"
},
{
"text":"]\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"cases"
],
"prefix":"    ",
"type":"chunk"
},
{
"text":"    else:\n        raise Exception(\"unknown command {}\".format(name))\n",
"type":"code"
},
{
"blank_lines_before":0,
"path":[
"fail case"
],
"prefix":"    ",
"type":"chunk"
}
],
"id":"455a8795c9774f5082f680defbbc33bc",
"type":"code"
},
{
"fragments":[
{
"text":"It fetches the instruction pointed to by the program counter. Then it switches on the type of instruction like this:",
"type":"text"
}
],
"id":"b063b33e75374dae8f2a53bb2b99ec3d",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"if name == \"...\":\n    ...\nelif name == \"...\":\n    ...\n",
"type":"code"
}
],
"id":"0db7d0e6795649659dfb725bfcd5b08d",
"language":"python",
"type":"code"
},
{
"fragments":[
{
"text":"If the instruction is not recognized, an exception is raised in the final else clause. Each case ends with a ",
"type":"text"
},
{
"text":"continue",
"type":"code"
},
{
"text":" statement (if there was no failure) to restart the loop and avoid the fail case being executed. The fail case is handled at the end of the loop since it is common to many instructions.",
"type":"text"
}
],
"id":"8415a2c0de434685b3d3e97ee64ccdce",
"type":"text"
},
{
"fragments":[
{
"text":"The order in which the cases appear in the if-chain is important. To get to the last case, all previous cases need to be tested, which takes time. So it is important that the more common cases appear earlier in the if-chain. I did an instruction frequency analysis when RLMeta compiled itself to determine the most common instructions. They are presented in that order.",
"type":"text"
}
],
"id":"68e3bcae66ca4daf9fd359a53559b019",
"type":"text"
},
{
"fragments":[
{
"text":"The VM makes use of two semantic actions that represent match results: one for constant values and one for user defined functions:",
"type":"text"
}
],
"id":"639c4abdf34e4ea9ad5f30cb2eb3c6fa",
"type":"text"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class _ConstantSemanticAction(object):\n\n    def __init__(self, value):\n        self.value = value\n\n    def eval(self):\n        return self.value\n",
"type":"code"
}
],
"id":"435a082d5e964a7e835a9362d6c5c045",
"type":"code"
},
{
"chunkpath":[
"classes"
],
"filepath":[
"support.py"
],
"fragments":[
{
"text":"class ",
"type":"code"
},
{
"id":"7a1794156546491399acbcdfd1e663c1",
"type":"variable"
},
{
"text":"(object):\n\n    def __init__(self, fn, scope):\n        self.fn = fn\n        self.scope = scope\n\n    def eval(self):\n        return self.fn(self.scope)\n",
"type":"code"
}
],
"id":"64bbd9910fc94f7c9fcb5918408a9ff0",
"type":"code"
},
{
"fragments":[
{
"text":"Let's move on to the implementation of each instruction.",
"type":"text"
}
],
"id":"f35d6c69077448f9a590b05bfa7a2093",
"type":"text"
}
],
"title":"VM"
},
{
"children":[],
"id":"2e3ad1de345642658be2e5910ab5be4e",
"paragraphs":[
{
"fragments":[
{
"text":"Compared to the optimized version, the VM based version is a little bigger:",
"type":"text"
}
],
"id":"6f2a61a4cb49480797827f07c5e287da",
"type":"text"
},
{
"chunkpath":[],
"filepath":[],
"fragments":[
{
"text":"   53 parser.rlmeta\n   74 codegenerator.rlmeta\n  312 support.py\n   45 compile.sh\n  484 total\n",
"type":"code"
}
],
"id":"f33fce82407345ae8e66619900f1ad6a",
"type":"code"
},
{
"fragments":[
{
"text":"That is 484 lines of code instead of 429. The ",
"type":"text"
},
{
"text":"rlmeta_vm",
"type":"code"
},
{
"text":" function is quite optimized and therefore is slightly longer. But 484 lines is still small.",
"type":"text"
}
],
"id":"f26efacd023b405e998090b8f07e2740",
"type":"text"
}
],
"title":"Note on size"
},
{
"children":[],
"id":"c490369b053247c0b7761f324658aa15",
"paragraphs":[
{
"fragments":[
{
"text":"The VM based version also turns out to be faster than the ",
"type":"text"
},
{
"text":"optimized version",
"type":"link",
"url":"/writing/optimizing-rlmeta/#3616eda03f5c40458ac9439def097739"
},
{
"text":":",
"type":"text"
}
],
"id":"3fdd0f91af8542a7a18695c4d5ad5538",
"type":"text"
},
{
"fragments":[],
"id":"87d7c0a2d52944bea5ee2797e02893a2",
"image_base64":"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",
"type":"image"
},
{
"fragments":[
{
"text":"Being faster was not a goal with the VM based version, but it's and interesting side effect. There are probably more optimizations that can be made to the instructions as well.",
"type":"text"
}
],
"id":"b40a4e53fd7142fc828167dc1161884d",
"type":"text"
}
],
"title":"Note on performance"
},
{
"children":[
{
"children":[],
"id":"53f0708b231b468d844291df3fe17cf2",
"paragraphs":[
{
"code_id":"0a3d1c1a8c4c49ab803ba2aabb11f6b1",
"id":"82002b8dd2284b2ca2355c83aed9f216",
"type":"expanded_code"
}
],
"title":"parser.rlmeta"
},
{
"children":[],
"id":"74bf51f7e8d94bcba1747edb477137ef",
"paragraphs":[
{
"code_id":"c4887eaa08da4799acaad6fdbde5d2f7",
"id":"a376af48b31246aba6d5a8bc75857e7f",
"type":"expanded_code"
}
],
"title":"codegenerator.rlmeta"
},
{
"children":[],
"id":"60ff77cb85fa455589e3e45cdeac8160",
"paragraphs":[
{
"code_id":"5dd5edbabef546a383244c3df74dc7b0",
"id":"a5db6607ca9547a885d956e3916cb92d",
"type":"expanded_code"
}
],
"title":"support.py"
},
{
"children":[],
"id":"338ad257e61e4025b8859d610a475c6a",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\nrlmeta_compiler=\"$(pwd)/$1\"\n\ncd \"$(dirname \"$0\")\"\n\nto_python_string() {\n    python -c 'import sys; sys.stdout.write(repr(sys.stdin.read()))'\n}\n\nsupport_py_string=$(to_python_string < support.py)\nsupport_py=$(python \"$rlmeta_compiler\" --support)\nparser_py=$(python \"$rlmeta_compiler\" < parser.rlmeta)\ncodegenerator_py=$(python \"$rlmeta_compiler\" < codegenerator.rlmeta)\n\ncat <<EOF\nimport sys\n\nSUPPORT = $support_py_string\n\n$support_py\n\n$parser_py\n\n$codegenerator_py\n\njoin = \"\".join\n\ndef compile_grammar(grammar):\n    parser = Parser()\n    code_generator = CodeGenerator()\n    return code_generator.run(\"ast\", parser.run(\"grammar\", grammar))\n\nif __name__ == \"__main__\":\n    if \"--support\" in sys.argv:\n        sys.stdout.write(SUPPORT)\n    else:\n        try:\n            sys.stdout.write(compile_grammar(sys.stdin.read()))\n        except ",
"type":"code"
},
{
"id":"67782a80b8a0487f8930e57551490023",
"type":"variable"
},
{
"text":" as e:\n            sys.stderr.write(e.describe())\n            sys.exit(1)\nEOF\n",
"type":"code"
}
],
"id":"5603502f765e4392be55f0ad5f8ec9ac",
"type":"code"
}
],
"title":"compile.sh"
},
{
"children":[],
"id":"272d17f2d55749b59d7e5ec7b9b8e0ec",
"paragraphs":[
{
"chunkpath":[],
"filepath":[
"meta_compile.sh"
],
"fragments":[
{
"text":"#!/bin/bash\n\nset -e\n\ncd \"$(dirname \"$0\")\"\n\n./compile.sh rlmeta.py > rlmeta1.py\n\n./compile.sh rlmeta1.py > rlmeta2.py\n\n./compile.sh rlmeta2.py > rlmeta3.py\n\ndiff rlmeta2.py rlmeta3.py\n\ndiff support.py <(python rlmeta3.py --support)\n\nmv rlmeta3.py rlmeta2.py\n\nmv rlmeta2.py rlmeta1.py\n\nmv rlmeta1.py rlmeta.py\n\necho OK\n",
"type":"code"
}
],
"id":"59997b4d5c134c4183d2f5a1f8804543",
"type":"code"
}
],
"title":"meta_compile.sh"
}
],
"id":"7e7b4c5318ff4c849c6e98e9ddeaacf0",
"paragraphs":[],
"title":"Code listings for RLMeta"
}
],
"id":"3dffd837b9ec4ad88b4e7f4c4b3b5aae",
"paragraphs":[
{
"fragments":[
{
"text":"In this article I present an alternative implementation of ",
"type":"text"
},
{
"text":"RLMeta",
"type":"link",
"url":"/writing/rlmeta/index.html"
},
{
"text":" in which grammars are compiled into instructions for a virtual machine (VM).",
"type":"text"
}
],
"id":"ad1d041250524b98a193f9fd3fa627f5",
"type":"text"
},
{
"fragments":[
{
"text":"The VM based version builds upon the ",
"type":"text"
},
{
"text":"optimized version",
"type":"link",
"url":"/writing/optimizing-rlmeta/index.html"
},
{
"text":" and the implementation is inspired by ",
"type":"text"
},
{
"text":"Regular Expression Matching: the Virtual Machine Approach",
"type":"link",
"url":"https://swtch.com/~rsc/regexp/regexp2.html"
},
{
"text":" and ",
"type":"text"
},
{
"text":"A Text Pattern-Matching Tool based on Parsing Expression Grammars",
"type":"link",
"url":"http://www.inf.puc-rio.br/%7Eroberto/docs/peg.pdf"
},
{
"text":".",
"type":"text"
}
],
"id":"79ae9067afde497085d5b885fe4fb8a4",
"type":"text"
}
],
"title":"RLMeta: a VM based approach"
},
"variables":{
"0799d98c45e348e59ff71aa2d228a38b":"latest_fail_pos",
"0a9fe66a6284461caec36d4cc17e0f84":"stream_pos_stack",
"1a932d7b55d945b68f7ac7a869283721":"labels",
"46962506a4b34797a7bd52e4203131ef":"start_rule",
"4ae34787de174f88ac725fd6d0132a9b":"stream",
"5a36de8ac0824e5e9e2d50ce6256b57a":"latest_fail_message",
"67782a80b8a0487f8930e57551490023":"_MatchError",
"68c9f5e79a3d4b04b5fe8c855cd71fff":"memo",
"6e2f0ba81b194ccab59fa146d23bb428":"scope_stack",
"7a1794156546491399acbcdfd1e663c1":"_UserSemanticAction",
"8da6870b3e814a309ac487512eb28fc6":"scope",
"ad46fcaa30dd48a0b04ab6d5ed3eb6c6":"pos",
"afdefdc6c0eb44d698ceb67eda022dc8":"call_backtrack_stack",
"b097b5b85d854f2bb89c4d50e8fe5577":"label_counter",
"c21d83213c4b4e3d9fc2f0b1d6940f77":"pc",
"ca256b5a40ca4d7a9359374655d29b3d":"instructions",
"d8f11069efcf4d318774bb082784c178":"last_action",
"e3158ae25dfe4975a53ca22a70d76d01":"fail_message"
}
}