CodeGenerator {
  Grammar        = .:x ast*:ys     -> {    "class " x "(_Program):\n" > "def _load(self):\n" > ys < < }
  Rule           = .:x ast:y       -> {    "self._label(" repr(x) ")\n"
                                           y
                                           "self._instruction('RETURN')\n"
                                      }
  MatchAny       =                 -> {    "self._instruction('MATCH_ANY')\n"                         }
  MatchCallRule  =                 -> {    "self._instruction('MATCH_CALL_RULE')\n"                   }
  String         = .:x             -> {    repr(x)                 }
  List           = astList:x       -> {    x                       }
  Builder        = astItems:x      -> {    "_Builder.create([" x "])"     }
  IndentBuilder  =                 -> {    "_IndentBuilder()"            }
  DedentBuilder  =                 -> {    "_DedentBuilder()"            }
  FnCall         = .:x astItems:y  -> {    x "(" y ")"          }
  VarLookup      = .:x             -> {    "env[" repr(x) "].eval()"               }
  Or             =
    | ast:x !.                     -> x
    | ast:x Or:y #:a #:b           -> {    "self._instruction('BACKTRACK', " a ")\n"
                                           x
                                           "self._instruction('COMMIT', " b ")\n"
                                           "self._label(" a ")\n"
                                           y
                                           "self._label(" b ")\n"
                                      }
    |                              -> { }
  Scope          = ast:x           -> {    "self._instruction('PUSH_SCOPE')\n"
                                           x
                                           "self._instruction('POP_SCOPE')\n"
                                      }
  And            = ast*
  Bind           = .:x ast:y       -> { y  "self._instruction('BIND', " repr(x) ")\n"           }
  Star           = ast:x #:a #:b   -> {    "self._instruction('LIST_START')\n"
                                           "self._label(" a ")\n"
                                           "self._instruction('BACKTRACK', " b ")\n"
                                           x
                                           "self._instruction('LIST_APPEND')\n"
                                           "self._instruction('COMMIT', " a ")\n"
                                           "self._label(" b ")\n"
                                           "self._instruction('LIST_END')\n"
                                      }
  Not            = ast:x #:a #:b   -> {    "self._instruction('BACKTRACK', " b ")\n"
                                           x
                                           "self._instruction('COMMIT', " a ")\n"
                                           "self._label(" a ")\n"
                                           "self._instruction('FAIL')\n"
                                           "self._label(" b ")\n"
                                      }
  SemanticAction = ast:x           -> {    "self._instruction('ACTION', lambda env: " x ")\n" }
  Label          =                 -> {    "self._instruction('LABEL')\n"                        }
  MatchRule      = .:x             -> {    "self._instruction('CALL', " repr(x) ")\n"               }
  MatchRange     = .:x .:y         -> {    "self._instruction('MATCH_RANGE', " repr(x) ", " repr(y) ")\n" }
  MatchString    = .:x             -> {    "self._instruction('MATCH_STRING', " repr(x) ")\n"             }
  MatchCharseq   = .:x             -> {    "self._instruction('MATCH_CHARSEQ', " repr(x) ")\n"            }
  MatchList      = ast:x           -> {    "self._instruction('PUSH_INPUT')\n"
                                           x
                                           "self._instruction('POP_INPUT')\n"
                                      }
  ast            = [%:x]           -> { x }
  astItems       =
    | ast:x !.                     -> { x }
    | ast:x astItems:y             -> { x ", " y }
    |                              -> { "" }
  astList        = astListItem*:xs -> { "(" xs "[])"                                            }
  astListItem    =
    | ["ListItemSplice" ast:x]     -> {     x  "+"                                              }
    | ast:x                        -> { "[" x "]+"                                              }
}
