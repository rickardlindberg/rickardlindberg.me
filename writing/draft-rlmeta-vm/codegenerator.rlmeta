CodeGenerator {
  Grammar        = .:x ast*:ys     -> { "class " x "(_Program):\n" >
                                          "def __init__(self):\n" >
                                            "instructions = []\n"
                                            "labels = {}\n"
                                            "def I(name, x=None, y=None):\n" >
                                              "instructions.append((name, x, y))\n"
                                            <
                                            "def LABEL(name):\n" >
                                              "labels[name] = len(instructions)\n"
                                            <
                                            ys
                                            "self._instructions = instructions\n"
                                            "self._labels = labels\n"
                                          <
                                        <                                  }
  Rule           = py:x ast:y      -> { "LABEL(" x ")\n"
                                        y
                                        "I('RETURN')\n"                    }
  Or             =
    | ast:x !.                     -> x
    | ast:x Or:y #:a #:b           -> { "I('BACKTRACK', " a ")\n"
                                        x
                                        "I('COMMIT', " b ")\n"
                                        "LABEL(" a ")\n"
                                        y
                                        "LABEL(" b ")\n"                   }
  Scope          = ast:x           -> { "I('PUSH_SCOPE')\n"
                                        x
                                        "I('POP_SCOPE')\n"                 }
  And            = ast*
  Bind           = py:x ast:y      -> { y
                                        "I('BIND', " x ")\n"               }
  Star           = ast:x #:a #:b   -> { "I('LIST_START')\n"
                                        "LABEL(" a ")\n"
                                        "I('BACKTRACK', " b ")\n"
                                        x
                                        "I('LIST_APPEND')\n"
                                        "I('COMMIT', " a ")\n"
                                        "LABEL(" b ")\n"
                                        "I('LIST_END')\n"                  }
  Not            = ast:x #:a #:b   -> { "I('BACKTRACK', " b ")\n"
                                        x
                                        "I('COMMIT', " a ")\n"
                                        "LABEL(" a ")\n"
                                        "I('FAIL')\n"
                                        "LABEL(" b ")\n"                   }
  MatchCallRule  =                 -> { "I('MATCH_CALL_RULE')\n"           }
  Label          =                 -> { "I('LABEL')\n"                     }
  SemanticAction = ast:x           -> { "I('ACTION', lambda env: " x ")\n" }
  MatchRule      = py:x            -> { "I('CALL', " x ")\n"               }
  MatchRange     = py:x py:y       -> { "I('MATCH_RANGE', " x ", " y ")\n" }
  MatchString    = py:x            -> { "I('MATCH_STRING', " x ")\n"       }
  MatchCharseq   = py:x            -> { "I('MATCH_CHARSEQ', " x ")\n"      }
  MatchAny       =                 -> { "I('MATCH_ANY')\n"                 }
  MatchList      = ast:x           -> { "I('PUSH_INPUT')\n"
                                        x
                                        "I('POP_INPUT')\n"                 }
  String         = py
  List           = astList:x       -> { x                                  }
  Builder        = astItems:x      -> { "_Builder.create([" x "])"         }
  IndentBuilder  =                 -> { "_IndentBuilder()"                 }
  DedentBuilder  =                 -> { "_DedentBuilder()"                 }
  FnCall         = .:x astItems:y  -> { x "(" y ")"                        }
  VarLookup      = py:x            -> { "env[" x "].eval()"                }
  ast            = [%:x]           -> { x                                  }
  astItems       =
    | ast:x astItem*:xs            -> { x xs                               }
    |                              -> {                                    }
  astItem        = ast:x           -> { ", " x                             }
  astList        = astListItem*:xs -> { "(" xs "[])"                       }
  astListItem    =
    | ["ListItemSplice" ast:x]     -> {     x  "+"                         }
    | ast:x                        -> { "[" x "]+"                         }
  py             = .:x             -> repr(x)
}
