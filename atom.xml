<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Rickard's personal homepage: latest posts</title>
    <link href="http://rickardlindberg.me/atom.xml" rel="self" />
    <link href="http://rickardlindberg.me" />
    <id>http://rickardlindberg.me/atom.xml</id>
    <author>
        <name>Rickard Lindberg</name>
        <email>rickard@rickardlindberg.me</email>
    </author>
    <updated>2023-05-09T00:00:00Z</updated>
    <entry>
    <title>Hit balloon and score points</title>
    <link href="http://rickardlindberg.me/writing/agdpp-hit-balloon-and-score-points/" />
    <id>http://rickardlindberg.me/writing/agdpp-hit-balloon-and-score-points/</id>
    <published>2023-05-09T00:00:00Z</published>
    <updated>2023-05-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Hit balloon and score points</h1>

<p><em>Published on  9 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>We have two stories left before we think we have a first, minimal version of a balloon shooter game:</p>
<ul>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
</ul>
<p>In this episode we will work on both of them. We will start with collision detection between arrow and balloon.</p>
<h2 id="clarify-behavior-with-test">Clarify behavior with test</h2>
<p>To clarify what we mean by arrow can hit balloon, we want to write a test first that shows the lacking behavior. Then implement the thing. We use the test both as a design tool to figure out what we are actually going to implement and as a testing tool to verify that behavior.</p>
<p>Our game scene object currently inits like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Balloon</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We would like to write a test where we shoot an arrow, make it collide with the balloon, and then assert that the balloon disappears.</p>
<p>With the current design, this is really difficult to do. It can only be done something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(...)</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span>
<span class="sd">&gt;&gt;&gt; game.update(??)</span>
<span class="sd">&gt;&gt;&gt; game.get_balloon() is None</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>But this is really flaky and hard to understand. In order for this to work, we have to time the shooting and the updating so that the arrow actually hits the balloon. Even if we get it to work, it will start failing if we for example change the speed of the arrow. And this test should really not care about arrow speed.</p>
<p>Let’s see if we can do better.</p>
<p>We change the init method to this instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">balloons</span><span class="o">=</span><span class="p">[(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)],</span> <span class="n">arrows</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">([</span>
            <span class="n">Balloon</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">balloons</span>
        <span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">([</span>
            <span class="n">Arrow</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">arrows</span>
        <span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>That is, we make it possible to create a game scene object where we specify where all the balloons should be and where all the flying arrows should be. We also change the balloon from a single object to a sprite group. This is not strictly necessary, but it will make removing hit balloons easier. The default values for the balloons and arrows mimics the current default. We have one balloon that starts at (50, 50) and zero flying arrows.</p>
<p>Here is the test that checks initial state:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(100, 100)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; len(game.get_flying_arrows())</span>
<span class="sd">1</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>In order for it to work, we expose another getter for the balloon sprites:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_balloons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>The test continues to check that we still have one balloon and one flying arrow after an update:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; len(game.get_flying_arrows())</span>
<span class="sd">1</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We update with 0 to ensure that nothing moves. We need to call update to make the collision detection code run, but to ensure exact positions, we pass 0 as the delta time. All movements should take the delta time into account, so 0 should result in no movement.</p>
<p>We continue and write the test for hitting a balloon like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; game.get_balloons()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We place the arrow at the center of the balloon, invoke the collision detection code with update, and assert that there are no longer any balloons.</p>
<h2 id="implement-arrow-hit">Implement arrow hit</h2>
<p>In the game update, we already loop over the arrows to remove the ones that are outside the screen. We add a loop that checks if any arrow hits any of the balloons. If so, we remove that balloon:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="o">...</span>
            <span class="k">for</span> <span class="n">balloon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_baloon</span><span class="p">(</span><span class="n">balloon</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">balloon</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We add <code>hits_baloon</code> to arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">hits_baloon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">balloon</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">balloon</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>And implement <code>inside</code> in balloon like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This is a bit of a trick in OOP that I learned some time ago that I’m not sure what I think about. Let me explain.</p>
<p>We could have written the test like this instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="n">balloon</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">arrow</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">arrow</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">balloon</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>But then the game scene object would have to reach into the arrow object to access the x and y coordinates.</p>
<p>With <code>hits_baloon</code> we introduce one more step in the chain where the arrow itself pass its coordinates along to <code>inside</code>. No need to expose them to the outside.</p>
<p>I like this because objects can expose less details about themselves. I dislike this because I think the code sometimes becomes a little harder to read. I guess the solution is good naming. And I think <code>arrow.hits_baloon(balloon)</code> reads pretty well.</p>
<h2 id="demo-trick">Demo trick</h2>
<p>The game works and if we manage to hit a balloon, it disappears. Again, bummer. We can shoot infinitely many arrows, but if there are no more balloons to hit, the game is not that interesting.</p>
<p>We had a situation like this <a href="/writing/agdpp-shooting-arrow/index.html">before</a> where you shot the arrow and you could only get a new one by restarting the game.</p>
<p>One trick I used when I demoed this for the customer was to run the game in a loop like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span>$ <span class="k">while</span> true<span class="p">;</span> <span class="k">do</span> ./zero.py rundev<span class="p">;</span> <span class="k">done</span>
</pre>
</div>
</div>
</div>
<p>So when you have no more arrows to shoot or no more balloons to hit, you close the game window and a new one will immediately pop up.</p>
<p>That way, it is a little smoother to gather feedback on the current game functionality.</p>
<p>We fixed so that you get more arrows to shoot before. Let’s also fix so that a new balloon is spawned after one is hit so we don’t need to restart the game in a loop anymore.</p>
<h2 id="primitive-obsession-refactoring">Primitive obsession refactoring</h2>
<p>Before we start adding new functionality, let’s have a look at the code and see if there is anything that we can improve to make it more clear and make the future a little smoother.</p>
<p>One thing that I notice is that we are passing around (x, y) coordinates in a lot of places, and objects keep track of the x and y coordinates. Here is the balloon class for example:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This smell is called primitive obsession. It is when you pass around primitive objects (integers, strings encoding information, etc) instead of an abstraction. That leads to duplicated logic. Say for example that we want to move an object, we might do something like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">2</span>
</pre>
</div>
</div>
</div>
<p>And we probably need to move multiple objects, so this kind of code will be duplicated in many places.</p>
<p>The solution is to create and abstraction for the concept. In this case, I choose to call it point:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</pre>
</div>
</div>
</div>
<p>We refactor in small, tiny steps to make use of this point.</p>
<p>Eventually, the inside check in the balloon looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We are no longer dealing with separate x and y coordinates. We are dealing with positions.</p>
<p>A big chunk of the hit test has also moved into the new point class:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">distance_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>If we are concerned about the performance of the square root, we could write <code>inside</code> like this (equivalent to what we had before):</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">distance_squared_to</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>I think this reads a little worse, and we don’t have performance issues yet.</p>
<p>What usually happens when you extract a concept like this point is that it starts attracting new functionality. Suddenly, there is a logical place to implement something instead of spreading it across the code base.</p>
<p>Another benefit of this abstraction is that we can now more easily test the behavior of <code>distance_to</code> in isolation. No need to involve a balloon.</p>
<h2 id="spawn-new-balloons">Spawn new balloons</h2>
<p>So it’s no fun to play the game after you hit the balloon, because then there are no more balloons to hit. We want to spawn new balloons.</p>
<p>We need to modify our test. It looks like this now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; len(game.get_balloons())</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; game.get_balloons()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We don’t want the balloon list to be empty. We still want it to contain a balloon. But not the balloon that we just shot down, but another one.</p>
<p>I think we can do it like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space, balloons=[(500, 500)], arrows=[(500, 500)])</span>
<span class="sd">&gt;&gt;&gt; balloons = game.get_balloons()</span>
<span class="sd">&gt;&gt;&gt; len(balloons)</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; game.update(0)</span>
<span class="sd">&gt;&gt;&gt; new_balloons = game.get_balloons()</span>
<span class="sd">&gt;&gt;&gt; len(new_balloons)</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; new_balloons == balloons</span>
<span class="sd">False</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We can make the test pass by adding another balloon after the one that has been shot down has been removed:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="o">...</span>
            <span class="k">for</span> <span class="n">balloon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_baloon</span><span class="p">(</span><span class="n">balloon</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">balloon</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Balloon</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">50</span><span class="p">)))</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This now works, but it is a little hard to actually notice that we hit a balloon. It should be more clear if we include a score.</p>
<h2 id="add-score">Add score</h2>
<p>We have a place in the code where we have hit a balloon. When that happens we would also like to increase a score. What is the simplest implementation of that?</p>
<p>What if we just maintain a list of sprites where each sprites represents a point? Let’s see.</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">balloons</span><span class="o">=</span><span class="p">[(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)],</span> <span class="n">arrows</span><span class="o">=</span><span class="p">[]):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="o">...</span>
            <span class="k">for</span> <span class="n">balloon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloons</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_baloon</span><span class="p">(</span><span class="n">balloon</span><span class="p">):</span>
                    <span class="o">...</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PointMarker</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">50</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">())</span><span class="o">*</span><span class="mi">10</span><span class="p">)))</span>
</pre>
</div>
</div>
</div>
<p>We use the length of the point sprites to calculate the position of the next point marker.</p>
<p>We also add a getter for the points so that we can test this behavior:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>And here is the <code>PointMarker</code> that draws a circle at the given position:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">PointMarker</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>This is what it looks like after a few balloons have been hit:</p>
<center>
<img src="points.png" title="fig:" alt="Point markers." />
</center>
<p>When I showed this to my son, he thought it was a little fun when point markers appeared on the screen. He also wanted to make the point markers go all across the screen, and also wanted me to count how many points we had about half way through. I don’t like counting small yellow circles, so we probably need a better solution for displaying points. We make a note about that.</p>
<p>If you want to try this version or look at the complete source code from this episode, it is on <a href="https://github.com/rickardlindberg/agdpp/tree/hit-balloon-and-score-points">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>The state based testing approach continues to work well. Tests are easy to write, and I don’t think the getters that we add to expose internal state are too problematic.</p>
<p>We now have a first version of a balloon shooter game. Now we have to show it to our customers, have them play it, gather feedback, and keep improving. One story at a time.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Game over?</title>
    <link href="http://rickardlindberg.me/writing/agdpp-game-over/" />
    <id>http://rickardlindberg.me/writing/agdpp-game-over/</id>
    <published>2023-05-06T00:00:00Z</published>
    <updated>2023-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Game over?</h1>

<p><em>Published on  6 May 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>When we worked on <a href="/writing/agdpp-shooting-arrow/index.html">shooting the arrow</a> we concluded that it was tedious to restart the game after each shot. When the arrow goes outside the screen, we want the game to be over instead and the arrow to be reset. Let’s work on that in this episode.</p>
<h2 id="do-we-really-need-game-over">Do we really need game over?</h2>
<p>If we implement game over now, there will be game over after every shot. Because there is no way to hit the balloon just yet.</p>
<p>If you play a game where it is game over immediately, would you enjoy it?</p>
<p>Perhaps game over is not the right story to work on? It is a solution to the problem that you don’t have any arrows to shoot after the first one.</p>
<p>How about if you get a new arrow immediately? So you can just keep firing?</p>
<p>From before, these are the stories we though about as needed for an initial balloon shooter:</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>Let’s think about this. For minimal, I don’t think we need real graphics. The circles convey the idea just fine.</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>I’m not sure the balloon needs to move downwards either. The current movement pattern is fine.</p>
<ul>
<li><del>Balloon moves downwards</del></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>And we can do something else instead of game over.</p>
<ul>
<li><del>Balloon moves downwards</del></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li><del>Game over when miss</del></li>
<li><del>Real graphics instead of circles</del></li>
</ul>
<p>That leaves us with this:</p>
<ul>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>New arrow when the current one has been shot</li>
</ul>
<p>We can always make something smaller. And what we initially thought we needed, we don’t need. At least not yet. When we play the game, we quite quickly find out what is needed next. Working software. In the hands of its users. Powerful.</p>
<p>Let’s work on spawning arrows now so that we can enjoy shooting arrows for a longer time without having to restart our game.</p>
<h2 id="acceptance-criteria">Acceptance criteria</h2>
<p>I can think of two test:</p>
<ul>
<li>You get a new arrow when you shoot the current one</li>
<li>When an arrow goes outside the screen, we stop rendering it</li>
</ul>
<p>The second test is kind of internal. If we render thousands of arrows outside the screen, no one will notice. Until there is a performance issue or an out of memory crash or something like that.</p>
<p>On the other hand, it makes sense, from a gameplay perspective, to talk about arrows going off the screen as being deactivated. Otherwise it might be that they come back after a while, but now instead move downwards.</p>
<h2 id="how-to-write-the-tests">How to write the tests?</h2>
<p>All tests for our game are currently written at the top-level. Here is the test that checks for behavior when we press the space key:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">We run the game for a few frames, press the space key, let it run for a few</span>
<span class="sd">frames, then quit:</span>

<span class="sd">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_keydown_space()],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>

<span class="sd">The arrow moves:</span>

<span class="sd">&gt;&gt;&gt; arrow_head_positions = events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We filter out <code>DRAW_CIRCLE</code> events with radius 10 with the assumption that the only circle drawn with radius 10 is the arrow head.</p>
<p>This test assumes only one arrow.</p>
<p>If we were to draw another arrow, there would be no way of identifying the two different arrows in this test.</p>
<p>So writing the new tests at this level feels difficult and error prone.</p>
<p>Testing is so hard.</p>
<p>Let’s see if we can make a new attempt at extracting a subsystem where this new behavior is easier to test.</p>
<h2 id="sprite-group-and-game-scene-refactoring">Sprite group and game scene refactoring</h2>
<p>Our game currently looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="n">Balloon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>I have an idea for how to push much of this logic down one level so that it can more easily be tested. Let’s give it a try.</p>
<p>We keep all our sprites in a list. Managing a list of sprites seems like a good job for a new class. We create a <code>SpriteGroup</code> class that works like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; class TestSprite:</span>
<span class="sd">...     def update(self, dt):</span>
<span class="sd">...         print(f&quot;TEST SPRITE update {dt}&quot;)</span>
<span class="sd">...     def draw(self, loop):</span>
<span class="sd">...         print(f&quot;TEST SPRITE draw {loop}&quot;)</span>

<span class="sd">&gt;&gt;&gt; group = SpriteGroup([TestSprite()])</span>
<span class="sd">&gt;&gt;&gt; x = TestSprite()</span>
<span class="sd">&gt;&gt;&gt; y = group.add(x)</span>
<span class="sd">&gt;&gt;&gt; x is y</span>
<span class="sd">True</span>

<span class="sd">&gt;&gt;&gt; group.update(4)</span>
<span class="sd">TEST SPRITE update 4</span>
<span class="sd">TEST SPRITE update 4</span>

<span class="sd">&gt;&gt;&gt; group.draw(None)</span>
<span class="sd">TEST SPRITE draw None</span>
<span class="sd">TEST SPRITE draw None</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>A sprite is any object that can respond to <code>update</code> and <code>draw</code> calls. When we update and draw the sprite group, it calls the corresponding methods on all its sprites.</p>
<p>We can use this new class in our game like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="n">Balloon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sprites</span> <span class="o">=</span> <span class="n">SpriteGroup</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sprites</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sprites</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>Not much of a difference. Mainly we moved the looping over the sprites from our game to the sprite group class. I think this is a bit cleaner, but it makes testing no easier.</p>
<p>But we are not done yet. Now, let’s extract a lower level object that we call <code>GameScene</code>.</p>
<p>The init of the game then changes to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span> <span class="o">=</span> <span class="n">GameScene</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>And the tick method changes to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">game_scene</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That is, we defer event handling, updating, and drawing to the game scene.</p>
<p>The game scene looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Balloon</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ExitGameLoop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>It inherits from <code>SpriteGroup</code> so it gets the <code>update</code> and <code>draw</code> “for free”. And the event handling code is extracted from game. (Since the <code>event</code> method does not have access to the game loop, we can’t call <code>loop.quit()</code> to exit, so we instead raise the exception that <code>loop.quit()</code> would have raised. Initially I thought it would be nice if the loop hide the quit mechanism, and so I did not want to expose the exception. That made this part difficult to write, so I reverted that decision. We constantly adapt the design to the current needs. Perhaps hiding was not the right decision? Or perhaps it was. This will do for now.)</p>
<p>Now that we have a new lower-level object, has testing become any easier?</p>
<h2 id="slow-progress">Slow progress</h2>
<p>I feel like this feature we are working on is quite easy to implement. It will just be a couple of lines of code. Yet, here we are many hours into a sprite group refactoring that we are not sure will even pay off. Why? Only so that we can write a test that “allow” us to write those couple of lines that actually implement this feature.</p>
<p>When we work in an agile way, we constantly change our software, and having a good safety net in the form of a test suite allows us to make changes confidently.</p>
<p>But if it always takes x minutes to write the test and x/10 minutes to implement the thing, is it really worth it?</p>
<p>My suspicion and hope is that testing time varies. When a feature requires a design change, things will take a little longer. With a new design in place, new features can more easily be added (and tested). Until another design challenge comes a long.</p>
<h2 id="state-based-testing">State based testing</h2>
<p>Let’s see how we can test our lower-level game scene object. It is now responsible for some behavior that the balloon shooter class was previously responsible for, so we should be able to write some tests that check the same behavior.</p>
<p>Let’s try initial state: the balloon should animate and the arrow should stay still. Here are tests for that:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initial state</span>
<span class="sd">    =============</span>

<span class="sd">    The balloon animates:</span>

<span class="sd">    &gt;&gt;&gt; game = GameScene()</span>
<span class="sd">    &gt;&gt;&gt; first_position = game.get_balloon_position()</span>
<span class="sd">    &gt;&gt;&gt; game.update(10)</span>
<span class="sd">    &gt;&gt;&gt; second_position = game.get_balloon_position()</span>
<span class="sd">    &gt;&gt;&gt; first_position == second_position</span>
<span class="sd">    False</span>

<span class="sd">    The arrow stays still:</span>

<span class="sd">    &gt;&gt;&gt; game = GameScene()</span>
<span class="sd">    &gt;&gt;&gt; first_position = game.get_arrow_position()</span>
<span class="sd">    &gt;&gt;&gt; game.update(10)</span>
<span class="sd">    &gt;&gt;&gt; second_position = game.get_arrow_position()</span>
<span class="sd">    &gt;&gt;&gt; first_position == second_position</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We create a game scene, query some of its state, update it, query some it its state again and make some assertions.</p>
<p>When we wrote these test at the balloon shooter level, we had to assert that circles were drawn in specific locations. In this test, no drawing is involved.</p>
<p>In order for the tests above to work, we have to write getters to expose some internal state:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_balloon_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_arrow_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>These are only used in tests.</p>
<p>For a long time, I was reluctant do this. Mainly because I’ve been taught that objects should not expose internals to the outside world. That is bad object oriented design.</p>
<p>But <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#visible-behavior">James writes</a></p>
<blockquote>
<p>For mutable objects, provide a way for changes in state to be observed, either with a getter method or an event.</p>
</blockquote>
<p>So if we don’t want to use mocks (which we are practicing), exposing state via getters is probably fine.</p>
<p>One thing that we are not testing with these new tests is that the balloon and the arrow are actually drawn at the positions that are returned by the getters.</p>
<p>We could probably write tests where we call the draw method as well and observe <code>DRAW_CIRCLE</code> events and see that they match. But I think the trade off is not worth it in this case. We still have the top-level tests that check that things are drawn on the screen, and the likelihood that we don’t draw at the position that the getter returns is quite small I think.</p>
<p>Anyway, now that we are (mostly) fine with writing getters to expose internal state, testing should be a little smoother.</p>
<h2 id="tests-for-new-arrow-behavior">Tests for new arrow behavior</h2>
<p>Let’s start with the initial state. We introduce the concept of flying arrows (arrows that have been shot) and check that there aren’t any in the beginning:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene()</span>
<span class="sd">&gt;&gt;&gt; game.get_flying_arrows()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We make it work like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_flying_arrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">()</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We also add the <code>get_sprites</code> getter in the <code>SpriteGroup</code> class. Again, this getter is only used in tests. This bothers me again. Not that it is only used in tests, but that this feels like bad object oriented design. Perhaps it would be cleaner it the sprite group only provided a <code>get_count</code> method? Or something more specific instead of just exposing its internal collection.</p>
<p>But we are fine with exposing internal state for testing purposes. So we don’t think too much about it now. But let’s keep it in the back of our minds for the future.</p>
<p>Let’s move on to shooting so that we get some flying arrows. Here is the test:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene()</span>
<span class="sd">&gt;&gt;&gt; initial_position = game.get_arrow_position()</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span>
<span class="sd">&gt;&gt;&gt; game.update(10)</span>

<span class="sd">It makes the arrow fire:</span>

<span class="sd">&gt;&gt;&gt; flying = game.get_flying_arrows()</span>
<span class="sd">&gt;&gt;&gt; len(flying)</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; flying[0].get_position() == initial_position</span>
<span class="sd">False</span>

<span class="sd">The initial arrow stays the same:</span>

<span class="sd">&gt;&gt;&gt; game.get_arrow_position() == initial_position</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We simulate a shot by sending a space keydown event followed by an update. We assert that we now have a flying arrow and that its position is not the original position of the arrow (it has moved). Furthermore we assert that the current arrow position is the same as the initial meaning that we still have an arrow that we can shoot.</p>
<p>The implementation: change the event handler for keydown space from this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Arrow</span><span class="p">(</span><span class="n">shooting</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>So the arrow that we shoot actually stays the same and we create a new arrow instance which will be the one shot.</p>
<p>At this point we can actually shoot multiple arrows in the game:</p>
<center>
<img src="multiple-arrows.png" title="fig:" alt="Multiple arrows." />
</center>
<h2 id="remove-arrows-outside-screen">Remove arrows outside screen</h2>
<p>We are almost there. But if we keep running the game for long enough, we will get an out of memory error. So we need to remove arrows that go outside the screen.</p>
<p>We write this test:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game = GameScene(space)</span>
<span class="sd">&gt;&gt;&gt; game.event(GameLoop.create_event_keydown_space())</span>
<span class="sd">&gt;&gt;&gt; game.update(10000)</span>
<span class="sd">&gt;&gt;&gt; game.get_flying_arrows()</span>
<span class="sd">[]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>If we decrease the number in <code>update</code> the flying arrows collection will not be empty because the arrow that we shoot has not had time to fly off screen yet.</p>
<p>We make this test pass by overriding the <code>update</code> method of the sprite group and doing the collision detection to remove flying arrows outside the screen:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameScene</span><span class="p">(</span><span class="n">SpriteGroup</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="n">SpriteGroup</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">hits_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Now the <code>get_sprites</code> method that we wrote before, for testing purposes, comes in handy. Iterating over sprites in a collection seems like a reasonable behavior. I still don’t think we should expose the internal collection. That is bad. But we could expose some kind of iterator.</p>
<p>Oh, and to remove the sprite, we actually reach into the fields of the flying arrows group and call it’s <code>remove</code> method. Yikes. But the tests pass. Let’s commit and see if we can improve this.</p>
<p>We come up wit this instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">SpriteGroup</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">arrow</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">get_sprites</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">arrow</span><span class="o">.</span><span class="n">hits_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flying_arrows</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">arrow</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p><code>x</code> is not a very meaningful name, so we call it <code>arrow</code> instead. Then we call a new <code>remove</code> method on the sprite group. No more reaching into internal fields and modifying them.</p>
<p>The sprite group looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">SpriteGroup</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">get_sprites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We ensure that <code>get_sprites</code> returns a new list so that the internal list is never exposed. This has two benefits:</p>
<ol type="1">
<li><p>The sprite group is in control of its own collection. No one on the outside can modify it.</p></li>
<li><p>It is safe to call <code>remove</code> at any time. Before we removed sprites from the collection we were iterating over. That is, in general, is a bad idea.</p></li>
</ol>
<p>I didn’t cover how the collision detection works or what <code>space</code> is. If you are curious, check out the details in <a href="https://github.com/rickardlindberg/agdpp/commit/4956769829b3426c9f0bb3fbe48ccde3150ca5a7">this commit</a>. The complete source code from this episode is on <a href="https://github.com/rickardlindberg/agdpp/tree/shoot-multiple-arrows">GitHub</a>.</p>
<h2 id="summary">Summary</h2>
<p>The big breakthrough in this episode was the realization that it’s OK to write getters to expose internal state for testing purposes. We saw that one of those getters turned out to be useful for the production code as well. I think this will make testing easier, and we will try to write as few getters as possible and only expose “sane” state. We still want to do good object oriented design.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>April 2023 Update</title>
    <link href="http://rickardlindberg.me/writing/newsletter/april-2023/" />
    <id>http://rickardlindberg.me/writing/newsletter/april-2023/</id>
    <published>2023-05-03T00:00:00Z</published>
    <updated>2023-05-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>April 2023 Update</h1>

<p><em>Published on  3 May 2023.</em></p>

<p>This is what I’ve been up to in April 2023:</p>
<ul>
<li><p>I finished writing the blog post <a href="/writing/what-should-a-ci-server-do/index.html">What should a Continuous Integration (CI) server do?</a></p></li>
<li><p>I started working on a game and am documenting the journey in a series called <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>. This month I wrote 6 blog posts with 4 accompanying videos. It has been a lot of fun. Right now I’ve spend a little more time programming and a little less time writing, so I have some catch up to do.</p></li>
<li><p>I read a bit and thought a bit about the agile concept of a (user) story. I plan to clarify my thinking about stories by writing a blog post about it.</p></li>
<li><p>I watched <a href="https://youtu.be/UwYbSBUrotU">Ron Jeffries and Chet Hendrickson Live from Agile2017 - LeadingAgile Soundnotes</a>. The part that was most interesting to me (and my research about stories) was the idea that not everything the team does is on the backlog. Only stuff the PO cares about is on the backlog.</p></li>
<li><p>I spent some time reading articles on <a href="https://www.ronjeffries.com/">Ron’s site</a>. One favourite is <a href="https://www.ronjeffries.com/articles/-z022/0222ff/gotta-be-good/">Gotta Be Good</a>. Ron is also working on a game in Python which I tried and <a href="/writing/trying-rons-python-asteroids/index.html">wrote</a> about. His writing about his game development partly inspired me to do a similar series about my game.</p></li>
<li><p>I published another four programming videos on my <a href="https://www.youtube.com/channel/UC4XI09URnsM_YYTSizAMliA">Youtube channel</a>:</p>
<ul>
<li><a href="https://youtu.be/9DZ81lOPfmo">Introducing Agile Game Development with Python and Pygame</a></li>
<li><a href="https://youtu.be/Q0347KVq7oU">Test driving the game loop | Agile Game Development with Python and Pygame (part 2)</a></li>
<li><a href="https://youtu.be/z20IocFrKLY">Demo and game idea | Agile Game Development with Python and Pygame (part 3)</a></li>
<li><a href="https://youtu.be/CfhEcp9Qghc">Shooting the arrow | Agile Game Development with Python and Pygame (part 4)</a></li>
</ul></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Thinking about test design</title>
    <link href="http://rickardlindberg.me/writing/agdpp-thinking-about-test-setup/" />
    <id>http://rickardlindberg.me/writing/agdpp-thinking-about-test-setup/</id>
    <published>2023-04-28T00:00:00Z</published>
    <updated>2023-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Thinking about test design</h1>

<p><em>Published on 28 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In the <a href="/writing/agdpp-shooting-arrow/index.html">previous</a> episode we were not quite happy with the design of our tests. Are we testing things at the right level? Do we see any smells? Are we missing tests? We will take some time in this episode to reflect on those questions so that things will go smooth(er), testing wise, when working on the next story.</p>
<h2 id="a-concrete-problem">A concrete problem</h2>
<p>In the previous episode I had a feeling that everything was not alright with the tests. I poked around a bit and noticed that I could change some vital production code that would break the game without my tests noticing.</p>
<p>Let’s have a look.</p>
<p>The event handling in the game now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>If we skip the check for the space key and always shoot the arrow, like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>Then the arrow goes off immediately when the game starts, which is obviously not correct, but all tests still pass.</p>
<h2 id="coverage-and-expectation">Coverage and expectation</h2>
<p>The promise of TDD and automated testing is that you can have very high test coverage. What I aspire to is to create a test suite that within seconds tells me if I broke the production code with my change. It might not be realistic, but when I find a case where I could break my production code without my tests noticing, I want to look more closely.</p>
<p>Testing can for sure be seen as a trade off. At some point it probably costs more to test than what you gain.</p>
<p>One reason to not test is that you don’t know how. That can be solved by practicing. Another reason might be that you decide that the cost is not worth it. However, the cost of testing goes down the better you get at it.</p>
<p>And in this series I’m trying to learn as well and document that process. So let’s analyze the problem with the gap in the test suite and see what we can come up with.</p>
<h2 id="what-test-is-missing">What test is missing?</h2>
<p>The balloon shooter has two tests. Here are their descriptions:</p>
<ol type="1">
<li><p>I draw the initial scene of the game which consists of a balloon and an arrow and quit when the user closes the window.</p></li>
<li><p>The arrow moves when it is shot by pressing the space key.</p></li>
</ol>
<p>The first test is checking that the initial frame is drawn correctly.</p>
<p>The second test is checking that the arrow moves when we press space.</p>
<p>But there is no test checking that the arrow stays still if we don’t press space.</p>
<p>I think we tried to remedy that in the previous episode by adding these two “lower-level tests” to the arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I stay still if I&#39;ve not been fired:</span>

<span class="sd">    &gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">    &gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; initial_y == arrow.y</span>
<span class="sd">    True</span>

<span class="sd">    I move upwards when fired:</span>

<span class="sd">    &gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">    &gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">    &gt;&gt;&gt; arrow.shoot()</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">    &gt;&gt;&gt; arrow.y &lt; initial_y</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The problem is that the event checking logic is not in the <code>Arrow</code> class, but in the <code>BalloonShooter</code> class. So what we want to test can’t be tested at this level.</p>
<h2 id="where-to-test">Where to test?</h2>
<p>Writing all tests as “top-level tests” which includes all objects is not a good idea. The test setup will get complicated. The asserts will get difficult to write. The test will be slower.</p>
<p>So we want to test at as a low level as possible.</p>
<p>So if we want to test the initial state of the arrow in the <code>Arrow</code> class, we need to move event handling logic into it, so that it’s its responsibility and does not need to be tested in <code>BalloonShooter</code>.</p>
<p>On the other hand, when you start writing tests for smaller subsystems, those subsystems become harder to refactor. Suppose you are not happy with the subsystems that you have created, and you want a different design. If you do that refactoring, you also have to modify the tests to fit. That makes refactoring and design harder. So you don’t want to do it too early.</p>
<p>In our case, I think we did it too early. Our game class only has one test, and we already started extracting subsystems and writing tests there.</p>
<p>Let’s see if we can fix that.</p>
<h2 id="testing-initial-state">Testing initial state</h2>
<p>Before we had this test for the initial state:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw the initial scene of the game which consists of a balloon and an</span>
<span class="sd">arrow and quit when the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 520</span>
<span class="sd">    radius: 15</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 540</span>
<span class="sd">    radius: 20</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This only captures the initial frame. Let’s see if we can rewrite this.</p>
<p>We start with this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I am a balloon shooter game!</span>

<span class="sd">Initial state</span>
<span class="sd">=============</span>

<span class="sd">We run the game for a few frames, then quit:</span>

<span class="sd">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This is just the setup. We simulate that we start the game, run it for a couple of frames, then quit.</p>
<p>What are some behaviors that we expect to see here?</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The game loop is initialized and cleaned up:</span>

<span class="sd">&gt;&gt;&gt; events.filter(&quot;GAMELOOP_INIT&quot;, &quot;GAMELOOP_QUIT&quot;)</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The balloon is drawn animated:</span>

<span class="sd">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=40).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">[(50, 50), (51, 50), (52, 50)]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The arrow is drawn in a fixed position:</span>

<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 500)}</span>
<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=15).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 520)}</span>
<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=20).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 540)}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>These new cases cover all the cases in the old test, so we can remove the old. Furthermore it also checks that the arrow doesn’t move so that we no longer can do the mistake of always shooting the arrow. Success!</p>
<h2 id="reflecting-on-new-test-setup">Reflecting on new test setup</h2>
<p>The test for the initial state is structured by simulating a run of the game, collecting events of what happened, and then making specific assertions about those events to check different behavior.</p>
<p>Let’s structure the rests of the test that way too:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">User presses space key</span>
<span class="sd">======================</span>

<span class="sd">We run the game for a few frames, press the space key, let it run for a few</span>
<span class="sd">frames, then quit:</span>

<span class="sd">&gt;&gt;&gt; events = BalloonShooter.run_in_test_mode(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_keydown_space()],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>

<span class="sd">The arrow moves:</span>

<span class="sd">&gt;&gt;&gt; arrow_head_positions = events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>If there are more things that should happen when we press the space key, we can add asserts for it. But for now, I don’t think there is any.</p>
<h2 id="summary">Summary</h2>
<p>All our tests for the game are now written at the top-level. They include all the objects. And they are written close to the acceptance criteria for stories. Don’t we need lower-level tests as well?</p>
<p>We for sure can’t keep testing all aspects of the game with top-level tests. Subsystems must for sure emerge that are easier to test. We will keep that in mind for the future and look extra carefully at what those subsystems might be. But for now, we are happy that we closed the gap in our test suite.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Shooting the arrow</title>
    <link href="http://rickardlindberg.me/writing/agdpp-shooting-arrow/" />
    <id>http://rickardlindberg.me/writing/agdpp-shooting-arrow/</id>
    <published>2023-04-27T00:00:00Z</published>
    <updated>2023-04-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Shooting the arrow</h1>

<p><em>Published on 27 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we continue towards the first version of the balloon shooter. It’s time to shoot the arrow!</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/CfhEcp9Qghc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="recap">Recap</h2>
<p>We are trying to create an absolute minimum version of a balloon shooter game that we can show to our customer and ask if that was what he had in mind. Our idea for minimal is this:</p>
<ul>
<li>1 balloon falling down the screen</li>
<li>1 arrow pointing in a fixed direction</li>
<li>1 button to shoot that single arrow</li>
<li>Then game over</li>
</ul>
<p>In the <a href="/writing/agdpp-demo-and-game-idea/index.html">previous</a> episode, we took the first step by drawing a balloon and an arrow. Here is what it looks like:</p>
<center>
<img src="shooter.png" title="fig:" alt="Balloon shooter." />
</center>
<p>And here is a list of possible stories to work on next:</p>
<ul>
<li>Balloon moves downwards</li>
<li><strong>Arrow animates when shot</strong></li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>I sometimes find it hard to look too far into the future. Perhaps that is true for our customer as well. I find it much easier to look at the current state of the software and ask myself “What to work on next?”</p>
<p>When I run the game now, all I want to do is fire that arrow and see it flying across the screen. So that is our next story!</p>
<h2 id="acceptance">Acceptance</h2>
<p>When working in an agile way, things might seem reversed from what you are used to. For example, when doing TDD, we write the test before we write the code. The same applies for stories. Before starting work on a story, we should figure out the acceptance criteria. How do we know when we are done?</p>
<p>For the story with shooting arrow I think the acceptance criteria is that you should see the arrow flying across the screen when you press the space key. Our customer agrees on that.</p>
<p>The next step is to figure out how to write an automated test for that.</p>
<h2 id="the-test-we-want-to-write">The test we want to write</h2>
<p>Just to recap, the test for the balloon shooter looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; BalloonShooter(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">...</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>That is, we run the balloon shooter game, configure a set of events that should be simulated, and then assert that certain things happens (game loop inits, circles are drawn on screen, etc).</p>
<p>The test we want to write the for the shoot behavior starts like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The arrow moves when it is shot by pressing the space key:</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_keydown_space()],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; BalloonShooter(loop).run()</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We introduce a new event, keydown space, and simulate that it happens after one frame, and then we simulate a couple of more frames. The reason that we include a couple of frames is that we want to observe that the arrows moves between different frames.</p>
<p>This partial test fails because this new event does not yet exist, so let’s fix that.</p>
<h2 id="adding-a-new-event">Adding a new event</h2>
<p>We add the new event like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_event_keydown_space</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; GameLoop.create_event_keydown_space().is_keydown_space()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">K_SPACE</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">is_keydown_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">K_SPACE</span>
</pre>
</div>
</div>
</div>
<p>We figure out the Pygame event parameters to use by reading the documentation.</p>
<p>We verify that we got it correct by printing something when we get the keydown space event when running the game. We press different keys to see if it correctly only captures the space key.</p>
<p>It seems to work.</p>
<h2 id="filtering-events">Filtering events</h2>
<p>The initial test now runs, but if we print all the events that we get, there is a lot of noise:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">...</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>What we want to observe in that list of events is that the arrow has been drawn in different positions (indicating movement).</p>
<p>So first we want to filter out the <code>DRAW_CIRCLE</code> events that are for the head of the arrow.</p>
<p>We want to write like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=10)</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Filtering on event fields is not yet possible, but we own the library, and the fix goes smoothly.</p>
<p>Once that is done, we get this list of events:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This means that when we ran our game in test mode, four frames where drawn and here are all the circles with radius 10. We use 10 here because we know that the head of the arrow is the only circle that is drawn with radius 10. But it is not bullet proof. It would be better if we could pass an id to the draw method call that is included in the event as well so that we could more accurately identify objects. But this will do for now.</p>
<h2 id="extracting-positions">Extracting positions</h2>
<p>In the output above, we can look at the x and y coordinates and see if they change. But there are also other fields that we don’t care about in this test. Let’s filter out the position like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;)</span>
<span class="sd">[(500, 500), (500, 500), (500, 500), (500, 500)]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Again, the <code>collect</code> method does not exist, but we can extend our library with it.</p>
<p>Now we have a list of positions where the head of the arrow is drawn. It doesn’t seem to change, which we can see more clearly by making the collection into a set and seeing that it has only one element:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; set(events.filter(&quot;DRAW_CIRCLE&quot;, radius=10).collect(&quot;x&quot;, &quot;y&quot;))</span>
<span class="sd">{(500, 500)}</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<h2 id="real-test-failure">Real test failure</h2>
<p>We want the arrow to move, so let’s write an assert like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; len(arrow_head_positions) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; len(set(arrow_head_positions)) &gt; 1</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>That is, we should get more than one position, and the set of all those positions should also be larger than one, indicating movement.</p>
<p>The first assertion passes, but the other one fails. That is expected. Finally we have the assertion failure that we wanted. Took a bit of time, huh? That might tell us something about the design of our system. We’ll talk about it in <a href="/writing/agdpp-thinking-about-test-setup/index.html">another episode</a>.</p>
<h2 id="implementation">Implementation</h2>
<p>First, we modify the event handler to check for the space key and shoot the arrow if so:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">BalloonShooter</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">is_keydown_space</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">shoot</span><span class="p">()</span>
        <span class="o">...</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The shooting mechanism, we implement like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">shoot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shooting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">dt</span>
</pre>
</div>
</div>
</div>
<p>We also adjust the drawing code so that all three circles that are drawn for the arrow are drawn relative to the now variable y position.</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="mi">20</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>The arrow now moves when we press the space key. Success! Unfortunately we only have one shot. Then we need to restart the game to get a new arrow. We will fix that in another story.</p>
<h2 id="getting-tangled-up-in-tests">Getting tangled up in tests</h2>
<p>The shooting works, but I think we forgot to test the initial case. If we don’t press the space key, the arrow should stay still.</p>
<p>We can change the tick method of the arrow to this, and all tests still pass:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">dt</span>
</pre>
</div>
</div>
</div>
<p>But that makes the arrow move immediately, even if not shot, which was not intended.</p>
<p>We write a few more specific tests for the behavior of the arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I stay still if I&#39;ve not been fired:</span>

<span class="sd">&gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">&gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; initial_y == arrow.y</span>
<span class="sd">True</span>

<span class="sd">I move upwards when fired:</span>

<span class="sd">&gt;&gt;&gt; arrow = Arrow()</span>
<span class="sd">&gt;&gt;&gt; initial_y = arrow.y</span>
<span class="sd">&gt;&gt;&gt; arrow.shoot()</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.tick(1)</span>
<span class="sd">&gt;&gt;&gt; arrow.y &lt; initial_y</span>
<span class="sd">True</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>That forces us to add the if statement again.</p>
<p>I’m not sure I’m entirely happy that we access the y variable like that. I prefer to see all fields of a class in Python as private (unless it’s a pure data object). But we got the test working at least.</p>
<p>I’m not happy with the current tests. On the other hand, I’m not sure how to improve them either.</p>
<p>Maybe it’s time to go for a jog or spend some time off the computer with my notebook to see if any better ideas emerge. But for now, we leave it like this.</p>
<h2 id="summary">Summary</h2>
<p>The arrow now moves. So exciting! But it’s a bummer that you have to restart the game after each shot. Therefore I think the game over screen might be most interesting to work on next. When the arrow misses (goes outside the screen) the game should be over, and the arrow should be reset.</p>
<p>After that, I think collision check with balloon would be most interesting.</p>
<p>All those require tests of course. So we should probably work on getting comfortable with the test setup as well.</p>
<p>The source code from this episode is on <a href="https://github.com/rickardlindberg/agdpp/tree/shoot-arrow">GitHub</a>.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Demo and game idea</title>
    <link href="http://rickardlindberg.me/writing/agdpp-demo-and-game-idea/" />
    <id>http://rickardlindberg.me/writing/agdpp-demo-and-game-idea/</id>
    <published>2023-04-24T00:00:00Z</published>
    <updated>2023-04-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Demo and game idea</h1>

<p><em>Published on 24 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we demo the “game” for our customer. We get some feedback on it and start evolving the game to meet our customer’s vision.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z20IocFrKLY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="demo">Demo</h2>
<p>I mentioned to my son that I had started working on a game. He wanted to see it. I told him that there isn’t much to play yet, but that I can show him what it looks like.</p>
<p>I started the “game” and he watched the circle going back and forth.</p>
<p>For reference, this is what the “game” looks like now:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<p>Then he tried to interact with the circle. He grabbed the mouse and clicked away and was disappointed that nothing happened. I told him that you can’t do anything yet, that it’s just an animation.</p>
<p>He looked at me sad and said “Dad, this game is boring.”</p>
<p>Initially I wasn’t planning on showing him the game because in this early stage there is not much to play, and I knew he was not going to like it. Did I ruin it?</p>
<p>Then I asked him, “What would you like to do with the circle?”</p>
<p>The sadness in his face disappeared and he started talking about balloons. He said that he wanted the circle to be a balloon and that he wanted to shoot down balloons with arrows.</p>
<p>I think we have an idea for a game.</p>
<h2 id="on-early-feedback">On early feedback</h2>
<p>My initial idea for the game was some kind of tetris variant. I was thinking that you have two boards and that you could help each other out by clearing blocks on each other’s boards. Cooperation seems more fun that competition.</p>
<p>Turns out, the customer wants a balloon shooter. If we hadn’t shown the demo, we might have never found that out.</p>
<h2 id="simplest-possible-version">Simplest possible version</h2>
<p>In the spirit of <a href="https://www.artima.com/articles/the-simplest-thing-that-could-possibly-work#part3">Ward</a> we ask ourselves what the simplest possible balloon shooter could look like. What is the absolute minimum version that I can give to my son and he can somewhat enjoy playing or at least recognize as a balloon shooter? (The goal is to create a game that <em>we</em> can enjoy playing together. That means some kind of multiplayer mode. But that is another for a later story.)</p>
<p>Here is what I’m thinking:</p>
<ul>
<li>1 balloon falling down the screen</li>
<li>1 arrow pointing in a fixed direction</li>
<li>1 button to shoot that single arrow</li>
<li>Then game over</li>
</ul>
<p>So the only challenge will be to fire the arrow at the right time for it to hit the balloon. You will either hit and get a point or miss and it’ll be game over.</p>
<p>Oh, and circles for the graphics is probably fine. The balloon can be drawn with one big circle, and the arrow maybe with three smaller circles in a row. If I tell my son to imagine they are balloons and arrows, I think he’ll accept that.</p>
<h2 id="first-story">First story</h2>
<p>To make progress towards a balloon shooter, I want to work on a story that is about drawing a balloon and an arrow. Create the initial scene of the game sort of.</p>
<p>Our game already animates a circle. Let’s put all behavior related to that circle into its own class called <code>Balloon</code>. Here is how our game <code>tick</code> method looks like now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>After we extract the balloon class, it looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>And here is the balloon class:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Balloon</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Any behavior that the balloon should have, we can now test at this lower level. We can instantiate a balloon, call its tick method, and observe that the right thing happens. There is no need to involve the game or the game loop. (At least if we accept exposing somewhat internal state like the x variable.)</p>
<p>With the balloon object in place, it is natural to create a new object called <code>Arrow</code> for our other piece in the balloon shooter game. We create a version that just draws a circle:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Arrow</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We make sure it is included in the game by modifying the tick method of the game to also tick and draw the arrow:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tick</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We notice a pattern here. It seems like the responsibility of the game is to call tick and draw on a set of objects. In games (or in Pygame) those objects are referred to as sprites. My understanding is that a sprite is any visual element that shows up in the game.</p>
<p>We refactor our game to reflect this new understanding:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balloon</span> <span class="o">=</span> <span class="n">Balloon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span> <span class="o">=</span> <span class="n">Arrow</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">balloon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>Is our game class just becoming a thing layer of loops? Can we move some of that responsibility to the game loop? I’m not certain yet, so we will leave it like this for now.</p>
<p>If we run the game now, this is what we see:</p>
<center>
<img src="scene1.png" title="fig:" alt="First scene of balloon shooter." />
</center>
<p>Not very pretty. What is that?</p>
<p>Let’s see if we can improve the drawing of the arrow. But remember, not perfection, but improvement. If I look at the game now, I don’t get an idea what the game is about. We just want to make the arrow slightly more realistic to convey the meaning of the object. We are still restricted to drawing circles. The current <code>draw_circle</code> looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>That’s stupid! Why is there no ability to specify anything but the x-coordinate? Well, until now, we haven’t needed that. Now that we do need it, let’s add it. No biggie:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">radius</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">radius</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We experiment with three circles for the arrow and tweak the numbers until we think it looks good. Here is the result:</p>
<center>
<img src="scene2.png" title="fig:" alt="Improved drawing of arrow." />
</center>
<p>I don’t know about you, but when I see this, I want to press a button to fire that arrow so it hits the balloon. I’m convinced this is a balloon shooter now. I hope our customer is as well.</p>
<p>Right, balloon shooter. Before we didn’t know what game we should write, so our game class was just called <code>Game</code>. Let’s fix that:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span> from gameloop import GameLoop
 
<span class="gd">-class Game:</span>
<span class="gi">+class BalloonShooter:</span>
</pre>
</div>
</div>
</div>
<p>There! Now the code more accurately represent the ideas that we have in our minds about this game.</p>
<p>I forget to mention anything about testing. (For the complete workflow, check out the video.) But here is what the test for the balloon shooter looks like now:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw the initial scene of the game which consists of a balloon and an</span>
<span class="sd">arrow and quit when the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; BalloonShooter(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">    y: 50</span>
<span class="sd">    radius: 40</span>
<span class="sd">    color: &#39;red&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 500</span>
<span class="sd">    radius: 10</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 520</span>
<span class="sd">    radius: 15</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 500</span>
<span class="sd">    y: 540</span>
<span class="sd">    radius: 20</span>
<span class="sd">    color: &#39;blue&#39;</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We both changed the description, becasue we have a balloon shooter now, not a generic game, and added checks for it drawing both the balloon and the arrow.</p>
<p>It might be too specific to assert on exact coordinates here. We have to visually inspect the output and see if we think it looks good. That’s what I did here. And when I was happy, I copied the coordinates into the test.</p>
<h2 id="summary">Summary</h2>
<p>We have completed a first vertical slice of our balloon shooter. There is now a balloon and an arrow on the screen. This is new behavior that we could show to our customer and get feedback on. Perhaps he doesn’t like the position of the arrow. If so, we can adjust. Perhaps he can’t imagine that the circle is actually a balloon. If so, we can work on improving the graphics.</p>
<p>What else do we think we need before we have the first version of the balloon shooter?</p>
<ul>
<li>Balloon moves downwards</li>
<li>Arrow animates when shot</li>
<li>Arrow can hit balloon</li>
<li>Point is given for hit</li>
<li>Game over when miss</li>
<li>Real graphics instead of circles</li>
</ul>
<p>Which one is the most important one to work on next? We’ll tackle that one in the next episode!</p>
<p>You can browse the <a href="https://github.com/rickardlindberg/agdpp/tree/initial-balloon-shooter-story">complete source code</a> from this episode.</p>
<p>See you!</p>
]]></summary>
</entry>
<entry>
    <title>Separating pygame completely from the rest of the game</title>
    <link href="http://rickardlindberg.me/writing/agdpp-pygame-separation-design/" />
    <id>http://rickardlindberg.me/writing/agdpp-pygame-separation-design/</id>
    <published>2023-04-20T00:00:00Z</published>
    <updated>2023-04-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Separating pygame completely from the rest of the game</h1>

<p><em>Published on 20 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we reflect on our current design. I see something that bothers me. We talk about it and how to fix it.</p>
<h2 id="the-problem">The problem</h2>
<p>Right now our game is split up into two main classes: the game and the game loop. The game contains the logic of our game, while the game loop is responsible for setting up pygame and calling our game on every frame.</p>
<p>Almost all references to pygame are contained in the game loop class. Our game knows almost nothing about pygame. Almost. And that bothers me.</p>
<p>Let’s have a look at the test for our game:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We can see references to pygame in two places. First when we create the quit event. We create an instance of a pygame event and pass that to the null version of the game loop. Later in the events that we assert on, there are event names mentioning pygame (<code>PYGAME_INIT</code> and <code>PYGAME_QUIT</code>).</p>
<p>Why does this bother me?</p>
<p>One purpose of introducing the game loop class was to separate pygame code from our game. One reason to do that is that our game becomes easier to test. And if it’s easier to test, it suggests that the design is also better. (People claim at least. So let’s go with that here.)</p>
<p>But some details of pygame are leaking out.</p>
<p>If <code>GameLoop</code> were instead called <code>PygameGameLoop</code>, I would be more fine with this. But I think the design would be more clear if the game didn’t know anything at all about pygame.</p>
<p>Our game loop uses the <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#infrastructure-wrappers">infrastructure wrapper</a> pattern. One purpose of that pattern is to isolate and contain infrastructure code so that the user of it can be provided an interface that is optimal for its consumption. In our case we want to design our game loop to fit exactly what our game needs. And the loop should encapsulate all the details of how to make that happen (using pygame).</p>
<p>Our game now needs to know that the pygame quit event is fired when the user closes the window. But wouldn’t it be more clear if that could be expressed in the code something like this instead?</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>Above, the game does not need to know about pygame and can directly express the idea that if the user closes the window, the game loop should be quit.</p>
<p>Enough talking, let’s see if we can fix this.</p>
<h2 id="wrapping-events">Wrapping events</h2>
<p>The tick method of our game now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The interface is that events is a list of pygame event instances.</p>
<p>Let’s change that to instead be instances of a new event class that we control. Here is a first version:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pygame_event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span> <span class="o">=</span> <span class="n">pygame_event</span>

    <span class="k">def</span> <span class="nf">is_user_closed_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_event</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Now we can change how the game loop calls the game from this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>to this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="p">[</span><span class="n">Event</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()])</span>
</pre>
</div>
</div>
</div>
<p>This breaks our tests saying that</p>
<pre><code>AttributeError: &#39;Event&#39; object has no attribute &#39;type&#39;</code></pre>
<p>We modify our game to use our new method instead:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">is_user_closed_window</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>All tests are passing again.</p>
<p>We can rely on our tests for this refactoring.</p>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/ac00de877b8f4ee58716c0030c8b2ecab19a318e"><code>git commit -a -m ‘Wrap events to tick for a nicer interface.’</code></a></p>
<h2 id="test-still-mentions-pygame">Test still mentions pygame</h2>
<p>Our test for the game still creates pygame events:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Here we would like to instead express the idea that we want to simulate a user closes the window event without mentioning any more details.</p>
<p>Here is one attempt:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [GameLoop.create_event_user_closed_window()],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>And in game loop, we add this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_event_user_closed_window</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Now the game loop knows the details of how to create pygame events. I think this is better. But there is one thing that still bothers me.</p>
<p>The tick method expects a list of events with the interface that we make up, but <code>create_event_user_closed_window</code> creates a pygame event. So right now, there is no way for us to test the tick method in isolation, because there is no way to create events. If we expose the <code>Event</code> class we could do something like this in a test:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; game.tick(dt=1, events=[Event(GameLoop.create_user_close_window())])</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>I’m not sure I like that. I think I would feel better if <code>create_event_user_closed_window</code> returned an event with our interface. Let’s try that.</p>
<p>We modify it:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_event_user_closed_window</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>Test fail:</p>
<pre><code>AttributeError: &#39;Event&#39; object has no attribute &#39;type&#39;</code></pre>
<p>I think we are now wrapping events in events. Let’s unpack the pygame event when creating the null version, going from this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">NullEvent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
</pre>
</div>
</div>
</div>
<p>to this</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">NullEvent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">pygame_event</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[]</span>
</pre>
</div>
</div>
</div>
<p>Now another test fails:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">create_null</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;some event&quot;</span><span class="p">]])</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We just changed the interface of <code>create_null</code> to expect <code>Event</code> instances. Here we are passing a string. It should really be a pygame event. But we ignore that for now and just change to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">create_null</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[[</span><span class="n">Event</span><span class="p">(</span><span class="s2">&quot;some event&quot;</span><span class="p">)]])</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>All tests are passing. Success!</p>
<p>We add a test to illustrate the usage of the factory method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_event_user_closed_window</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; GameLoop.create_event_user_closed_window().is_user_closed_window()</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">))</span>
</pre>
</div>
</div>
</div>
<p>At this point our game no longer depends on pygame. It only depends on the game loop which provides the infrastructure needed for writing a game (graphics, user input, music, etc). We can remove the import of pygame so the top of the file now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">from</span> <span class="nn">gameloop</span> <span class="kn">import</span> <span class="n">GameLoop</span>

<span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/3686e4d1f5740301f2177810cfa26fa093153c17"><code>git commit -a -m ‘Wrap events so that our game now longer knows about pygame.’</code></a></p>
<h2 id="get-rid-of-last-pygame-reference">Get rid of last pygame reference</h2>
<p>There is still one place left where our game test refers to pygame:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>Some events that the game loop emits have pygame in their name.</p>
<p>Imagine that we could plug any game loop implementation into our game and from the game’s perspective, they all worked the same. Then it doesn’t make sense for it to emit events that talk about the underlying technology to realize the game loop.</p>
<p>Let’s rename <code>PYGAME_INIT</code> to <code>GAMELOOP_INIT</code> and <code>PYGAME_QUIT</code> to <code>GAMELOOP_QUIT</code>. And while we are improving events, let’s also add the resolution and fps to the init event so that we can observe them.</p>
<p>Here is how the test reads then:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">GAMELOOP_INIT =&gt;</span>
<span class="sd">    resolution: (1280, 720)</span>
<span class="sd">    fps: 60</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">GAMELOOP_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p><a
href="https://github.com/rickardlindberg/agdpp/commit/b6ef6430ee93bf9b933f5f06d69d9666ca2d1cd2"><code>git commit -a -m ‘Game loop emits events with clearer names.’</code></a></p>
<h2 id="unnecessary-work">Unnecessary work?</h2>
<p>At this point, our game knows nothing about pygame. It only relies on the interface of the game loop. That is something that we control and can design specifically for what our game needs. And should we want to switch out pygame for another graphics library, we only need to modify the game loop, not our game.</p>
<p>You might object that this seems like too much speculative design. What is the likelyhood that we want to switch graphics package? And can’t we deal with those problems when they arise?</p>
<p>On the one hand, I think that objection is valid. But I would like to see this from another angle. The purpose of this change was not to make pygame easily replaceable. The purpose of the change was to design a clean interface for our game where the different classes had different responsibilities. Only as a side effect pygame became more replaceable.</p>
<p>Had we designed a base class <code>GameLoop</code> and then derived a <code>PygameGameLoop</code> from it, then I think we would have designed speculatively. There is only one implementation of the game loop right now. We don’t even anticipate any more implementations, so why make a “placeholder” in our design where a second implementation could be plugged in?</p>
<h2 id="summary">Summary</h2>
<p>Making design changes in the beginning is generally easier. The further you go in the wrong direction, the harder it is to undo. (But with careful refactoring, it is always possible.) One problem is that it might be harder to see problems with the design early on. How are a few references to pygame problematic? I think thinking in terms of code smells instead of in terms of speculative design is useful here.</p>
<p>By the way, I’m not sure the design I choose here is the “correct” one. I’m just trying to learn and practice here and explain my thinking. But I think if I give attention to design early on, the future will be easier.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Test driving the game loop</title>
    <link href="http://rickardlindberg.me/writing/agdpp-game-loop/" />
    <id>http://rickardlindberg.me/writing/agdpp-game-loop/</id>
    <published>2023-04-19T00:00:00Z</published>
    <updated>2023-04-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Test driving the game loop</h1>

<p><em>Published on 19 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>In this episode we look at how to set up the game loop, draw something on the screen, and test it. We begin with a spike to learn Pygame fundamentals and then we look at how to set up tests for it.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Q0347KVq7oU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="hello-world">Hello World</h2>
<p>We start with this example straight from the <a href="https://www.pygame.org/docs/">Pygame docs</a>:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="c1"># Example file showing a basic pygame &quot;game loop&quot;</span>
<span class="kn">import</span> <span class="nn">pygame</span>

<span class="c1"># pygame setup</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>
<span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="c1"># poll for events</span>
    <span class="c1"># pygame.QUIT event means the user clicked X to close your window</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># fill the screen with a color to wipe away anything from last frame</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>

    <span class="c1"># RENDER YOUR GAME HERE</span>

    <span class="c1"># flip() the display to put your work on screen</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>

    <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># limits FPS to 60</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>When we run it, it shows an empty screen:</p>
<center>
<img src="tutorial.png" title="fig:" alt="Tutorial output." />
</center>
<h2 id="draw-something">Draw something</h2>
<p>An empty screen is not that interesting, so let’s see if we can get an animation going.</p>
<p>We add a call to draw a circle and some logic to animate it:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="o">...</span>

<span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="n">running</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">if</span> <span class="n">pos_x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_x</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="mf">0.3</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">pos_x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>

    <span class="o">...</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>  <span class="c1"># limits FPS to 60</span>

<span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>This seems to work. We get an animated circle:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<h2 id="refactor-to-clarify">Refactor to clarify</h2>
<p>Next we separate the logic of the game loop from the logic of our game. We refactor in small steps, testing manually that everything works, and end up with this for our game:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">screen</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="mf">0.3</span>
        <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>And this for our game loop:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
        <span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>
        <span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">screen</span><span class="p">):</span>
                <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>And it is all used like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">Game</span><span class="p">(</span><span class="n">GameLoop</span><span class="p">())</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>Remember, we are only doing a spike here. We are trying to learn Pygame and how we could split the different responsibilities into different classes and how to possibly test it.</p>
<p>With this refactoring, the game is now responsible for handling events and drawing the animated circle and the game loop is responsible for setting up Pygame and calling the game in a loop.</p>
<p>I think we have learned enough about this setup and I think I know how we could test it. Let’s see.</p>
<h2 id="how-to-test-this">How to test this?</h2>
<p>So now we start completely from scratch, test driving our game. We know roughly what we want to do from the spike.</p>
<p>Where to start?</p>
<p>I find it easiest to start from the outside when writing tests. What should the system do? What should our game do?</p>
<p>Well, our game draws a circle on the screen until the user closes the window. Let’s start there.</p>
<p>Here is how we get some basic structure in place:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I draw an animated circle until the user closes the window.</span>

<span class="sd">    &gt;&gt;&gt; game = Game(GameLoop())</span>
<span class="sd">    &gt;&gt;&gt; game.run()</span>
<span class="sd">    DRAW_CIRCLE</span>
<span class="sd">    EXIT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GameLoop</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Instead of actually drawing and exiting, we just print the action. We fake it. The point of this is to get some basic structure in place with tests. From the spike we know in which direction to go. Let’s continue.</p>
<h2 id="remove-fakes">Remove fakes</h2>
<p>Eventually we want to turn <code>GameLoop</code> into an infrastructure wrapper. This will give us the ability to conveniently use it in tests. This pattern is explained in depth in <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks">Testing Without Mocks</a>.</p>
<p>One part of that pattern is that we should be able to observe what <code>GameLoop</code> is doing.</p>
<p>Here is how we rewrite the test for our game to assert on events fired from <code>GameLoop</code> instead of print statements:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The <code>GameLoop</code> now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
</pre>
</div>
</div>
</div>
<p>Instead of printing actions, it notifies about its actions via an observable pattern.</p>
<p>We also moved the circle drawing code to the game loop and have the game call that method instead. The game loop will be responsible for drawing things on the current frame.</p>
<p>But we are still not doing anything real, we are just firing events and asserting on them. Time to fix that.</p>
<h2 id="flesh-out-pygame-calls">Flesh out pygame calls</h2>
<p>Continuing the pattern of an infrastructure wrapper, we add an argument to <code>GameLoop</code> which is the Pygame module. We provide an embedded stub for the null version that does nothing:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">pygame</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_null</span><span class="p">():</span>
        <span class="k">class</span> <span class="nc">NullPygame</span><span class="p">:</span>
            <span class="o">...</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">NullPygame</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pygame</span><span class="p">):</span>
        <span class="n">Observable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span> <span class="o">=</span> <span class="n">pygame</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>We write a test for the game loop that checks that the proper events are fired:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I init and clean up pygame:</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; loop.run(NullGame())</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>And we also create a test that uses the real Pygame module:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; GameLoop.create().run(NullGame())</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This test will actually cause a window to pop up on the screen, so it is a bit distracting, but it makes sure we are calling Pygame correctly.</p>
<p>The game loop now looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;PYGAME_INIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We are getting closer. If we run the game now and look carefully, we can see that a circle is drawn on the screen for a split second before it closes. That is because there is no loop yet. We just render one frame and then exit. Time to fix that.</p>
<h2 id="loop-and-events">Loop and events</h2>
<p>Let’s start with our game. The test for it should simulate an event that the user closes the window, and first then exit the application:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>The <code>tick</code> method is modified to look like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>So we made the decision that the game loop should exit if the tick method returns true.</p>
<p>We add the ability for the null version of the game loop to simulate events:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">create_null</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="p">[]):</span>
    <span class="k">class</span> <span class="nc">NullPygame</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">NullEvent</span><span class="p">()</span>
            <span class="o">...</span>
    <span class="k">class</span> <span class="nc">NullEvent</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">events</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">NullPygame</span><span class="p">())</span>
</pre>
</div>
</div>
</div>
<p>And we modify the run method to actually do a loop and pass events to the <code>tick</code> method:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()):</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>If we do not configure tests for our game to simulate the quit event, the test will hang in an infinite loop.</p>
<p>If we run the game now, the circle stays on the screen until we close the window. But it doesn’t move. Let’s work on that.</p>
<h2 id="test-animation">Test animation</h2>
<p>We modify the test for our game by simulating one more event so that one more frame is rendered. That gives us two calls to draw circle:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>We had to add the <code>x</code> argument to the <code>DRAW_CIRCLE</code> event so that we could observe that it changed:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>We also had to make a new call to clear the screen. If we don’t clear the screen we end up with circles drawn on top of each other. Clearing the screen works like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">clear_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;CLEAR_SCREEN&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>And the implementation for the animation looks like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">clear_screen</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>To make the animation frame rate independent, we also had to include the delta time. This is implemented in the game loop similar to how we did it in the spike:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">()):</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">...</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>At this point our test-driven implementation does the same thing that our spike does. We are now in a good place to move forward.</p>
<h2 id="refactor-exit">Refactor exit</h2>
<p>Before closing this episode, let’s take advantage of our test suite and explore an alternative way to exit the application. Instead of having a boolean return from <code>tick</code> indicating if we should exit or not, which I think is a bit unclear, let’s try an exception. Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">ExitGameLoop</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre>
</div>
</div>
</div>
<p>The tick method then turns into this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ExitGameLoop</span><span class="p">()</span>
    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>And the game loop into this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="o">...</span>
    <span class="k">except</span> <span class="n">ExitGameLoop</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;PYGAME_QUIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>I like this better. And all the tests still pass, unchanged.</p>
<h2 id="summary">Summary</h2>
<p>We have now recreated the functionality that we had in the spike, added the ability to test it, and improved the design with the safety net of our tests. Great success!</p>
<p>You can browse the <a href="https://github.com/rickardlindberg/agdpp/tree/initial-game-loop">complete source code</a> from this episode.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>Trying Ron's Python Asteroids</title>
    <link href="http://rickardlindberg.me/writing/trying-rons-python-asteroids/" />
    <id>http://rickardlindberg.me/writing/trying-rons-python-asteroids/</id>
    <published>2023-04-18T00:00:00Z</published>
    <updated>2023-04-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Trying Ron's Python Asteroids</h1>

<p><em>Published on 18 April 2023.</em></p>

<p><a href="https://www.ronjeffries.com/">Ron</a> is working on an Asteroids game in Python and also <a href="https://www.ronjeffries.com/categories/python/">writing</a> about it. I’m interested in his workflow, so I follow along.</p>
<p>He recently published the code on <a href="https://github.com/RonJeffries/python-asteroids-1">Github</a>.</p>
<p>I thought I would have a look.</p>
<h2 id="first-look">First look</h2>
<p>I clone the repo and see a bunch of Python files and an <code>.idea</code> folder.</p>
<p>I’ve never been a fan of IDEs. Perhaps I should learn one properly. In any case I find it useful to be able to run commands from the command line as well.</p>
<p>First, I want to see if I can get this game running:</p>
<pre><code>$ python game.py
AttributeError: &#39;pygame.math.Vector2&#39; object has no attribute &#39;copy&#39;</code></pre>
<p>I suspect I’m using a different version of pygame that lacks the copy method on vectors.</p>
<p>I try to run the test to see if I get the same failure there. How to run the tests? I think Ron mentioned that he uses <a href="https://pytest.org/">pytets</a>. I try:</p>
<pre><code>$ pytest
===================================================================== test session starts =====================================================================
platform linux -- Python 3.9.10, pytest-6.2.2, py-1.11.0, pluggy-0.13.1
rootdir: /home/rick/downloads/python-asteroids-1
collected 3 items / 3 errors
...</code></pre>
<p>I see the same error about the copy method of vector and some more in the same style.</p>
<p>I read about the copy method in the pygame manual and conclude that it was added in a later version.</p>
<h2 id="upgrade-pygame">Upgrade pygame</h2>
<p>I think I’ve installed pygame via Fedora’s package manager. That doesn’t have a more recent version of pygame.</p>
<p>I try to install it using pip instead:</p>
<pre><code>$ pip install --user pygame
Requirement already satisfied: pygame in /usr/lib64/python3.9/site-packages (2.0.3)</code></pre>
<p>I add <code>--user</code> because I don’t want to install anything globally using pip. I suppose I should create a virtual environment, but I haven’t worked much with them. This will do.</p>
<p>It indeed tells me that I already have pygame installed. How do I upgrade? Ah, the <code>--upgrade</code> flag:</p>
<pre><code>$ pip install --user --upgrade pygame
Requirement already satisfied: pygame in /usr/lib64/python3.9/site-packages (2.0.3)
Collecting pygame
  Downloading pygame-2.3.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (13.8 MB)
     |████████████████████████████████| 13.8 MB 692 kB/s 
Installing collected packages: pygame
Successfully installed pygame-2.3.0</code></pre>
<p>Sometimes I hesitate to install Python packages via pip. Especially when they are not pure Python packages (like pygame which depends on SDL and C libraries). Mostly because it hasn’t worked so well for me in the past. Maybe things are better now. And maybe it depends on the library. Let’s see how this works now.</p>
<h2 id="testing-the-game-again">Testing the game again</h2>
<p>I try running the game again:</p>
<pre><code>$ python game.py 
pygame 2.3.0 (SDL 2.24.2, Python 3.9.10)
Hello from the pygame community. https://www.pygame.org/contribute.html</code></pre>
<p>Success! Or, I don’t get any errors at least. But it exits right away. Am I running the wrong file?</p>
<p>Ah, there is a <code>main.py</code>. Let’s try that.</p>
<p>It works!</p>
<center>
<img src="game.png" title="fig:" alt="Ron’s Asteroids game." />
</center>
<h2 id="zero-friction">Zero friction</h2>
<p>I’m quite familiar with both Python and pygame, so it was not that difficult for me to get started. But I think we can improve.</p>
<p>One idea that I got from James Shore’s writing about a <a href="https://www.jamesshore.com/v2/books/aoad2/zero_friction">zero friction</a> development is that you should have scripts for doing common tasks like running your tests.</p>
<p>Let’s <a href="https://github.com/RonJeffries/python-asteroids-1/pull/1">see</a> if Ron likes that as well. I add one script to test</p>
<div class="rliterate-code">
<div class="rliterate-code-header">
<ol class="rliterate-code-path">
<li>
<span class="cp">build.sh </span>
</li>
</ol>
</div>
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="ch">#!/usr/bin/env bash</span>

<span class="nb">set</span> -e

pytest
</pre>
</div>
</div>
</div>
<p>and one to run the application</p>
<div class="rliterate-code">
<div class="rliterate-code-header">
<ol class="rliterate-code-path">
<li>
<span class="cp">rundev.sh </span>
</li>
</ol>
</div>
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="ch">#!/usr/bin/env bash</span>

<span class="nb">exec</span> python main.py
</pre>
</div>
</div>
</div>
<p>Should the way to run tests or the application change, only those files need to be changed, and the usage of the developer stays the same.</p>
]]></summary>
</entry>
<entry>
    <title>TDD trick: fake it!</title>
    <link href="http://rickardlindberg.me/writing/tdd-fake-it/" />
    <id>http://rickardlindberg.me/writing/tdd-fake-it/</id>
    <published>2023-04-17T00:00:00Z</published>
    <updated>2023-04-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>TDD trick: fake it!</h1>

<p><em>Published on 17 April 2023.</em></p>

<ul>
<li><a href="#the-example">The example</a></li>
<li><a href="#fake-it">Fake it!</a></li>
<li><a href="#refactor">Refactor</a></li>
<li><a href="#infrastructure-wrapper">Infrastructure wrapper</a></li>
<li><a href="#make-game-loop-more-real">Make game loop more real</a></li>
<li><a href="#looping-and-animation">Looping and animation</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
<p>The first step in the TDD loop is to think about what test to write. I find it easiest to do that from the outside-in. I might not yet know what different parts my system will consist of (especially in the beginning), but I do know some behavior of the entire system.</p>
<p>The problem with outside-in is that the test might be difficult to write because we don’t have enough infrastructure in place to make the appropriate assertions.</p>
<p>In this blog post I want to show you a trick to overcome that problem: fake it! (This is also similar to what James describes in <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks#grow-seeds">Grow Evolutionary Seeds</a>.)</p>
<h2 id="the-example">The example</h2>
<p>I will illustrate this trick with an example from a <a href="/projects/agdpp/index.html">game</a> that I’m working on.</p>
<p>So far, the game doesn’t do much. It just animates a circle:</p>
<center>
<img src="animation.png" title="fig:" alt="Animated circle." />
</center>
<p>The behavior of the game can be described as this:</p>
<blockquote>
<p>I draw an animated circle until the user closes the window.</p>
</blockquote>
<h2 id="fake-it">Fake it!</h2>
<p>With an empty project, it seems quite difficult to write a test that actually checks for that. What to do? Let’s fake it! Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I draw an animated circle until the user closes the window.</span>

<span class="sd">    &gt;&gt;&gt; game = Game()</span>
<span class="sd">    &gt;&gt;&gt; game.run()</span>
<span class="sd">    DRAW_CIRCLE</span>
<span class="sd">    EXIT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Really? How is this useful?</p>
<p>First of all we have got a description of one behavior of our system. We also have code that verifies that behavior, even though it is not yet complete. (The example shown in the docstring of the game class is actually an executable test written using Python’s <a href="https://docs.python.org/3/library/doctest.html">doctest</a> module.)</p>
<p>From here it is usually easier to see what to continue with. When we have <a href="https://www.artima.com/articles/the-simplest-thing-that-could-possibly-work">something on the screen</a>, we can more easily criticize it and improve it.</p>
<p>So, what next?</p>
<h2 id="refactor">Refactor</h2>
<p>Are you kidding? Refactor already?</p>
<p>To make this game testable, I want to separate the logic of the game from the infrastructure needed to initialize and use a graphics library. I imagine a game loop class that is responsible for that.</p>
<p>We can evolve the design in that direction even with what we have now. Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Game</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    I draw an animated circle until the user closes the window.</span>

<span class="sd">    &gt;&gt;&gt; game = Game(GameLoop())</span>
<span class="sd">    &gt;&gt;&gt; game.run()</span>
<span class="sd">    DRAW_CIRCLE</span>
<span class="sd">    EXIT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">draw_circle</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">GameLoop</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>The game now gets a loop as a dependency. Can you see how this would be possible to test now? We could inject some kind of test double as the loop and verify that it is called correctly.</p>
<p>Notice that we were able to do this refactoring with the safety net of the test. We have one teeny, tiny test that asserts something fake, but it still helped us do this refactoring.</p>
<h2 id="infrastructure-wrapper">Infrastructure wrapper</h2>
<p>For the test double version of the game loop, I want to use some patterns from <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks">Testing Without Mocks</a>.</p>
<p>I want to turn the game loop into an infrastructure wrapper. One part of that pattern is that it should emit events of what it’s doing so that tests can observe it.</p>
<p>Let’s replace the print statements, that we used to fake actions, with events. Here it is:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
</pre>
</div>
</div>
</div>
<p>The test for the game then changes to this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>(I won’t show the code for <code>Observable</code>. If you are curious to know the details, you can look <a href="https://github.com/rickardlindberg/agdpp/blob/initial-game-loop/events.py">here</a>.)</p>
<p>And this is starting to look more real now. There is no real faking going on in the game or its test any more. It seems logical to assert that the game loop emits those events.</p>
<p>But the game loop is still just emitting events, it’s not actually doing anything.</p>
<h2 id="make-game-loop-more-real">Make game loop more real</h2>
<p>The game loop should initialize a graphics library and provide to the game a way to draw on the screen. We will use <a href="https://www.pygame.org/news">pygame</a> for that. So our game loop will be an infrastructure wrapper around pygame providing a clean interface for our game to draw on the screen.</p>
<p>We need to make the <code>run</code> method and the <code>draw_circle</code> method do something real. Here is a first version:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;PYGAME_INIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">))</span>
        <span class="n">game</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;EXIT&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="s2">&quot;DRAW_CIRCLE&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="mi">40</span><span class="p">)</span>
</pre>
</div>
</div>
</div>
<p>Notice that have an instance variable called <code>pygame</code>.</p>
<p>When we test our game class, we don’t actually want to execute any pygame code that creates windows and draws circles on the screen. Therefore we use another pattern of an infrastructure wrapper which is that it can be nullable. That means that we can instantiate two version of our game loop:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="n">GameLoop</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
<span class="n">GameLoop</span><span class="o">.</span><span class="n">create_null</span><span class="p">()</span>
</pre>
</div>
</div>
</div>
<p>The creation methods look like this:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="n">Observable</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">pygame</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_null</span><span class="p">():</span>
        <span class="k">class</span> <span class="nc">NullPygame</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span> <span class="c1"># Do nothing</span>
            <span class="o">...</span>
        <span class="k">return</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">NullPygame</span><span class="p">())</span>

    <span class="o">...</span>
</pre>
</div>
</div>
</div>
<p>The null version works exactly the same as the real version except it nulls out all the calls that actually do anything with pygame. This is useful in tests so that we don’t open windows and actually draw graphics when we don’t need to.</p>
<p>Our game test can use the null version of the game loop and will continue to work as it did before.</p>
<p>When actually running our game, we create the real version of the game loop which will include all the real calls to pygame.</p>
<p>We can also test the real game loop in isolation, passing it a test game, to make sure that we call pygame correctly:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; GameLoop.create().run(TestGame())</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>This will actually open a window and draw whatever the test game draws. We can program the test game to exit immediately so that the test suite will not hang waiting for user input. But we will still see a flashing window which is a bit distracting.</p>
<p>To verify that our implementation of <code>draw_circle</code> works, we have to inspect the output visually. A test like the one above only asserts that we call pygame functions correctly, not that the output looks the way we want.</p>
<p>This is a general problem with infrastructure that it is difficult to test, because it involves the real world.</p>
<p>Anyway, that’s a little beside the point of this article. Where were we?</p>
<h2 id="looping-and-animation">Looping and animation</h2>
<p>If we run our game now, it will actually show a window with a circle on it. But the window will close immediately.</p>
<p>That is because the game loop still doesn’t implement a loop.</p>
<p>Let’s have a look at our game test again:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop()</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">EXIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<p>It talks about <em>animating</em> a circle, and about <em>waiting</em> for the user to close the window. But there is nothing in the setup or assertions about this. We are missing something.</p>
<p>Hopefully, at this point, it is a bit more clear where to continue.</p>
<p>Once we implement the loop and some event handling, I think the initial behavior of our game will actually be fully realized.</p>
<p>Here is what the final test for the game looks like when I continued fleshing out all the fakes and missing pieces:</p>
<div class="rliterate-code">
<div class="rliterate-code-body">
<div class="highlight">
<pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">I draw an animated circle until the user closes the window.</span>

<span class="sd">&gt;&gt;&gt; loop = GameLoop.create_null(</span>
<span class="sd">...     events=[</span>
<span class="sd">...         [],</span>
<span class="sd">...         [],</span>
<span class="sd">...         [pygame.event.Event(pygame.QUIT)],</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; events = loop.track_events()</span>
<span class="sd">&gt;&gt;&gt; Game(loop).run()</span>
<span class="sd">&gt;&gt;&gt; events</span>
<span class="sd">PYGAME_INIT =&gt;</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 50</span>
<span class="sd">CLEAR_SCREEN =&gt;</span>
<span class="sd">DRAW_CIRCLE =&gt;</span>
<span class="sd">    x: 51</span>
<span class="sd">PYGAME_QUIT =&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre>
</div>
</div>
</div>
<h2 id="summary">Summary</h2>
<p>We started with something fake, then did a bit of design, then removed one fake at a time until there were no fakes left.</p>
<p>I find this a useful way of working, especially when getting started. Once you have some structure in place it is easier to see where you need to add additional tests and functionality.</p>
<p>(If you want more details about this example in particular, check out my <a href="/writing/agdpp-game-loop/index.html">article</a> about how I implemented this part of the game.)</p>
]]></summary>
</entry>
<entry>
    <title>Introducing Agile Game Development with Python and Pygame</title>
    <link href="http://rickardlindberg.me/writing/agdpp-introduction/" />
    <id>http://rickardlindberg.me/writing/agdpp-introduction/</id>
    <published>2023-04-09T00:00:00Z</published>
    <updated>2023-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Introducing Agile Game Development with Python and Pygame</h1>

<p><em>Published on  9 April 2023 in <a href="/projects/agdpp/index.html">Agile Game Development with Python and Pygame</a>.</em></p>

<p>I recently started playing computer games with my son. That sparked an interest in me to create a game myself that we can play together. Mostly because I think this will be a <strong>fun project</strong>, but also to show my son that you can actually make your own games. It’s not something that you <em>only</em> consume.</p>
<p>I thought I would also document this journey in a series of blog posts and videos.</p>
<h2 id="video-version">Video version</h2>
<p>The video version of this episode:</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/9DZ81lOPfmo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</center>
<h2 id="the-challenge">The challenge</h2>
<p>The challenge is to create a game that me and my son will enjoy playing together.</p>
<h2 id="the-method">The method</h2>
<p>I want to develop this game using Agile methodology.</p>
<p>It means that instead of first figuring out what game I want to write, I will develop it incrementally and guide development by feedback.</p>
<p>It also means that I will rely heavily on self-testing code and TDD.</p>
<h2 id="my-background-in-games">My background in games</h2>
<p>I’m by no means an expert in creating games. I don’t even play games that much. But I have enjoyed creating some simple games in the past, like a Tetris clone and some kind of Asteroids.</p>
<p>I was actually able to restore an old copy of one of my Tetris games. It is written using Python and Pygame (which I also plan to use for my new game). I just needed to make a few small adjustments to make it work with Python 3. This is what it looks like:</p>
<center>
<img src="tetris1.png" title="fig:" alt="Intro screen of my Tetris game." />
</center>
<center>
<img src="tetris2.png" title="fig:" alt="Gameplay screen of my Tetris game." />
</center>
<h2 id="series-overview">Series overview</h2>
<p>So this series will cover how to create a game from the perspective of someone who has much experience programming, but not that much knowledge in the game domain.</p>
<p>Here is a list of topics off the top of my head that I imagine I will cover:</p>
<ul>
<li>Game loop and how to test it</li>
<li>Can you really use TDD for games?</li>
<li>Learn to capture events from Logitech controller</li>
<li>How to come up with an idea for a game?</li>
<li>Performance: background erase vs redraw?</li>
<li>Resolution: what to choose?</li>
<li>How to incrementally develop a game idea?</li>
<li>Particle effects</li>
</ul>
<p>This list is just the beginning of my journey. I hope will enjoy following along.</p>
<p>See you in the next episode!</p>
]]></summary>
</entry>
<entry>
    <title>What should a Continuous Integration (CI) server do?</title>
    <link href="http://rickardlindberg.me/writing/what-should-a-ci-server-do/" />
    <id>http://rickardlindberg.me/writing/what-should-a-ci-server-do/</id>
    <published>2023-04-06T00:00:00Z</published>
    <updated>2023-04-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>What should a Continuous Integration (CI) server do?</h1>

<p><em>Published on  6 April 2023.</em></p>

<ul>
<li><a href="#what-is-ci">What is CI?</a></li>
<li><a href="#what-does-integrate-mean">What does integrate mean?</a></li>
<li><a href="#how-often-should-you-integrate">How often should you integrate?</a></li>
<li><a href="#how-to-keep-the-main-branch-working">How to keep the main branch working?</a></li>
<li><a href="#attitude-not-a-tool">Attitude, not a tool</a></li>
<li><a href="#ci-server-functionality">CI server functionality</a>
<ul>
<li><a href="#basic-workflow">Basic workflow</a></li>
<li><a href="#clean-environments">Clean environments</a></li>
<li><a href="#multiple-environments">Multiple environments</a></li>
<li><a href="#pipeline-language">Pipeline language</a></li>
<li><a href="#objection">Objection!?</a></li>
<li><a href="#communication">Communication</a></li>
<li><a href="#multiple-test-suites">Multiple test suites</a></li>
</ul></li>
<li><a href="#common-ci-workflows-and-their-problems">Common “CI” workflows and their problems</a>
<ul>
<li><a href="#run-pipeline-after-commit">Run pipeline after commit</a></li>
<li><a href="#run-pipeline-on-branch-then-again-after-merge">Run pipeline on branch, then again after merge</a></li>
</ul></li>
<li><a href="#why-dont-tools-for-ci-work-like-this">Why don’t tools for CI work like this?</a></li>
<li><a href="#what-about-pull-requests">What about pull requests?</a></li>
</ul>
<p><em>After drafting this article, I asked for feedback on <a href="https://discord.com/channels/897648912851173408/897648913799077930/1076788077353246760">James’ Discord</a>. <a href="https://coding-is-like-cooking.info/">Emily</a> <a href="https://discord.com/channels/897648912851173408/897648913799077930/1078285384527650877">wrote</a> back and said that this sounded a lot like pre-tested integration that she had written about (<a href="https://www.eficode.com/blog/pre-tested-integration">here</a> and <a href="https://www.eficode.com/blog/pre-tested-integration2">here</a>) earlier. She describes almost the exact same workflow as I imagine with this CI server, and there is also a Jenkins plugin to support that workflow. I encourage you the check out her writing as well.</em></p>
<p>I think I have figured out what a Continuous Integration (CI) server <em>should</em> do. It is very simple. Yet common tools used for CI, like Jenkins, make it hard or near impossible.</p>
<h2 id="what-is-ci">What is CI?</h2>
<p>CI probably means different things to different people.</p>
<p>I’ve tried to find the root of the practice, and a lot of my thoughts here are based on James Shore’s descriptions in <a href="https://www.jamesshore.com/v2/books/aoad2/continuous_integration">AOAD2</a>.</p>
<p>So with that in mind, CI to me is about two things:</p>
<ol type="1">
<li>Integrate often.</li>
<li>Promise to keep the main branch working at all times.</li>
</ol>
<h2 id="what-does-integrate-mean">What does integrate mean?</h2>
<p>Integrate means to merge your changes into the main branch. This branch is commonly also referred to as master or trunk.</p>
<h2 id="how-often-should-you-integrate">How often should you integrate?</h2>
<p>From what I’ve read, the consensus seems to be that you should integrate at least once a day. If you do it less frequently, you are not doing <em>continuous</em> integration.</p>
<h2 id="how-to-keep-the-main-branch-working">How to keep the main branch working?</h2>
<p>Every time you integrate, you have to make sure that the main branch is still working. This is the second aspect of CI.</p>
<p>How can you do that?</p>
<p>The only way to do that, and still integrate often, is with an automatic test suite.</p>
<p>When you integrate your code, you want to run the test suite to make sure that everything still works.</p>
<p><strong>The test suite should give you confidence that when it’s time to deploy to production, it will just work.</strong></p>
<p>I’m using the term test suite here to include everything you need to gain that confidence, so it includes compiling, linting, static analysis, unit tests, deploy to test environment, smoke test… <em>everything</em>.</p>
<h2 id="attitude-not-a-tool">Attitude, not a tool</h2>
<p>James Shore writes that <a href="https://www.jamesshore.com/v2/blog/2005/continuous-integration-is-an-attitude">Continuous Integration is an Attitude, Not a Tool</a> and points out that <a href="https://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day">you can do CI without a tool</a>.</p>
<p>No tool can choose to integrate your changes often. You have to change your way of working so that you <em>can</em> integrate more often and also do so. This requires practice.</p>
<p>No tool can enforce that your main branch is always working. You have to have a mindset of working like that. This requires practice.</p>
<p>However, there are some things that a tool can help with. To make it easier to work in this way.</p>
<h2 id="ci-server-functionality">CI server functionality</h2>
<p><strong>A CI server should merge changes to the main branch in a “safe” way.</strong></p>
<h3 id="basic-workflow">Basic workflow</h3>
<p>Here is pseudo code for how a CI server should integrate changes from a branch in a Git repo:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">def</span> integrate(repo, branch):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="cf">with</span> lock(repo):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>        sh(<span class="st">&quot;git clone </span><span class="sc">{repo}</span><span class="st">&quot;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        sh(<span class="st">&quot;git merge origin/</span><span class="sc">{branch}</span><span class="st">&quot;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>        sh(<span class="st">&quot;&lt;command to run test suite&gt;&quot;</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        sh(<span class="st">&quot;git push&quot;</span>)</span></code></pre></div>
<p>The lock step ensures that only one integration can happen at a time. If you have two branches that want to integrate, one has to wait for the other to be integrated first.</p>
<p>The branch is then integrated by performing a <code>git merge</code>.</p>
<p>To make sure the new main branch works, a test suite is then run. This test suite should be defined in the repo.</p>
<p>If the test suite passes, a <code>git push</code> is performed to “publish” the new main branch.</p>
<p>This workflow ensures that every change that is merged into the main branch works. Where “works” is defined as passing the test suite.</p>
<p>That is the basic function that I think a CI server should perform. Let’s look at some directions where this design can be evolved to make a more full fledged CI server.</p>
<h3 id="clean-environments">Clean environments</h3>
<p>One thing that a dedicated CI server helps prevent is the problem that code works on one developer’s machine, but not on another’s. Perhaps it is due to a dependency missing on one developer’s machine.</p>
<p>With a CI server, the one true environment is the CI server’s environment.</p>
<p>Preferably, this should also be set up in the exact same way before every test run so that two test runs have the exact same clean environment.</p>
<p>Clean environments make test runs more predictable and helps make integrations safe.</p>
<p>Setting up a clean environment looks different in different contexts. One option would be to use Docker containers. In the Python world, virtual environments could be set up for each test run.</p>
<p>Any function that a CI server can perform to help set up a clean environment is useful.</p>
<h3 id="multiple-environments">Multiple environments</h3>
<p>Another advantage of a dedicated CI server is that you can make sure that your code works in an environment that you don’t have access to on your development machine.</p>
<p>You might write Python code that should work on both Windows and Linux, but your laptop only runs Windows.</p>
<p>A CI server should have functionality to run the test suite in different environments.</p>
<h3 id="pipeline-language">Pipeline language</h3>
<p>To take full advantage of the CI server, the “command to run the test suite” should be written in a “pipeline language” that the CI server understands.</p>
<p>Consider this pseudo example:</p>
<pre><code>step(&#39;compile&#39;) {
    sh(&#39;make&#39;)
}
parallel {
    step(&#39;test unix&#39;) {
        environment(&#39;unix&#39;) {
            sh(&#39;./test&#39;)
        }
    }
    step(&#39;test windows&#39;) {
        environment(&#39;windows&#39;) {
            sh(&#39;test.exe&#39;)
        }
    }
}</code></pre>
<p>This script could not have been written as a Bash script for example, because then it could not have taken advantage of the CI server functionality to run commands in different environments.</p>
<h3 id="objection">Objection!?</h3>
<p>When I asked for feedback on this article, I got some objections about a CI server being responsible for environments and a pipeline language.</p>
<p>One person wrote <a href="https://discord.com/channels/897648912851173408/897648913799077930/1077685040311435314">this</a> and <a href="https://discord.com/channels/897648912851173408/897648913799077930/1078738880653693060">this</a>:</p>
<blockquote>
<p>… having a pipeline script that works <em>only</em> with the ci software seems like a huge lockin and risk</p>
</blockquote>
<blockquote>
<p>I feel that the moment I say I can’t do this locally and I need a pre-configured build server, I am violating the basic principles of development.</p>
</blockquote>
<p>I partly agree with those objections.</p>
<p>It would be better if you could run your whole pipeline locally and have it set up all the clean environments for you. With virtualisation technology, this is becoming more and more possible.</p>
<p>If you manage to get this setup, then the CI server only functions as a single integration point that everyone has to go through.</p>
<p>I still think that a pipeline language would be useful for programming your pipeline. However, it could be used outside the CI server as well. That way you could also debug your pipeline locally without involving the CI server. If a pipeline step requires a specific environment that you can’t get locally, that step could be skipped when run locally.</p>
<h3 id="communication">Communication</h3>
<p>Another aspect of continuous integration is communication.</p>
<p>For example, when you integrate, you want to tell your team members about the change so that they can pull your changes and test their code against it.</p>
<p>A CI server can help communicate. It can for example do the following:</p>
<ul>
<li>Notify the team on a successful integration.</li>
<li>Show today’s integrations in a dashboard to visualize what’s happening.</li>
<li>Show success rate of integrations to give an idea of how the team is doing.</li>
<li>Present clear errors when an integration fails.</li>
<li>Present a clear view of a pipeline and what steps were run.</li>
</ul>
<h3 id="multiple-test-suites">Multiple test suites</h3>
<p>The lock step in the basic workflow ensures that only one integration can happen at a time.</p>
<p>In some situations you might have a longer running test suite that you don’t want to block further integrations.</p>
<p>A CI server could support that something like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">def</span> integrate(repo, branch):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="cf">with</span> lock(repo):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>        sh(<span class="st">&quot;git clone </span><span class="sc">{repo}</span><span class="st">&quot;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        sh(<span class="st">&quot;git merge origin/</span><span class="sc">{branch}</span><span class="st">&quot;</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>        sh(<span class="st">&quot;&lt;command to run fast test suite&gt;&quot;</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        sh(<span class="st">&quot;git push&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    sh(<span class="st">&quot;&lt;command to run slow test suite&gt;&quot;</span>)</span></code></pre></div>
<p>Of course, when you do this, you risk breaking the main branch since all tests are not run before the change is integrated.</p>
<p>One scenario where this could be useful is if you have a slow running test suite today that you can’t make instantly faster. You can start using this pattern with the goal of making all your slow tests fast. As a rule of thumb, the fast test suite should not take more than 10 minutes. If it takes longer for an integration to complete, chances are that you start multitasking because you don’t want to wait for it.</p>
<p>Some tests might also be impossible to run in less than 10 minutes. In that case, this pattern is also good. But make sure that all basic functionality is tested in the fast test suite.</p>
<h2 id="common-ci-workflows-and-their-problems">Common “CI” workflows and their problems</h2>
<p>When it comes to tools commonly used for CI, I primarily have experience with Jenkins. And the two most common patterns in Jenkins, which a believe are not unique to Jenkins, prevent you from doing continuous integration. Let’s have a look.</p>
<h3 id="run-pipeline-after-commit">Run pipeline after commit</h3>
<p>This pattern runs a pipeline only after you have merged your changes to the main branch.</p>
<p>If the test suite fails, your main branch is broken, and everyone who pulls your changes will base their work on something broken.</p>
<p>If you are serious about continuous integration, you fix this problem immediately. Either by reverting the change or merging a fix. It might not be too big a problem.</p>
<p>If you are not serious about continuous integration, you might leave the main branch broken and hope that someone else fixes it.</p>
<p>With a CI server I describe in this article, it is simply impossible to merge something broken. (Given that your test suite will catch the broken things.)</p>
<h3 id="run-pipeline-on-branch-then-again-after-merge">Run pipeline on branch, then again after merge</h3>
<p>This patterns runs a pipeline on every branch so that you know that your changes work before you merge them. And when you merge them, the pipeline is run again.</p>
<p>This is a slight improvement over the previous pattern, but it still has a flaw. Consider this scenario:</p>
<pre><code>0---0
     \
      \---A
       \
        \---B</code></pre>
<p><code>A</code> and <code>B</code> are two branches that both have passing test suites, so they both go ahead and merge, resulting in this:</p>
<pre><code>0---0-------A&#39;---B&#39;
     \     /    /
      \---A    /
       \      /
        \----B</code></pre>
<p><code>A'</code> has already been tested on the branch, but <code>B'</code> has never been tested. That is, the combination of <code>A</code>’s and <code>B</code>’s changes has never been tested, until they are both merged.</p>
<p>With a CI server I describe in this article, this problem is solved with the lock where multiple integrations have to wait for each other.</p>
<p>If you use the multiple test suites pattern, you still have this problem. At least for functionality only covered by the slow test suite. But then it’s a choice you make. You decide if the trade off is worth it for you or not.</p>
<h2 id="why-dont-tools-for-ci-work-like-this">Why don’t tools for CI work like this?</h2>
<p>I think that tools for CI should help you do CI well. Why don’t they?</p>
<p>I have two speculations.</p>
<p>First, if your team is committed to doing continuous integration, a broken main branch might not be too big a deal since everyone is committed to fixing it fast.</p>
<p>Second, back in the day of using SVN (which was my fist version control system), branching was expensive. The default way to share changes was to push directly to the main branch. Having a CI tool do the actual integration was probably technically more difficult. However, now with Git, that is no longer true.</p>
<p>Do you know why tools for CI don’t work like I describe in this article? Please let me know.</p>
<p>Emily <a href="https://discord.com/channels/897648912851173408/897648913799077930/1078571337989234780">responded</a> the following to that question:</p>
<blockquote>
<p>I think it’s hard to tell at this distance, but I suspect the people building the tools weren’t always the same people who really understood what CI is, and there was a communication gap. The tools that ended up becoming popular were perhaps the easiest to adopt and had the best marketing?</p>
</blockquote>
<p>That sounds reasonable to me.</p>
<p>Another person <a href="https://discord.com/channels/897648912851173408/897648913799077930/1077685040311435314">responded</a> with this:</p>
<blockquote>
<p>i think most [build servers] can be configured that way [proper CI]. many users do not want to because they don’t understand the ci process. instead they regard the build server as some central platform on which development is done.</p>
</blockquote>
<p>So people find value in build servers even though they are not designed explicitly for CI. That also makes sense.</p>
<p>So perhaps the reason why we don’t have better tools for CI is that people don’t understand the value of CI or don’t want to adopt it?</p>
<h2 id="what-about-pull-requests">What about pull requests?</h2>
<p>Pull requests are a common way of working, but they don’t play nicely together with CI.</p>
<p>First of all, when working with pull requests, you integrate your code by pressing a button that will perform the merge. With a CI tool like the one I describe in this article, the CI tool performs the merge. With the former, no tool can prevent broken code on the main branch. (The best they can do is test the branch, then test again after merge.)</p>
<p>Second of all, pull requests, at least blocking ones, add delay to the process of integrating code, making it difficult to integrate often.</p>
<p>Pull requests are often used to review changes before they are merged. In a CI server that I describe in this article, there is nothing preventing you from having a manual review step before the CI server is allowed to merge. However, a manual review step adds delays and makes it difficult to integrate often.</p>
]]></summary>
</entry>
<entry>
    <title>March 2023 Update</title>
    <link href="http://rickardlindberg.me/writing/newsletter/march-2023/" />
    <id>http://rickardlindberg.me/writing/newsletter/march-2023/</id>
    <published>2023-04-02T00:00:00Z</published>
    <updated>2023-04-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>March 2023 Update</h1>

<p><em>Published on  2 April 2023.</em></p>

<p>This is what I’ve been up to in March 2023:</p>
<ul>
<li><p>I got interested in building a game using <a href="https://www.pygame.org">Pygame</a>. I’ve started playing computer games with my son, so I thought it would be a fun challenge to see if I can build a game that we both enjoy playing. I think this will be my next side project.</p></li>
<li><p>I watched <a href="https://youtu.be/guycIP56YeY">Kent Beck On The FIRST Testing Frameworks, TDD, Waterfall &amp; MORE | The Engineering Room Ep. 16</a>. Listening to Kent Beck is always interesting since many of the practices in the software world come from him.</p></li>
<li><p>I published no programming videos on my <a href="https://www.youtube.com/channel/UC4XI09URnsM_YYTSizAMliA">Youtube channel</a>. But I suspect upcoming ones will be about agile game development.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>February 2023 Update</title>
    <link href="http://rickardlindberg.me/writing/newsletter/february-2023/" />
    <id>http://rickardlindberg.me/writing/newsletter/february-2023/</id>
    <published>2023-03-05T00:00:00Z</published>
    <updated>2023-03-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>February 2023 Update</h1>

<p><em>Published on  5 March 2023.</em></p>

<p>This is what I’ve been up to in February 2023:</p>
<ul>
<li><p>I started reading <a href="https://joyofagility.com/">Joy of Agility</a>. It has many interesting stories that provide valuable lessons.</p></li>
<li><p>I continued writing my blog post <a href="/writing/what-should-a-ci-server-do/index.html">What should a Continuous Integration (CI) server do?</a>. I also asked for feedback on <a href="https://www.jamesshore.com/">James’</a> Discord server and got many useful responses. In particular i learned about <a href="https://www.eficode.com/blog/pre-tested-integration">pre-tested integration</a> which looks very similar to what I tried to describe. I will update my blog post with feedback, and then I will call it done.</p></li>
<li><p>I <a href="https://hachyderm.io/@rickardlindberg/109846707922919650">asked Allen Holub</a> how to think about work that is not a story. Agile is about constantly providing value via stories, but what about work that needs to be done that doesn’t fit that category?</p></li>
<li><p>I read <a href="https://computerhistory.org/blog/postscript-a-digital-printing-press/">PostScript: A Digital Printing Press</a>. It was a bit of computer history that I enjoyed.</p></li>
<li><p>I published another two programming videos on my <a href="https://www.youtube.com/channel/UC4XI09URnsM_YYTSizAMliA">Youtube channel</a>:</p>
<ul>
<li><a href="https://youtu.be/2VrKIIMTFUI">What should a Continuous Integration (CI) server do?</a></li>
<li><a href="https://youtu.be/_uB1KGPjJjw">How TDD helps me solve programming problems.</a></li>
</ul></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>January 2023 Update</title>
    <link href="http://rickardlindberg.me/writing/newsletter/january-2023/" />
    <id>http://rickardlindberg.me/writing/newsletter/january-2023/</id>
    <published>2023-02-11T00:00:00Z</published>
    <updated>2023-02-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>January 2023 Update</h1>

<p><em>Published on 11 February 2023.</em></p>

<p>This is what I’ve been up to in January 2023:</p>
<ul>
<li><p>I started working on my <a href="https://github.com/rickardlindberg/projects">ideal code hosting platform</a>. I’ve attempted to do this once before and failed. I got the urge to give it another try. With my new experience of working in an agile way, I think my chance of succeeding this time is higher. But as always, you need to keep working on the project if it’s not going to die. Anyway, I am happy with the experience of trying and will for sure learn something.</p></li>
<li><p>I watched <a href="https://youtu.be/yXrY5pT88vA">AgileByExample 2021: J.B. Rainsberger - Unlocking the Awesome Power of Refactoring</a>. I learned about the idea of practice. If something you do regularly requires conscious brain effort, practice it until it becomes boring. That frees up brain capacity to think about more high-level problems.</p></li>
<li><p>I started reading <em>Extreme Programming Explained</em> (Second Edition) by Kent Beck. I wanted to learn more about XP since it seems to be the origin of “real” agile. I wanted to learn more about how accurate <a href="https://twitter.com/christianhujer/status/1614888741126176771">this tweet</a> was:</p>
<blockquote>
<p>• DevOps is just whole team+CI from XP.<br> • Teaming is whole team+pair programming from XP.<br> • TBD is just CI from XP.<br> • BDD is TDD+ATDD from XP.<br> <br> ⇒ 20+ years later, XP is still leading the way.</p>
</blockquote></li>
<li><p>I made some progress on my thinking about continuous integration and have a post about it in progress titled <a href="/writing/what-should-a-ci-server-do/index.html">What should a Continuous Integration (CI) server do?</a></p></li>
<li><p>I published another two programming videos on my <a href="https://www.youtube.com/channel/UC4XI09URnsM_YYTSizAMliA">Youtube channel</a>:</p>
<ul>
<li><a href="https://youtu.be/Hdg0LNga2dQ">My experience of one year on Youtube.</a></li>
<li><a href="https://youtu.be/ZvowW_toPmQ">How I start a new programming project. Building my ideal code hosting platform.</a></li>
</ul></li>
</ul>
]]></summary>
</entry>

</feed>
