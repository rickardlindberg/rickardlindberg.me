<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>
      Learning Microservice Architecture | Rickard's personal homepage
    </title>

    <meta name="keywords" content="programming, writing" />
    <meta name="description" content="Rickard's personal homepage.">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <link rel="stylesheet" href="../../css/blueprint/screen.css" type="text/css" media="screen, projection">
    <link rel="stylesheet" href="../../css/blueprint/print.css" type="text/css" media="print">
    <!--[if lt IE 8]>
      <link rel="stylesheet" href="/css/blueprint/ie.css" type="text/css" media="screen, projection">
    <![endif]-->
    <link rel="stylesheet" href="../../css/layout.css" type="text/css" media="screen, projection">
    <link rel="stylesheet" href="../../css/syntax.css" type="text/css">
  </head>
  <body>
    <div class="container noshowgrid">
      <div class="span-18 prepend-3 append-3">
        <h1>Learning Microservice Architecture</h1>

<p>I find Fred George’s talks about microservice architecture interesting. He describes a different way to structure systems: a different architecture that I’ve not come across before. What he describes also sounds similar to the actor model. But the talks only give an overview. How do you implement microservice architecture in practice?</p>
<p>In this article I will explore microservice architecture by writing small but complete examples. I’m learning as I go along.</p>
<h2 id="framework">Framework</h2>
<p>In order to test my ideas, I will build a small framework. I want to implement a message bus where anyone can publish and subscribe to messages. That way each microservice does not have to know about each other. They just need to know how to connect to the bus.</p>
<p>I’m not sure if you always implement microservice architecture with a message bus, but from Fred’s presentations, I got the feeling that’s how he did it.</p>
<p>My implementation will be in Haskell and use ZeroMQ for communication. First up are necessary imports:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>(), pack, unpack, append)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Time</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.ZMQ3.Monadic</span></code></pre>
<p>Next, let’s define the two endpoints for publishing and subscribing to messages on the bus.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> pubUrl <span class="fu">=</span> <span class="st">&quot;inproc://publish&quot;</span>
<span class="ot">&gt;</span> subUrl <span class="fu">=</span> <span class="st">&quot;inproc://subscribe&quot;</span></code></pre>
<p>The bus itself is implemented with a proxy between XPub and XSub sockets. When the XPub and XSub sockets have been bound to their endpoint, the proxy starts in the background along with any nodes that should be on the bus. The main node is run in the foreground and should act as the entry point for the bus.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; bus ::</span> <span class="dt">ZMQ</span> z () <span class="ot">-&gt;</span> [<span class="dt">ZMQ</span> z ()] <span class="ot">-&gt;</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> bus main nodes <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     busPub <span class="ot">&lt;-</span> socket <span class="dt">XPub</span>
<span class="ot">&gt;</span>     busSub <span class="ot">&lt;-</span> socket <span class="dt">XSub</span>
<span class="ot">&gt;</span>     bind busPub subUrl
<span class="ot">&gt;</span>     bind busSub pubUrl
<span class="ot">&gt;</span>     async <span class="fu">$</span> proxy busSub busPub <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     mapM_ async nodes
<span class="ot">&gt;</span>     main</code></pre>
<p>Let’s define two functions that make it easier to get Pub and Sub sockets for use on the bus.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; getPublisher ::</span> <span class="dt">ZMQ</span> z (<span class="dt">Socket</span> z <span class="dt">Pub</span>)
<span class="ot">&gt;</span> getPublisher <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     s <span class="ot">&lt;-</span> socket <span class="dt">Pub</span>
<span class="ot">&gt;</span>     connect s pubUrl
<span class="ot">&gt;</span>     return s
<span class="ot">&gt;</span> 
<span class="ot">&gt; getSubscriber ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ZMQ</span> z (<span class="dt">Socket</span> z <span class="dt">Sub</span>)
<span class="ot">&gt;</span> getSubscriber topic <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     s <span class="ot">&lt;-</span> socket <span class="dt">Sub</span>
<span class="ot">&gt;</span>     connect s subUrl
<span class="ot">&gt;</span>     subscribe s topic
<span class="ot">&gt;</span>     return s</code></pre>
<p>And a function to make logging to the console easier:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zmqLog ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> zmqLog message <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     t <span class="ot">&lt;-</span> liftIO getCurrentTime
<span class="ot">&gt;</span>     <span class="kw">let</span> x <span class="fu">=</span> show t <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> message
<span class="ot">&gt;</span>     liftIO <span class="fu">$</span> putStrLn x</code></pre>
<h2 id="example-usage">Example usage</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; examplePublisher ::</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> examplePublisher <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     pub <span class="ot">&lt;-</span> getPublisher
<span class="ot">&gt;</span>     forever <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         send pub [] <span class="st">&quot;hello Rickard&quot;</span>
<span class="ot">&gt;</span>         send pub [] <span class="st">&quot;another message&quot;</span>
<span class="ot">&gt;</span>         liftIO <span class="fu">$</span> threadDelay (<span class="dv">1</span> <span class="fu">*</span> <span class="dv">1000</span> <span class="fu">*</span> <span class="dv">1000</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; exampleSubscriber ::</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> exampleSubscriber <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     sub <span class="ot">&lt;-</span> getSubscriber <span class="st">&quot;hello&quot;</span>
<span class="ot">&gt;</span>     forever <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         message <span class="ot">&lt;-</span> receive sub
<span class="ot">&gt;</span>         zmqLog <span class="fu">$</span> unpack message
<span class="ot">&gt;</span> 
<span class="ot">&gt; exampleMain ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> exampleMain <span class="fu">=</span> runZMQ <span class="fu">$</span> bus (forever <span class="fu">$</span> return ()) [examplePublisher, exampleSubscriber]</code></pre>
<h2 id="kata">Kata</h2>
<p>First, I need a problem to solve. Is microservice architecture only suited for some kinds of problems? It seems like you want to solve small problems, like the string calculator kata, within a single microservice. But let’s try to break it up. How can we partition the string calculator into multiple microservices?</p>
<p>“” -&gt; 0 “5” -&gt; 5 “2,3” -&gt; 5 “1,2,3” -&gt; 6</p>
<p>Possible actors:</p>
<ul>
<li>add two numbers</li>
<li>split string on numbers</li>
</ul>
<p>The code bellow is specific to the problem being solved. It uses the bus framework above.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; kataMain ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> kataMain <span class="fu">=</span> runZMQ <span class="fu">$</span> bus repl [logger, singleNumbers]
<span class="ot">&gt;</span> 
<span class="ot">&gt; repl ::</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> repl <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     pub <span class="ot">&lt;-</span> getPublisher
<span class="ot">&gt;</span>     sub <span class="ot">&lt;-</span> getSubscriber <span class="st">&quot;conclusion&quot;</span>
<span class="ot">&gt;</span>     zmqLog <span class="st">&quot;repl online&quot;</span>
<span class="ot">&gt;</span>     forever <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         query <span class="ot">&lt;-</span> liftIO getLine
<span class="ot">&gt;</span>         send pub [] (<span class="st">&quot;query &quot;</span> <span class="ot">`append`</span> pack query)
<span class="ot">&gt;</span> 
<span class="ot">&gt; logger ::</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> logger <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     sub <span class="ot">&lt;-</span> getSubscriber <span class="st">&quot;&quot;</span>
<span class="ot">&gt;</span>     zmqLog <span class="st">&quot;logger online&quot;</span>
<span class="ot">&gt;</span>     forever <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         message <span class="ot">&lt;-</span> receive sub
<span class="ot">&gt;</span>         zmqLog <span class="fu">$</span> <span class="st">&quot;logger: &quot;</span> <span class="fu">++</span> unpack message
<span class="ot">&gt;</span> 
<span class="ot">&gt; singleNumbers ::</span> <span class="dt">ZMQ</span> z ()
<span class="ot">&gt;</span> singleNumbers <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     pub <span class="ot">&lt;-</span> getPublisher
<span class="ot">&gt;</span>     sub <span class="ot">&lt;-</span> getSubscriber <span class="st">&quot;query&quot;</span>
<span class="ot">&gt;</span>     zmqLog <span class="st">&quot;single numbers online&quot;</span>
<span class="ot">&gt;</span>     forever <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         query <span class="ot">&lt;-</span> receive sub
<span class="ot">&gt;</span>         send pub [] (<span class="st">&quot;conclusion &quot;</span> <span class="ot">`append`</span> pack (show <span class="fu">$</span> parseNum <span class="fu">$</span> unwords <span class="fu">$</span> tail <span class="fu">$</span> words <span class="fu">$</span> unpack query))
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;         parseNum ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>         parseNum <span class="fu">=</span> read</code></pre>
<h2 id="putting-it-together">Putting it together</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     args <span class="ot">&lt;-</span> getArgs
<span class="ot">&gt;</span>     <span class="kw">case</span> args <span class="kw">of</span>
<span class="ot">&gt;</span>         [<span class="st">&quot;example&quot;</span>] <span class="ot">-&gt;</span> exampleMain
<span class="ot">&gt;</span>         [<span class="st">&quot;kata&quot;</span>] <span class="ot">-&gt;</span> kataMain</code></pre>


<hr>

<h2>Feedback</h2>

<p>If you answer a question about this post, you will make me very happy.
<em>/Rickard<em></p>

<p>
<!-- Change the width and height values to suit you best -->
<div class="typeform-widget" data-url="https://rickardlindberg.typeform.com/to/ej6VaG?post=Learning%20Microservice%20Architecture" data-text="Post Feedback" style="width:100%;height:300px;"></div>
<script>(function(){var qs,js,q,s,d=document,gi=d.getElementById,ce=d.createElement,gt=d.getElementsByTagName,id='typef_orm',b='https://s3-eu-west-1.amazonaws.com/share.typeform.com/';if(!gi.call(d,id)){js=ce.call(d,'script');js.id=id;js.src=b+'widget.js';q=gt.call(d,'script')[0];q.parentNode.insertBefore(js,q)}})()</script>
    <div style="font-family: Sans-Serif;font-size: 12px;color: #999;opacity: 0.5; padding-top: 5px;">Powered by <a href="http://www.typeform.com/?utm_campaign=typeform_ej6VaG&amp;utm_source=website&amp;utm_medium=typeform&amp;utm_content=typeform-embedded&amp;utm_term=English" style="color: #999" target="_blank">Typeform</a></div>
</p>

<hr>
<p><a href="../../">Home</a></p>

        <hr>
        <p>Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</p>
      </div>
    </div>
  </body>
</html>
